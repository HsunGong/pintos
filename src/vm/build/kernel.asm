
kernel.o：     文件格式 elf32-i386


Disassembly of section .text:

c0020078 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c0020078:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c002007d:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c002007f:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c0020080:	b4 88                	mov    $0x88,%ah
	int $0x15
c0020082:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c0020084:	66 05 00 04          	add    $0x400,%ax
c0020088:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c002008a:	66 3d 00 00          	cmp    $0x0,%ax
c002008e:	01 00                	add    %eax,(%eax)
	jbe 1f
c0020090:	76 06                	jbe    c0020098 <start+0x20>
	mov $0x10000, %eax
c0020092:	66 b8 00 00          	mov    $0x0,%ax
c0020096:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c0020098:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c002009c:	67 66 a3 7e 01       	addr16 mov %ax,0x17e
c00200a1:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c00200a3:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200a5:	a8 02                	test   $0x2,%al
	jnz 1b
c00200a7:	75 fa                	jne    c00200a3 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c00200a9:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c00200ab:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c00200ad:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200af:	a8 02                	test   $0x2,%al
	jnz 1b
c00200b1:	75 fa                	jne    c00200ad <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c00200b3:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c00200b5:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c00200b7:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200b9:	a8 02                	test   $0x2,%al
	jnz 1b
c00200bb:	75 fa                	jne    c00200b7 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c00200bd:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c00200c2:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c00200c5:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c00200c8:	66 b9 00 04          	mov    $0x400,%cx
c00200cc:	00 00                	add    %al,(%eax)
	rep stosl
c00200ce:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c00200d1:	66 b8 07 00          	mov    $0x7,%ax
c00200d5:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c00200d7:	66 b9 11 00          	mov    $0x11,%cx
c00200db:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200dd:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200e0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200e7:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c00200e8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c00200eb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c00200f2:	00 e2                	add    %ah,%dl
	loop 1b
c00200f4:	eb b8                	jmp    c00200ae <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c00200f6:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c00200f8:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c00200fa:	66 b8 07 00          	mov    $0x7,%ax
c00200fe:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c0020100:	66 b9 00 40          	mov    $0x4000,%cx
c0020104:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c0020106:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c0020109:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c0020110:	66 
	addw $4, %di
	addl $0x1000, %eax
c0020111:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c0020116:	e2 f1                	loop   c0020109 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c0020118:	66 b8 00 f0          	mov    $0xf000,%ax
c002011c:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c002011e:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020121:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020122:	67 66 0f 01 15       	lgdtw  (%di)
c0020127:	78 01                	js     c002012a <start+0xb2>
c0020129:	00 00                	add    %al,(%eax)
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002012b:	0f 20 c0             	mov    %cr0,%eax
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002012e:	66 0d 05 00          	or     $0x5,%ax
c0020132:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020138:	ea 3f 01 02 c0 08 00 	ljmp   $0x8,$0xc002013f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002013f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020143:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020145:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020147:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020149:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002014b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002014d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020153:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020158:	e8 2f 01 00 00       	call   c002028c <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002015d:	eb fe                	jmp    c002015d <start+0xe5>
	...

c0020160 <gdt>:
	...
c0020168:	ff                   	(bad)  
c0020169:	ff 00                	incl   (%eax)
c002016b:	00 00                	add    %al,(%eax)
c002016d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020174:	00                   	.byte 0x0
c0020175:	92                   	xchg   %eax,%edx
c0020176:	cf                   	iret   
	...

c0020178 <gdtdesc>:
c0020178:	17                   	pop    %ss
c0020179:	00 60 01             	add    %ah,0x1(%eax)
c002017c:	02 c0                	add    %al,%al

c002017e <init_ram_pages>:
c002017e:	00 00                	add    %al,(%eax)
	...

c0020182 <locate_block_device>:
   block device with the given NAME, if NAME is non-null,
   otherwise the first block device in probe order of type
   ROLE. */
static void
locate_block_device(enum block_type role, const char *name)
{
c0020182:	55                   	push   %ebp
c0020183:	57                   	push   %edi
c0020184:	56                   	push   %esi
c0020185:	53                   	push   %ebx
c0020186:	83 ec 0c             	sub    $0xc,%esp
c0020189:	e8 58 23 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002018e:	81 c3 ae 0a 02 00    	add    $0x20aae,%ebx
c0020194:	89 c7                	mov    %eax,%edi
  struct block *block = NULL;

  if (name != NULL)
c0020196:	85 d2                	test   %edx,%edx
c0020198:	74 70                	je     c002020a <locate_block_device+0x88>
c002019a:	89 d5                	mov    %edx,%ebp
  {
    block = block_get_by_name(name);
c002019c:	83 ec 0c             	sub    $0xc,%esp
c002019f:	52                   	push   %edx
c00201a0:	e8 35 56 00 00       	call   c00257da <block_get_by_name>
c00201a5:	89 c6                	mov    %eax,%esi
    if (block == NULL)
c00201a7:	83 c4 10             	add    $0x10,%esp
c00201aa:	85 c0                	test   %eax,%eax
c00201ac:	74 39                	je     c00201e7 <locate_block_device+0x65>
        break;
  }

  if (block != NULL)
  {
    printf("%s: using %s\n", block_type_name(role), block_name(block));
c00201ae:	83 ec 0c             	sub    $0xc,%esp
c00201b1:	56                   	push   %esi
c00201b2:	e8 3d 57 00 00       	call   c00258f4 <block_name>
c00201b7:	89 c5                	mov    %eax,%ebp
c00201b9:	89 3c 24             	mov    %edi,(%esp)
c00201bc:	e8 c2 54 00 00       	call   c0025683 <block_type_name>
c00201c1:	83 c4 0c             	add    $0xc,%esp
c00201c4:	55                   	push   %ebp
c00201c5:	50                   	push   %eax
c00201c6:	8d 83 77 2c ff ff    	lea    -0xd389(%ebx),%eax
c00201cc:	50                   	push   %eax
c00201cd:	e8 2c 79 00 00       	call   c0027afe <printf>
    block_set_role(role, block);
c00201d2:	83 c4 08             	add    $0x8,%esp
c00201d5:	56                   	push   %esi
c00201d6:	57                   	push   %edi
c00201d7:	e8 3b 55 00 00       	call   c0025717 <block_set_role>
c00201dc:	83 c4 10             	add    $0x10,%esp
  }
}
c00201df:	83 c4 0c             	add    $0xc,%esp
c00201e2:	5b                   	pop    %ebx
c00201e3:	5e                   	pop    %esi
c00201e4:	5f                   	pop    %edi
c00201e5:	5d                   	pop    %ebp
c00201e6:	c3                   	ret    
      PANIC("No such block device \"%s\"", name);
c00201e7:	83 ec 0c             	sub    $0xc,%esp
c00201ea:	55                   	push   %ebp
c00201eb:	8d 83 48 2c ff ff    	lea    -0xd3b8(%ebx),%eax
c00201f1:	50                   	push   %eax
c00201f2:	8d 83 f4 18 ff ff    	lea    -0xe70c(%ebx),%eax
c00201f8:	50                   	push   %eax
c00201f9:	68 ce 01 00 00       	push   $0x1ce
c00201fe:	8d 83 62 2c ff ff    	lea    -0xd39e(%ebx),%eax
c0020204:	50                   	push   %eax
c0020205:	e8 8b 96 00 00       	call   c0029895 <debug_panic>
    for (block = block_first(); block != NULL; block = block_next(block))
c002020a:	e8 56 55 00 00       	call   c0025765 <block_first>
c002020f:	89 c6                	mov    %eax,%esi
c0020211:	85 c0                	test   %eax,%eax
c0020213:	74 ca                	je     c00201df <locate_block_device+0x5d>
      if (block_type(block) == role)
c0020215:	83 ec 0c             	sub    $0xc,%esp
c0020218:	56                   	push   %esi
c0020219:	e8 de 56 00 00       	call   c00258fc <block_type>
c002021e:	83 c4 10             	add    $0x10,%esp
c0020221:	39 f8                	cmp    %edi,%eax
c0020223:	74 14                	je     c0020239 <locate_block_device+0xb7>
    for (block = block_first(); block != NULL; block = block_next(block))
c0020225:	83 ec 0c             	sub    $0xc,%esp
c0020228:	56                   	push   %esi
c0020229:	e8 71 55 00 00       	call   c002579f <block_next>
c002022e:	89 c6                	mov    %eax,%esi
c0020230:	83 c4 10             	add    $0x10,%esp
c0020233:	85 c0                	test   %eax,%eax
c0020235:	75 de                	jne    c0020215 <locate_block_device+0x93>
c0020237:	eb a6                	jmp    c00201df <locate_block_device+0x5d>
  if (block != NULL)
c0020239:	85 f6                	test   %esi,%esi
c002023b:	74 a2                	je     c00201df <locate_block_device+0x5d>
c002023d:	e9 6c ff ff ff       	jmp    c00201ae <locate_block_device+0x2c>

c0020242 <run_task>:
{
c0020242:	56                   	push   %esi
c0020243:	53                   	push   %ebx
c0020244:	83 ec 0c             	sub    $0xc,%esp
c0020247:	e8 9a 22 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002024c:	81 c3 f0 09 02 00    	add    $0x209f0,%ebx
  const char *task = argv[1];
c0020252:	8b 44 24 18          	mov    0x18(%esp),%eax
c0020256:	8b 70 04             	mov    0x4(%eax),%esi
  printf("Executing '%s':\n", task);
c0020259:	56                   	push   %esi
c002025a:	8d 83 85 2c ff ff    	lea    -0xd37b(%ebx),%eax
c0020260:	50                   	push   %eax
c0020261:	e8 98 78 00 00       	call   c0027afe <printf>
  process_wait(process_execute(task));
c0020266:	89 34 24             	mov    %esi,(%esp)
c0020269:	e8 93 b6 00 00       	call   c002b901 <process_execute>
c002026e:	89 04 24             	mov    %eax,(%esp)
c0020271:	e8 59 b7 00 00       	call   c002b9cf <process_wait>
  printf("Execution of '%s' complete.\n", task);
c0020276:	83 c4 08             	add    $0x8,%esp
c0020279:	56                   	push   %esi
c002027a:	8d 83 96 2c ff ff    	lea    -0xd36a(%ebx),%eax
c0020280:	50                   	push   %eax
c0020281:	e8 78 78 00 00       	call   c0027afe <printf>
}
c0020286:	83 c4 14             	add    $0x14,%esp
c0020289:	5b                   	pop    %ebx
c002028a:	5e                   	pop    %esi
c002028b:	c3                   	ret    

c002028c <pintos_init>:
{
c002028c:	55                   	push   %ebp
c002028d:	57                   	push   %edi
c002028e:	56                   	push   %esi
c002028f:	53                   	push   %ebx
c0020290:	81 ec 30 01 00 00    	sub    $0x130,%esp
c0020296:	e8 4b 22 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002029b:	81 c3 a1 09 02 00    	add    $0x209a1,%ebx
  memset(&_start_bss, 0, &_end_bss - &_start_bss);
c00202a1:	c7 c2 3c 0c 04 c0    	mov    $0xc0040c3c,%edx
c00202a7:	c7 c0 d0 b2 04 c0    	mov    $0xc004b2d0,%eax
c00202ad:	29 d0                	sub    %edx,%eax
c00202af:	50                   	push   %eax
c00202b0:	6a 00                	push   $0x0
c00202b2:	52                   	push   %edx
c00202b3:	e8 5c 8b 00 00       	call   c0028e14 <memset>
  argc = *(uint32_t *)ptov(LOADER_ARG_CNT);
c00202b8:	a1 3a 7d 00 c0       	mov    0xc0007d3a,%eax
c00202bd:	89 44 24 14          	mov    %eax,0x14(%esp)
c00202c1:	89 c5                	mov    %eax,%ebp
  for (i = 0; i < argc; i++)
c00202c3:	83 c4 10             	add    $0x10,%esp
c00202c6:	bf 00 00 00 00       	mov    $0x0,%edi
  p = ptov(LOADER_ARGS);
c00202cb:	be 3e 7d 00 c0       	mov    $0xc0007d3e,%esi
  for (i = 0; i < argc; i++)
c00202d0:	85 c0                	test   %eax,%eax
c00202d2:	7f 6d                	jg     c0020341 <pintos_init+0xb5>
  argv[argc] = NULL;
c00202d4:	8b 44 24 04          	mov    0x4(%esp),%eax
c00202d8:	c7 84 83 24 00 00 00 	movl   $0x0,0x24(%ebx,%eax,4)
c00202df:	00 00 00 00 
  printf("Kernel command line:");
c00202e3:	83 ec 0c             	sub    $0xc,%esp
c00202e6:	8d 83 9f 2d ff ff    	lea    -0xd261(%ebx),%eax
c00202ec:	50                   	push   %eax
c00202ed:	e8 0c 78 00 00       	call   c0027afe <printf>
c00202f2:	83 c4 10             	add    $0x10,%esp
  printf("\n");
c00202f5:	83 ec 0c             	sub    $0xc,%esp
c00202f8:	6a 0a                	push   $0xa
c00202fa:	e8 e1 b5 00 00       	call   c002b8e0 <putchar>
  for (; *argv != NULL && **argv == '-'; argv++)
c00202ff:	8b 83 24 00 00 00    	mov    0x24(%ebx),%eax
c0020305:	83 c4 10             	add    $0x10,%esp
c0020308:	85 c0                	test   %eax,%eax
c002030a:	0f 84 1e 03 00 00    	je     c002062e <pintos_init+0x3a2>
c0020310:	80 38 2d             	cmpb   $0x2d,(%eax)
c0020313:	0f 85 b6 03 00 00    	jne    c00206cf <pintos_init+0x443>
c0020319:	8d ab 24 00 00 00    	lea    0x24(%ebx),%ebp
    char *name = strtok_r(*argv, "=", &save_ptr);
c002031f:	8d 8c 24 a0 00 00 00 	lea    0xa0(%esp),%ecx
c0020326:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
      thread_mlfqs = true;
c002032a:	c7 c1 bc b2 04 c0    	mov    $0xc004b2bc,%ecx
c0020330:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0020334:	e9 06 01 00 00       	jmp    c002043f <pintos_init+0x1b3>
    if (p >= end)
c0020339:	81 fe bd 7d 00 c0    	cmp    $0xc0007dbd,%esi
c002033f:	77 66                	ja     c00203a7 <pintos_init+0x11b>
    argv[i] = p;
c0020341:	89 b4 bb 24 00 00 00 	mov    %esi,0x24(%ebx,%edi,4)
    p += strnlen(p, end - p) + 1;
c0020348:	83 ec 08             	sub    $0x8,%esp
c002034b:	b8 be 7d 00 c0       	mov    $0xc0007dbe,%eax
c0020350:	29 f0                	sub    %esi,%eax
c0020352:	50                   	push   %eax
c0020353:	56                   	push   %esi
c0020354:	e8 64 8b 00 00       	call   c0028ebd <strnlen>
c0020359:	8d 74 06 01          	lea    0x1(%esi,%eax,1),%esi
  for (i = 0; i < argc; i++)
c002035d:	83 c7 01             	add    $0x1,%edi
c0020360:	83 c4 10             	add    $0x10,%esp
c0020363:	39 fd                	cmp    %edi,%ebp
c0020365:	75 d2                	jne    c0020339 <pintos_init+0xad>
  argv[argc] = NULL;
c0020367:	8d ab 24 00 00 00    	lea    0x24(%ebx),%ebp
c002036d:	c7 44 bd 00 00 00 00 	movl   $0x0,0x0(%ebp,%edi,4)
c0020374:	00 
  printf("Kernel command line:");
c0020375:	83 ec 0c             	sub    $0xc,%esp
c0020378:	8d 83 9f 2d ff ff    	lea    -0xd261(%ebx),%eax
c002037e:	50                   	push   %eax
c002037f:	e8 7a 77 00 00       	call   c0027afe <printf>
c0020384:	89 ee                	mov    %ebp,%esi
c0020386:	8b 44 24 14          	mov    0x14(%esp),%eax
c002038a:	8d 6c 85 00          	lea    0x0(%ebp,%eax,4),%ebp
c002038e:	83 c4 10             	add    $0x10,%esp
      printf(" '%s'", argv[i]);
c0020391:	8d 83 b3 2c ff ff    	lea    -0xd34d(%ebx),%eax
c0020397:	89 44 24 04          	mov    %eax,0x4(%esp)
      printf(" %s", argv[i]);
c002039b:	8d 83 67 3d ff ff    	lea    -0xc299(%ebx),%eax
c00203a1:	89 44 24 08          	mov    %eax,0x8(%esp)
c00203a5:	eb 3a                	jmp    c00203e1 <pintos_init+0x155>
      PANIC("command line arguments overflow");
c00203a7:	8d 83 d0 2d ff ff    	lea    -0xd230(%ebx),%eax
c00203ad:	50                   	push   %eax
c00203ae:	8d 83 2c 19 ff ff    	lea    -0xe6d4(%ebx),%eax
c00203b4:	50                   	push   %eax
c00203b5:	68 01 01 00 00       	push   $0x101
c00203ba:	8d 83 62 2c ff ff    	lea    -0xd39e(%ebx),%eax
c00203c0:	50                   	push   %eax
c00203c1:	e8 cf 94 00 00       	call   c0029895 <debug_panic>
      printf(" %s", argv[i]);
c00203c6:	83 ec 08             	sub    $0x8,%esp
c00203c9:	57                   	push   %edi
c00203ca:	ff 74 24 14          	pushl  0x14(%esp)
c00203ce:	e8 2b 77 00 00       	call   c0027afe <printf>
c00203d3:	83 c4 10             	add    $0x10,%esp
c00203d6:	83 c6 04             	add    $0x4,%esi
  for (i = 0; i < argc; i++)
c00203d9:	39 ee                	cmp    %ebp,%esi
c00203db:	0f 84 14 ff ff ff    	je     c00202f5 <pintos_init+0x69>
    if (strchr(argv[i], ' ') == NULL)
c00203e1:	8b 3e                	mov    (%esi),%edi
c00203e3:	83 ec 08             	sub    $0x8,%esp
c00203e6:	6a 20                	push   $0x20
c00203e8:	57                   	push   %edi
c00203e9:	e8 d8 87 00 00       	call   c0028bc6 <strchr>
c00203ee:	83 c4 10             	add    $0x10,%esp
c00203f1:	85 c0                	test   %eax,%eax
c00203f3:	74 d1                	je     c00203c6 <pintos_init+0x13a>
      printf(" '%s'", argv[i]);
c00203f5:	83 ec 08             	sub    $0x8,%esp
c00203f8:	57                   	push   %edi
c00203f9:	ff 74 24 10          	pushl  0x10(%esp)
c00203fd:	e8 fc 76 00 00       	call   c0027afe <printf>
c0020402:	83 c4 10             	add    $0x10,%esp
c0020405:	eb cf                	jmp    c00203d6 <pintos_init+0x14a>
  printf("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c0020407:	83 ec 0c             	sub    $0xc,%esp
c002040a:	8d 83 f0 2d ff ff    	lea    -0xd210(%ebx),%eax
c0020410:	50                   	push   %eax
c0020411:	e8 58 b4 00 00       	call   c002b86e <puts>
  shutdown_power_off();
c0020416:	e8 38 6f 00 00       	call   c0027353 <shutdown_power_off>
      shutdown_configure(SHUTDOWN_POWER_OFF);
c002041b:	83 ec 0c             	sub    $0xc,%esp
c002041e:	6a 01                	push   $0x1
c0020420:	e8 9d 6e 00 00       	call   c00272c2 <shutdown_configure>
c0020425:	83 c4 10             	add    $0x10,%esp
  for (; *argv != NULL && **argv == '-'; argv++)
c0020428:	83 c5 04             	add    $0x4,%ebp
c002042b:	8b 45 00             	mov    0x0(%ebp),%eax
c002042e:	85 c0                	test   %eax,%eax
c0020430:	0f 84 fe 01 00 00    	je     c0020634 <pintos_init+0x3a8>
c0020436:	80 38 2d             	cmpb   $0x2d,(%eax)
c0020439:	0f 85 f5 01 00 00    	jne    c0020634 <pintos_init+0x3a8>
    char *name = strtok_r(*argv, "=", &save_ptr);
c002043f:	83 ec 04             	sub    $0x4,%esp
c0020442:	8b 7c 24 10          	mov    0x10(%esp),%edi
c0020446:	57                   	push   %edi
c0020447:	8d 93 fa 3b ff ff    	lea    -0xc406(%ebx),%edx
c002044d:	52                   	push   %edx
c002044e:	50                   	push   %eax
c002044f:	e8 8c 88 00 00       	call   c0028ce0 <strtok_r>
c0020454:	89 c6                	mov    %eax,%esi
c0020456:	89 44 24 14          	mov    %eax,0x14(%esp)
    char *value = strtok_r(NULL, "", &save_ptr);
c002045a:	83 c4 0c             	add    $0xc,%esp
c002045d:	57                   	push   %edi
c002045e:	8d 83 76 4c ff ff    	lea    -0xb38a(%ebx),%eax
c0020464:	50                   	push   %eax
c0020465:	6a 00                	push   $0x0
c0020467:	e8 74 88 00 00       	call   c0028ce0 <strtok_r>
c002046c:	89 44 24 18          	mov    %eax,0x18(%esp)
    if (!strcmp(name, "-h"))
c0020470:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020475:	8d bb b9 2c ff ff    	lea    -0xd347(%ebx),%edi
c002047b:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002047d:	0f 97 c0             	seta   %al
c0020480:	1c 00                	sbb    $0x0,%al
c0020482:	83 c4 10             	add    $0x10,%esp
c0020485:	84 c0                	test   %al,%al
c0020487:	0f 84 7a ff ff ff    	je     c0020407 <pintos_init+0x17b>
    else if (!strcmp(name, "-q"))
c002048d:	b9 03 00 00 00       	mov    $0x3,%ecx
c0020492:	8d bb bc 2c ff ff    	lea    -0xd344(%ebx),%edi
c0020498:	8b 74 24 04          	mov    0x4(%esp),%esi
c002049c:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002049e:	0f 97 c0             	seta   %al
c00204a1:	1c 00                	sbb    $0x0,%al
c00204a3:	84 c0                	test   %al,%al
c00204a5:	0f 84 70 ff ff ff    	je     c002041b <pintos_init+0x18f>
    else if (!strcmp(name, "-r"))
c00204ab:	b9 03 00 00 00       	mov    $0x3,%ecx
c00204b0:	8d bb bf 2c ff ff    	lea    -0xd341(%ebx),%edi
c00204b6:	8b 74 24 04          	mov    0x4(%esp),%esi
c00204ba:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00204bc:	0f 97 c0             	seta   %al
c00204bf:	1c 00                	sbb    $0x0,%al
c00204c1:	84 c0                	test   %al,%al
c00204c3:	74 26                	je     c00204eb <pintos_init+0x25f>
    else if (!strcmp(name, "-f"))
c00204c5:	b9 03 00 00 00       	mov    $0x3,%ecx
c00204ca:	8d bb c2 2c ff ff    	lea    -0xd33e(%ebx),%edi
c00204d0:	8b 74 24 04          	mov    0x4(%esp),%esi
c00204d4:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00204d6:	0f 97 c0             	seta   %al
c00204d9:	1c 00                	sbb    $0x0,%al
c00204db:	84 c0                	test   %al,%al
c00204dd:	75 1e                	jne    c00204fd <pintos_init+0x271>
      format_filesys = true;
c00204df:	c6 83 34 01 00 00 01 	movb   $0x1,0x134(%ebx)
c00204e6:	e9 3d ff ff ff       	jmp    c0020428 <pintos_init+0x19c>
      shutdown_configure(SHUTDOWN_REBOOT);
c00204eb:	83 ec 0c             	sub    $0xc,%esp
c00204ee:	6a 02                	push   $0x2
c00204f0:	e8 cd 6d 00 00       	call   c00272c2 <shutdown_configure>
c00204f5:	83 c4 10             	add    $0x10,%esp
c00204f8:	e9 2b ff ff ff       	jmp    c0020428 <pintos_init+0x19c>
    else if (!strcmp(name, "-filesys"))
c00204fd:	b9 09 00 00 00       	mov    $0x9,%ecx
c0020502:	8d bb c5 2c ff ff    	lea    -0xd33b(%ebx),%edi
c0020508:	8b 74 24 04          	mov    0x4(%esp),%esi
c002050c:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c002050e:	0f 97 c0             	seta   %al
c0020511:	1c 00                	sbb    $0x0,%al
c0020513:	84 c0                	test   %al,%al
c0020515:	75 0f                	jne    c0020526 <pintos_init+0x29a>
      filesys_bdev_name = value;
c0020517:	8b 44 24 08          	mov    0x8(%esp),%eax
c002051b:	89 83 30 01 00 00    	mov    %eax,0x130(%ebx)
c0020521:	e9 02 ff ff ff       	jmp    c0020428 <pintos_init+0x19c>
    else if (!strcmp(name, "-scratch"))
c0020526:	b9 09 00 00 00       	mov    $0x9,%ecx
c002052b:	8d bb ce 2c ff ff    	lea    -0xd332(%ebx),%edi
c0020531:	8b 74 24 04          	mov    0x4(%esp),%esi
c0020535:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020537:	0f 97 c0             	seta   %al
c002053a:	1c 00                	sbb    $0x0,%al
c002053c:	84 c0                	test   %al,%al
c002053e:	75 0f                	jne    c002054f <pintos_init+0x2c3>
      scratch_bdev_name = value;
c0020540:	8b 44 24 08          	mov    0x8(%esp),%eax
c0020544:	89 83 2c 01 00 00    	mov    %eax,0x12c(%ebx)
c002054a:	e9 d9 fe ff ff       	jmp    c0020428 <pintos_init+0x19c>
    else if (!strcmp(name, "-swap"))
c002054f:	b9 06 00 00 00       	mov    $0x6,%ecx
c0020554:	8d bb d7 2c ff ff    	lea    -0xd329(%ebx),%edi
c002055a:	8b 74 24 04          	mov    0x4(%esp),%esi
c002055e:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020560:	0f 97 c0             	seta   %al
c0020563:	1c 00                	sbb    $0x0,%al
c0020565:	84 c0                	test   %al,%al
c0020567:	75 0f                	jne    c0020578 <pintos_init+0x2ec>
      swap_bdev_name = value;
c0020569:	8b 44 24 08          	mov    0x8(%esp),%eax
c002056d:	89 83 28 01 00 00    	mov    %eax,0x128(%ebx)
c0020573:	e9 b0 fe ff ff       	jmp    c0020428 <pintos_init+0x19c>
    else if (!strcmp(name, "-rs"))
c0020578:	83 ec 08             	sub    $0x8,%esp
c002057b:	8d 83 dd 2c ff ff    	lea    -0xd323(%ebx),%eax
c0020581:	50                   	push   %eax
c0020582:	ff 74 24 10          	pushl  0x10(%esp)
c0020586:	e8 cf 85 00 00       	call   c0028b5a <strcmp>
c002058b:	83 c4 10             	add    $0x10,%esp
c002058e:	85 c0                	test   %eax,%eax
c0020590:	74 26                	je     c00205b8 <pintos_init+0x32c>
    else if (!strcmp(name, "-mlfqs"))
c0020592:	83 ec 08             	sub    $0x8,%esp
c0020595:	8d 83 e1 2c ff ff    	lea    -0xd31f(%ebx),%eax
c002059b:	50                   	push   %eax
c002059c:	ff 74 24 10          	pushl  0x10(%esp)
c00205a0:	e8 b5 85 00 00       	call   c0028b5a <strcmp>
c00205a5:	83 c4 10             	add    $0x10,%esp
c00205a8:	85 c0                	test   %eax,%eax
c00205aa:	75 28                	jne    c00205d4 <pintos_init+0x348>
      thread_mlfqs = true;
c00205ac:	8b 44 24 10          	mov    0x10(%esp),%eax
c00205b0:	c6 00 01             	movb   $0x1,(%eax)
c00205b3:	e9 70 fe ff ff       	jmp    c0020428 <pintos_init+0x19c>
      random_init(atoi(value));
c00205b8:	83 ec 0c             	sub    $0xc,%esp
c00205bb:	ff 74 24 14          	pushl  0x14(%esp)
c00205bf:	e8 1b 82 00 00       	call   c00287df <atoi>
c00205c4:	89 04 24             	mov    %eax,(%esp)
c00205c7:	e8 ae 6f 00 00       	call   c002757a <random_init>
c00205cc:	83 c4 10             	add    $0x10,%esp
c00205cf:	e9 54 fe ff ff       	jmp    c0020428 <pintos_init+0x19c>
    else if (!strcmp(name, "-ul"))
c00205d4:	83 ec 08             	sub    $0x8,%esp
c00205d7:	8d 83 e8 2c ff ff    	lea    -0xd318(%ebx),%eax
c00205dd:	50                   	push   %eax
c00205de:	ff 74 24 10          	pushl  0x10(%esp)
c00205e2:	e8 73 85 00 00       	call   c0028b5a <strcmp>
c00205e7:	83 c4 10             	add    $0x10,%esp
c00205ea:	85 c0                	test   %eax,%eax
c00205ec:	75 1a                	jne    c0020608 <pintos_init+0x37c>
      user_page_limit = atoi(value);
c00205ee:	83 ec 0c             	sub    $0xc,%esp
c00205f1:	ff 74 24 14          	pushl  0x14(%esp)
c00205f5:	e8 e5 81 00 00       	call   c00287df <atoi>
c00205fa:	89 83 b4 fb ff ff    	mov    %eax,-0x44c(%ebx)
c0020600:	83 c4 10             	add    $0x10,%esp
c0020603:	e9 20 fe ff ff       	jmp    c0020428 <pintos_init+0x19c>
      PANIC("unknown option `%s' (use -h for help)", name);
c0020608:	83 ec 0c             	sub    $0xc,%esp
c002060b:	ff 74 24 10          	pushl  0x10(%esp)
c002060f:	8d 83 54 32 ff ff    	lea    -0xcdac(%ebx),%eax
c0020615:	50                   	push   %eax
c0020616:	8d 83 1c 19 ff ff    	lea    -0xe6e4(%ebx),%eax
c002061c:	50                   	push   %eax
c002061d:	68 3a 01 00 00       	push   $0x13a
c0020622:	8d 83 62 2c ff ff    	lea    -0xd39e(%ebx),%eax
c0020628:	50                   	push   %eax
c0020629:	e8 67 92 00 00       	call   c0029895 <debug_panic>
  for (; *argv != NULL && **argv == '-'; argv++)
c002062e:	8d ab 24 00 00 00    	lea    0x24(%ebx),%ebp
  random_init(rtc_get_time());
c0020634:	e8 13 6b 00 00       	call   c002714c <rtc_get_time>
c0020639:	83 ec 0c             	sub    $0xc,%esp
c002063c:	50                   	push   %eax
c002063d:	e8 38 6f 00 00       	call   c002757a <random_init>
  thread_init();
c0020642:	e8 e0 07 00 00       	call   c0020e27 <thread_init>
  console_init();
c0020647:	e8 7a b1 00 00       	call   c002b7c6 <console_init>
  printf("Pintos booting with %'" PRIu32 " kB RAM...\n",
c002064c:	83 c4 08             	add    $0x8,%esp
         init_ram_pages * PGSIZE / 1024);
c002064f:	c7 c6 7e 01 02 c0    	mov    $0xc002017e,%esi
c0020655:	8b 06                	mov    (%esi),%eax
c0020657:	c1 e0 0c             	shl    $0xc,%eax
  printf("Pintos booting with %'" PRIu32 " kB RAM...\n",
c002065a:	c1 e8 0a             	shr    $0xa,%eax
c002065d:	50                   	push   %eax
c002065e:	8d 83 7c 32 ff ff    	lea    -0xcd84(%ebx),%eax
c0020664:	50                   	push   %eax
c0020665:	e8 94 74 00 00       	call   c0027afe <printf>
  palloc_init(user_page_limit);
c002066a:	83 c4 04             	add    $0x4,%esp
c002066d:	ff b3 b4 fb ff ff    	pushl  -0x44c(%ebx)
c0020673:	e8 fa 36 00 00       	call   c0023d72 <palloc_init>
  malloc_init();
c0020678:	e8 76 3b 00 00       	call   c00241f3 <malloc_init>
  pd = init_page_dir = palloc_get_page(PAL_ASSERT | PAL_ZERO);
c002067d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
c0020684:	e8 46 38 00 00       	call   c0023ecf <palloc_get_page>
c0020689:	89 c1                	mov    %eax,%ecx
c002068b:	89 44 24 20          	mov    %eax,0x20(%esp)
c002068f:	c7 c0 b4 b2 04 c0    	mov    $0xc004b2b4,%eax
c0020695:	89 08                	mov    %ecx,(%eax)
  for (page = 0; page < init_ram_pages; page++)
c0020697:	83 c4 10             	add    $0x10,%esp
c002069a:	83 3e 00             	cmpl   $0x0,(%esi)
c002069d:	0f 84 6f 01 00 00    	je     c0020812 <pintos_init+0x586>
c00206a3:	bf 00 00 00 c0       	mov    $0xc0000000,%edi
  pt = NULL;
c00206a8:	b8 00 00 00 00       	mov    $0x0,%eax
  for (page = 0; page < init_ram_pages; page++)
c00206ad:	be 00 00 00 00       	mov    $0x0,%esi
    bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c00206b2:	c7 c1 00 70 03 c0    	mov    $0xc0037000,%ecx
c00206b8:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c00206bc:	c7 c1 00 00 02 c0    	mov    $0xc0020000,%ecx
c00206c2:	89 4c 24 18          	mov    %ecx,0x18(%esp)
c00206c6:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
c00206ca:	e9 a6 00 00 00       	jmp    c0020775 <pintos_init+0x4e9>
  for (; *argv != NULL && **argv == '-'; argv++)
c00206cf:	8d ab 24 00 00 00    	lea    0x24(%ebx),%ebp
c00206d5:	e9 5a ff ff ff       	jmp    c0020634 <pintos_init+0x3a8>
#define PTE_D 0x40           /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create(uint32_t *pt)
{
  ASSERT(pg_ofs(pt) == 0);
c00206da:	83 ec 0c             	sub    $0xc,%esp
c00206dd:	8d 83 ec 2c ff ff    	lea    -0xd314(%ebx),%eax
c00206e3:	50                   	push   %eax
c00206e4:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00206ea:	50                   	push   %eax
c00206eb:	8d 83 10 19 ff ff    	lea    -0xe6f0(%ebx),%eax
c00206f1:	50                   	push   %eax
c00206f2:	6a 4b                	push   $0x4b
c00206f4:	8d 83 13 2d ff ff    	lea    -0xd2ed(%ebx),%eax
c00206fa:	50                   	push   %eax
c00206fb:	e8 95 91 00 00       	call   c0029895 <debug_panic>
/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop(const void *vaddr)
{
  ASSERT(is_kernel_vaddr(vaddr));
c0020700:	83 ec 0c             	sub    $0xc,%esp
c0020703:	8d 83 27 2d ff ff    	lea    -0xd2d9(%ebx),%eax
c0020709:	50                   	push   %eax
c002070a:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0020710:	50                   	push   %eax
c0020711:	8d 83 08 19 ff ff    	lea    -0xe6f8(%ebx),%eax
c0020717:	50                   	push   %eax
c0020718:	6a 58                	push   $0x58
c002071a:	8d 83 3e 2d ff ff    	lea    -0xd2c2(%ebx),%eax
c0020720:	50                   	push   %eax
c0020721:	e8 6f 91 00 00       	call   c0029895 <debug_panic>
    pt[pte_idx] = pte_create_kernel(vaddr, !in_kernel_text);
c0020726:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c002072a:	8d 0c 88             	lea    (%eax,%ecx,4),%ecx
c002072d:	81 7c 24 0c ff ff ff 	cmpl   $0xbfffffff,0xc(%esp)
c0020734:	bf 
c0020735:	0f 86 ad 00 00 00    	jbe    c00207e8 <pintos_init+0x55c>
c002073b:	89 f2                	mov    %esi,%edx
c002073d:	c1 e2 0c             	shl    $0xc,%edx
c0020740:	89 54 24 08          	mov    %edx,0x8(%esp)
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel(void *page, bool writable)
{
  ASSERT(pg_ofs(page) == 0);
  return vtop(page) | PTE_P | (writable ? PTE_W : 0);
c0020744:	0f b6 6c 24 04       	movzbl 0x4(%esp),%ebp
c0020749:	83 f5 01             	xor    $0x1,%ebp
c002074c:	89 ea                	mov    %ebp,%edx
c002074e:	0f b6 ea             	movzbl %dl,%ebp
c0020751:	01 ed                	add    %ebp,%ebp
c0020753:	8b 54 24 08          	mov    0x8(%esp),%edx
c0020757:	83 ca 01             	or     $0x1,%edx
c002075a:	09 ea                	or     %ebp,%edx
c002075c:	89 11                	mov    %edx,(%ecx)
  for (page = 0; page < init_ram_pages; page++)
c002075e:	83 c6 01             	add    $0x1,%esi
c0020761:	81 c7 00 10 00 00    	add    $0x1000,%edi
c0020767:	c7 c2 7e 01 02 c0    	mov    $0xc002017e,%edx
c002076d:	3b 32                	cmp    (%edx),%esi
c002076f:	0f 83 99 00 00 00    	jae    c002080e <pintos_init+0x582>
  return ((uintptr_t)va & PTMASK) >> PTSHIFT;
c0020775:	89 fa                	mov    %edi,%edx
c0020777:	c1 ea 0c             	shr    $0xc,%edx
c002077a:	81 e2 ff 03 00 00    	and    $0x3ff,%edx
c0020780:	89 54 24 08          	mov    %edx,0x8(%esp)
c0020784:	89 7c 24 0c          	mov    %edi,0xc(%esp)
    bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020788:	3b 7c 24 14          	cmp    0x14(%esp),%edi
c002078c:	0f 92 c1             	setb   %cl
c002078f:	3b 7c 24 18          	cmp    0x18(%esp),%edi
c0020793:	0f 93 c2             	setae  %dl
c0020796:	21 d1                	and    %edx,%ecx
c0020798:	88 4c 24 04          	mov    %cl,0x4(%esp)
  return (uintptr_t)va >> PDSHIFT;
c002079c:	89 fa                	mov    %edi,%edx
c002079e:	c1 ea 16             	shr    $0x16,%edx
    if (pd[pde_idx] == 0)
c00207a1:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c00207a5:	8d 2c 91             	lea    (%ecx,%edx,4),%ebp
c00207a8:	83 7d 00 00          	cmpl   $0x0,0x0(%ebp)
c00207ac:	0f 85 74 ff ff ff    	jne    c0020726 <pintos_init+0x49a>
      pt = palloc_get_page(PAL_ASSERT | PAL_ZERO);
c00207b2:	83 ec 0c             	sub    $0xc,%esp
c00207b5:	6a 03                	push   $0x3
c00207b7:	e8 13 37 00 00       	call   c0023ecf <palloc_get_page>
  return (uintptr_t)va & PGMASK;
c00207bc:	89 c2                	mov    %eax,%edx
  ASSERT(pg_ofs(pt) == 0);
c00207be:	83 c4 10             	add    $0x10,%esp
c00207c1:	a9 ff 0f 00 00       	test   $0xfff,%eax
c00207c6:	0f 85 0e ff ff ff    	jne    c00206da <pintos_init+0x44e>
  ASSERT(is_kernel_vaddr(vaddr));
c00207cc:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00207d1:	0f 86 29 ff ff ff    	jbe    c0020700 <pintos_init+0x474>

  return (uintptr_t)vaddr - (uintptr_t)PHYS_BASE;
c00207d7:	81 c2 00 00 00 40    	add    $0x40000000,%edx
  return vtop(pt) | PTE_U | PTE_P | PTE_W;
c00207dd:	83 ca 07             	or     $0x7,%edx
c00207e0:	89 55 00             	mov    %edx,0x0(%ebp)
c00207e3:	e9 3e ff ff ff       	jmp    c0020726 <pintos_init+0x49a>
  ASSERT(is_kernel_vaddr(vaddr));
c00207e8:	83 ec 0c             	sub    $0xc,%esp
c00207eb:	8d 83 27 2d ff ff    	lea    -0xd2d9(%ebx),%eax
c00207f1:	50                   	push   %eax
c00207f2:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00207f8:	50                   	push   %eax
c00207f9:	8d 83 08 19 ff ff    	lea    -0xe6f8(%ebx),%eax
c00207ff:	50                   	push   %eax
c0020800:	6a 58                	push   $0x58
c0020802:	8d 83 3e 2d ff ff    	lea    -0xd2c2(%ebx),%eax
c0020808:	50                   	push   %eax
c0020809:	e8 87 90 00 00       	call   c0029895 <debug_panic>
c002080e:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
               : "r"(vtop(init_page_dir)));
c0020812:	c7 c0 b4 b2 04 c0    	mov    $0xc004b2b4,%eax
c0020818:	8b 00                	mov    (%eax),%eax
c002081a:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002081f:	0f 86 ce 00 00 00    	jbe    c00208f3 <pintos_init+0x667>
  return (uintptr_t)vaddr - (uintptr_t)PHYS_BASE;
c0020825:	05 00 00 00 40       	add    $0x40000000,%eax
  asm volatile("movl %0, %%cr3"
c002082a:	0f 22 d8             	mov    %eax,%cr3
  tss_init();
c002082d:	e8 1e da 00 00       	call   c002e250 <tss_init>
  gdt_init();
c0020832:	e8 ae d8 00 00       	call   c002e0e5 <gdt_init>
  intr_init();
c0020837:	e8 90 17 00 00       	call   c0021fcc <intr_init>
  timer_init();
c002083c:	e8 be 41 00 00       	call   c00249ff <timer_init>
  kbd_init();
c0020841:	e8 81 47 00 00       	call   c0024fc7 <kbd_init>
  input_init();
c0020846:	e8 ab 62 00 00       	call   c0026af6 <input_init>
  exception_init();
c002084b:	e8 dd c3 00 00       	call   c002cc2d <exception_init>
  syscall_init();
c0020850:	e8 41 c5 00 00       	call   c002cd96 <syscall_init>
  thread_start();
c0020855:	e8 0f 12 00 00       	call   c0021a69 <thread_start>
  serial_init_queue();
c002085a:	e8 12 4c 00 00       	call   c0025471 <serial_init_queue>
  timer_calibrate();
c002085f:	e8 d2 41 00 00       	call   c0024a36 <timer_calibrate>
  ide_init();
c0020864:	e8 53 5d 00 00       	call   c00265bc <ide_init>
  locate_block_device(BLOCK_FILESYS, filesys_bdev_name);
c0020869:	8b 93 30 01 00 00    	mov    0x130(%ebx),%edx
c002086f:	b8 01 00 00 00       	mov    $0x1,%eax
c0020874:	e8 09 f9 ff ff       	call   c0020182 <locate_block_device>
  locate_block_device(BLOCK_SCRATCH, scratch_bdev_name);
c0020879:	8b 93 2c 01 00 00    	mov    0x12c(%ebx),%edx
c002087f:	b8 02 00 00 00       	mov    $0x2,%eax
c0020884:	e8 f9 f8 ff ff       	call   c0020182 <locate_block_device>
  locate_block_device(BLOCK_SWAP, swap_bdev_name);
c0020889:	8b 93 28 01 00 00    	mov    0x128(%ebx),%edx
c002088f:	b8 03 00 00 00       	mov    $0x3,%eax
c0020894:	e8 e9 f8 ff ff       	call   c0020182 <locate_block_device>
  filesys_init(format_filesys);
c0020899:	83 ec 0c             	sub    $0xc,%esp
c002089c:	0f b6 83 34 01 00 00 	movzbl 0x134(%ebx),%eax
c00208a3:	50                   	push   %eax
c00208a4:	e8 e7 db 00 00       	call   c002e490 <filesys_init>
    page_init();
c00208a9:	e8 8f 14 01 00       	call   c0031d3d <page_init>
    frame_init();
c00208ae:	e8 5f 0a 01 00       	call   c0031312 <frame_init>
    swap_init();
c00208b3:	e8 34 11 01 00       	call   c00319ec <swap_init>
  printf("Boot complete.\n");
c00208b8:	8d 83 54 2d ff ff    	lea    -0xd2ac(%ebx),%eax
c00208be:	89 04 24             	mov    %eax,(%esp)
c00208c1:	e8 a8 af 00 00       	call   c002b86e <puts>
  if (*argv != NULL)
c00208c6:	8b 7d 00             	mov    0x0(%ebp),%edi
c00208c9:	83 c4 10             	add    $0x10,%esp
      if (a->name == NULL)
c00208cc:	8d 83 a2 35 ff ff    	lea    -0xca5e(%ebx),%eax
c00208d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  if (*argv != NULL)
c00208d6:	85 ff                	test   %edi,%edi
c00208d8:	0f 85 9f 00 00 00    	jne    c002097d <pintos_init+0x6f1>
    char cmd[CMD_LENGTH] = {'\0'};
c00208de:	8d 7c 24 20          	lea    0x20(%esp),%edi
c00208e2:	b9 20 00 00 00       	mov    $0x20,%ecx
c00208e7:	b8 00 00 00 00       	mov    $0x0,%eax
c00208ec:	f3 ab                	rep stos %eax,%es:(%edi)
c00208ee:	e9 e3 00 00 00       	jmp    c00209d6 <pintos_init+0x74a>
  ASSERT(is_kernel_vaddr(vaddr));
c00208f3:	83 ec 0c             	sub    $0xc,%esp
c00208f6:	8d 83 27 2d ff ff    	lea    -0xd2d9(%ebx),%eax
c00208fc:	50                   	push   %eax
c00208fd:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0020903:	50                   	push   %eax
c0020904:	8d 83 08 19 ff ff    	lea    -0xe6f8(%ebx),%eax
c002090a:	50                   	push   %eax
c002090b:	6a 58                	push   $0x58
c002090d:	8d 83 3e 2d ff ff    	lea    -0xd2c2(%ebx),%eax
c0020913:	50                   	push   %eax
c0020914:	e8 7c 8f 00 00       	call   c0029895 <debug_panic>
    for (i = 1; i < a->argc; i++)
c0020919:	8b 56 04             	mov    0x4(%esi),%edx
c002091c:	83 fa 01             	cmp    $0x1,%edx
c002091f:	7e 40                	jle    c0020961 <pintos_init+0x6d5>
      if (argv[i] == NULL)
c0020921:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c0020925:	74 13                	je     c002093a <pintos_init+0x6ae>
    for (i = 1; i < a->argc; i++)
c0020927:	b8 01 00 00 00       	mov    $0x1,%eax
c002092c:	83 c0 01             	add    $0x1,%eax
c002092f:	39 c2                	cmp    %eax,%edx
c0020931:	74 2e                	je     c0020961 <pintos_init+0x6d5>
      if (argv[i] == NULL)
c0020933:	83 7c 85 00 00       	cmpl   $0x0,0x0(%ebp,%eax,4)
c0020938:	75 f2                	jne    c002092c <pintos_init+0x6a0>
        PANIC("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c002093a:	83 ec 08             	sub    $0x8,%esp
c002093d:	83 ea 01             	sub    $0x1,%edx
c0020940:	52                   	push   %edx
c0020941:	57                   	push   %edi
c0020942:	8d 83 c8 32 ff ff    	lea    -0xcd38(%ebx),%eax
c0020948:	50                   	push   %eax
c0020949:	8d 83 e8 18 ff ff    	lea    -0xe718(%ebx),%eax
c002094f:	50                   	push   %eax
c0020950:	68 82 01 00 00       	push   $0x182
c0020955:	8d 83 62 2c ff ff    	lea    -0xd39e(%ebx),%eax
c002095b:	50                   	push   %eax
c002095c:	e8 34 8f 00 00       	call   c0029895 <debug_panic>
    a->function(argv);
c0020961:	83 ec 0c             	sub    $0xc,%esp
c0020964:	55                   	push   %ebp
c0020965:	ff 56 08             	call   *0x8(%esi)
    argv += a->argc;
c0020968:	8b 46 04             	mov    0x4(%esi),%eax
c002096b:	8d 6c 85 00          	lea    0x0(%ebp,%eax,4),%ebp
  while (*argv != NULL)
c002096f:	8b 7d 00             	mov    0x0(%ebp),%edi
c0020972:	83 c4 10             	add    $0x10,%esp
c0020975:	85 ff                	test   %edi,%edi
c0020977:	0f 84 95 01 00 00    	je     c0020b12 <pintos_init+0x886>
      if (a->name == NULL)
c002097d:	8b 44 24 04          	mov    0x4(%esp),%eax
    for (a = actions;; a++)
c0020981:	8d b3 e4 57 ff ff    	lea    -0xa81c(%ebx),%esi
      else if (!strcmp(*argv, a->name))
c0020987:	83 ec 08             	sub    $0x8,%esp
c002098a:	50                   	push   %eax
c002098b:	57                   	push   %edi
c002098c:	e8 c9 81 00 00       	call   c0028b5a <strcmp>
c0020991:	83 c4 10             	add    $0x10,%esp
c0020994:	85 c0                	test   %eax,%eax
c0020996:	74 81                	je     c0020919 <pintos_init+0x68d>
    for (a = actions;; a++)
c0020998:	83 c6 0c             	add    $0xc,%esi
      if (a->name == NULL)
c002099b:	8b 06                	mov    (%esi),%eax
c002099d:	85 c0                	test   %eax,%eax
c002099f:	75 e6                	jne    c0020987 <pintos_init+0x6fb>
        PANIC("unknown action `%s' (use -h for help)", *argv);
c00209a1:	83 ec 0c             	sub    $0xc,%esp
c00209a4:	57                   	push   %edi
c00209a5:	8d 83 a0 32 ff ff    	lea    -0xcd60(%ebx),%eax
c00209ab:	50                   	push   %eax
c00209ac:	8d 83 e8 18 ff ff    	lea    -0xe718(%ebx),%eax
c00209b2:	50                   	push   %eax
c00209b3:	68 7b 01 00 00       	push   $0x17b
c00209b8:	8d 83 62 2c ff ff    	lea    -0xd39e(%ebx),%eax
c00209be:	50                   	push   %eax
c00209bf:	e8 d1 8e 00 00       	call   c0029895 <debug_panic>
        puts("PintOS--SJTU");
c00209c4:	83 ec 0c             	sub    $0xc,%esp
c00209c7:	8d 83 7e 2d ff ff    	lea    -0xd282(%ebx),%eax
c00209cd:	50                   	push   %eax
c00209ce:	e8 9b ae 00 00       	call   c002b86e <puts>
c00209d3:	83 c4 10             	add    $0x10,%esp
      int tick = timer_ticks();
c00209d6:	e8 49 41 00 00       	call   c0024b24 <timer_ticks>
c00209db:	89 c6                	mov    %eax,%esi
      char output_str[CMD_LENGTH] = {'\0'};
c00209dd:	8d bc 24 a0 00 00 00 	lea    0xa0(%esp),%edi
c00209e4:	b9 20 00 00 00       	mov    $0x20,%ecx
c00209e9:	b8 00 00 00 00       	mov    $0x0,%eax
c00209ee:	f3 ab                	rep stos %eax,%es:(%edi)
      snprintf(output_str, CMD_LENGTH, "~ at %02d:%02d:%02d||", hour % 24, min % 60, sec % 60);
c00209f0:	83 ec 08             	sub    $0x8,%esp
      int sec = tick / TIMER_FREQ;
c00209f3:	b8 1f 85 eb 51       	mov    $0x51eb851f,%eax
c00209f8:	f7 ee                	imul   %esi
c00209fa:	c1 fa 05             	sar    $0x5,%edx
c00209fd:	89 f5                	mov    %esi,%ebp
c00209ff:	c1 fd 1f             	sar    $0x1f,%ebp
c0020a02:	89 d1                	mov    %edx,%ecx
c0020a04:	29 e9                	sub    %ebp,%ecx
      snprintf(output_str, CMD_LENGTH, "~ at %02d:%02d:%02d||", hour % 24, min % 60, sec % 60);
c0020a06:	bf 89 88 88 88       	mov    $0x88888889,%edi
c0020a0b:	89 c8                	mov    %ecx,%eax
c0020a0d:	f7 ef                	imul   %edi
c0020a0f:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
c0020a12:	c1 f8 05             	sar    $0x5,%eax
c0020a15:	89 ca                	mov    %ecx,%edx
c0020a17:	c1 fa 1f             	sar    $0x1f,%edx
c0020a1a:	29 d0                	sub    %edx,%eax
c0020a1c:	6b c0 3c             	imul   $0x3c,%eax,%eax
c0020a1f:	29 c1                	sub    %eax,%ecx
c0020a21:	51                   	push   %ecx
      int min = sec / 60;
c0020a22:	ba f1 19 76 05       	mov    $0x57619f1,%edx
c0020a27:	89 f0                	mov    %esi,%eax
c0020a29:	f7 ea                	imul   %edx
c0020a2b:	c1 fa 07             	sar    $0x7,%edx
c0020a2e:	89 d1                	mov    %edx,%ecx
c0020a30:	29 e9                	sub    %ebp,%ecx
      snprintf(output_str, CMD_LENGTH, "~ at %02d:%02d:%02d||", hour % 24, min % 60, sec % 60);
c0020a32:	89 c8                	mov    %ecx,%eax
c0020a34:	f7 ef                	imul   %edi
c0020a36:	8d 04 0a             	lea    (%edx,%ecx,1),%eax
c0020a39:	c1 f8 05             	sar    $0x5,%eax
c0020a3c:	89 ca                	mov    %ecx,%edx
c0020a3e:	c1 fa 1f             	sar    $0x1f,%edx
c0020a41:	29 d0                	sub    %edx,%eax
c0020a43:	6b c0 3c             	imul   $0x3c,%eax,%eax
c0020a46:	29 c1                	sub    %eax,%ecx
c0020a48:	51                   	push   %ecx
      int hour = min / 60;
c0020a49:	ba ef ed 34 5d       	mov    $0x5d34edef,%edx
c0020a4e:	89 f0                	mov    %esi,%eax
c0020a50:	f7 ea                	imul   %edx
c0020a52:	89 d6                	mov    %edx,%esi
c0020a54:	c1 fe 11             	sar    $0x11,%esi
c0020a57:	29 ee                	sub    %ebp,%esi
      snprintf(output_str, CMD_LENGTH, "~ at %02d:%02d:%02d||", hour % 24, min % 60, sec % 60);
c0020a59:	ba ab aa aa 2a       	mov    $0x2aaaaaab,%edx
c0020a5e:	89 f0                	mov    %esi,%eax
c0020a60:	f7 ea                	imul   %edx
c0020a62:	c1 fa 02             	sar    $0x2,%edx
c0020a65:	89 f0                	mov    %esi,%eax
c0020a67:	c1 f8 1f             	sar    $0x1f,%eax
c0020a6a:	29 c2                	sub    %eax,%edx
c0020a6c:	8d 04 52             	lea    (%edx,%edx,2),%eax
c0020a6f:	c1 e0 03             	shl    $0x3,%eax
c0020a72:	29 c6                	sub    %eax,%esi
c0020a74:	56                   	push   %esi
c0020a75:	8d 83 63 2d ff ff    	lea    -0xd29d(%ebx),%eax
c0020a7b:	50                   	push   %eax
c0020a7c:	68 80 00 00 00       	push   $0x80
c0020a81:	8d b4 24 bc 00 00 00 	lea    0xbc(%esp),%esi
c0020a88:	56                   	push   %esi
c0020a89:	e8 91 79 00 00       	call   c002841f <snprintf>
      puts(output_str);
c0020a8e:	83 c4 14             	add    $0x14,%esp
c0020a91:	56                   	push   %esi
c0020a92:	e8 d7 ad 00 00       	call   c002b86e <puts>
      puts("$ \0");
c0020a97:	8d 83 e4 18 ff ff    	lea    -0xe71c(%ebx),%eax
c0020a9d:	89 04 24             	mov    %eax,(%esp)
c0020aa0:	e8 c9 ad 00 00       	call   c002b86e <puts>
      readline(cmd, CMD_LENGTH);
c0020aa5:	83 c4 08             	add    $0x8,%esp
c0020aa8:	68 80 00 00 00       	push   $0x80
c0020aad:	8d 74 24 2c          	lea    0x2c(%esp),%esi
c0020ab1:	56                   	push   %esi
c0020ab2:	e8 3a 61 00 00       	call   c0026bf1 <readline>
      if (strcmp(cmd, "info") == 0)
c0020ab7:	b9 05 00 00 00       	mov    $0x5,%ecx
c0020abc:	8d bb 79 2d ff ff    	lea    -0xd287(%ebx),%edi
c0020ac2:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020ac4:	0f 97 c0             	seta   %al
c0020ac7:	1c 00                	sbb    $0x0,%al
c0020ac9:	83 c4 10             	add    $0x10,%esp
c0020acc:	84 c0                	test   %al,%al
c0020ace:	0f 84 f0 fe ff ff    	je     c00209c4 <pintos_init+0x738>
      else if (strcmp(cmd, "exit") == 0)
c0020ad4:	8d 74 24 20          	lea    0x20(%esp),%esi
c0020ad8:	b9 05 00 00 00       	mov    $0x5,%ecx
c0020add:	8d bb 8b 2d ff ff    	lea    -0xd275(%ebx),%edi
c0020ae3:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c0020ae5:	0f 97 c0             	seta   %al
c0020ae8:	1c 00                	sbb    $0x0,%al
c0020aea:	84 c0                	test   %al,%al
c0020aec:	74 17                	je     c0020b05 <pintos_init+0x879>
        puts("Can not found.");
c0020aee:	83 ec 0c             	sub    $0xc,%esp
c0020af1:	8d 83 90 2d ff ff    	lea    -0xd270(%ebx),%eax
c0020af7:	50                   	push   %eax
c0020af8:	e8 71 ad 00 00       	call   c002b86e <puts>
c0020afd:	83 c4 10             	add    $0x10,%esp
    {
c0020b00:	e9 d1 fe ff ff       	jmp    c00209d6 <pintos_init+0x74a>
        shutdown_configure(SHUTDOWN_POWER_OFF);
c0020b05:	83 ec 0c             	sub    $0xc,%esp
c0020b08:	6a 01                	push   $0x1
c0020b0a:	e8 b3 67 00 00       	call   c00272c2 <shutdown_configure>
c0020b0f:	83 c4 10             	add    $0x10,%esp
  shutdown();
c0020b12:	e8 e4 68 00 00       	call   c00273fb <shutdown>
  thread_exit();
c0020b17:	e8 5e 0b 00 00       	call   c002167a <thread_exit>

c0020b1c <alloc_frame>:

/* Allocates a SIZE-byte frame at the top of thread T's stack and
   returns a pointer to the frame's base. */
static void *
alloc_frame(struct thread *t, size_t size)
{
c0020b1c:	53                   	push   %ebx
c0020b1d:	83 ec 08             	sub    $0x8,%esp
c0020b20:	e8 c1 19 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0020b25:	81 c3 17 01 02 00    	add    $0x20117,%ebx
  return t != NULL && t->magic == THREAD_MAGIC;
c0020b2b:	85 c0                	test   %eax,%eax
c0020b2d:	74 09                	je     c0020b38 <alloc_frame+0x1c>
c0020b2f:	81 78 38 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x38(%eax)
c0020b36:	74 52                	je     c0020b8a <alloc_frame+0x6e>
  /* Stack data is always allocated in word-size units. */
  ASSERT(is_thread(t));
c0020b38:	83 ec 0c             	sub    $0xc,%esp
c0020b3b:	8d 83 20 33 ff ff    	lea    -0xcce0(%ebx),%eax
c0020b41:	50                   	push   %eax
c0020b42:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0020b48:	50                   	push   %eax
c0020b49:	8d 83 20 1a ff ff    	lea    -0xe5e0(%ebx),%eax
c0020b4f:	50                   	push   %eax
c0020b50:	68 85 02 00 00       	push   $0x285
c0020b55:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0020b5b:	50                   	push   %eax
c0020b5c:	e8 34 8d 00 00       	call   c0029895 <debug_panic>
  ASSERT(size % sizeof(uint32_t) == 0);
c0020b61:	83 ec 0c             	sub    $0xc,%esp
c0020b64:	8d 83 ec 32 ff ff    	lea    -0xcd14(%ebx),%eax
c0020b6a:	50                   	push   %eax
c0020b6b:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0020b71:	50                   	push   %eax
c0020b72:	8d 83 20 1a ff ff    	lea    -0xe5e0(%ebx),%eax
c0020b78:	50                   	push   %eax
c0020b79:	68 86 02 00 00       	push   $0x286
c0020b7e:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0020b84:	50                   	push   %eax
c0020b85:	e8 0b 8d 00 00       	call   c0029895 <debug_panic>
c0020b8a:	f6 c2 03             	test   $0x3,%dl
c0020b8d:	75 d2                	jne    c0020b61 <alloc_frame+0x45>

  t->stack -= size;
c0020b8f:	8b 48 18             	mov    0x18(%eax),%ecx
c0020b92:	29 d1                	sub    %edx,%ecx
c0020b94:	89 48 18             	mov    %ecx,0x18(%eax)
  return t->stack;
}
c0020b97:	89 c8                	mov    %ecx,%eax
c0020b99:	83 c4 08             	add    $0x8,%esp
c0020b9c:	5b                   	pop    %ebx
c0020b9d:	c3                   	ret    

c0020b9e <init_thread>:
{
c0020b9e:	55                   	push   %ebp
c0020b9f:	57                   	push   %edi
c0020ba0:	56                   	push   %esi
c0020ba1:	53                   	push   %ebx
c0020ba2:	83 ec 1c             	sub    $0x1c,%esp
c0020ba5:	e8 3c 19 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0020baa:	81 c3 92 00 02 00    	add    $0x20092,%ebx
  ASSERT(t != NULL);
c0020bb0:	85 c0                	test   %eax,%eax
c0020bb2:	0f 84 1b 01 00 00    	je     c0020cd3 <init_thread+0x135>
c0020bb8:	89 c6                	mov    %eax,%esi
c0020bba:	89 cd                	mov    %ecx,%ebp
  ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
c0020bbc:	83 f9 3f             	cmp    $0x3f,%ecx
c0020bbf:	0f 87 37 01 00 00    	ja     c0020cfc <init_thread+0x15e>
  ASSERT(name != NULL);
c0020bc5:	85 d2                	test   %edx,%edx
c0020bc7:	0f 84 58 01 00 00    	je     c0020d25 <init_thread+0x187>
  memset(t, 0, sizeof *t);
c0020bcd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0020bd3:	c7 80 d0 00 00 00 00 	movl   $0x0,0xd0(%eax)
c0020bda:	00 00 00 
c0020bdd:	8d 78 04             	lea    0x4(%eax),%edi
c0020be0:	83 e7 fc             	and    $0xfffffffc,%edi
c0020be3:	89 c1                	mov    %eax,%ecx
c0020be5:	29 f9                	sub    %edi,%ecx
c0020be7:	81 c1 d4 00 00 00    	add    $0xd4,%ecx
c0020bed:	c1 e9 02             	shr    $0x2,%ecx
c0020bf0:	b8 00 00 00 00       	mov    $0x0,%eax
c0020bf5:	f3 ab                	rep stos %eax,%es:(%edi)
  t->status = THREAD_BLOCKED;
c0020bf7:	c7 46 04 02 00 00 00 	movl   $0x2,0x4(%esi)
  strlcpy(t->name, name, sizeof t->name);
c0020bfe:	83 ec 04             	sub    $0x4,%esp
c0020c01:	6a 10                	push   $0x10
c0020c03:	52                   	push   %edx
c0020c04:	8d 46 08             	lea    0x8(%esi),%eax
c0020c07:	50                   	push   %eax
c0020c08:	e8 dd 82 00 00       	call   c0028eea <strlcpy>
  t->stack = (uint8_t *)t + PGSIZE;
c0020c0d:	8d 86 00 10 00 00    	lea    0x1000(%esi),%eax
c0020c13:	89 46 18             	mov    %eax,0x18(%esi)
  t->priority = priority;
c0020c16:	89 6e 1c             	mov    %ebp,0x1c(%esi)
  t->magic = THREAD_MAGIC;
c0020c19:	c7 46 38 4b bf 6a cd 	movl   $0xcd6abf4b,0x38(%esi)
  if (thread_mlfqs)
c0020c20:	83 c4 10             	add    $0x10,%esp
c0020c23:	c7 c0 bc b2 04 c0    	mov    $0xc004b2bc,%eax
c0020c29:	80 38 00             	cmpb   $0x0,(%eax)
c0020c2c:	0f 85 1c 01 00 00    	jne    c0020d4e <init_thread+0x1b0>
  t->priority_to_set = -1;
c0020c32:	c7 46 58 ff ff ff ff 	movl   $0xffffffff,0x58(%esi)
  t->max_donate = 0;
c0020c39:	c7 46 60 00 00 00 00 	movl   $0x0,0x60(%esi)
  t->father = NULL;
c0020c40:	c7 46 64 00 00 00 00 	movl   $0x0,0x64(%esi)
  list_init(&t->lock_list);
c0020c47:	83 ec 0c             	sub    $0xc,%esp
c0020c4a:	8d 46 48             	lea    0x48(%esi),%eax
c0020c4d:	50                   	push   %eax
c0020c4e:	e8 0f 8d 00 00       	call   c0029962 <list_init>
  t->grandpa_died = false;
c0020c53:	c6 86 a8 00 00 00 00 	movb   $0x0,0xa8(%esi)
  list_init(&t->child_list);
c0020c5a:	8d 46 70             	lea    0x70(%esi),%eax
c0020c5d:	89 04 24             	mov    %eax,(%esp)
c0020c60:	e8 fd 8c 00 00       	call   c0029962 <list_init>
  sema_init(&t->sema_finished, 0);
c0020c65:	83 c4 08             	add    $0x8,%esp
c0020c68:	6a 00                	push   $0x0
c0020c6a:	8d 86 80 00 00 00    	lea    0x80(%esi),%eax
c0020c70:	50                   	push   %eax
c0020c71:	e8 4a 25 00 00       	call   c00231c0 <sema_init>
  sema_init(&t->sema_started, 0);
c0020c76:	83 c4 08             	add    $0x8,%esp
c0020c79:	6a 00                	push   $0x0
c0020c7b:	8d 86 94 00 00 00    	lea    0x94(%esi),%eax
c0020c81:	50                   	push   %eax
c0020c82:	e8 39 25 00 00       	call   c00231c0 <sema_init>
  t->return_value = 0;
c0020c87:	c7 86 b4 00 00 00 00 	movl   $0x0,0xb4(%esi)
c0020c8e:	00 00 00 
    list_init(&t->mmap_list);
c0020c91:	8d 86 c0 00 00 00    	lea    0xc0(%esi),%eax
c0020c97:	89 04 24             	mov    %eax,(%esp)
c0020c9a:	e8 c3 8c 00 00       	call   c0029962 <list_init>
    t->next_mapid = 1;
c0020c9f:	c7 86 d0 00 00 00 01 	movl   $0x1,0xd0(%esi)
c0020ca6:	00 00 00 
  old_level = intr_disable();
c0020ca9:	e8 fd 12 00 00       	call   c0021fab <intr_disable>
c0020cae:	89 c7                	mov    %eax,%edi
  list_push_back(&all_list, &t->allelem);
c0020cb0:	83 c4 08             	add    $0x8,%esp
c0020cb3:	83 c6 20             	add    $0x20,%esi
c0020cb6:	56                   	push   %esi
c0020cb7:	8d 83 a0 01 00 00    	lea    0x1a0(%ebx),%eax
c0020cbd:	50                   	push   %eax
c0020cbe:	e8 85 92 00 00       	call   c0029f48 <list_push_back>
  intr_set_level(old_level);
c0020cc3:	89 3c 24             	mov    %edi,(%esp)
c0020cc6:	e8 e7 12 00 00       	call   c0021fb2 <intr_set_level>
}
c0020ccb:	83 c4 2c             	add    $0x2c,%esp
c0020cce:	5b                   	pop    %ebx
c0020ccf:	5e                   	pop    %esi
c0020cd0:	5f                   	pop    %edi
c0020cd1:	5d                   	pop    %ebp
c0020cd2:	c3                   	ret    
  ASSERT(t != NULL);
c0020cd3:	83 ec 0c             	sub    $0xc,%esp
c0020cd6:	8d 83 32 57 ff ff    	lea    -0xa8ce(%ebx),%eax
c0020cdc:	50                   	push   %eax
c0020cdd:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0020ce3:	50                   	push   %eax
c0020ce4:	8d 83 4c 1a ff ff    	lea    -0xe5b4(%ebx),%eax
c0020cea:	50                   	push   %eax
c0020ceb:	68 56 02 00 00       	push   $0x256
c0020cf0:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0020cf6:	50                   	push   %eax
c0020cf7:	e8 99 8b 00 00       	call   c0029895 <debug_panic>
  ASSERT(PRI_MIN <= priority && priority <= PRI_MAX);
c0020cfc:	83 ec 0c             	sub    $0xc,%esp
c0020cff:	8d 83 f4 33 ff ff    	lea    -0xcc0c(%ebx),%eax
c0020d05:	50                   	push   %eax
c0020d06:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0020d0c:	50                   	push   %eax
c0020d0d:	8d 83 4c 1a ff ff    	lea    -0xe5b4(%ebx),%eax
c0020d13:	50                   	push   %eax
c0020d14:	68 57 02 00 00       	push   $0x257
c0020d19:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0020d1f:	50                   	push   %eax
c0020d20:	e8 70 8b 00 00       	call   c0029895 <debug_panic>
  ASSERT(name != NULL);
c0020d25:	83 ec 0c             	sub    $0xc,%esp
c0020d28:	8d 83 0c 52 ff ff    	lea    -0xadf4(%ebx),%eax
c0020d2e:	50                   	push   %eax
c0020d2f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0020d35:	50                   	push   %eax
c0020d36:	8d 83 4c 1a ff ff    	lea    -0xe5b4(%ebx),%eax
c0020d3c:	50                   	push   %eax
c0020d3d:	68 58 02 00 00       	push   $0x258
c0020d42:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0020d48:	50                   	push   %eax
c0020d49:	e8 47 8b 00 00       	call   c0029895 <debug_panic>
    t->nice = 0;
c0020d4e:	c7 46 5c 00 00 00 00 	movl   $0x0,0x5c(%esi)
    t->recent_cpu = float32_init(0);
c0020d55:	8d 44 24 0c          	lea    0xc(%esp),%eax
c0020d59:	83 ec 08             	sub    $0x8,%esp
c0020d5c:	6a 00                	push   $0x0
c0020d5e:	50                   	push   %eax
c0020d5f:	e8 bc 38 00 00       	call   c0024620 <float32_init>
c0020d64:	8b 44 24 18          	mov    0x18(%esp),%eax
c0020d68:	89 46 3c             	mov    %eax,0x3c(%esi)
    t->priority = PRI_MAX;
c0020d6b:	c7 46 1c 3f 00 00 00 	movl   $0x3f,0x1c(%esi)
c0020d72:	83 c4 0c             	add    $0xc,%esp
c0020d75:	e9 b8 fe ff ff       	jmp    c0020c32 <init_thread+0x94>

c0020d7a <thread_insert_ready_list>:
  }
}

/* Insert a thread to the ready list in order. */
static void thread_insert_ready_list(struct list_elem *elem)
{
c0020d7a:	56                   	push   %esi
c0020d7b:	53                   	push   %ebx
c0020d7c:	83 ec 10             	sub    $0x10,%esp
c0020d7f:	e8 62 17 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0020d84:	81 c3 b8 fe 01 00    	add    $0x1feb8,%ebx
c0020d8a:	89 c6                	mov    %eax,%esi
  if (!list_empty(&ready_list))
c0020d8c:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
c0020d92:	50                   	push   %eax
c0020d93:	e8 6f 92 00 00       	call   c002a007 <list_empty>
c0020d98:	83 c4 10             	add    $0x10,%esp
c0020d9b:	84 c0                	test   %al,%al
c0020d9d:	74 19                	je     c0020db8 <thread_insert_ready_list+0x3e>
    list_insert_ordered(&ready_list, elem, thread_priority_greater, NULL);
  else
    list_push_back(&ready_list, elem);
c0020d9f:	83 ec 08             	sub    $0x8,%esp
c0020da2:	56                   	push   %esi
c0020da3:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
c0020da9:	50                   	push   %eax
c0020daa:	e8 99 91 00 00       	call   c0029f48 <list_push_back>
c0020daf:	83 c4 10             	add    $0x10,%esp
}
c0020db2:	83 c4 04             	add    $0x4,%esp
c0020db5:	5b                   	pop    %ebx
c0020db6:	5e                   	pop    %esi
c0020db7:	c3                   	ret    
    list_insert_ordered(&ready_list, elem, thread_priority_greater, NULL);
c0020db8:	6a 00                	push   $0x0
c0020dba:	8d 83 d3 05 fe ff    	lea    -0x1fa2d(%ebx),%eax
c0020dc0:	50                   	push   %eax
c0020dc1:	56                   	push   %esi
c0020dc2:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
c0020dc8:	50                   	push   %eax
c0020dc9:	e8 8c 96 00 00       	call   c002a45a <list_insert_ordered>
c0020dce:	83 c4 10             	add    $0x10,%esp
c0020dd1:	eb df                	jmp    c0020db2 <thread_insert_ready_list+0x38>

c0020dd3 <thread_update_priority>:
{
c0020dd3:	56                   	push   %esi
c0020dd4:	53                   	push   %ebx
c0020dd5:	83 ec 14             	sub    $0x14,%esp
c0020dd8:	e8 09 17 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0020ddd:	81 c3 5f fe 01 00    	add    $0x1fe5f,%ebx
c0020de3:	8b 74 24 20          	mov    0x20(%esp),%esi
  if (t == idle_thread)
c0020de7:	39 b3 9c 01 00 00    	cmp    %esi,0x19c(%ebx)
c0020ded:	74 32                	je     c0020e21 <thread_update_priority+0x4e>
  int recent_cpu_div4 = float32_trunc(float32_div_int(t->recent_cpu, 4));
c0020def:	8d 44 24 0c          	lea    0xc(%esp),%eax
c0020df3:	83 ec 04             	sub    $0x4,%esp
c0020df6:	6a 04                	push   $0x4
c0020df8:	ff 76 3c             	pushl  0x3c(%esi)
c0020dfb:	50                   	push   %eax
c0020dfc:	e8 a0 39 00 00       	call   c00247a1 <float32_div_int>
c0020e01:	ff 74 24 18          	pushl  0x18(%esp)
c0020e05:	e8 26 38 00 00       	call   c0024630 <float32_trunc>
  t->priority = PRI_MAX - recent_cpu_div4 - t->nice * 2;
c0020e0a:	ba 3f 00 00 00       	mov    $0x3f,%edx
c0020e0f:	29 c2                	sub    %eax,%edx
c0020e11:	89 d0                	mov    %edx,%eax
c0020e13:	8b 4e 5c             	mov    0x5c(%esi),%ecx
c0020e16:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
c0020e19:	29 d0                	sub    %edx,%eax
c0020e1b:	89 46 1c             	mov    %eax,0x1c(%esi)
c0020e1e:	83 c4 10             	add    $0x10,%esp
}
c0020e21:	83 c4 14             	add    $0x14,%esp
c0020e24:	5b                   	pop    %ebx
c0020e25:	5e                   	pop    %esi
c0020e26:	c3                   	ret    

c0020e27 <thread_init>:
{
c0020e27:	55                   	push   %ebp
c0020e28:	57                   	push   %edi
c0020e29:	56                   	push   %esi
c0020e2a:	53                   	push   %ebx
c0020e2b:	83 ec 1c             	sub    $0x1c,%esp
c0020e2e:	e8 b3 16 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0020e33:	81 c3 09 fe 01 00    	add    $0x1fe09,%ebx
  ASSERT(intr_get_level() == INTR_OFF);
c0020e39:	e8 1b 11 00 00       	call   c0021f59 <intr_get_level>
c0020e3e:	85 c0                	test   %eax,%eax
c0020e40:	0f 85 b3 00 00 00    	jne    c0020ef9 <thread_init+0xd2>
  lock_init(&tid_lock);
c0020e46:	83 ec 0c             	sub    $0xc,%esp
c0020e49:	8d b3 64 01 00 00    	lea    0x164(%ebx),%esi
c0020e4f:	56                   	push   %esi
c0020e50:	e8 ad 26 00 00       	call   c0023502 <lock_init>
  list_init(&ready_list);
c0020e55:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
c0020e5b:	89 04 24             	mov    %eax,(%esp)
c0020e5e:	e8 ff 8a 00 00       	call   c0029962 <list_init>
  list_init(&all_list);
c0020e63:	8d 83 a0 01 00 00    	lea    0x1a0(%ebx),%eax
c0020e69:	89 04 24             	mov    %eax,(%esp)
c0020e6c:	e8 f1 8a 00 00       	call   c0029962 <list_init>
  list_init(&children);
c0020e71:	8d 83 c4 01 00 00    	lea    0x1c4(%ebx),%eax
c0020e77:	89 04 24             	mov    %eax,(%esp)
c0020e7a:	e8 e3 8a 00 00       	call   c0029962 <list_init>
  list_init(&file_list);
c0020e7f:	8d 83 d4 01 00 00    	lea    0x1d4(%ebx),%eax
c0020e85:	89 04 24             	mov    %eax,(%esp)
c0020e88:	e8 d5 8a 00 00       	call   c0029962 <list_init>
  asm("mov %%esp, %0"
c0020e8d:	89 e0                	mov    %esp,%eax
  return (void *)((uintptr_t)va & ~PGMASK);
c0020e8f:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  initial_thread = running_thread();
c0020e94:	89 83 98 01 00 00    	mov    %eax,0x198(%ebx)
  init_thread(initial_thread, "main", PRI_DEFAULT);
c0020e9a:	b9 1f 00 00 00       	mov    $0x1f,%ecx
c0020e9f:	8d 93 4a 33 ff ff    	lea    -0xccb6(%ebx),%edx
c0020ea5:	e8 f4 fc ff ff       	call   c0020b9e <init_thread>
  initial_thread->status = THREAD_RUNNING;
c0020eaa:	8b bb 98 01 00 00    	mov    0x198(%ebx),%edi
c0020eb0:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
  lock_acquire(&tid_lock);
c0020eb7:	89 34 24             	mov    %esi,(%esp)
c0020eba:	e8 03 27 00 00       	call   c00235c2 <lock_acquire>
  tid = next_tid++;
c0020ebf:	8b ab b8 fb ff ff    	mov    -0x448(%ebx),%ebp
c0020ec5:	8d 45 01             	lea    0x1(%ebp),%eax
c0020ec8:	89 83 b8 fb ff ff    	mov    %eax,-0x448(%ebx)
  lock_release(&tid_lock);
c0020ece:	89 34 24             	mov    %esi,(%esp)
c0020ed1:	e8 c0 28 00 00       	call   c0023796 <lock_release>
  initial_thread->tid = allocate_tid();
c0020ed6:	89 2f                	mov    %ebp,(%edi)
  load_avg = float32_init(0);
c0020ed8:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c0020edc:	83 c4 08             	add    $0x8,%esp
c0020edf:	6a 00                	push   $0x0
c0020ee1:	50                   	push   %eax
c0020ee2:	e8 39 37 00 00       	call   c0024620 <float32_init>
c0020ee7:	8b 44 24 18          	mov    0x18(%esp),%eax
c0020eeb:	89 83 c0 01 00 00    	mov    %eax,0x1c0(%ebx)
}
c0020ef1:	83 c4 28             	add    $0x28,%esp
c0020ef4:	5b                   	pop    %ebx
c0020ef5:	5e                   	pop    %esi
c0020ef6:	5f                   	pop    %edi
c0020ef7:	5d                   	pop    %ebp
c0020ef8:	c3                   	ret    
  ASSERT(intr_get_level() == INTR_OFF);
c0020ef9:	83 ec 0c             	sub    $0xc,%esp
c0020efc:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c0020f02:	50                   	push   %eax
c0020f03:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0020f09:	50                   	push   %eax
c0020f0a:	8d 83 58 1a ff ff    	lea    -0xe5a8(%ebx),%eax
c0020f10:	50                   	push   %eax
c0020f11:	68 80 00 00 00       	push   $0x80
c0020f16:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0020f1c:	50                   	push   %eax
c0020f1d:	e8 73 89 00 00       	call   c0029895 <debug_panic>

c0020f22 <thread_print_stats>:
{
c0020f22:	53                   	push   %ebx
c0020f23:	83 ec 0c             	sub    $0xc,%esp
c0020f26:	e8 bb 15 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0020f2b:	81 c3 11 fd 01 00    	add    $0x1fd11,%ebx
  printf("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020f31:	ff b3 50 01 00 00    	pushl  0x150(%ebx)
c0020f37:	ff b3 4c 01 00 00    	pushl  0x14c(%ebx)
c0020f3d:	ff b3 58 01 00 00    	pushl  0x158(%ebx)
c0020f43:	ff b3 54 01 00 00    	pushl  0x154(%ebx)
c0020f49:	ff b3 60 01 00 00    	pushl  0x160(%ebx)
c0020f4f:	ff b3 5c 01 00 00    	pushl  0x15c(%ebx)
c0020f55:	8d 83 20 34 ff ff    	lea    -0xcbe0(%ebx),%eax
c0020f5b:	50                   	push   %eax
c0020f5c:	e8 9d 6b 00 00       	call   c0027afe <printf>
}
c0020f61:	83 c4 28             	add    $0x28,%esp
c0020f64:	5b                   	pop    %ebx
c0020f65:	c3                   	ret    

c0020f66 <thread_unblock>:
{
c0020f66:	57                   	push   %edi
c0020f67:	56                   	push   %esi
c0020f68:	53                   	push   %ebx
c0020f69:	e8 78 15 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0020f6e:	81 c3 ce fc 01 00    	add    $0x1fcce,%ebx
c0020f74:	8b 74 24 10          	mov    0x10(%esp),%esi
  return t != NULL && t->magic == THREAD_MAGIC;
c0020f78:	85 f6                	test   %esi,%esi
c0020f7a:	74 09                	je     c0020f85 <thread_unblock+0x1f>
c0020f7c:	81 7e 38 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x38(%esi)
c0020f83:	74 52                	je     c0020fd7 <thread_unblock+0x71>
  ASSERT(is_thread(t));
c0020f85:	83 ec 0c             	sub    $0xc,%esp
c0020f88:	8d 83 20 33 ff ff    	lea    -0xcce0(%ebx),%eax
c0020f8e:	50                   	push   %eax
c0020f8f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0020f95:	50                   	push   %eax
c0020f96:	8d 83 f4 19 ff ff    	lea    -0xe60c(%ebx),%eax
c0020f9c:	50                   	push   %eax
c0020f9d:	68 27 01 00 00       	push   $0x127
c0020fa2:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0020fa8:	50                   	push   %eax
c0020fa9:	e8 e7 88 00 00       	call   c0029895 <debug_panic>
  ASSERT(t->status == THREAD_BLOCKED);
c0020fae:	83 ec 0c             	sub    $0xc,%esp
c0020fb1:	8d 83 4f 33 ff ff    	lea    -0xccb1(%ebx),%eax
c0020fb7:	50                   	push   %eax
c0020fb8:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0020fbe:	50                   	push   %eax
c0020fbf:	8d 83 f4 19 ff ff    	lea    -0xe60c(%ebx),%eax
c0020fc5:	50                   	push   %eax
c0020fc6:	68 2a 01 00 00       	push   $0x12a
c0020fcb:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0020fd1:	50                   	push   %eax
c0020fd2:	e8 be 88 00 00       	call   c0029895 <debug_panic>
  old_level = intr_disable();
c0020fd7:	e8 cf 0f 00 00       	call   c0021fab <intr_disable>
c0020fdc:	89 c7                	mov    %eax,%edi
  ASSERT(t->status == THREAD_BLOCKED);
c0020fde:	83 7e 04 02          	cmpl   $0x2,0x4(%esi)
c0020fe2:	75 ca                	jne    c0020fae <thread_unblock+0x48>
  thread_insert_ready_list(&t->elem);
c0020fe4:	8d 46 28             	lea    0x28(%esi),%eax
c0020fe7:	e8 8e fd ff ff       	call   c0020d7a <thread_insert_ready_list>
  t->status = THREAD_READY;
c0020fec:	c7 46 04 01 00 00 00 	movl   $0x1,0x4(%esi)
  intr_set_level(old_level);
c0020ff3:	83 ec 0c             	sub    $0xc,%esp
c0020ff6:	57                   	push   %edi
c0020ff7:	e8 b6 0f 00 00       	call   c0021fb2 <intr_set_level>
}
c0020ffc:	83 c4 10             	add    $0x10,%esp
c0020fff:	5b                   	pop    %ebx
c0021000:	5e                   	pop    %esi
c0021001:	5f                   	pop    %edi
c0021002:	c3                   	ret    

c0021003 <thread_sleep_checker>:
{
c0021003:	56                   	push   %esi
c0021004:	53                   	push   %ebx
c0021005:	83 ec 04             	sub    $0x4,%esp
c0021008:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  if (t->sleep_ticks > 0)
c002100c:	8b 41 40             	mov    0x40(%ecx),%eax
c002100f:	8b 51 44             	mov    0x44(%ecx),%edx
c0021012:	85 d2                	test   %edx,%edx
c0021014:	78 14                	js     c002102a <thread_sleep_checker+0x27>
c0021016:	85 d2                	test   %edx,%edx
c0021018:	7e 16                	jle    c0021030 <thread_sleep_checker+0x2d>
    (t->sleep_ticks)--;
c002101a:	83 c0 ff             	add    $0xffffffff,%eax
c002101d:	83 d2 ff             	adc    $0xffffffff,%edx
c0021020:	89 41 40             	mov    %eax,0x40(%ecx)
c0021023:	89 51 44             	mov    %edx,0x44(%ecx)
    if (!(t->sleep_ticks))
c0021026:	09 c2                	or     %eax,%edx
c0021028:	74 0d                	je     c0021037 <thread_sleep_checker+0x34>
}
c002102a:	83 c4 04             	add    $0x4,%esp
c002102d:	5b                   	pop    %ebx
c002102e:	5e                   	pop    %esi
c002102f:	c3                   	ret    
  if (t->sleep_ticks > 0)
c0021030:	83 f8 00             	cmp    $0x0,%eax
c0021033:	76 f5                	jbe    c002102a <thread_sleep_checker+0x27>
c0021035:	eb e3                	jmp    c002101a <thread_sleep_checker+0x17>
      thread_unblock(t);
c0021037:	83 ec 0c             	sub    $0xc,%esp
c002103a:	51                   	push   %ecx
c002103b:	e8 26 ff ff ff       	call   c0020f66 <thread_unblock>
c0021040:	83 c4 10             	add    $0x10,%esp
}
c0021043:	eb e5                	jmp    c002102a <thread_sleep_checker+0x27>

c0021045 <thread_current>:
{
c0021045:	53                   	push   %ebx
c0021046:	83 ec 08             	sub    $0x8,%esp
c0021049:	e8 98 14 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002104e:	81 c3 ee fb 01 00    	add    $0x1fbee,%ebx
  asm("mov %%esp, %0"
c0021054:	89 e0                	mov    %esp,%eax
  return t != NULL && t->magic == THREAD_MAGIC;
c0021056:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002105b:	74 09                	je     c0021066 <thread_current+0x21>
c002105d:	81 78 38 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x38(%eax)
c0021064:	74 52                	je     c00210b8 <thread_current+0x73>
  ASSERT(is_thread(t));
c0021066:	83 ec 0c             	sub    $0xc,%esp
c0021069:	8d 83 20 33 ff ff    	lea    -0xcce0(%ebx),%eax
c002106f:	50                   	push   %eax
c0021070:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0021076:	50                   	push   %eax
c0021077:	8d 83 e4 19 ff ff    	lea    -0xe61c(%ebx),%eax
c002107d:	50                   	push   %eax
c002107e:	68 44 01 00 00       	push   $0x144
c0021083:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0021089:	50                   	push   %eax
c002108a:	e8 06 88 00 00       	call   c0029895 <debug_panic>
  ASSERT(t->status == THREAD_RUNNING);
c002108f:	83 ec 0c             	sub    $0xc,%esp
c0021092:	8d 83 6b 33 ff ff    	lea    -0xcc95(%ebx),%eax
c0021098:	50                   	push   %eax
c0021099:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002109f:	50                   	push   %eax
c00210a0:	8d 83 e4 19 ff ff    	lea    -0xe61c(%ebx),%eax
c00210a6:	50                   	push   %eax
c00210a7:	68 45 01 00 00       	push   $0x145
c00210ac:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c00210b2:	50                   	push   %eax
c00210b3:	e8 dd 87 00 00       	call   c0029895 <debug_panic>
c00210b8:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c00210bc:	75 d1                	jne    c002108f <thread_current+0x4a>
}
c00210be:	83 c4 08             	add    $0x8,%esp
c00210c1:	5b                   	pop    %ebx
c00210c2:	c3                   	ret    

c00210c3 <thread_tick>:
{
c00210c3:	53                   	push   %ebx
c00210c4:	83 ec 08             	sub    $0x8,%esp
c00210c7:	e8 1a 14 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00210cc:	81 c3 70 fb 01 00    	add    $0x1fb70,%ebx
  struct thread *t = thread_current();
c00210d2:	e8 6e ff ff ff       	call   c0021045 <thread_current>
  if (t == idle_thread)
c00210d7:	39 83 9c 01 00 00    	cmp    %eax,0x19c(%ebx)
c00210dd:	74 2d                	je     c002110c <thread_tick+0x49>
  else if (t->pagedir != NULL)
c00210df:	83 78 30 00          	cmpl   $0x0,0x30(%eax)
c00210e3:	74 37                	je     c002111c <thread_tick+0x59>
    user_ticks++;
c00210e5:	83 83 4c 01 00 00 01 	addl   $0x1,0x14c(%ebx)
c00210ec:	83 93 50 01 00 00 00 	adcl   $0x0,0x150(%ebx)
  if (++thread_ticks >= TIME_SLICE)
c00210f3:	8b 83 44 01 00 00    	mov    0x144(%ebx),%eax
c00210f9:	83 c0 01             	add    $0x1,%eax
c00210fc:	89 83 44 01 00 00    	mov    %eax,0x144(%ebx)
c0021102:	83 f8 03             	cmp    $0x3,%eax
c0021105:	77 25                	ja     c002112c <thread_tick+0x69>
}
c0021107:	83 c4 08             	add    $0x8,%esp
c002110a:	5b                   	pop    %ebx
c002110b:	c3                   	ret    
    idle_ticks++;
c002110c:	83 83 5c 01 00 00 01 	addl   $0x1,0x15c(%ebx)
c0021113:	83 93 60 01 00 00 00 	adcl   $0x0,0x160(%ebx)
c002111a:	eb d7                	jmp    c00210f3 <thread_tick+0x30>
    kernel_ticks++;
c002111c:	83 83 54 01 00 00 01 	addl   $0x1,0x154(%ebx)
c0021123:	83 93 58 01 00 00 00 	adcl   $0x0,0x158(%ebx)
c002112a:	eb c7                	jmp    c00210f3 <thread_tick+0x30>
    intr_yield_on_return();
c002112c:	e8 30 11 00 00       	call   c0022261 <intr_yield_on_return>
}
c0021131:	eb d4                	jmp    c0021107 <thread_tick+0x44>

c0021133 <thread_name>:
{
c0021133:	83 ec 0c             	sub    $0xc,%esp
  return thread_current()->name;
c0021136:	e8 0a ff ff ff       	call   c0021045 <thread_current>
c002113b:	83 c0 08             	add    $0x8,%eax
}
c002113e:	83 c4 0c             	add    $0xc,%esp
c0021141:	c3                   	ret    

c0021142 <thread_tid>:
{
c0021142:	83 ec 0c             	sub    $0xc,%esp
  return thread_current()->tid;
c0021145:	e8 fb fe ff ff       	call   c0021045 <thread_current>
c002114a:	8b 00                	mov    (%eax),%eax
}
c002114c:	83 c4 0c             	add    $0xc,%esp
c002114f:	c3                   	ret    

c0021150 <thread_foreach>:
{
c0021150:	55                   	push   %ebp
c0021151:	57                   	push   %edi
c0021152:	56                   	push   %esi
c0021153:	53                   	push   %ebx
c0021154:	83 ec 0c             	sub    $0xc,%esp
c0021157:	e8 8a 13 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002115c:	81 c3 e0 fa 01 00    	add    $0x1fae0,%ebx
c0021162:	8b 6c 24 24          	mov    0x24(%esp),%ebp
  ASSERT(intr_get_level() == INTR_OFF);
c0021166:	e8 ee 0d 00 00       	call   c0021f59 <intr_get_level>
c002116b:	85 c0                	test   %eax,%eax
c002116d:	75 1c                	jne    c002118b <thread_foreach+0x3b>
  for (e = list_begin(&all_list); e != list_end(&all_list);
c002116f:	83 ec 0c             	sub    $0xc,%esp
c0021172:	8d 83 a0 01 00 00    	lea    0x1a0(%ebx),%eax
c0021178:	50                   	push   %eax
c0021179:	e8 3c 88 00 00       	call   c00299ba <list_begin>
c002117e:	89 c6                	mov    %eax,%esi
c0021180:	83 c4 10             	add    $0x10,%esp
c0021183:	8d bb a0 01 00 00    	lea    0x1a0(%ebx),%edi
c0021189:	eb 42                	jmp    c00211cd <thread_foreach+0x7d>
  ASSERT(intr_get_level() == INTR_OFF);
c002118b:	83 ec 0c             	sub    $0xc,%esp
c002118e:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c0021194:	50                   	push   %eax
c0021195:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002119b:	50                   	push   %eax
c002119c:	8d 83 b8 19 ff ff    	lea    -0xe648(%ebx),%eax
c00211a2:	50                   	push   %eax
c00211a3:	68 94 01 00 00       	push   $0x194
c00211a8:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c00211ae:	50                   	push   %eax
c00211af:	e8 e1 86 00 00       	call   c0029895 <debug_panic>
    func(t, aux);
c00211b4:	83 ec 08             	sub    $0x8,%esp
c00211b7:	55                   	push   %ebp
    struct thread *t = list_entry(e, struct thread, allelem);
c00211b8:	8d 46 e0             	lea    -0x20(%esi),%eax
    func(t, aux);
c00211bb:	50                   	push   %eax
c00211bc:	ff 54 24 30          	call   *0x30(%esp)
       e = list_next(e))
c00211c0:	89 34 24             	mov    %esi,(%esp)
c00211c3:	e8 37 88 00 00       	call   c00299ff <list_next>
c00211c8:	89 c6                	mov    %eax,%esi
c00211ca:	83 c4 10             	add    $0x10,%esp
  for (e = list_begin(&all_list); e != list_end(&all_list);
c00211cd:	83 ec 0c             	sub    $0xc,%esp
c00211d0:	57                   	push   %edi
c00211d1:	e8 86 88 00 00       	call   c0029a5c <list_end>
c00211d6:	83 c4 10             	add    $0x10,%esp
c00211d9:	39 f0                	cmp    %esi,%eax
c00211db:	75 d7                	jne    c00211b4 <thread_foreach+0x64>
}
c00211dd:	83 c4 0c             	add    $0xc,%esp
c00211e0:	5b                   	pop    %ebx
c00211e1:	5e                   	pop    %esi
c00211e2:	5f                   	pop    %edi
c00211e3:	5d                   	pop    %ebp
c00211e4:	c3                   	ret    

c00211e5 <thread_get_certain_priority>:
{
c00211e5:	53                   	push   %ebx
c00211e6:	e8 03 13 01 00       	call   c00324ee <__x86.get_pc_thunk.dx>
c00211eb:	81 c2 51 fa 01 00    	add    $0x1fa51,%edx
c00211f1:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  return t->priority + (thread_mlfqs ? 0 : t->max_donate);
c00211f5:	8b 41 1c             	mov    0x1c(%ecx),%eax
c00211f8:	c7 c3 bc b2 04 c0    	mov    $0xc004b2bc,%ebx
c00211fe:	ba 00 00 00 00       	mov    $0x0,%edx
c0021203:	80 3b 00             	cmpb   $0x0,(%ebx)
c0021206:	75 03                	jne    c002120b <thread_get_certain_priority+0x26>
c0021208:	8b 51 60             	mov    0x60(%ecx),%edx
c002120b:	01 d0                	add    %edx,%eax
}
c002120d:	5b                   	pop    %ebx
c002120e:	c3                   	ret    

c002120f <thread_priority_greater>:
{
c002120f:	53                   	push   %ebx
  const struct thread *a = list_entry(a_, struct thread, elem);
c0021210:	8b 44 24 08          	mov    0x8(%esp),%eax
c0021214:	83 e8 28             	sub    $0x28,%eax
  return thread_get_certain_priority(a) > thread_get_certain_priority(b);
c0021217:	50                   	push   %eax
c0021218:	e8 c8 ff ff ff       	call   c00211e5 <thread_get_certain_priority>
c002121d:	89 c3                	mov    %eax,%ebx
  const struct thread *b = list_entry(b_, struct thread, elem);
c002121f:	8b 44 24 10          	mov    0x10(%esp),%eax
c0021223:	83 e8 28             	sub    $0x28,%eax
  return thread_get_certain_priority(a) > thread_get_certain_priority(b);
c0021226:	89 04 24             	mov    %eax,(%esp)
c0021229:	e8 b7 ff ff ff       	call   c00211e5 <thread_get_certain_priority>
c002122e:	83 c4 04             	add    $0x4,%esp
c0021231:	39 c3                	cmp    %eax,%ebx
c0021233:	0f 9f c0             	setg   %al
}
c0021236:	5b                   	pop    %ebx
c0021237:	c3                   	ret    

c0021238 <thread_get_priority>:
{
c0021238:	83 ec 0c             	sub    $0xc,%esp
  return thread_get_certain_priority(thread_current());
c002123b:	e8 05 fe ff ff       	call   c0021045 <thread_current>
c0021240:	83 ec 0c             	sub    $0xc,%esp
c0021243:	50                   	push   %eax
c0021244:	e8 9c ff ff ff       	call   c00211e5 <thread_get_certain_priority>
}
c0021249:	83 c4 1c             	add    $0x1c,%esp
c002124c:	c3                   	ret    

c002124d <thread_set_nice>:
{
c002124d:	53                   	push   %ebx
c002124e:	83 ec 08             	sub    $0x8,%esp
c0021251:	e8 90 12 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0021256:	81 c3 e6 f9 01 00    	add    $0x1f9e6,%ebx
  thread_current()->nice = nice;
c002125c:	e8 e4 fd ff ff       	call   c0021045 <thread_current>
c0021261:	8b 54 24 10          	mov    0x10(%esp),%edx
c0021265:	89 50 5c             	mov    %edx,0x5c(%eax)
  if (thread_mlfqs)
c0021268:	c7 c0 bc b2 04 c0    	mov    $0xc004b2bc,%eax
c002126e:	80 38 00             	cmpb   $0x0,(%eax)
c0021271:	75 05                	jne    c0021278 <thread_set_nice+0x2b>
}
c0021273:	83 c4 08             	add    $0x8,%esp
c0021276:	5b                   	pop    %ebx
c0021277:	c3                   	ret    
    thread_update_priority(thread_current(), NULL);
c0021278:	e8 c8 fd ff ff       	call   c0021045 <thread_current>
c002127d:	83 ec 08             	sub    $0x8,%esp
c0021280:	6a 00                	push   $0x0
c0021282:	50                   	push   %eax
c0021283:	e8 4b fb ff ff       	call   c0020dd3 <thread_update_priority>
c0021288:	83 c4 10             	add    $0x10,%esp
}
c002128b:	eb e6                	jmp    c0021273 <thread_set_nice+0x26>

c002128d <thread_get_nice>:
{
c002128d:	83 ec 0c             	sub    $0xc,%esp
  struct thread *cur = thread_current();
c0021290:	e8 b0 fd ff ff       	call   c0021045 <thread_current>
  return cur->nice;
c0021295:	8b 40 5c             	mov    0x5c(%eax),%eax
}
c0021298:	83 c4 0c             	add    $0xc,%esp
c002129b:	c3                   	ret    

c002129c <thread_get_load_avg>:
{
c002129c:	53                   	push   %ebx
c002129d:	83 ec 18             	sub    $0x18,%esp
c00212a0:	e8 41 12 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00212a5:	81 c3 97 f9 01 00    	add    $0x1f997,%ebx
  ASSERT(thread_mlfqs);
c00212ab:	c7 c0 bc b2 04 c0    	mov    $0xc004b2bc,%eax
c00212b1:	80 38 00             	cmpb   $0x0,(%eax)
c00212b4:	74 23                	je     c00212d9 <thread_get_load_avg+0x3d>
  return float32_round(float32_mul_int(load_avg, 100));
c00212b6:	8d 44 24 0c          	lea    0xc(%esp),%eax
c00212ba:	83 ec 04             	sub    $0x4,%esp
c00212bd:	6a 64                	push   $0x64
c00212bf:	ff b3 c0 01 00 00    	pushl  0x1c0(%ebx)
c00212c5:	50                   	push   %eax
c00212c6:	e8 7f 34 00 00       	call   c002474a <float32_mul_int>
c00212cb:	ff 74 24 18          	pushl  0x18(%esp)
c00212cf:	e8 64 33 00 00       	call   c0024638 <float32_round>
}
c00212d4:	83 c4 28             	add    $0x28,%esp
c00212d7:	5b                   	pop    %ebx
c00212d8:	c3                   	ret    
  ASSERT(thread_mlfqs);
c00212d9:	83 ec 0c             	sub    $0xc,%esp
c00212dc:	8d 83 87 33 ff ff    	lea    -0xcc79(%ebx),%eax
c00212e2:	50                   	push   %eax
c00212e3:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00212e9:	50                   	push   %eax
c00212ea:	8d 83 a4 19 ff ff    	lea    -0xe65c(%ebx),%eax
c00212f0:	50                   	push   %eax
c00212f1:	68 ec 01 00 00       	push   $0x1ec
c00212f6:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c00212fc:	50                   	push   %eax
c00212fd:	e8 93 85 00 00       	call   c0029895 <debug_panic>

c0021302 <thread_update_recent_cpu>:
{
c0021302:	55                   	push   %ebp
c0021303:	57                   	push   %edi
c0021304:	56                   	push   %esi
c0021305:	53                   	push   %ebx
c0021306:	83 ec 1c             	sub    $0x1c,%esp
c0021309:	e8 d8 11 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002130e:	81 c3 2e f9 01 00    	add    $0x1f92e,%ebx
c0021314:	8b 74 24 30          	mov    0x30(%esp),%esi
  ASSERT(thread_mlfqs);
c0021318:	c7 c0 bc b2 04 c0    	mov    $0xc004b2bc,%eax
c002131e:	80 38 00             	cmpb   $0x0,(%eax)
c0021321:	74 49                	je     c002136c <thread_update_recent_cpu+0x6a>
  int load_avg2 = thread_get_load_avg() * 2;
c0021323:	e8 74 ff ff ff       	call   c002129c <thread_get_load_avg>
c0021328:	01 c0                	add    %eax,%eax
  t->recent_cpu = float32_add_int(float32_mul(float32_div_int2(load_avg2, load_avg2 + 100),
c002132a:	8b 6e 5c             	mov    0x5c(%esi),%ebp
c002132d:	8d 7c 24 0c          	lea    0xc(%esp),%edi
c0021331:	83 ec 04             	sub    $0x4,%esp
c0021334:	8d 50 64             	lea    0x64(%eax),%edx
c0021337:	52                   	push   %edx
c0021338:	50                   	push   %eax
c0021339:	57                   	push   %edi
c002133a:	e8 76 34 00 00       	call   c00247b5 <float32_div_int2>
c002133f:	83 ec 08             	sub    $0x8,%esp
c0021342:	ff 76 3c             	pushl  0x3c(%esi)
c0021345:	ff 74 24 24          	pushl  0x24(%esp)
c0021349:	57                   	push   %edi
c002134a:	e8 ae 33 00 00       	call   c00246fd <float32_mul>
c002134f:	83 c4 08             	add    $0x8,%esp
c0021352:	55                   	push   %ebp
c0021353:	ff 74 24 24          	pushl  0x24(%esp)
c0021357:	57                   	push   %edi
c0021358:	e8 65 33 00 00       	call   c00246c2 <float32_add_int>
c002135d:	8b 44 24 28          	mov    0x28(%esp),%eax
c0021361:	89 46 3c             	mov    %eax,0x3c(%esi)
}
c0021364:	83 c4 38             	add    $0x38,%esp
c0021367:	5b                   	pop    %ebx
c0021368:	5e                   	pop    %esi
c0021369:	5f                   	pop    %edi
c002136a:	5d                   	pop    %ebp
c002136b:	c3                   	ret    
  ASSERT(thread_mlfqs);
c002136c:	83 ec 0c             	sub    $0xc,%esp
c002136f:	8d 83 87 33 ff ff    	lea    -0xcc79(%ebx),%eax
c0021375:	50                   	push   %eax
c0021376:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002137c:	50                   	push   %eax
c002137d:	8d 83 58 19 ff ff    	lea    -0xe6a8(%ebx),%eax
c0021383:	50                   	push   %eax
c0021384:	68 f7 01 00 00       	push   $0x1f7
c0021389:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c002138f:	50                   	push   %eax
c0021390:	e8 00 85 00 00       	call   c0029895 <debug_panic>

c0021395 <thread_get_recent_cpu>:
{
c0021395:	53                   	push   %ebx
c0021396:	83 ec 18             	sub    $0x18,%esp
c0021399:	e8 48 11 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002139e:	81 c3 9e f8 01 00    	add    $0x1f89e,%ebx
  ASSERT(thread_mlfqs);
c00213a4:	c7 c0 bc b2 04 c0    	mov    $0xc004b2bc,%eax
c00213aa:	80 38 00             	cmpb   $0x0,(%eax)
c00213ad:	74 25                	je     c00213d4 <thread_get_recent_cpu+0x3f>
      float32_mul_int(thread_current()->recent_cpu, 100));
c00213af:	e8 91 fc ff ff       	call   c0021045 <thread_current>
  return float32_trunc(
c00213b4:	8d 54 24 0c          	lea    0xc(%esp),%edx
c00213b8:	83 ec 04             	sub    $0x4,%esp
c00213bb:	6a 64                	push   $0x64
c00213bd:	ff 70 3c             	pushl  0x3c(%eax)
c00213c0:	52                   	push   %edx
c00213c1:	e8 84 33 00 00       	call   c002474a <float32_mul_int>
c00213c6:	ff 74 24 18          	pushl  0x18(%esp)
c00213ca:	e8 61 32 00 00       	call   c0024630 <float32_trunc>
}
c00213cf:	83 c4 28             	add    $0x28,%esp
c00213d2:	5b                   	pop    %ebx
c00213d3:	c3                   	ret    
  ASSERT(thread_mlfqs);
c00213d4:	83 ec 0c             	sub    $0xc,%esp
c00213d7:	8d 83 87 33 ff ff    	lea    -0xcc79(%ebx),%eax
c00213dd:	50                   	push   %eax
c00213de:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00213e4:	50                   	push   %eax
c00213e5:	8d 83 8c 19 ff ff    	lea    -0xe674(%ebx),%eax
c00213eb:	50                   	push   %eax
c00213ec:	68 01 02 00 00       	push   $0x201
c00213f1:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c00213f7:	50                   	push   %eax
c00213f8:	e8 98 84 00 00       	call   c0029895 <debug_panic>

c00213fd <thread_schedule_tail>:
{
c00213fd:	57                   	push   %edi
c00213fe:	56                   	push   %esi
c00213ff:	53                   	push   %ebx
c0021400:	e8 e1 10 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0021405:	81 c3 37 f8 01 00    	add    $0x1f837,%ebx
c002140b:	8b 7c 24 10          	mov    0x10(%esp),%edi
  asm("mov %%esp, %0"
c002140f:	89 e6                	mov    %esp,%esi
c0021411:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
  ASSERT(intr_get_level() == INTR_OFF);
c0021417:	e8 3d 0b 00 00       	call   c0021f59 <intr_get_level>
c002141c:	85 c0                	test   %eax,%eax
c002141e:	75 24                	jne    c0021444 <thread_schedule_tail+0x47>
  cur->status = THREAD_RUNNING;
c0021420:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
  thread_ticks = 0;
c0021427:	c7 83 44 01 00 00 00 	movl   $0x0,0x144(%ebx)
c002142e:	00 00 00 
  process_activate();
c0021431:	e8 41 a6 00 00       	call   c002ba77 <process_activate>
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread)
c0021436:	85 ff                	test   %edi,%edi
c0021438:	74 06                	je     c0021440 <thread_schedule_tail+0x43>
c002143a:	83 7f 04 03          	cmpl   $0x3,0x4(%edi)
c002143e:	74 2d                	je     c002146d <thread_schedule_tail+0x70>
}
c0021440:	5b                   	pop    %ebx
c0021441:	5e                   	pop    %esi
c0021442:	5f                   	pop    %edi
c0021443:	c3                   	ret    
  ASSERT(intr_get_level() == INTR_OFF);
c0021444:	83 ec 0c             	sub    $0xc,%esp
c0021447:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c002144d:	50                   	push   %eax
c002144e:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0021454:	50                   	push   %eax
c0021455:	8d 83 74 19 ff ff    	lea    -0xe68c(%ebx),%eax
c002145b:	50                   	push   %eax
c002145c:	68 ae 02 00 00       	push   $0x2ae
c0021461:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0021467:	50                   	push   %eax
c0021468:	e8 28 84 00 00       	call   c0029895 <debug_panic>
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread)
c002146d:	39 bb 98 01 00 00    	cmp    %edi,0x198(%ebx)
c0021473:	74 cb                	je     c0021440 <thread_schedule_tail+0x43>
    ASSERT(prev != cur);
c0021475:	39 f7                	cmp    %esi,%edi
c0021477:	74 0e                	je     c0021487 <thread_schedule_tail+0x8a>
    palloc_free_page(prev);
c0021479:	83 ec 0c             	sub    $0xc,%esp
c002147c:	57                   	push   %edi
c002147d:	e8 bb 2b 00 00       	call   c002403d <palloc_free_page>
c0021482:	83 c4 10             	add    $0x10,%esp
}
c0021485:	eb b9                	jmp    c0021440 <thread_schedule_tail+0x43>
    ASSERT(prev != cur);
c0021487:	83 ec 0c             	sub    $0xc,%esp
c002148a:	8d 83 94 33 ff ff    	lea    -0xcc6c(%ebx),%eax
c0021490:	50                   	push   %eax
c0021491:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0021497:	50                   	push   %eax
c0021498:	8d 83 74 19 ff ff    	lea    -0xe68c(%ebx),%eax
c002149e:	50                   	push   %eax
c002149f:	68 c2 02 00 00       	push   $0x2c2
c00214a4:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c00214aa:	50                   	push   %eax
c00214ab:	e8 e5 83 00 00       	call   c0029895 <debug_panic>

c00214b0 <schedule>:
{
c00214b0:	57                   	push   %edi
c00214b1:	56                   	push   %esi
c00214b2:	53                   	push   %ebx
c00214b3:	e8 2e 10 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00214b8:	81 c3 84 f7 01 00    	add    $0x1f784,%ebx
  asm("mov %%esp, %0"
c00214be:	89 e6                	mov    %esp,%esi
c00214c0:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
  if (list_empty(&ready_list))
c00214c6:	83 ec 0c             	sub    $0xc,%esp
c00214c9:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
c00214cf:	50                   	push   %eax
c00214d0:	e8 32 8b 00 00       	call   c002a007 <list_empty>
c00214d5:	83 c4 10             	add    $0x10,%esp
c00214d8:	84 c0                	test   %al,%al
c00214da:	74 4f                	je     c002152b <schedule+0x7b>
    return idle_thread;
c00214dc:	8b bb 9c 01 00 00    	mov    0x19c(%ebx),%edi
  ASSERT(intr_get_level() == INTR_OFF);
c00214e2:	e8 72 0a 00 00       	call   c0021f59 <intr_get_level>
c00214e7:	85 c0                	test   %eax,%eax
c00214e9:	75 57                	jne    c0021542 <schedule+0x92>
  ASSERT(cur->status != THREAD_RUNNING);
c00214eb:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c00214ef:	74 7a                	je     c002156b <schedule+0xbb>
  return t != NULL && t->magic == THREAD_MAGIC;
c00214f1:	85 ff                	test   %edi,%edi
c00214f3:	74 0d                	je     c0021502 <schedule+0x52>
c00214f5:	81 7f 38 4b bf 6a cd 	cmpl   $0xcd6abf4b,0x38(%edi)
c00214fc:	0f 84 92 00 00 00    	je     c0021594 <schedule+0xe4>
  ASSERT(is_thread(next));
c0021502:	83 ec 0c             	sub    $0xc,%esp
c0021505:	8d 83 be 33 ff ff    	lea    -0xcc42(%ebx),%eax
c002150b:	50                   	push   %eax
c002150c:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0021512:	50                   	push   %eax
c0021513:	8d 83 04 1a ff ff    	lea    -0xe5fc(%ebx),%eax
c0021519:	50                   	push   %eax
c002151a:	68 d7 02 00 00       	push   $0x2d7
c002151f:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0021525:	50                   	push   %eax
c0021526:	e8 6a 83 00 00       	call   c0029895 <debug_panic>
    return list_entry(list_pop_front(&ready_list), struct thread, elem);
c002152b:	83 ec 0c             	sub    $0xc,%esp
c002152e:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
c0021534:	50                   	push   %eax
c0021535:	e8 44 8b 00 00       	call   c002a07e <list_pop_front>
c002153a:	8d 78 d8             	lea    -0x28(%eax),%edi
c002153d:	83 c4 10             	add    $0x10,%esp
c0021540:	eb a0                	jmp    c00214e2 <schedule+0x32>
  ASSERT(intr_get_level() == INTR_OFF);
c0021542:	83 ec 0c             	sub    $0xc,%esp
c0021545:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c002154b:	50                   	push   %eax
c002154c:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0021552:	50                   	push   %eax
c0021553:	8d 83 04 1a ff ff    	lea    -0xe5fc(%ebx),%eax
c0021559:	50                   	push   %eax
c002155a:	68 d5 02 00 00       	push   $0x2d5
c002155f:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0021565:	50                   	push   %eax
c0021566:	e8 2a 83 00 00       	call   c0029895 <debug_panic>
  ASSERT(cur->status != THREAD_RUNNING);
c002156b:	83 ec 0c             	sub    $0xc,%esp
c002156e:	8d 83 a0 33 ff ff    	lea    -0xcc60(%ebx),%eax
c0021574:	50                   	push   %eax
c0021575:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002157b:	50                   	push   %eax
c002157c:	8d 83 04 1a ff ff    	lea    -0xe5fc(%ebx),%eax
c0021582:	50                   	push   %eax
c0021583:	68 d6 02 00 00       	push   $0x2d6
c0021588:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c002158e:	50                   	push   %eax
c002158f:	e8 01 83 00 00       	call   c0029895 <debug_panic>
  struct thread *prev = NULL;
c0021594:	b8 00 00 00 00       	mov    $0x0,%eax
  if (cur != next)
c0021599:	39 f7                	cmp    %esi,%edi
c002159b:	74 0d                	je     c00215aa <schedule+0xfa>
    prev = switch_threads(cur, next);
c002159d:	83 ec 08             	sub    $0x8,%esp
c00215a0:	57                   	push   %edi
c00215a1:	56                   	push   %esi
c00215a2:	e8 25 08 00 00       	call   c0021dcc <switch_threads>
c00215a7:	83 c4 10             	add    $0x10,%esp
  thread_schedule_tail(prev);
c00215aa:	83 ec 0c             	sub    $0xc,%esp
c00215ad:	50                   	push   %eax
c00215ae:	e8 4a fe ff ff       	call   c00213fd <thread_schedule_tail>
}
c00215b3:	83 c4 10             	add    $0x10,%esp
c00215b6:	5b                   	pop    %ebx
c00215b7:	5e                   	pop    %esi
c00215b8:	5f                   	pop    %edi
c00215b9:	c3                   	ret    

c00215ba <thread_block>:
{
c00215ba:	53                   	push   %ebx
c00215bb:	83 ec 08             	sub    $0x8,%esp
c00215be:	e8 23 0f 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00215c3:	81 c3 79 f6 01 00    	add    $0x1f679,%ebx
  ASSERT(!intr_context());
c00215c9:	e8 81 0c 00 00       	call   c002224f <intr_context>
c00215ce:	84 c0                	test   %al,%al
c00215d0:	75 1f                	jne    c00215f1 <thread_block+0x37>
  ASSERT(intr_get_level() == INTR_OFF);
c00215d2:	e8 82 09 00 00       	call   c0021f59 <intr_get_level>
c00215d7:	85 c0                	test   %eax,%eax
c00215d9:	75 3f                	jne    c002161a <thread_block+0x60>
  thread_current()->status = THREAD_BLOCKED;
c00215db:	e8 65 fa ff ff       	call   c0021045 <thread_current>
c00215e0:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  schedule();
c00215e7:	e8 c4 fe ff ff       	call   c00214b0 <schedule>
}
c00215ec:	83 c4 08             	add    $0x8,%esp
c00215ef:	5b                   	pop    %ebx
c00215f0:	c3                   	ret    
  ASSERT(!intr_context());
c00215f1:	83 ec 0c             	sub    $0xc,%esp
c00215f4:	8d 83 ce 33 ff ff    	lea    -0xcc32(%ebx),%eax
c00215fa:	50                   	push   %eax
c00215fb:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0021601:	50                   	push   %eax
c0021602:	8d 83 10 1a ff ff    	lea    -0xe5f0(%ebx),%eax
c0021608:	50                   	push   %eax
c0021609:	68 14 01 00 00       	push   $0x114
c002160e:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0021614:	50                   	push   %eax
c0021615:	e8 7b 82 00 00       	call   c0029895 <debug_panic>
  ASSERT(intr_get_level() == INTR_OFF);
c002161a:	83 ec 0c             	sub    $0xc,%esp
c002161d:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c0021623:	50                   	push   %eax
c0021624:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002162a:	50                   	push   %eax
c002162b:	8d 83 10 1a ff ff    	lea    -0xe5f0(%ebx),%eax
c0021631:	50                   	push   %eax
c0021632:	68 15 01 00 00       	push   $0x115
c0021637:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c002163d:	50                   	push   %eax
c002163e:	e8 52 82 00 00       	call   c0029895 <debug_panic>

c0021643 <idle>:
{
c0021643:	53                   	push   %ebx
c0021644:	83 ec 08             	sub    $0x8,%esp
c0021647:	e8 9a 0e 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002164c:	81 c3 f0 f5 01 00    	add    $0x1f5f0,%ebx
  idle_thread = thread_current();
c0021652:	e8 ee f9 ff ff       	call   c0021045 <thread_current>
c0021657:	89 83 9c 01 00 00    	mov    %eax,0x19c(%ebx)
  sema_up(idle_started);
c002165d:	83 ec 0c             	sub    $0xc,%esp
c0021660:	ff 74 24 1c          	pushl  0x1c(%esp)
c0021664:	e8 c8 1c 00 00       	call   c0023331 <sema_up>
c0021669:	83 c4 10             	add    $0x10,%esp
    intr_disable();
c002166c:	e8 3a 09 00 00       	call   c0021fab <intr_disable>
    thread_block();
c0021671:	e8 44 ff ff ff       	call   c00215ba <thread_block>
    asm volatile("sti; hlt"
c0021676:	fb                   	sti    
c0021677:	f4                   	hlt    
c0021678:	eb f2                	jmp    c002166c <idle+0x29>

c002167a <thread_exit>:
{
c002167a:	55                   	push   %ebp
c002167b:	57                   	push   %edi
c002167c:	56                   	push   %esi
c002167d:	53                   	push   %ebx
c002167e:	83 ec 1c             	sub    $0x1c,%esp
c0021681:	e8 60 0e 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0021686:	81 c3 b6 f5 01 00    	add    $0x1f5b6,%ebx
  ASSERT(!intr_context());
c002168c:	e8 be 0b 00 00       	call   c002224f <intr_context>
c0021691:	84 c0                	test   %al,%al
c0021693:	74 29                	je     c00216be <thread_exit+0x44>
c0021695:	83 ec 0c             	sub    $0xc,%esp
c0021698:	8d 83 ce 33 ff ff    	lea    -0xcc32(%ebx),%eax
c002169e:	50                   	push   %eax
c002169f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00216a5:	50                   	push   %eax
c00216a6:	8d 83 d8 19 ff ff    	lea    -0xe628(%ebx),%eax
c00216ac:	50                   	push   %eax
c00216ad:	68 54 01 00 00       	push   $0x154
c00216b2:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c00216b8:	50                   	push   %eax
c00216b9:	e8 d7 81 00 00       	call   c0029895 <debug_panic>
  process_exit();
c00216be:	e8 5b aa 00 00       	call   c002c11e <process_exit>
  sema_up(&thread_current()->sema_finished);
c00216c3:	e8 7d f9 ff ff       	call   c0021045 <thread_current>
c00216c8:	83 ec 0c             	sub    $0xc,%esp
c00216cb:	83 e8 80             	sub    $0xffffff80,%eax
c00216ce:	50                   	push   %eax
c00216cf:	e8 5d 1c 00 00       	call   c0023331 <sema_up>
  struct thread *cur = thread_current();
c00216d4:	e8 6c f9 ff ff       	call   c0021045 <thread_current>
c00216d9:	89 c7                	mov    %eax,%edi
  if (!list_empty(&file_list))
c00216db:	8d 83 d4 01 00 00    	lea    0x1d4(%ebx),%eax
c00216e1:	89 04 24             	mov    %eax,(%esp)
c00216e4:	e8 1e 89 00 00       	call   c002a007 <list_empty>
c00216e9:	83 c4 10             	add    $0x10,%esp
c00216ec:	84 c0                	test   %al,%al
c00216ee:	74 59                	je     c0021749 <thread_exit+0xcf>
  if (cur->exec_file != NULL)
c00216f0:	8b 47 34             	mov    0x34(%edi),%eax
c00216f3:	85 c0                	test   %eax,%eax
c00216f5:	74 0c                	je     c0021703 <thread_exit+0x89>
    syscall_file_close(cur->exec_file);
c00216f7:	83 ec 0c             	sub    $0xc,%esp
c00216fa:	50                   	push   %eax
c00216fb:	e8 d2 b6 00 00       	call   c002cdd2 <syscall_file_close>
c0021700:	83 c4 10             	add    $0x10,%esp
  intr_disable();
c0021703:	e8 a3 08 00 00       	call   c0021fab <intr_disable>
  list_remove(&thread_current()->allelem);
c0021708:	e8 38 f9 ff ff       	call   c0021045 <thread_current>
c002170d:	83 ec 0c             	sub    $0xc,%esp
c0021710:	83 c0 20             	add    $0x20,%eax
c0021713:	50                   	push   %eax
c0021714:	e8 4c 88 00 00       	call   c0029f65 <list_remove>
  thread_current()->status = THREAD_DYING;
c0021719:	e8 27 f9 ff ff       	call   c0021045 <thread_current>
c002171e:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
  schedule();
c0021725:	e8 86 fd ff ff       	call   c00214b0 <schedule>
  NOT_REACHED();
c002172a:	8d 83 60 34 ff ff    	lea    -0xcba0(%ebx),%eax
c0021730:	50                   	push   %eax
c0021731:	8d 83 d8 19 ff ff    	lea    -0xe628(%ebx),%eax
c0021737:	50                   	push   %eax
c0021738:	68 79 01 00 00       	push   $0x179
c002173d:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0021743:	50                   	push   %eax
c0021744:	e8 4c 81 00 00       	call   c0029895 <debug_panic>
    for (i = list_begin(&file_list); i != list_end(&file_list); i = list_next(i))
c0021749:	83 ec 0c             	sub    $0xc,%esp
c002174c:	8d 83 d4 01 00 00    	lea    0x1d4(%ebx),%eax
c0021752:	50                   	push   %eax
c0021753:	e8 62 82 00 00       	call   c00299ba <list_begin>
c0021758:	89 c6                	mov    %eax,%esi
c002175a:	83 c4 10             	add    $0x10,%esp
c002175d:	8d ab d4 01 00 00    	lea    0x1d4(%ebx),%ebp
c0021763:	eb 0e                	jmp    c0021773 <thread_exit+0xf9>
c0021765:	83 ec 0c             	sub    $0xc,%esp
c0021768:	56                   	push   %esi
c0021769:	e8 91 82 00 00       	call   c00299ff <list_next>
c002176e:	89 c6                	mov    %eax,%esi
c0021770:	83 c4 10             	add    $0x10,%esp
c0021773:	83 ec 0c             	sub    $0xc,%esp
c0021776:	55                   	push   %ebp
c0021777:	e8 e0 82 00 00       	call   c0029a5c <list_end>
c002177c:	83 c4 10             	add    $0x10,%esp
c002177f:	39 f0                	cmp    %esi,%eax
c0021781:	0f 84 69 ff ff ff    	je     c00216f0 <thread_exit+0x76>
      if (hd->owned_thread == cur)
c0021787:	39 7e f8             	cmp    %edi,-0x8(%esi)
c002178a:	75 d9                	jne    c0021765 <thread_exit+0xeb>
        syscall_file_close(hd->opened_file);
c002178c:	83 ec 0c             	sub    $0xc,%esp
c002178f:	ff 76 f4             	pushl  -0xc(%esi)
c0021792:	e8 3b b6 00 00       	call   c002cdd2 <syscall_file_close>
        i = list_prev(i);
c0021797:	89 34 24             	mov    %esi,(%esp)
c002179a:	e8 47 83 00 00       	call   c0029ae6 <list_prev>
c002179f:	89 44 24 18          	mov    %eax,0x18(%esp)
        list_remove(&(hd->elem));
c00217a3:	8d 56 f0             	lea    -0x10(%esi),%edx
c00217a6:	89 54 24 1c          	mov    %edx,0x1c(%esp)
c00217aa:	89 34 24             	mov    %esi,(%esp)
c00217ad:	e8 b3 87 00 00       	call   c0029f65 <list_remove>
        free(hd);
c00217b2:	83 c4 04             	add    $0x4,%esp
c00217b5:	ff 74 24 18          	pushl  0x18(%esp)
c00217b9:	e8 dc 2c 00 00       	call   c002449a <free>
c00217be:	83 c4 10             	add    $0x10,%esp
        i = list_prev(i);
c00217c1:	8b 74 24 08          	mov    0x8(%esp),%esi
c00217c5:	eb 9e                	jmp    c0021765 <thread_exit+0xeb>

c00217c7 <kernel_thread>:
{
c00217c7:	56                   	push   %esi
c00217c8:	53                   	push   %ebx
c00217c9:	83 ec 04             	sub    $0x4,%esp
c00217cc:	e8 15 0d 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00217d1:	81 c3 6b f4 01 00    	add    $0x1f46b,%ebx
c00217d7:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT(function != NULL);
c00217db:	85 f6                	test   %esi,%esi
c00217dd:	74 13                	je     c00217f2 <kernel_thread+0x2b>
  intr_enable(); /* The scheduler runs with interrupts off. */
c00217df:	e8 7e 07 00 00       	call   c0021f62 <intr_enable>
  function(aux); /* Execute the thread function. */
c00217e4:	83 ec 0c             	sub    $0xc,%esp
c00217e7:	ff 74 24 20          	pushl  0x20(%esp)
c00217eb:	ff d6                	call   *%esi
  thread_exit(); /* If function() returns, kill the thread. */
c00217ed:	e8 88 fe ff ff       	call   c002167a <thread_exit>
  ASSERT(function != NULL);
c00217f2:	83 ec 0c             	sub    $0xc,%esp
c00217f5:	8d 83 de 33 ff ff    	lea    -0xcc22(%ebx),%eax
c00217fb:	50                   	push   %eax
c00217fc:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0021802:	50                   	push   %eax
c0021803:	8d 83 2c 1a ff ff    	lea    -0xe5d4(%ebx),%eax
c0021809:	50                   	push   %eax
c002180a:	68 32 02 00 00       	push   $0x232
c002180f:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0021815:	50                   	push   %eax
c0021816:	e8 7a 80 00 00       	call   c0029895 <debug_panic>

c002181b <thread_yield>:
{
c002181b:	57                   	push   %edi
c002181c:	56                   	push   %esi
c002181d:	53                   	push   %ebx
c002181e:	e8 c3 0c 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0021823:	81 c3 19 f4 01 00    	add    $0x1f419,%ebx
  struct thread *cur = thread_current();
c0021829:	e8 17 f8 ff ff       	call   c0021045 <thread_current>
c002182e:	89 c6                	mov    %eax,%esi
  ASSERT(!intr_context());
c0021830:	e8 1a 0a 00 00       	call   c002224f <intr_context>
c0021835:	84 c0                	test   %al,%al
c0021837:	75 33                	jne    c002186c <thread_yield+0x51>
  old_level = intr_disable();
c0021839:	e8 6d 07 00 00       	call   c0021fab <intr_disable>
c002183e:	89 c7                	mov    %eax,%edi
  if (cur != idle_thread)
c0021840:	39 b3 9c 01 00 00    	cmp    %esi,0x19c(%ebx)
c0021846:	74 08                	je     c0021850 <thread_yield+0x35>
    thread_insert_ready_list(&cur->elem);
c0021848:	8d 46 28             	lea    0x28(%esi),%eax
c002184b:	e8 2a f5 ff ff       	call   c0020d7a <thread_insert_ready_list>
  cur->status = THREAD_READY;
c0021850:	c7 46 04 01 00 00 00 	movl   $0x1,0x4(%esi)
  schedule();
c0021857:	e8 54 fc ff ff       	call   c00214b0 <schedule>
  intr_set_level(old_level);
c002185c:	83 ec 0c             	sub    $0xc,%esp
c002185f:	57                   	push   %edi
c0021860:	e8 4d 07 00 00       	call   c0021fb2 <intr_set_level>
}
c0021865:	83 c4 10             	add    $0x10,%esp
c0021868:	5b                   	pop    %ebx
c0021869:	5e                   	pop    %esi
c002186a:	5f                   	pop    %edi
c002186b:	c3                   	ret    
  ASSERT(!intr_context());
c002186c:	83 ec 0c             	sub    $0xc,%esp
c002186f:	8d 83 ce 33 ff ff    	lea    -0xcc32(%ebx),%eax
c0021875:	50                   	push   %eax
c0021876:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002187c:	50                   	push   %eax
c002187d:	8d 83 c8 19 ff ff    	lea    -0xe638(%ebx),%eax
c0021883:	50                   	push   %eax
c0021884:	68 83 01 00 00       	push   $0x183
c0021889:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c002188f:	50                   	push   %eax
c0021890:	e8 00 80 00 00       	call   c0029895 <debug_panic>

c0021895 <thread_revolt>:
{
c0021895:	56                   	push   %esi
c0021896:	53                   	push   %ebx
c0021897:	83 ec 04             	sub    $0x4,%esp
c002189a:	e8 47 0c 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002189f:	81 c3 9d f3 01 00    	add    $0x1f39d,%ebx
  if (thread_current() != idle_thread &&
c00218a5:	e8 9b f7 ff ff       	call   c0021045 <thread_current>
c00218aa:	3b 83 9c 01 00 00    	cmp    0x19c(%ebx),%eax
c00218b0:	74 16                	je     c00218c8 <thread_revolt+0x33>
      !list_empty(&ready_list) &&
c00218b2:	83 ec 0c             	sub    $0xc,%esp
c00218b5:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
c00218bb:	50                   	push   %eax
c00218bc:	e8 46 87 00 00       	call   c002a007 <list_empty>
  if (thread_current() != idle_thread &&
c00218c1:	83 c4 10             	add    $0x10,%esp
c00218c4:	84 c0                	test   %al,%al
c00218c6:	74 06                	je     c00218ce <thread_revolt+0x39>
}
c00218c8:	83 c4 04             	add    $0x4,%esp
c00218cb:	5b                   	pop    %ebx
c00218cc:	5e                   	pop    %esi
c00218cd:	c3                   	ret    
      thread_get_priority() <
c00218ce:	e8 65 f9 ff ff       	call   c0021238 <thread_get_priority>
c00218d3:	89 c6                	mov    %eax,%esi
              list_entry(list_begin(&ready_list), struct thread, elem)))
c00218d5:	83 ec 0c             	sub    $0xc,%esp
c00218d8:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
c00218de:	50                   	push   %eax
c00218df:	e8 d6 80 00 00       	call   c00299ba <list_begin>
          thread_get_certain_priority(
c00218e4:	83 e8 28             	sub    $0x28,%eax
c00218e7:	89 04 24             	mov    %eax,(%esp)
c00218ea:	e8 f6 f8 ff ff       	call   c00211e5 <thread_get_certain_priority>
c00218ef:	83 c4 10             	add    $0x10,%esp
      !list_empty(&ready_list) &&
c00218f2:	39 c6                	cmp    %eax,%esi
c00218f4:	7d d2                	jge    c00218c8 <thread_revolt+0x33>
    thread_yield();
c00218f6:	e8 20 ff ff ff       	call   c002181b <thread_yield>
}
c00218fb:	eb cb                	jmp    c00218c8 <thread_revolt+0x33>

c00218fd <thread_create>:
{
c00218fd:	55                   	push   %ebp
c00218fe:	57                   	push   %edi
c00218ff:	56                   	push   %esi
c0021900:	53                   	push   %ebx
c0021901:	83 ec 0c             	sub    $0xc,%esp
c0021904:	e8 dd 0b 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0021909:	81 c3 33 f3 01 00    	add    $0x1f333,%ebx
  ASSERT(function != NULL);
c002190f:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0021914:	0f 84 1f 01 00 00    	je     c0021a39 <thread_create+0x13c>
  t = palloc_get_page(PAL_ZERO);
c002191a:	83 ec 0c             	sub    $0xc,%esp
c002191d:	6a 02                	push   $0x2
c002191f:	e8 ab 25 00 00       	call   c0023ecf <palloc_get_page>
c0021924:	89 c6                	mov    %eax,%esi
  if (t == NULL)
c0021926:	83 c4 10             	add    $0x10,%esp
c0021929:	85 c0                	test   %eax,%eax
c002192b:	0f 84 31 01 00 00    	je     c0021a62 <thread_create+0x165>
  init_thread(t, name, priority);
c0021931:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0021935:	8b 54 24 20          	mov    0x20(%esp),%edx
c0021939:	e8 60 f2 ff ff       	call   c0020b9e <init_thread>
  lock_acquire(&tid_lock);
c002193e:	83 ec 0c             	sub    $0xc,%esp
c0021941:	8d bb 64 01 00 00    	lea    0x164(%ebx),%edi
c0021947:	57                   	push   %edi
c0021948:	e8 75 1c 00 00       	call   c00235c2 <lock_acquire>
  tid = next_tid++;
c002194d:	8b ab b8 fb ff ff    	mov    -0x448(%ebx),%ebp
c0021953:	8d 45 01             	lea    0x1(%ebp),%eax
c0021956:	89 83 b8 fb ff ff    	mov    %eax,-0x448(%ebx)
  lock_release(&tid_lock);
c002195c:	89 3c 24             	mov    %edi,(%esp)
c002195f:	e8 32 1e 00 00       	call   c0023796 <lock_release>
  tid = t->tid = allocate_tid();
c0021964:	89 2e                	mov    %ebp,(%esi)
  struct child_message *own = palloc_get_page(PAL_ZERO);
c0021966:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c002196d:	e8 5d 25 00 00       	call   c0023ecf <palloc_get_page>
c0021972:	89 c7                	mov    %eax,%edi
  own->tid = tid;
c0021974:	89 68 04             	mov    %ebp,0x4(%eax)
  own->tchild = t;
c0021977:	89 30                	mov    %esi,(%eax)
  own->exited = false;
c0021979:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  own->terminated = false;
c002197d:	c6 40 09 00          	movb   $0x0,0x9(%eax)
  own->load_failed = false;
c0021981:	c6 40 0a 00          	movb   $0x0,0xa(%eax)
  own->return_value = 0;
c0021985:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  own->sema_finished = &t->sema_finished;
c002198c:	8d 86 80 00 00 00    	lea    0x80(%esi),%eax
c0021992:	89 47 10             	mov    %eax,0x10(%edi)
  own->sema_started = &t->sema_started;
c0021995:	8d 86 94 00 00 00    	lea    0x94(%esi),%eax
c002199b:	89 47 14             	mov    %eax,0x14(%edi)
  list_push_back(&children, &own->allelem);
c002199e:	83 c4 08             	add    $0x8,%esp
c00219a1:	8d 47 20             	lea    0x20(%edi),%eax
c00219a4:	50                   	push   %eax
c00219a5:	8d 83 c4 01 00 00    	lea    0x1c4(%ebx),%eax
c00219ab:	50                   	push   %eax
c00219ac:	e8 97 85 00 00       	call   c0029f48 <list_push_back>
  t->message_to_grandpa = own;
c00219b1:	89 be ac 00 00 00    	mov    %edi,0xac(%esi)
  t->current_dir = thread_current()->current_dir;
c00219b7:	e8 89 f6 ff ff       	call   c0021045 <thread_current>
c00219bc:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
c00219c2:	89 86 b0 00 00 00    	mov    %eax,0xb0(%esi)
  t->exec_file = NULL;
c00219c8:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  kf = alloc_frame(t, sizeof *kf);
c00219cf:	ba 0c 00 00 00       	mov    $0xc,%edx
c00219d4:	89 f0                	mov    %esi,%eax
c00219d6:	e8 41 f1 ff ff       	call   c0020b1c <alloc_frame>
  kf->eip = NULL;
c00219db:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c00219e1:	8b 4c 24 38          	mov    0x38(%esp),%ecx
c00219e5:	89 48 04             	mov    %ecx,0x4(%eax)
  kf->aux = aux;
c00219e8:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c00219ec:	89 50 08             	mov    %edx,0x8(%eax)
  ef = alloc_frame(t, sizeof *ef);
c00219ef:	ba 04 00 00 00       	mov    $0x4,%edx
c00219f4:	89 f0                	mov    %esi,%eax
c00219f6:	e8 21 f1 ff ff       	call   c0020b1c <alloc_frame>
  ef->eip = (void (*)(void))kernel_thread;
c00219fb:	8d 93 8b 0b fe ff    	lea    -0x1f475(%ebx),%edx
c0021a01:	89 10                	mov    %edx,(%eax)
  sf = alloc_frame(t, sizeof *sf);
c0021a03:	ba 1c 00 00 00       	mov    $0x1c,%edx
c0021a08:	89 f0                	mov    %esi,%eax
c0021a0a:	e8 0d f1 ff ff       	call   c0020b1c <alloc_frame>
  sf->eip = switch_entry;
c0021a0f:	c7 c2 e9 1d 02 c0    	mov    $0xc0021de9,%edx
c0021a15:	89 50 10             	mov    %edx,0x10(%eax)
  sf->ebp = 0;
c0021a18:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
  thread_unblock(t);
c0021a1f:	89 34 24             	mov    %esi,(%esp)
c0021a22:	e8 3f f5 ff ff       	call   c0020f66 <thread_unblock>
  thread_revolt();
c0021a27:	e8 69 fe ff ff       	call   c0021895 <thread_revolt>
  return tid;
c0021a2c:	83 c4 10             	add    $0x10,%esp
}
c0021a2f:	89 e8                	mov    %ebp,%eax
c0021a31:	83 c4 0c             	add    $0xc,%esp
c0021a34:	5b                   	pop    %ebx
c0021a35:	5e                   	pop    %esi
c0021a36:	5f                   	pop    %edi
c0021a37:	5d                   	pop    %ebp
c0021a38:	c3                   	ret    
  ASSERT(function != NULL);
c0021a39:	83 ec 0c             	sub    $0xc,%esp
c0021a3c:	8d 83 de 33 ff ff    	lea    -0xcc22(%ebx),%eax
c0021a42:	50                   	push   %eax
c0021a43:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0021a49:	50                   	push   %eax
c0021a4a:	8d 83 3c 1a ff ff    	lea    -0xe5c4(%ebx),%eax
c0021a50:	50                   	push   %eax
c0021a51:	68 d9 00 00 00       	push   $0xd9
c0021a56:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0021a5c:	50                   	push   %eax
c0021a5d:	e8 33 7e 00 00       	call   c0029895 <debug_panic>
    return TID_ERROR;
c0021a62:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c0021a67:	eb c6                	jmp    c0021a2f <thread_create+0x132>

c0021a69 <thread_start>:
{
c0021a69:	56                   	push   %esi
c0021a6a:	53                   	push   %ebx
c0021a6b:	83 ec 2c             	sub    $0x2c,%esp
c0021a6e:	e8 73 0a 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0021a73:	81 c3 c9 f1 01 00    	add    $0x1f1c9,%ebx
  sema_init(&idle_started, 0);
c0021a79:	6a 00                	push   $0x0
c0021a7b:	8d 74 24 18          	lea    0x18(%esp),%esi
c0021a7f:	56                   	push   %esi
c0021a80:	e8 3b 17 00 00       	call   c00231c0 <sema_init>
  thread_create("idle", PRI_MIN, idle, &idle_started);
c0021a85:	56                   	push   %esi
c0021a86:	8d 83 07 0a fe ff    	lea    -0x1f5f9(%ebx),%eax
c0021a8c:	50                   	push   %eax
c0021a8d:	6a 00                	push   $0x0
c0021a8f:	8d 83 ef 33 ff ff    	lea    -0xcc11(%ebx),%eax
c0021a95:	50                   	push   %eax
c0021a96:	e8 62 fe ff ff       	call   c00218fd <thread_create>
  intr_enable();
c0021a9b:	83 c4 20             	add    $0x20,%esp
c0021a9e:	e8 bf 04 00 00       	call   c0021f62 <intr_enable>
  sema_down(&idle_started);
c0021aa3:	83 ec 0c             	sub    $0xc,%esp
c0021aa6:	56                   	push   %esi
c0021aa7:	e8 68 17 00 00       	call   c0023214 <sema_down>
}
c0021aac:	83 c4 34             	add    $0x34,%esp
c0021aaf:	5b                   	pop    %ebx
c0021ab0:	5e                   	pop    %esi
c0021ab1:	c3                   	ret    

c0021ab2 <thread_set_priority>:
{
c0021ab2:	e8 33 0a 01 00       	call   c00324ea <__x86.get_pc_thunk.ax>
c0021ab7:	05 85 f1 01 00       	add    $0x1f185,%eax
  if (thread_mlfqs)
c0021abc:	c7 c0 bc b2 04 c0    	mov    $0xc004b2bc,%eax
c0021ac2:	80 38 00             	cmpb   $0x0,(%eax)
c0021ac5:	74 02                	je     c0021ac9 <thread_set_priority+0x17>
c0021ac7:	f3 c3                	repz ret 
{
c0021ac9:	83 ec 0c             	sub    $0xc,%esp
  if (thread_current()->max_donate == 0)
c0021acc:	e8 74 f5 ff ff       	call   c0021045 <thread_current>
c0021ad1:	83 78 60 00          	cmpl   $0x0,0x60(%eax)
c0021ad5:	74 0b                	je     c0021ae2 <thread_set_priority+0x30>
    thread_current()->priority_to_set = new_priority;
c0021ad7:	8b 54 24 10          	mov    0x10(%esp),%edx
c0021adb:	89 50 58             	mov    %edx,0x58(%eax)
}
c0021ade:	83 c4 0c             	add    $0xc,%esp
c0021ae1:	c3                   	ret    
    thread_current()->priority = new_priority;
c0021ae2:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0021ae6:	89 48 1c             	mov    %ecx,0x1c(%eax)
    thread_revolt();
c0021ae9:	e8 a7 fd ff ff       	call   c0021895 <thread_revolt>
c0021aee:	eb ee                	jmp    c0021ade <thread_set_priority+0x2c>

c0021af0 <thread_timer>:
{
  list_sort(&ready_list, thread_priority_greater, NULL);
}

void thread_timer(bool full_second)
{
c0021af0:	55                   	push   %ebp
c0021af1:	57                   	push   %edi
c0021af2:	56                   	push   %esi
c0021af3:	53                   	push   %ebx
c0021af4:	83 ec 1c             	sub    $0x1c,%esp
c0021af7:	e8 ea 09 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0021afc:	81 c3 40 f1 01 00    	add    $0x1f140,%ebx
c0021b02:	8b 74 24 30          	mov    0x30(%esp),%esi
  if (thread_mlfqs)
c0021b06:	c7 c0 bc b2 04 c0    	mov    $0xc004b2bc,%eax
c0021b0c:	80 38 00             	cmpb   $0x0,(%eax)
c0021b0f:	75 19                	jne    c0021b2a <thread_timer+0x3a>
      thread_foreach(thread_update_recent_cpu, NULL);
      thread_foreach(thread_update_priority, NULL);
      thread_ready_list_greater();
    }
  }
  thread_foreach(thread_sleep_checker, NULL);
c0021b11:	83 ec 08             	sub    $0x8,%esp
c0021b14:	6a 00                	push   $0x0
c0021b16:	8d 83 c7 03 fe ff    	lea    -0x1fc39(%ebx),%eax
c0021b1c:	50                   	push   %eax
c0021b1d:	e8 2e f6 ff ff       	call   c0021150 <thread_foreach>
}
c0021b22:	83 c4 2c             	add    $0x2c,%esp
c0021b25:	5b                   	pop    %ebx
c0021b26:	5e                   	pop    %esi
c0021b27:	5f                   	pop    %edi
c0021b28:	5d                   	pop    %ebp
c0021b29:	c3                   	ret    

/* Add recent_cpu of the running thread by 1 per second */
static void thread_add_recent_cpu(void)
{
  ASSERT(thread_mlfqs);
  struct thread *cur = thread_current();
c0021b2a:	e8 16 f5 ff ff       	call   c0021045 <thread_current>
c0021b2f:	89 c7                	mov    %eax,%edi
  if (cur != idle_thread)
c0021b31:	3b 83 9c 01 00 00    	cmp    0x19c(%ebx),%eax
c0021b37:	74 1c                	je     c0021b55 <thread_timer+0x65>
    cur->recent_cpu = float32_add_int(cur->recent_cpu, 1);
c0021b39:	8d 44 24 0c          	lea    0xc(%esp),%eax
c0021b3d:	83 ec 04             	sub    $0x4,%esp
c0021b40:	6a 01                	push   $0x1
c0021b42:	ff 77 3c             	pushl  0x3c(%edi)
c0021b45:	50                   	push   %eax
c0021b46:	e8 77 2b 00 00       	call   c00246c2 <float32_add_int>
c0021b4b:	8b 44 24 18          	mov    0x18(%esp),%eax
c0021b4f:	89 47 3c             	mov    %eax,0x3c(%edi)
c0021b52:	83 c4 0c             	add    $0xc,%esp
  thread_update_priority(thread_current(), NULL);
c0021b55:	e8 eb f4 ff ff       	call   c0021045 <thread_current>
c0021b5a:	83 ec 08             	sub    $0x8,%esp
c0021b5d:	6a 00                	push   $0x0
c0021b5f:	50                   	push   %eax
c0021b60:	e8 6e f2 ff ff       	call   c0020dd3 <thread_update_priority>
    if (full_second)
c0021b65:	83 c4 10             	add    $0x10,%esp
c0021b68:	89 f0                	mov    %esi,%eax
c0021b6a:	84 c0                	test   %al,%al
c0021b6c:	74 a3                	je     c0021b11 <thread_timer+0x21>
  ASSERT(thread_mlfqs);
c0021b6e:	c7 c0 bc b2 04 c0    	mov    $0xc004b2bc,%eax
c0021b74:	80 38 00             	cmpb   $0x0,(%eax)
c0021b77:	74 21                	je     c0021b9a <thread_timer+0xaa>
  for (e = list_begin(&all_list); e != list_end(&all_list);
c0021b79:	83 ec 0c             	sub    $0xc,%esp
c0021b7c:	8d 83 a0 01 00 00    	lea    0x1a0(%ebx),%eax
c0021b82:	50                   	push   %eax
c0021b83:	e8 32 7e 00 00       	call   c00299ba <list_begin>
c0021b88:	89 c6                	mov    %eax,%esi
c0021b8a:	83 c4 10             	add    $0x10,%esp
  int ready_threads = 0;
c0021b8d:	bd 00 00 00 00       	mov    $0x0,%ebp
  for (e = list_begin(&all_list); e != list_end(&all_list);
c0021b92:	8d bb a0 01 00 00    	lea    0x1a0(%ebx),%edi
c0021b98:	eb 37                	jmp    c0021bd1 <thread_timer+0xe1>
  ASSERT(thread_mlfqs);
c0021b9a:	83 ec 0c             	sub    $0xc,%esp
c0021b9d:	8d 83 87 33 ff ff    	lea    -0xcc79(%ebx),%eax
c0021ba3:	50                   	push   %eax
c0021ba4:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0021baa:	50                   	push   %eax
c0021bab:	8d 83 40 19 ff ff    	lea    -0xe6c0(%ebx),%eax
c0021bb1:	50                   	push   %eax
c0021bb2:	68 dc 01 00 00       	push   $0x1dc
c0021bb7:	8d 83 09 33 ff ff    	lea    -0xccf7(%ebx),%eax
c0021bbd:	50                   	push   %eax
c0021bbe:	e8 d2 7c 00 00       	call   c0029895 <debug_panic>
       e = list_next(e))
c0021bc3:	83 ec 0c             	sub    $0xc,%esp
c0021bc6:	56                   	push   %esi
c0021bc7:	e8 33 7e 00 00       	call   c00299ff <list_next>
c0021bcc:	89 c6                	mov    %eax,%esi
c0021bce:	83 c4 10             	add    $0x10,%esp
  for (e = list_begin(&all_list); e != list_end(&all_list);
c0021bd1:	83 ec 0c             	sub    $0xc,%esp
c0021bd4:	57                   	push   %edi
c0021bd5:	e8 82 7e 00 00       	call   c0029a5c <list_end>
c0021bda:	83 c4 10             	add    $0x10,%esp
c0021bdd:	39 c6                	cmp    %eax,%esi
c0021bdf:	74 19                	je     c0021bfa <thread_timer+0x10a>
    if ((t->status == THREAD_RUNNING || t->status == THREAD_READY) && t != idle_thread)
c0021be1:	83 7e e4 01          	cmpl   $0x1,-0x1c(%esi)
c0021be5:	77 dc                	ja     c0021bc3 <thread_timer+0xd3>
    struct thread *t = list_entry(e, struct thread, allelem);
c0021be7:	8d 46 e0             	lea    -0x20(%esi),%eax
      ready_threads++;
c0021bea:	39 83 9c 01 00 00    	cmp    %eax,0x19c(%ebx)
c0021bf0:	0f 95 c0             	setne  %al
c0021bf3:	0f b6 c0             	movzbl %al,%eax
c0021bf6:	01 c5                	add    %eax,%ebp
c0021bf8:	eb c9                	jmp    c0021bc3 <thread_timer+0xd3>
  load_avg = float32_div_int(float32_add_int(float32_mul_int(load_avg, 59), ready_threads), 60);
c0021bfa:	8d 74 24 0c          	lea    0xc(%esp),%esi
c0021bfe:	83 ec 04             	sub    $0x4,%esp
c0021c01:	6a 3b                	push   $0x3b
c0021c03:	ff b3 c0 01 00 00    	pushl  0x1c0(%ebx)
c0021c09:	56                   	push   %esi
c0021c0a:	e8 3b 2b 00 00       	call   c002474a <float32_mul_int>
c0021c0f:	83 ec 08             	sub    $0x8,%esp
c0021c12:	55                   	push   %ebp
c0021c13:	ff 74 24 24          	pushl  0x24(%esp)
c0021c17:	56                   	push   %esi
c0021c18:	e8 a5 2a 00 00       	call   c00246c2 <float32_add_int>
c0021c1d:	83 c4 08             	add    $0x8,%esp
c0021c20:	6a 3c                	push   $0x3c
c0021c22:	ff 74 24 24          	pushl  0x24(%esp)
c0021c26:	56                   	push   %esi
c0021c27:	e8 75 2b 00 00       	call   c00247a1 <float32_div_int>
c0021c2c:	8b 44 24 28          	mov    0x28(%esp),%eax
c0021c30:	89 83 c0 01 00 00    	mov    %eax,0x1c0(%ebx)
      thread_foreach(thread_update_recent_cpu, NULL);
c0021c36:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c0021c3d:	8d 83 c6 06 fe ff    	lea    -0x1f93a(%ebx),%eax
c0021c43:	50                   	push   %eax
c0021c44:	e8 07 f5 ff ff       	call   c0021150 <thread_foreach>
      thread_foreach(thread_update_priority, NULL);
c0021c49:	83 c4 18             	add    $0x18,%esp
c0021c4c:	6a 00                	push   $0x0
c0021c4e:	8d 83 97 01 fe ff    	lea    -0x1fe69(%ebx),%eax
c0021c54:	50                   	push   %eax
c0021c55:	e8 f6 f4 ff ff       	call   c0021150 <thread_foreach>
  list_sort(&ready_list, thread_priority_greater, NULL);
c0021c5a:	83 c4 0c             	add    $0xc,%esp
c0021c5d:	6a 00                	push   $0x0
c0021c5f:	8d 83 d3 05 fe ff    	lea    -0x1fa2d(%ebx),%eax
c0021c65:	50                   	push   %eax
c0021c66:	8d 83 b0 01 00 00    	lea    0x1b0(%ebx),%eax
c0021c6c:	50                   	push   %eax
c0021c6d:	e8 fb 84 00 00       	call   c002a16d <list_sort>
c0021c72:	83 c4 10             	add    $0x10,%esp
c0021c75:	e9 97 fe ff ff       	jmp    c0021b11 <thread_timer+0x21>

c0021c7a <thread_get_child_message>:
}



struct child_message *thread_get_child_message(tid_t tid)
{
c0021c7a:	55                   	push   %ebp
c0021c7b:	57                   	push   %edi
c0021c7c:	56                   	push   %esi
c0021c7d:	53                   	push   %ebx
c0021c7e:	83 ec 18             	sub    $0x18,%esp
c0021c81:	e8 60 08 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0021c86:	81 c3 b6 ef 01 00    	add    $0x1efb6,%ebx
c0021c8c:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
  struct list_elem *e;
  struct child_message *l;
  for (e = list_rbegin(&children); e != list_rend(&children); e = list_prev(e))
c0021c90:	8d 83 c4 01 00 00    	lea    0x1c4(%ebx),%eax
c0021c96:	50                   	push   %eax
c0021c97:	e8 05 7e 00 00       	call   c0029aa1 <list_rbegin>
c0021c9c:	89 c6                	mov    %eax,%esi
c0021c9e:	83 c4 10             	add    $0x10,%esp
c0021ca1:	8d bb c4 01 00 00    	lea    0x1c4(%ebx),%edi
c0021ca7:	83 ec 0c             	sub    $0xc,%esp
c0021caa:	57                   	push   %edi
c0021cab:	e8 0c 80 00 00       	call   c0029cbc <list_rend>
c0021cb0:	83 c4 10             	add    $0x10,%esp
c0021cb3:	39 f0                	cmp    %esi,%eax
c0021cb5:	74 1a                	je     c0021cd1 <thread_get_child_message+0x57>
  {
    l = list_entry(e, struct child_message, allelem);
    if (l->tid == tid)
c0021cb7:	39 6e e4             	cmp    %ebp,-0x1c(%esi)
c0021cba:	74 10                	je     c0021ccc <thread_get_child_message+0x52>
  for (e = list_rbegin(&children); e != list_rend(&children); e = list_prev(e))
c0021cbc:	83 ec 0c             	sub    $0xc,%esp
c0021cbf:	56                   	push   %esi
c0021cc0:	e8 21 7e 00 00       	call   c0029ae6 <list_prev>
c0021cc5:	89 c6                	mov    %eax,%esi
c0021cc7:	83 c4 10             	add    $0x10,%esp
c0021cca:	eb db                	jmp    c0021ca7 <thread_get_child_message+0x2d>
    l = list_entry(e, struct child_message, allelem);
c0021ccc:	8d 46 e0             	lea    -0x20(%esi),%eax
c0021ccf:	eb 05                	jmp    c0021cd6 <thread_get_child_message+0x5c>
      return l;
  }
  return NULL;
c0021cd1:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0021cd6:	83 c4 0c             	add    $0xc,%esp
c0021cd9:	5b                   	pop    %ebx
c0021cda:	5e                   	pop    %esi
c0021cdb:	5f                   	pop    %edi
c0021cdc:	5d                   	pop    %ebp
c0021cdd:	c3                   	ret    

c0021cde <set_main_thread_dir>:
/*
 * Set main thread's current directory
 * MUST use after filesys init
 * */
void set_main_thread_dir()
{
c0021cde:	56                   	push   %esi
c0021cdf:	53                   	push   %ebx
c0021ce0:	83 ec 04             	sub    $0x4,%esp
c0021ce3:	e8 fe 07 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0021ce8:	81 c3 54 ef 01 00    	add    $0x1ef54,%ebx
  initial_thread->current_dir = dir_open_root();
c0021cee:	8b b3 98 01 00 00    	mov    0x198(%ebx),%esi
c0021cf4:	e8 5e d1 00 00       	call   c002ee57 <dir_open_root>
c0021cf9:	89 86 b0 00 00 00    	mov    %eax,0xb0(%esi)
}
c0021cff:	83 c4 04             	add    $0x4,%esp
c0021d02:	5b                   	pop    %ebx
c0021d03:	5e                   	pop    %esi
c0021d04:	c3                   	ret    

c0021d05 <thread_exit_with_return_value>:
#endif

/* Terminate thread with a return value FINAL_VALUE */
void thread_exit_with_return_value(struct intr_frame *f, int return_value)
{
c0021d05:	53                   	push   %ebx
c0021d06:	83 ec 08             	sub    $0x8,%esp
c0021d09:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  struct thread *cur = thread_current();
c0021d0d:	e8 33 f3 ff ff       	call   c0021045 <thread_current>
  cur->return_value = return_value;
c0021d12:	89 98 b4 00 00 00    	mov    %ebx,0xb4(%eax)
  f->eax = (uint32_t)return_value;
c0021d18:	8b 44 24 10          	mov    0x10(%esp),%eax
c0021d1c:	89 58 1c             	mov    %ebx,0x1c(%eax)
  thread_exit();
c0021d1f:	e8 56 f9 ff ff       	call   c002167a <thread_exit>

c0021d24 <thread_file_list_inster>:
}

void thread_file_list_inster(struct file_handle *fh)
{
c0021d24:	53                   	push   %ebx
c0021d25:	83 ec 10             	sub    $0x10,%esp
c0021d28:	e8 b9 07 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0021d2d:	81 c3 0f ef 01 00    	add    $0x1ef0f,%ebx
  list_push_back(&file_list, &(fh->elem));
c0021d33:	8b 44 24 18          	mov    0x18(%esp),%eax
c0021d37:	83 c0 10             	add    $0x10,%eax
c0021d3a:	50                   	push   %eax
c0021d3b:	8d 83 d4 01 00 00    	lea    0x1d4(%ebx),%eax
c0021d41:	50                   	push   %eax
c0021d42:	e8 01 82 00 00       	call   c0029f48 <list_push_back>
}
c0021d47:	83 c4 18             	add    $0x18,%esp
c0021d4a:	5b                   	pop    %ebx
c0021d4b:	c3                   	ret    

c0021d4c <syscall_get_file_handle>:

/* Get the file_handle pointer according to fd
 * Return NULL if fd is invalid
 * */
struct file_handle *syscall_get_file_handle(int fd)
{
c0021d4c:	55                   	push   %ebp
c0021d4d:	57                   	push   %edi
c0021d4e:	56                   	push   %esi
c0021d4f:	53                   	push   %ebx
c0021d50:	83 ec 1c             	sub    $0x1c,%esp
c0021d53:	e8 8e 07 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0021d58:	81 c3 e4 ee 01 00    	add    $0x1eee4,%ebx
c0021d5e:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  struct thread *cur = thread_current();
c0021d62:	e8 de f2 ff ff       	call   c0021045 <thread_current>
c0021d67:	89 44 24 0c          	mov    %eax,0xc(%esp)
  struct list_elem *i;
  for (i = list_begin(&file_list); i != list_end(&file_list); i = list_next(i))
c0021d6b:	83 ec 0c             	sub    $0xc,%esp
c0021d6e:	8d 83 d4 01 00 00    	lea    0x1d4(%ebx),%eax
c0021d74:	50                   	push   %eax
c0021d75:	e8 40 7c 00 00       	call   c00299ba <list_begin>
c0021d7a:	89 c6                	mov    %eax,%esi
c0021d7c:	83 c4 10             	add    $0x10,%esp
c0021d7f:	8d bb d4 01 00 00    	lea    0x1d4(%ebx),%edi
c0021d85:	83 ec 0c             	sub    $0xc,%esp
c0021d88:	57                   	push   %edi
c0021d89:	e8 ce 7c 00 00       	call   c0029a5c <list_end>
c0021d8e:	83 c4 10             	add    $0x10,%esp
c0021d91:	39 f0                	cmp    %esi,%eax
c0021d93:	74 23                	je     c0021db8 <syscall_get_file_handle+0x6c>
  {
    struct file_handle *t;
    t = list_entry(i, struct file_handle, elem);
    if (t->fd == fd)
c0021d95:	39 6e f0             	cmp    %ebp,-0x10(%esi)
c0021d98:	74 10                	je     c0021daa <syscall_get_file_handle+0x5e>
  for (i = list_begin(&file_list); i != list_end(&file_list); i = list_next(i))
c0021d9a:	83 ec 0c             	sub    $0xc,%esp
c0021d9d:	56                   	push   %esi
c0021d9e:	e8 5c 7c 00 00       	call   c00299ff <list_next>
c0021da3:	89 c6                	mov    %eax,%esi
c0021da5:	83 c4 10             	add    $0x10,%esp
c0021da8:	eb db                	jmp    c0021d85 <syscall_get_file_handle+0x39>
    {
      if (t->owned_thread != cur)
c0021daa:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0021dae:	39 46 f8             	cmp    %eax,-0x8(%esi)
c0021db1:	75 12                	jne    c0021dc5 <syscall_get_file_handle+0x79>
    t = list_entry(i, struct file_handle, elem);
c0021db3:	8d 46 f0             	lea    -0x10(%esi),%eax
        return NULL;
      else
        return t;
c0021db6:	eb 05                	jmp    c0021dbd <syscall_get_file_handle+0x71>
    }
  }
  return NULL;
c0021db8:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0021dbd:	83 c4 1c             	add    $0x1c,%esp
c0021dc0:	5b                   	pop    %ebx
c0021dc1:	5e                   	pop    %esi
c0021dc2:	5f                   	pop    %edi
c0021dc3:	5d                   	pop    %ebp
c0021dc4:	c3                   	ret    
        return NULL;
c0021dc5:	b8 00 00 00 00       	mov    $0x0,%eax
c0021dca:	eb f1                	jmp    c0021dbd <syscall_get_file_handle+0x71>

c0021dcc <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c0021dcc:	53                   	push   %ebx
	pushl %ebp
c0021dcd:	55                   	push   %ebp
	pushl %esi
c0021dce:	56                   	push   %esi
	pushl %edi
c0021dcf:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c0021dd0:	8b 15 f8 07 04 c0    	mov    0xc00407f8,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c0021dd6:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c0021dda:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c0021ddd:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c0021de1:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c0021de4:	5f                   	pop    %edi
	popl %esi
c0021de5:	5e                   	pop    %esi
	popl %ebp
c0021de6:	5d                   	pop    %ebp
	popl %ebx
c0021de7:	5b                   	pop    %ebx
        ret
c0021de8:	c3                   	ret    

c0021de9 <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c0021de9:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c0021dec:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c0021ded:	e8 0b f6 ff ff       	call   c00213fd <thread_schedule_tail>
	addl $4, %esp
c0021df2:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c0021df5:	c3                   	ret    

c0021df6 <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate(void (*function)(void), int dpl, int type)
{
c0021df6:	53                   	push   %ebx
c0021df7:	83 ec 08             	sub    $0x8,%esp
c0021dfa:	e8 e7 06 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0021dff:	81 c3 3d ee 01 00    	add    $0x1ee3d,%ebx
  uint32_t e0, e1;

  ASSERT(function != NULL);
c0021e05:	85 c0                	test   %eax,%eax
c0021e07:	74 2a                	je     c0021e33 <make_gate+0x3d>
  ASSERT(dpl >= 0 && dpl <= 3);
c0021e09:	83 fa 03             	cmp    $0x3,%edx
c0021e0c:	77 4e                	ja     c0021e5c <make_gate+0x66>
  ASSERT(type >= 0 && type <= 15);
c0021e0e:	83 f9 0f             	cmp    $0xf,%ecx
c0021e11:	77 72                	ja     c0021e85 <make_gate+0x8f>

  e1 = (((uint32_t)function & 0xffff0000) /* Offset 31:16. */
        | (1 << 15)                       /* Present. */
        | ((uint32_t)dpl << 13)           /* Descriptor privilege level. */
        | (0 << 12)                       /* System. */
        | ((uint32_t)type << 8));         /* Gate type. */
c0021e13:	c1 e1 08             	shl    $0x8,%ecx
  e1 = (((uint32_t)function & 0xffff0000) /* Offset 31:16. */
c0021e16:	80 cd 80             	or     $0x80,%ch
        | ((uint32_t)dpl << 13)           /* Descriptor privilege level. */
c0021e19:	c1 e2 0d             	shl    $0xd,%edx
  e1 = (((uint32_t)function & 0xffff0000) /* Offset 31:16. */
c0021e1c:	09 ca                	or     %ecx,%edx
c0021e1e:	89 c1                	mov    %eax,%ecx
c0021e20:	66 b9 00 00          	mov    $0x0,%cx
c0021e24:	09 ca                	or     %ecx,%edx
  e0 = (((uint32_t)function & 0xffff) /* Offset 15:0. */
c0021e26:	0f b7 c0             	movzwl %ax,%eax
c0021e29:	0d 00 00 08 00       	or     $0x80000,%eax

  return e0 | ((uint64_t)e1 << 32);
}
c0021e2e:	83 c4 08             	add    $0x8,%esp
c0021e31:	5b                   	pop    %ebx
c0021e32:	c3                   	ret    
  ASSERT(function != NULL);
c0021e33:	83 ec 0c             	sub    $0xc,%esp
c0021e36:	8d 83 de 33 ff ff    	lea    -0xcc22(%ebx),%eax
c0021e3c:	50                   	push   %eax
c0021e3d:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0021e43:	50                   	push   %eax
c0021e44:	8d 83 e0 1a ff ff    	lea    -0xe520(%ebx),%eax
c0021e4a:	50                   	push   %eax
c0021e4b:	68 2b 01 00 00       	push   $0x12b
c0021e50:	8d 83 82 34 ff ff    	lea    -0xcb7e(%ebx),%eax
c0021e56:	50                   	push   %eax
c0021e57:	e8 39 7a 00 00       	call   c0029895 <debug_panic>
  ASSERT(dpl >= 0 && dpl <= 3);
c0021e5c:	83 ec 0c             	sub    $0xc,%esp
c0021e5f:	8d 83 9c 34 ff ff    	lea    -0xcb64(%ebx),%eax
c0021e65:	50                   	push   %eax
c0021e66:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0021e6c:	50                   	push   %eax
c0021e6d:	8d 83 e0 1a ff ff    	lea    -0xe520(%ebx),%eax
c0021e73:	50                   	push   %eax
c0021e74:	68 2c 01 00 00       	push   $0x12c
c0021e79:	8d 83 82 34 ff ff    	lea    -0xcb7e(%ebx),%eax
c0021e7f:	50                   	push   %eax
c0021e80:	e8 10 7a 00 00       	call   c0029895 <debug_panic>
  ASSERT(type >= 0 && type <= 15);
c0021e85:	83 ec 0c             	sub    $0xc,%esp
c0021e88:	8d 83 b1 34 ff ff    	lea    -0xcb4f(%ebx),%eax
c0021e8e:	50                   	push   %eax
c0021e8f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0021e95:	50                   	push   %eax
c0021e96:	8d 83 e0 1a ff ff    	lea    -0xe520(%ebx),%eax
c0021e9c:	50                   	push   %eax
c0021e9d:	68 2d 01 00 00       	push   $0x12d
c0021ea2:	8d 83 82 34 ff ff    	lea    -0xcb7e(%ebx),%eax
c0021ea8:	50                   	push   %eax
c0021ea9:	e8 e7 79 00 00       	call   c0029895 <debug_panic>

c0021eae <register_handler>:
{
c0021eae:	56                   	push   %esi
c0021eaf:	53                   	push   %ebx
c0021eb0:	83 ec 04             	sub    $0x4,%esp
c0021eb3:	e8 2e 06 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0021eb8:	81 c3 84 ed 01 00    	add    $0x1ed84,%ebx
  ASSERT(intr_handlers[vec_no] == NULL);
c0021ebe:	0f b6 f0             	movzbl %al,%esi
c0021ec1:	83 bc b3 04 0a 00 00 	cmpl   $0x0,0xa04(%ebx,%esi,4)
c0021ec8:	00 
c0021ec9:	75 42                	jne    c0021f0d <register_handler+0x5f>
  if (level == INTR_ON)
c0021ecb:	83 f9 01             	cmp    $0x1,%ecx
c0021ece:	74 66                	je     c0021f36 <register_handler+0x88>
    idt[vec_no] = make_intr_gate(intr_stubs[vec_no], dpl);
c0021ed0:	c7 c0 fc 07 04 c0    	mov    $0xc00407fc,%eax
/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate(void (*function)(void), int dpl)
{
  return make_gate(function, dpl, 14);
c0021ed6:	8b 04 b0             	mov    (%eax,%esi,4),%eax
c0021ed9:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0021ede:	e8 13 ff ff ff       	call   c0021df6 <make_gate>
    idt[vec_no] = make_intr_gate(intr_stubs[vec_no], dpl);
c0021ee3:	89 84 f3 04 0e 00 00 	mov    %eax,0xe04(%ebx,%esi,8)
c0021eea:	89 94 f3 08 0e 00 00 	mov    %edx,0xe08(%ebx,%esi,8)
  intr_handlers[vec_no] = handler;
c0021ef1:	8b 44 24 10          	mov    0x10(%esp),%eax
c0021ef5:	89 84 b3 04 0a 00 00 	mov    %eax,0xa04(%ebx,%esi,4)
  intr_names[vec_no] = name;
c0021efc:	8b 44 24 14          	mov    0x14(%esp),%eax
c0021f00:	89 84 b3 04 06 00 00 	mov    %eax,0x604(%ebx,%esi,4)
}
c0021f07:	83 c4 04             	add    $0x4,%esp
c0021f0a:	5b                   	pop    %ebx
c0021f0b:	5e                   	pop    %esi
c0021f0c:	c3                   	ret    
  ASSERT(intr_handlers[vec_no] == NULL);
c0021f0d:	83 ec 0c             	sub    $0xc,%esp
c0021f10:	8d 83 c9 34 ff ff    	lea    -0xcb37(%ebx),%eax
c0021f16:	50                   	push   %eax
c0021f17:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0021f1d:	50                   	push   %eax
c0021f1e:	8d 83 b8 1a ff ff    	lea    -0xe548(%ebx),%eax
c0021f24:	50                   	push   %eax
c0021f25:	68 ad 00 00 00       	push   $0xad
c0021f2a:	8d 83 82 34 ff ff    	lea    -0xcb7e(%ebx),%eax
c0021f30:	50                   	push   %eax
c0021f31:	e8 5f 79 00 00       	call   c0029895 <debug_panic>
    idt[vec_no] = make_trap_gate(intr_stubs[vec_no], dpl);
c0021f36:	c7 c0 fc 07 04 c0    	mov    $0xc00407fc,%eax
/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate(void (*function)(void), int dpl)
{
  return make_gate(function, dpl, 15);
c0021f3c:	8b 04 b0             	mov    (%eax,%esi,4),%eax
c0021f3f:	b9 0f 00 00 00       	mov    $0xf,%ecx
c0021f44:	e8 ad fe ff ff       	call   c0021df6 <make_gate>
    idt[vec_no] = make_trap_gate(intr_stubs[vec_no], dpl);
c0021f49:	89 84 f3 04 0e 00 00 	mov    %eax,0xe04(%ebx,%esi,8)
c0021f50:	89 94 f3 08 0e 00 00 	mov    %edx,0xe08(%ebx,%esi,8)
c0021f57:	eb 98                	jmp    c0021ef1 <register_handler+0x43>

c0021f59 <intr_get_level>:
  asm volatile("pushfl; popl %0"
c0021f59:	9c                   	pushf  
c0021f5a:	58                   	pop    %eax
  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c0021f5b:	c1 e8 09             	shr    $0x9,%eax
c0021f5e:	83 e0 01             	and    $0x1,%eax
}
c0021f61:	c3                   	ret    

c0021f62 <intr_enable>:
{
c0021f62:	53                   	push   %ebx
c0021f63:	83 ec 08             	sub    $0x8,%esp
c0021f66:	e8 7b 05 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0021f6b:	81 c3 d1 ec 01 00    	add    $0x1ecd1,%ebx
  enum intr_level old_level = intr_get_level();
c0021f71:	e8 e3 ff ff ff       	call   c0021f59 <intr_get_level>
  ASSERT(!intr_context());
c0021f76:	80 bb e5 01 00 00 00 	cmpb   $0x0,0x1e5(%ebx)
c0021f7d:	75 06                	jne    c0021f85 <intr_enable+0x23>
  asm volatile("sti");
c0021f7f:	fb                   	sti    
}
c0021f80:	83 c4 08             	add    $0x8,%esp
c0021f83:	5b                   	pop    %ebx
c0021f84:	c3                   	ret    
  ASSERT(!intr_context());
c0021f85:	83 ec 0c             	sub    $0xc,%esp
c0021f88:	8d 83 ce 33 ff ff    	lea    -0xcc32(%ebx),%eax
c0021f8e:	50                   	push   %eax
c0021f8f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0021f95:	50                   	push   %eax
c0021f96:	8d 83 ec 1a ff ff    	lea    -0xe514(%ebx),%eax
c0021f9c:	50                   	push   %eax
c0021f9d:	6a 5c                	push   $0x5c
c0021f9f:	8d 83 82 34 ff ff    	lea    -0xcb7e(%ebx),%eax
c0021fa5:	50                   	push   %eax
c0021fa6:	e8 ea 78 00 00       	call   c0029895 <debug_panic>

c0021fab <intr_disable>:
  enum intr_level old_level = intr_get_level();
c0021fab:	e8 a9 ff ff ff       	call   c0021f59 <intr_get_level>
  asm volatile("cli"
c0021fb0:	fa                   	cli    
}
c0021fb1:	c3                   	ret    

c0021fb2 <intr_set_level>:
{
c0021fb2:	83 ec 0c             	sub    $0xc,%esp
  return level == INTR_ON ? intr_enable() : intr_disable();
c0021fb5:	83 7c 24 10 01       	cmpl   $0x1,0x10(%esp)
c0021fba:	74 09                	je     c0021fc5 <intr_set_level+0x13>
c0021fbc:	e8 ea ff ff ff       	call   c0021fab <intr_disable>
}
c0021fc1:	83 c4 0c             	add    $0xc,%esp
c0021fc4:	c3                   	ret    
  return level == INTR_ON ? intr_enable() : intr_disable();
c0021fc5:	e8 98 ff ff ff       	call   c0021f62 <intr_enable>
c0021fca:	eb f5                	jmp    c0021fc1 <intr_set_level+0xf>

c0021fcc <intr_init>:
{
c0021fcc:	57                   	push   %edi
c0021fcd:	56                   	push   %esi
c0021fce:	53                   	push   %ebx
c0021fcf:	83 ec 10             	sub    $0x10,%esp
c0021fd2:	e8 1b 05 01 00       	call   c00324f2 <__x86.get_pc_thunk.si>
c0021fd7:	81 c6 65 ec 01 00    	add    $0x1ec65,%esi
/* Writes byte DATA to PORT. */
static inline void
outb(uint16_t port, uint8_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile("outb %b0, %w1"
c0021fdd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0021fe2:	e6 21                	out    %al,$0x21
c0021fe4:	e6 a1                	out    %al,$0xa1
c0021fe6:	b9 11 00 00 00       	mov    $0x11,%ecx
c0021feb:	89 c8                	mov    %ecx,%eax
c0021fed:	e6 20                	out    %al,$0x20
c0021fef:	b8 20 00 00 00       	mov    $0x20,%eax
c0021ff4:	e6 21                	out    %al,$0x21
c0021ff6:	b8 04 00 00 00       	mov    $0x4,%eax
c0021ffb:	e6 21                	out    %al,$0x21
c0021ffd:	ba 01 00 00 00       	mov    $0x1,%edx
c0022002:	89 d0                	mov    %edx,%eax
c0022004:	e6 21                	out    %al,$0x21
c0022006:	89 c8                	mov    %ecx,%eax
c0022008:	e6 a0                	out    %al,$0xa0
c002200a:	b8 28 00 00 00       	mov    $0x28,%eax
c002200f:	e6 a1                	out    %al,$0xa1
c0022011:	b8 02 00 00 00       	mov    $0x2,%eax
c0022016:	e6 a1                	out    %al,$0xa1
c0022018:	89 d0                	mov    %edx,%eax
c002201a:	e6 a1                	out    %al,$0xa1
c002201c:	b8 00 00 00 00       	mov    $0x0,%eax
c0022021:	e6 21                	out    %al,$0x21
c0022023:	e6 a1                	out    %al,$0xa1
  for (i = 0; i < INTR_CNT; i++)
c0022025:	bb 00 00 00 00       	mov    $0x0,%ebx
    idt[i] = make_intr_gate(intr_stubs[i], 0);
c002202a:	c7 c7 fc 07 04 c0    	mov    $0xc00407fc,%edi
  return make_gate(function, dpl, 14);
c0022030:	8b 04 9f             	mov    (%edi,%ebx,4),%eax
c0022033:	b9 0e 00 00 00       	mov    $0xe,%ecx
c0022038:	ba 00 00 00 00       	mov    $0x0,%edx
c002203d:	e8 b4 fd ff ff       	call   c0021df6 <make_gate>
    idt[i] = make_intr_gate(intr_stubs[i], 0);
c0022042:	89 84 de 04 0e 00 00 	mov    %eax,0xe04(%esi,%ebx,8)
c0022049:	89 94 de 08 0e 00 00 	mov    %edx,0xe08(%esi,%ebx,8)
  for (i = 0; i < INTR_CNT; i++)
c0022050:	83 c3 01             	add    $0x1,%ebx
c0022053:	81 fb 00 01 00 00    	cmp    $0x100,%ebx
c0022059:	75 d5                	jne    c0022030 <intr_init+0x64>
/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand(uint16_t limit, void *base)
{
  return limit | ((uint64_t)(uint32_t)base << 16);
c002205b:	8d 86 04 0e 00 00    	lea    0xe04(%esi),%eax
c0022061:	ba 00 00 00 00       	mov    $0x0,%edx
c0022066:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c002206a:	c1 e0 10             	shl    $0x10,%eax
c002206d:	0d ff 07 00 00       	or     $0x7ff,%eax
c0022072:	89 44 24 08          	mov    %eax,0x8(%esp)
c0022076:	89 54 24 0c          	mov    %edx,0xc(%esp)
  asm volatile("lidt %0"
c002207a:	0f 01 5c 24 08       	lidtl  0x8(%esp)
c002207f:	8d 86 04 06 00 00    	lea    0x604(%esi),%eax
c0022085:	8d 8e 04 0a 00 00    	lea    0xa04(%esi),%ecx
    intr_names[i] = "unknown";
c002208b:	8d 96 e7 34 ff ff    	lea    -0xcb19(%esi),%edx
c0022091:	89 10                	mov    %edx,(%eax)
c0022093:	83 c0 04             	add    $0x4,%eax
  for (i = 0; i < INTR_CNT; i++)
c0022096:	39 c1                	cmp    %eax,%ecx
c0022098:	75 f7                	jne    c0022091 <intr_init+0xc5>
  intr_names[0] = "#DE Divide Error";
c002209a:	8d 86 ef 34 ff ff    	lea    -0xcb11(%esi),%eax
c00220a0:	89 86 04 06 00 00    	mov    %eax,0x604(%esi)
  intr_names[1] = "#DB Debug Exception";
c00220a6:	8d 86 00 35 ff ff    	lea    -0xcb00(%esi),%eax
c00220ac:	89 86 08 06 00 00    	mov    %eax,0x608(%esi)
  intr_names[2] = "NMI Interrupt";
c00220b2:	8d 86 14 35 ff ff    	lea    -0xcaec(%esi),%eax
c00220b8:	89 86 0c 06 00 00    	mov    %eax,0x60c(%esi)
  intr_names[3] = "#BP Breakpoint Exception";
c00220be:	8d 86 22 35 ff ff    	lea    -0xcade(%esi),%eax
c00220c4:	89 86 10 06 00 00    	mov    %eax,0x610(%esi)
  intr_names[4] = "#OF Overflow Exception";
c00220ca:	8d 86 3b 35 ff ff    	lea    -0xcac5(%esi),%eax
c00220d0:	89 86 14 06 00 00    	mov    %eax,0x614(%esi)
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c00220d6:	8d 86 78 36 ff ff    	lea    -0xc988(%esi),%eax
c00220dc:	89 86 18 06 00 00    	mov    %eax,0x618(%esi)
  intr_names[6] = "#UD Invalid Opcode Exception";
c00220e2:	8d 86 52 35 ff ff    	lea    -0xcaae(%esi),%eax
c00220e8:	89 86 1c 06 00 00    	mov    %eax,0x61c(%esi)
  intr_names[7] = "#NM Device Not Available Exception";
c00220ee:	8d 86 9c 36 ff ff    	lea    -0xc964(%esi),%eax
c00220f4:	89 86 20 06 00 00    	mov    %eax,0x620(%esi)
  intr_names[8] = "#DF Double Fault Exception";
c00220fa:	8d 86 6f 35 ff ff    	lea    -0xca91(%esi),%eax
c0022100:	89 86 24 06 00 00    	mov    %eax,0x624(%esi)
  intr_names[9] = "Coprocessor Segment Overrun";
c0022106:	8d 86 8a 35 ff ff    	lea    -0xca76(%esi),%eax
c002210c:	89 86 28 06 00 00    	mov    %eax,0x628(%esi)
  intr_names[10] = "#TS Invalid TSS Exception";
c0022112:	8d 86 a6 35 ff ff    	lea    -0xca5a(%esi),%eax
c0022118:	89 86 2c 06 00 00    	mov    %eax,0x62c(%esi)
  intr_names[11] = "#NP Segment Not Present";
c002211e:	8d 86 c0 35 ff ff    	lea    -0xca40(%esi),%eax
c0022124:	89 86 30 06 00 00    	mov    %eax,0x630(%esi)
  intr_names[12] = "#SS Stack Fault Exception";
c002212a:	8d 86 d8 35 ff ff    	lea    -0xca28(%esi),%eax
c0022130:	89 86 34 06 00 00    	mov    %eax,0x634(%esi)
  intr_names[13] = "#GP General Protection Exception";
c0022136:	8d 86 c0 36 ff ff    	lea    -0xc940(%esi),%eax
c002213c:	89 86 38 06 00 00    	mov    %eax,0x638(%esi)
  intr_names[14] = "#PF Page-Fault Exception";
c0022142:	8d 86 f2 35 ff ff    	lea    -0xca0e(%esi),%eax
c0022148:	89 86 3c 06 00 00    	mov    %eax,0x63c(%esi)
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c002214e:	8d 86 e4 36 ff ff    	lea    -0xc91c(%esi),%eax
c0022154:	89 86 44 06 00 00    	mov    %eax,0x644(%esi)
  intr_names[17] = "#AC Alignment Check Exception";
c002215a:	8d 86 0b 36 ff ff    	lea    -0xc9f5(%esi),%eax
c0022160:	89 86 48 06 00 00    	mov    %eax,0x648(%esi)
  intr_names[18] = "#MC Machine-Check Exception";
c0022166:	8d 86 29 36 ff ff    	lea    -0xc9d7(%esi),%eax
c002216c:	89 86 4c 06 00 00    	mov    %eax,0x64c(%esi)
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c0022172:	8d 86 08 37 ff ff    	lea    -0xc8f8(%esi),%eax
c0022178:	89 86 50 06 00 00    	mov    %eax,0x650(%esi)
}
c002217e:	83 c4 10             	add    $0x10,%esp
c0022181:	5b                   	pop    %ebx
c0022182:	5e                   	pop    %esi
c0022183:	5f                   	pop    %edi
c0022184:	c3                   	ret    

c0022185 <intr_register_ext>:
{
c0022185:	53                   	push   %ebx
c0022186:	83 ec 08             	sub    $0x8,%esp
c0022189:	e8 58 03 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002218e:	81 c3 ae ea 01 00    	add    $0x1eaae,%ebx
c0022194:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(vec_no >= 0x20 && vec_no <= 0x2f);
c0022198:	8d 50 e0             	lea    -0x20(%eax),%edx
c002219b:	80 fa 0f             	cmp    $0xf,%dl
c002219e:	77 22                	ja     c00221c2 <intr_register_ext+0x3d>
  register_handler(vec_no, 0, INTR_OFF, handler, name);
c00221a0:	0f b6 c0             	movzbl %al,%eax
c00221a3:	83 ec 08             	sub    $0x8,%esp
c00221a6:	ff 74 24 20          	pushl  0x20(%esp)
c00221aa:	ff 74 24 20          	pushl  0x20(%esp)
c00221ae:	b9 00 00 00 00       	mov    $0x0,%ecx
c00221b3:	ba 00 00 00 00       	mov    $0x0,%edx
c00221b8:	e8 f1 fc ff ff       	call   c0021eae <register_handler>
}
c00221bd:	83 c4 18             	add    $0x18,%esp
c00221c0:	5b                   	pop    %ebx
c00221c1:	c3                   	ret    
  ASSERT(vec_no >= 0x20 && vec_no <= 0x2f);
c00221c2:	83 ec 0c             	sub    $0xc,%esp
c00221c5:	8d 83 2c 37 ff ff    	lea    -0xc8d4(%ebx),%eax
c00221cb:	50                   	push   %eax
c00221cc:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00221d2:	50                   	push   %eax
c00221d3:	8d 83 cc 1a ff ff    	lea    -0xe534(%ebx),%eax
c00221d9:	50                   	push   %eax
c00221da:	68 bc 00 00 00       	push   $0xbc
c00221df:	8d 83 82 34 ff ff    	lea    -0xcb7e(%ebx),%eax
c00221e5:	50                   	push   %eax
c00221e6:	e8 aa 76 00 00       	call   c0029895 <debug_panic>

c00221eb <intr_register_int>:
{
c00221eb:	53                   	push   %ebx
c00221ec:	83 ec 08             	sub    $0x8,%esp
c00221ef:	e8 f2 02 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00221f4:	81 c3 48 ea 01 00    	add    $0x1ea48,%ebx
c00221fa:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(vec_no < 0x20 || vec_no > 0x2f);
c00221fe:	8d 50 e0             	lea    -0x20(%eax),%edx
c0022201:	80 fa 0f             	cmp    $0xf,%dl
c0022204:	76 20                	jbe    c0022226 <intr_register_int+0x3b>
  register_handler(vec_no, dpl, level, handler, name);
c0022206:	0f b6 c0             	movzbl %al,%eax
c0022209:	83 ec 08             	sub    $0x8,%esp
c002220c:	ff 74 24 28          	pushl  0x28(%esp)
c0022210:	ff 74 24 28          	pushl  0x28(%esp)
c0022214:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c0022218:	8b 54 24 24          	mov    0x24(%esp),%edx
c002221c:	e8 8d fc ff ff       	call   c0021eae <register_handler>
}
c0022221:	83 c4 18             	add    $0x18,%esp
c0022224:	5b                   	pop    %ebx
c0022225:	c3                   	ret    
  ASSERT(vec_no < 0x20 || vec_no > 0x2f);
c0022226:	83 ec 0c             	sub    $0xc,%esp
c0022229:	8d 83 50 37 ff ff    	lea    -0xc8b0(%ebx),%eax
c002222f:	50                   	push   %eax
c0022230:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0022236:	50                   	push   %eax
c0022237:	8d 83 a4 1a ff ff    	lea    -0xe55c(%ebx),%eax
c002223d:	50                   	push   %eax
c002223e:	68 d0 00 00 00       	push   $0xd0
c0022243:	8d 83 82 34 ff ff    	lea    -0xcb7e(%ebx),%eax
c0022249:	50                   	push   %eax
c002224a:	e8 46 76 00 00       	call   c0029895 <debug_panic>

c002224f <intr_context>:
{
c002224f:	e8 96 02 01 00       	call   c00324ea <__x86.get_pc_thunk.ax>
c0022254:	05 e8 e9 01 00       	add    $0x1e9e8,%eax
  return in_external_intr;
c0022259:	0f b6 80 e5 01 00 00 	movzbl 0x1e5(%eax),%eax
}
c0022260:	c3                   	ret    

c0022261 <intr_yield_on_return>:
{
c0022261:	53                   	push   %ebx
c0022262:	83 ec 08             	sub    $0x8,%esp
c0022265:	e8 7c 02 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002226a:	81 c3 d2 e9 01 00    	add    $0x1e9d2,%ebx
  ASSERT(intr_context());
c0022270:	80 bb e5 01 00 00 00 	cmpb   $0x0,0x1e5(%ebx)
c0022277:	74 0c                	je     c0022285 <intr_yield_on_return+0x24>
  yield_on_return = true;
c0022279:	c6 83 e4 01 00 00 01 	movb   $0x1,0x1e4(%ebx)
}
c0022280:	83 c4 08             	add    $0x8,%esp
c0022283:	5b                   	pop    %ebx
c0022284:	c3                   	ret    
  ASSERT(intr_context());
c0022285:	83 ec 0c             	sub    $0xc,%esp
c0022288:	8d 93 cf 33 ff ff    	lea    -0xcc31(%ebx),%edx
c002228e:	52                   	push   %edx
c002228f:	8d 93 fc 2c ff ff    	lea    -0xd304(%ebx),%edx
c0022295:	52                   	push   %edx
c0022296:	8d 93 8c 1a ff ff    	lea    -0xe574(%ebx),%edx
c002229c:	52                   	push   %edx
c002229d:	68 e1 00 00 00       	push   $0xe1
c00222a2:	8d 93 82 34 ff ff    	lea    -0xcb7e(%ebx),%edx
c00222a8:	52                   	push   %edx
c00222a9:	e8 e7 75 00 00       	call   c0029895 <debug_panic>

c00222ae <intr_handler>:
/* Handler for all interrupts, faults, and exceptions.  This
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void intr_handler(struct intr_frame *frame)
{
c00222ae:	55                   	push   %ebp
c00222af:	57                   	push   %edi
c00222b0:	56                   	push   %esi
c00222b1:	53                   	push   %ebx
c00222b2:	83 ec 0c             	sub    $0xc,%esp
c00222b5:	e8 2c 02 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00222ba:	81 c3 82 e9 01 00    	add    $0x1e982,%ebx
c00222c0:	8b 7c 24 20          	mov    0x20(%esp),%edi

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c00222c4:	8b 47 30             	mov    0x30(%edi),%eax
c00222c7:	8d 70 e0             	lea    -0x20(%eax),%esi
  if (external)
c00222ca:	83 fe 0f             	cmp    $0xf,%esi
c00222cd:	76 2c                	jbe    c00222fb <intr_handler+0x4d>
    in_external_intr = true;
    yield_on_return = false;
  }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c00222cf:	8b 57 30             	mov    0x30(%edi),%edx
c00222d2:	8b 84 93 04 0a 00 00 	mov    0xa04(%ebx,%edx,4),%eax
  if (handler != NULL)
c00222d9:	85 c0                	test   %eax,%eax
c00222db:	0f 84 8e 00 00 00    	je     c002236f <intr_handler+0xc1>
    handler(frame);
c00222e1:	83 ec 0c             	sub    $0xc,%esp
c00222e4:	57                   	push   %edi
c00222e5:	ff d0                	call   *%eax
c00222e7:	83 c4 10             	add    $0x10,%esp
  }
  else
    unexpected_interrupt(frame);

  /* Complete the processing of an external interrupt. */
  if (external)
c00222ea:	83 fe 0f             	cmp    $0xf,%esi
c00222ed:	0f 86 c2 00 00 00    	jbe    c00223b5 <intr_handler+0x107>
    pic_end_of_interrupt(frame->vec_no);

    if (yield_on_return)
      thread_yield();
  }
}
c00222f3:	83 c4 0c             	add    $0xc,%esp
c00222f6:	5b                   	pop    %ebx
c00222f7:	5e                   	pop    %esi
c00222f8:	5f                   	pop    %edi
c00222f9:	5d                   	pop    %ebp
c00222fa:	c3                   	ret    
    ASSERT(intr_get_level() == INTR_OFF);
c00222fb:	e8 59 fc ff ff       	call   c0021f59 <intr_get_level>
c0022300:	85 c0                	test   %eax,%eax
c0022302:	75 19                	jne    c002231d <intr_handler+0x6f>
    ASSERT(!intr_context());
c0022304:	80 bb e5 01 00 00 00 	cmpb   $0x0,0x1e5(%ebx)
c002230b:	75 39                	jne    c0022346 <intr_handler+0x98>
    in_external_intr = true;
c002230d:	c6 83 e5 01 00 00 01 	movb   $0x1,0x1e5(%ebx)
    yield_on_return = false;
c0022314:	c6 83 e4 01 00 00 00 	movb   $0x0,0x1e4(%ebx)
c002231b:	eb b2                	jmp    c00222cf <intr_handler+0x21>
    ASSERT(intr_get_level() == INTR_OFF);
c002231d:	83 ec 0c             	sub    $0xc,%esp
c0022320:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c0022326:	50                   	push   %eax
c0022327:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002232d:	50                   	push   %eax
c002232e:	8d 83 7c 1a ff ff    	lea    -0xe584(%ebx),%eax
c0022334:	50                   	push   %eax
c0022335:	68 65 01 00 00       	push   $0x165
c002233a:	8d 83 82 34 ff ff    	lea    -0xcb7e(%ebx),%eax
c0022340:	50                   	push   %eax
c0022341:	e8 4f 75 00 00       	call   c0029895 <debug_panic>
    ASSERT(!intr_context());
c0022346:	83 ec 0c             	sub    $0xc,%esp
c0022349:	8d 83 ce 33 ff ff    	lea    -0xcc32(%ebx),%eax
c002234f:	50                   	push   %eax
c0022350:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0022356:	50                   	push   %eax
c0022357:	8d 83 7c 1a ff ff    	lea    -0xe584(%ebx),%eax
c002235d:	50                   	push   %eax
c002235e:	68 66 01 00 00       	push   $0x166
c0022363:	8d 83 82 34 ff ff    	lea    -0xcb7e(%ebx),%eax
c0022369:	50                   	push   %eax
c002236a:	e8 26 75 00 00       	call   c0029895 <debug_panic>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c002236f:	89 d0                	mov    %edx,%eax
c0022371:	83 e0 f7             	and    $0xfffffff7,%eax
c0022374:	83 f8 27             	cmp    $0x27,%eax
c0022377:	0f 84 6d ff ff ff    	je     c00222ea <intr_handler+0x3c>
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt(const struct intr_frame *f)
{
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c002237d:	8d ab 04 02 00 00    	lea    0x204(%ebx),%ebp
c0022383:	8b 4c 95 00          	mov    0x0(%ebp,%edx,4),%ecx
c0022387:	8d 41 01             	lea    0x1(%ecx),%eax
c002238a:	89 44 95 00          	mov    %eax,0x0(%ebp,%edx,4)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c002238e:	85 c1                	test   %eax,%ecx
c0022390:	0f 85 54 ff ff ff    	jne    c00222ea <intr_handler+0x3c>
    printf("Unexpected interrupt %#04x (%s)\n",
c0022396:	83 ec 04             	sub    $0x4,%esp
c0022399:	ff b4 93 04 06 00 00 	pushl  0x604(%ebx,%edx,4)
c00223a0:	52                   	push   %edx
c00223a1:	8d 83 70 37 ff ff    	lea    -0xc890(%ebx),%eax
c00223a7:	50                   	push   %eax
c00223a8:	e8 51 57 00 00       	call   c0027afe <printf>
c00223ad:	83 c4 10             	add    $0x10,%esp
c00223b0:	e9 35 ff ff ff       	jmp    c00222ea <intr_handler+0x3c>
    ASSERT(intr_get_level() == INTR_OFF);
c00223b5:	e8 9f fb ff ff       	call   c0021f59 <intr_get_level>
c00223ba:	85 c0                	test   %eax,%eax
c00223bc:	75 40                	jne    c00223fe <intr_handler+0x150>
    ASSERT(intr_context());
c00223be:	80 bb e5 01 00 00 00 	cmpb   $0x0,0x1e5(%ebx)
c00223c5:	74 60                	je     c0022427 <intr_handler+0x179>
    in_external_intr = false;
c00223c7:	c6 83 e5 01 00 00 00 	movb   $0x0,0x1e5(%ebx)
    pic_end_of_interrupt(frame->vec_no);
c00223ce:	8b 57 30             	mov    0x30(%edi),%edx
  ASSERT(irq >= 0x20 && irq < 0x30);
c00223d1:	8d 42 e0             	lea    -0x20(%edx),%eax
c00223d4:	83 f8 0f             	cmp    $0xf,%eax
c00223d7:	77 77                	ja     c0022450 <intr_handler+0x1a2>
c00223d9:	b8 20 00 00 00       	mov    $0x20,%eax
c00223de:	e6 20                	out    %al,$0x20
  if (irq >= 0x28)
c00223e0:	83 fa 27             	cmp    $0x27,%edx
c00223e3:	7e 02                	jle    c00223e7 <intr_handler+0x139>
c00223e5:	e6 a0                	out    %al,$0xa0
    if (yield_on_return)
c00223e7:	80 bb e4 01 00 00 00 	cmpb   $0x0,0x1e4(%ebx)
c00223ee:	0f 84 ff fe ff ff    	je     c00222f3 <intr_handler+0x45>
      thread_yield();
c00223f4:	e8 22 f4 ff ff       	call   c002181b <thread_yield>
}
c00223f9:	e9 f5 fe ff ff       	jmp    c00222f3 <intr_handler+0x45>
    ASSERT(intr_get_level() == INTR_OFF);
c00223fe:	83 ec 0c             	sub    $0xc,%esp
c0022401:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c0022407:	50                   	push   %eax
c0022408:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002240e:	50                   	push   %eax
c002240f:	8d 83 7c 1a ff ff    	lea    -0xe584(%ebx),%eax
c0022415:	50                   	push   %eax
c0022416:	68 7c 01 00 00       	push   $0x17c
c002241b:	8d 83 82 34 ff ff    	lea    -0xcb7e(%ebx),%eax
c0022421:	50                   	push   %eax
c0022422:	e8 6e 74 00 00       	call   c0029895 <debug_panic>
    ASSERT(intr_context());
c0022427:	83 ec 0c             	sub    $0xc,%esp
c002242a:	8d 83 cf 33 ff ff    	lea    -0xcc31(%ebx),%eax
c0022430:	50                   	push   %eax
c0022431:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0022437:	50                   	push   %eax
c0022438:	8d 83 7c 1a ff ff    	lea    -0xe584(%ebx),%eax
c002243e:	50                   	push   %eax
c002243f:	68 7d 01 00 00       	push   $0x17d
c0022444:	8d 83 82 34 ff ff    	lea    -0xcb7e(%ebx),%eax
c002244a:	50                   	push   %eax
c002244b:	e8 45 74 00 00       	call   c0029895 <debug_panic>
  ASSERT(irq >= 0x20 && irq < 0x30);
c0022450:	83 ec 0c             	sub    $0xc,%esp
c0022453:	8d 83 45 36 ff ff    	lea    -0xc9bb(%ebx),%eax
c0022459:	50                   	push   %eax
c002245a:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0022460:	50                   	push   %eax
c0022461:	8d 83 64 1a ff ff    	lea    -0xe59c(%ebx),%eax
c0022467:	50                   	push   %eax
c0022468:	68 0c 01 00 00       	push   $0x10c
c002246d:	8d 83 82 34 ff ff    	lea    -0xcb7e(%ebx),%eax
c0022473:	50                   	push   %eax
c0022474:	e8 1c 74 00 00       	call   c0029895 <debug_panic>

c0022479 <intr_dump_frame>:
           f->vec_no, intr_names[f->vec_no]);
}

/* Dumps interrupt frame F to the console, for debugging. */
void intr_dump_frame(const struct intr_frame *f)
{
c0022479:	57                   	push   %edi
c002247a:	56                   	push   %esi
c002247b:	53                   	push   %ebx
c002247c:	e8 65 00 01 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0022481:	81 c3 bb e7 01 00    	add    $0x1e7bb,%ebx
c0022487:	8b 74 24 10          	mov    0x10(%esp),%esi
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm("movl %%cr2, %0"
c002248b:	0f 20 d7             	mov    %cr2,%edi
      : "=r"(cr2));

  printf("Interrupt %#04x (%s) at eip=%p\n",
         f->vec_no, intr_names[f->vec_no], f->eip);
c002248e:	8b 46 30             	mov    0x30(%esi),%eax
  printf("Interrupt %#04x (%s) at eip=%p\n",
c0022491:	ff 76 3c             	pushl  0x3c(%esi)
c0022494:	ff b4 83 04 06 00 00 	pushl  0x604(%ebx,%eax,4)
c002249b:	50                   	push   %eax
c002249c:	8d 83 94 37 ff ff    	lea    -0xc86c(%ebx),%eax
c00224a2:	50                   	push   %eax
c00224a3:	e8 56 56 00 00       	call   c0027afe <printf>
  printf(" cr2=%08" PRIx32 " error=%08" PRIx32 "\n", cr2, f->error_code);
c00224a8:	83 c4 0c             	add    $0xc,%esp
c00224ab:	ff 76 34             	pushl  0x34(%esi)
c00224ae:	57                   	push   %edi
c00224af:	8d 83 5f 36 ff ff    	lea    -0xc9a1(%ebx),%eax
c00224b5:	50                   	push   %eax
c00224b6:	e8 43 56 00 00       	call   c0027afe <printf>
  printf(" eax=%08" PRIx32 " ebx=%08" PRIx32 " ecx=%08" PRIx32 " edx=%08" PRIx32 "\n",
c00224bb:	83 c4 04             	add    $0x4,%esp
c00224be:	ff 76 14             	pushl  0x14(%esi)
c00224c1:	ff 76 18             	pushl  0x18(%esi)
c00224c4:	ff 76 10             	pushl  0x10(%esi)
c00224c7:	ff 76 1c             	pushl  0x1c(%esi)
c00224ca:	8d 83 b4 37 ff ff    	lea    -0xc84c(%ebx),%eax
c00224d0:	50                   	push   %eax
c00224d1:	e8 28 56 00 00       	call   c0027afe <printf>
         f->eax, f->ebx, f->ecx, f->edx);
  printf(" esi=%08" PRIx32 " edi=%08" PRIx32 " esp=%08" PRIx32 " ebp=%08" PRIx32 "\n",
c00224d6:	83 c4 14             	add    $0x14,%esp
c00224d9:	ff 76 08             	pushl  0x8(%esi)
c00224dc:	ff 76 48             	pushl  0x48(%esi)
c00224df:	ff 36                	pushl  (%esi)
c00224e1:	ff 76 04             	pushl  0x4(%esi)
c00224e4:	8d 83 dc 37 ff ff    	lea    -0xc824(%ebx),%eax
c00224ea:	50                   	push   %eax
c00224eb:	e8 0e 56 00 00       	call   c0027afe <printf>
         f->esi, f->edi, (uint32_t)f->esp, f->ebp);
  printf(" cs=%04" PRIx16 " ds=%04" PRIx16 " es=%04" PRIx16 " ss=%04" PRIx16 "\n",
c00224f0:	83 c4 14             	add    $0x14,%esp
c00224f3:	0f b7 46 4c          	movzwl 0x4c(%esi),%eax
c00224f7:	50                   	push   %eax
c00224f8:	0f b7 46 28          	movzwl 0x28(%esi),%eax
c00224fc:	50                   	push   %eax
c00224fd:	0f b7 46 2c          	movzwl 0x2c(%esi),%eax
c0022501:	50                   	push   %eax
c0022502:	0f b7 46 40          	movzwl 0x40(%esi),%eax
c0022506:	50                   	push   %eax
c0022507:	8d 83 04 38 ff ff    	lea    -0xc7fc(%ebx),%eax
c002250d:	50                   	push   %eax
c002250e:	e8 eb 55 00 00       	call   c0027afe <printf>
         f->cs, f->ds, f->es, f->ss);
}
c0022513:	83 c4 20             	add    $0x20,%esp
c0022516:	5b                   	pop    %ebx
c0022517:	5e                   	pop    %esi
c0022518:	5f                   	pop    %edi
c0022519:	c3                   	ret    

c002251a <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name(uint8_t vec)
{
c002251a:	e8 cb ff 00 00       	call   c00324ea <__x86.get_pc_thunk.ax>
c002251f:	05 1d e7 01 00       	add    $0x1e71d,%eax
  return intr_names[vec];
c0022524:	0f b6 54 24 04       	movzbl 0x4(%esp),%edx
c0022529:	8b 84 90 04 06 00 00 	mov    0x604(%eax,%edx,4),%eax
}
c0022530:	c3                   	ret    

c0022531 <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c0022531:	1e                   	push   %ds
	pushl %es
c0022532:	06                   	push   %es
	pushl %fs
c0022533:	0f a0                	push   %fs
	pushl %gs
c0022535:	0f a8                	push   %gs
	pushal
c0022537:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c0022538:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c0022539:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c002253e:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c0022540:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c0022542:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c0022546:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c0022547:	e8 62 fd ff ff       	call   c00222ae <intr_handler>
	addl $4, %esp
c002254c:	83 c4 04             	add    $0x4,%esp

c002254f <intr_exit>:
   userprog/process.c). */
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
c002254f:	61                   	popa   
	popl %gs
c0022550:	0f a9                	pop    %gs
	popl %fs
c0022552:	0f a1                	pop    %fs
	popl %es
c0022554:	07                   	pop    %es
	popl %ds
c0022555:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c0022556:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c0022559:	cf                   	iret   

c002255a <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c002255a:	55                   	push   %ebp
c002255b:	6a 00                	push   $0x0
c002255d:	6a 00                	push   $0x0
c002255f:	eb d0                	jmp    c0022531 <intr_entry>

c0022561 <intr01_stub>:
c0022561:	55                   	push   %ebp
c0022562:	6a 00                	push   $0x0
c0022564:	6a 01                	push   $0x1
c0022566:	eb c9                	jmp    c0022531 <intr_entry>

c0022568 <intr02_stub>:
c0022568:	55                   	push   %ebp
c0022569:	6a 00                	push   $0x0
c002256b:	6a 02                	push   $0x2
c002256d:	eb c2                	jmp    c0022531 <intr_entry>

c002256f <intr03_stub>:
c002256f:	55                   	push   %ebp
c0022570:	6a 00                	push   $0x0
c0022572:	6a 03                	push   $0x3
c0022574:	eb bb                	jmp    c0022531 <intr_entry>

c0022576 <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c0022576:	55                   	push   %ebp
c0022577:	6a 00                	push   $0x0
c0022579:	6a 04                	push   $0x4
c002257b:	eb b4                	jmp    c0022531 <intr_entry>

c002257d <intr05_stub>:
c002257d:	55                   	push   %ebp
c002257e:	6a 00                	push   $0x0
c0022580:	6a 05                	push   $0x5
c0022582:	eb ad                	jmp    c0022531 <intr_entry>

c0022584 <intr06_stub>:
c0022584:	55                   	push   %ebp
c0022585:	6a 00                	push   $0x0
c0022587:	6a 06                	push   $0x6
c0022589:	eb a6                	jmp    c0022531 <intr_entry>

c002258b <intr07_stub>:
c002258b:	55                   	push   %ebp
c002258c:	6a 00                	push   $0x0
c002258e:	6a 07                	push   $0x7
c0022590:	eb 9f                	jmp    c0022531 <intr_entry>

c0022592 <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c0022592:	ff 34 24             	pushl  (%esp)
c0022595:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022599:	6a 08                	push   $0x8
c002259b:	eb 94                	jmp    c0022531 <intr_entry>

c002259d <intr09_stub>:
c002259d:	55                   	push   %ebp
c002259e:	6a 00                	push   $0x0
c00225a0:	6a 09                	push   $0x9
c00225a2:	eb 8d                	jmp    c0022531 <intr_entry>

c00225a4 <intr0a_stub>:
c00225a4:	ff 34 24             	pushl  (%esp)
c00225a7:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00225ab:	6a 0a                	push   $0xa
c00225ad:	eb 82                	jmp    c0022531 <intr_entry>

c00225af <intr0b_stub>:
c00225af:	ff 34 24             	pushl  (%esp)
c00225b2:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00225b6:	6a 0b                	push   $0xb
c00225b8:	e9 74 ff ff ff       	jmp    c0022531 <intr_entry>

c00225bd <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c00225bd:	55                   	push   %ebp
c00225be:	6a 00                	push   $0x0
c00225c0:	6a 0c                	push   $0xc
c00225c2:	e9 6a ff ff ff       	jmp    c0022531 <intr_entry>

c00225c7 <intr0d_stub>:
c00225c7:	ff 34 24             	pushl  (%esp)
c00225ca:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00225ce:	6a 0d                	push   $0xd
c00225d0:	e9 5c ff ff ff       	jmp    c0022531 <intr_entry>

c00225d5 <intr0e_stub>:
c00225d5:	ff 34 24             	pushl  (%esp)
c00225d8:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00225dc:	6a 0e                	push   $0xe
c00225de:	e9 4e ff ff ff       	jmp    c0022531 <intr_entry>

c00225e3 <intr0f_stub>:
c00225e3:	55                   	push   %ebp
c00225e4:	6a 00                	push   $0x0
c00225e6:	6a 0f                	push   $0xf
c00225e8:	e9 44 ff ff ff       	jmp    c0022531 <intr_entry>

c00225ed <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c00225ed:	55                   	push   %ebp
c00225ee:	6a 00                	push   $0x0
c00225f0:	6a 10                	push   $0x10
c00225f2:	e9 3a ff ff ff       	jmp    c0022531 <intr_entry>

c00225f7 <intr11_stub>:
c00225f7:	ff 34 24             	pushl  (%esp)
c00225fa:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c00225fe:	6a 11                	push   $0x11
c0022600:	e9 2c ff ff ff       	jmp    c0022531 <intr_entry>

c0022605 <intr12_stub>:
c0022605:	55                   	push   %ebp
c0022606:	6a 00                	push   $0x0
c0022608:	6a 12                	push   $0x12
c002260a:	e9 22 ff ff ff       	jmp    c0022531 <intr_entry>

c002260f <intr13_stub>:
c002260f:	55                   	push   %ebp
c0022610:	6a 00                	push   $0x0
c0022612:	6a 13                	push   $0x13
c0022614:	e9 18 ff ff ff       	jmp    c0022531 <intr_entry>

c0022619 <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c0022619:	55                   	push   %ebp
c002261a:	6a 00                	push   $0x0
c002261c:	6a 14                	push   $0x14
c002261e:	e9 0e ff ff ff       	jmp    c0022531 <intr_entry>

c0022623 <intr15_stub>:
c0022623:	55                   	push   %ebp
c0022624:	6a 00                	push   $0x0
c0022626:	6a 15                	push   $0x15
c0022628:	e9 04 ff ff ff       	jmp    c0022531 <intr_entry>

c002262d <intr16_stub>:
c002262d:	55                   	push   %ebp
c002262e:	6a 00                	push   $0x0
c0022630:	6a 16                	push   $0x16
c0022632:	e9 fa fe ff ff       	jmp    c0022531 <intr_entry>

c0022637 <intr17_stub>:
c0022637:	55                   	push   %ebp
c0022638:	6a 00                	push   $0x0
c002263a:	6a 17                	push   $0x17
c002263c:	e9 f0 fe ff ff       	jmp    c0022531 <intr_entry>

c0022641 <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c0022641:	ff 34 24             	pushl  (%esp)
c0022644:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022648:	6a 18                	push   $0x18
c002264a:	e9 e2 fe ff ff       	jmp    c0022531 <intr_entry>

c002264f <intr19_stub>:
c002264f:	55                   	push   %ebp
c0022650:	6a 00                	push   $0x0
c0022652:	6a 19                	push   $0x19
c0022654:	e9 d8 fe ff ff       	jmp    c0022531 <intr_entry>

c0022659 <intr1a_stub>:
c0022659:	ff 34 24             	pushl  (%esp)
c002265c:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022660:	6a 1a                	push   $0x1a
c0022662:	e9 ca fe ff ff       	jmp    c0022531 <intr_entry>

c0022667 <intr1b_stub>:
c0022667:	ff 34 24             	pushl  (%esp)
c002266a:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c002266e:	6a 1b                	push   $0x1b
c0022670:	e9 bc fe ff ff       	jmp    c0022531 <intr_entry>

c0022675 <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c0022675:	55                   	push   %ebp
c0022676:	6a 00                	push   $0x0
c0022678:	6a 1c                	push   $0x1c
c002267a:	e9 b2 fe ff ff       	jmp    c0022531 <intr_entry>

c002267f <intr1d_stub>:
c002267f:	ff 34 24             	pushl  (%esp)
c0022682:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022686:	6a 1d                	push   $0x1d
c0022688:	e9 a4 fe ff ff       	jmp    c0022531 <intr_entry>

c002268d <intr1e_stub>:
c002268d:	ff 34 24             	pushl  (%esp)
c0022690:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0022694:	6a 1e                	push   $0x1e
c0022696:	e9 96 fe ff ff       	jmp    c0022531 <intr_entry>

c002269b <intr1f_stub>:
c002269b:	55                   	push   %ebp
c002269c:	6a 00                	push   $0x0
c002269e:	6a 1f                	push   $0x1f
c00226a0:	e9 8c fe ff ff       	jmp    c0022531 <intr_entry>

c00226a5 <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c00226a5:	55                   	push   %ebp
c00226a6:	6a 00                	push   $0x0
c00226a8:	6a 20                	push   $0x20
c00226aa:	e9 82 fe ff ff       	jmp    c0022531 <intr_entry>

c00226af <intr21_stub>:
c00226af:	55                   	push   %ebp
c00226b0:	6a 00                	push   $0x0
c00226b2:	6a 21                	push   $0x21
c00226b4:	e9 78 fe ff ff       	jmp    c0022531 <intr_entry>

c00226b9 <intr22_stub>:
c00226b9:	55                   	push   %ebp
c00226ba:	6a 00                	push   $0x0
c00226bc:	6a 22                	push   $0x22
c00226be:	e9 6e fe ff ff       	jmp    c0022531 <intr_entry>

c00226c3 <intr23_stub>:
c00226c3:	55                   	push   %ebp
c00226c4:	6a 00                	push   $0x0
c00226c6:	6a 23                	push   $0x23
c00226c8:	e9 64 fe ff ff       	jmp    c0022531 <intr_entry>

c00226cd <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c00226cd:	55                   	push   %ebp
c00226ce:	6a 00                	push   $0x0
c00226d0:	6a 24                	push   $0x24
c00226d2:	e9 5a fe ff ff       	jmp    c0022531 <intr_entry>

c00226d7 <intr25_stub>:
c00226d7:	55                   	push   %ebp
c00226d8:	6a 00                	push   $0x0
c00226da:	6a 25                	push   $0x25
c00226dc:	e9 50 fe ff ff       	jmp    c0022531 <intr_entry>

c00226e1 <intr26_stub>:
c00226e1:	55                   	push   %ebp
c00226e2:	6a 00                	push   $0x0
c00226e4:	6a 26                	push   $0x26
c00226e6:	e9 46 fe ff ff       	jmp    c0022531 <intr_entry>

c00226eb <intr27_stub>:
c00226eb:	55                   	push   %ebp
c00226ec:	6a 00                	push   $0x0
c00226ee:	6a 27                	push   $0x27
c00226f0:	e9 3c fe ff ff       	jmp    c0022531 <intr_entry>

c00226f5 <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c00226f5:	55                   	push   %ebp
c00226f6:	6a 00                	push   $0x0
c00226f8:	6a 28                	push   $0x28
c00226fa:	e9 32 fe ff ff       	jmp    c0022531 <intr_entry>

c00226ff <intr29_stub>:
c00226ff:	55                   	push   %ebp
c0022700:	6a 00                	push   $0x0
c0022702:	6a 29                	push   $0x29
c0022704:	e9 28 fe ff ff       	jmp    c0022531 <intr_entry>

c0022709 <intr2a_stub>:
c0022709:	55                   	push   %ebp
c002270a:	6a 00                	push   $0x0
c002270c:	6a 2a                	push   $0x2a
c002270e:	e9 1e fe ff ff       	jmp    c0022531 <intr_entry>

c0022713 <intr2b_stub>:
c0022713:	55                   	push   %ebp
c0022714:	6a 00                	push   $0x0
c0022716:	6a 2b                	push   $0x2b
c0022718:	e9 14 fe ff ff       	jmp    c0022531 <intr_entry>

c002271d <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c002271d:	55                   	push   %ebp
c002271e:	6a 00                	push   $0x0
c0022720:	6a 2c                	push   $0x2c
c0022722:	e9 0a fe ff ff       	jmp    c0022531 <intr_entry>

c0022727 <intr2d_stub>:
c0022727:	55                   	push   %ebp
c0022728:	6a 00                	push   $0x0
c002272a:	6a 2d                	push   $0x2d
c002272c:	e9 00 fe ff ff       	jmp    c0022531 <intr_entry>

c0022731 <intr2e_stub>:
c0022731:	55                   	push   %ebp
c0022732:	6a 00                	push   $0x0
c0022734:	6a 2e                	push   $0x2e
c0022736:	e9 f6 fd ff ff       	jmp    c0022531 <intr_entry>

c002273b <intr2f_stub>:
c002273b:	55                   	push   %ebp
c002273c:	6a 00                	push   $0x0
c002273e:	6a 2f                	push   $0x2f
c0022740:	e9 ec fd ff ff       	jmp    c0022531 <intr_entry>

c0022745 <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c0022745:	55                   	push   %ebp
c0022746:	6a 00                	push   $0x0
c0022748:	6a 30                	push   $0x30
c002274a:	e9 e2 fd ff ff       	jmp    c0022531 <intr_entry>

c002274f <intr31_stub>:
c002274f:	55                   	push   %ebp
c0022750:	6a 00                	push   $0x0
c0022752:	6a 31                	push   $0x31
c0022754:	e9 d8 fd ff ff       	jmp    c0022531 <intr_entry>

c0022759 <intr32_stub>:
c0022759:	55                   	push   %ebp
c002275a:	6a 00                	push   $0x0
c002275c:	6a 32                	push   $0x32
c002275e:	e9 ce fd ff ff       	jmp    c0022531 <intr_entry>

c0022763 <intr33_stub>:
c0022763:	55                   	push   %ebp
c0022764:	6a 00                	push   $0x0
c0022766:	6a 33                	push   $0x33
c0022768:	e9 c4 fd ff ff       	jmp    c0022531 <intr_entry>

c002276d <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c002276d:	55                   	push   %ebp
c002276e:	6a 00                	push   $0x0
c0022770:	6a 34                	push   $0x34
c0022772:	e9 ba fd ff ff       	jmp    c0022531 <intr_entry>

c0022777 <intr35_stub>:
c0022777:	55                   	push   %ebp
c0022778:	6a 00                	push   $0x0
c002277a:	6a 35                	push   $0x35
c002277c:	e9 b0 fd ff ff       	jmp    c0022531 <intr_entry>

c0022781 <intr36_stub>:
c0022781:	55                   	push   %ebp
c0022782:	6a 00                	push   $0x0
c0022784:	6a 36                	push   $0x36
c0022786:	e9 a6 fd ff ff       	jmp    c0022531 <intr_entry>

c002278b <intr37_stub>:
c002278b:	55                   	push   %ebp
c002278c:	6a 00                	push   $0x0
c002278e:	6a 37                	push   $0x37
c0022790:	e9 9c fd ff ff       	jmp    c0022531 <intr_entry>

c0022795 <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c0022795:	55                   	push   %ebp
c0022796:	6a 00                	push   $0x0
c0022798:	6a 38                	push   $0x38
c002279a:	e9 92 fd ff ff       	jmp    c0022531 <intr_entry>

c002279f <intr39_stub>:
c002279f:	55                   	push   %ebp
c00227a0:	6a 00                	push   $0x0
c00227a2:	6a 39                	push   $0x39
c00227a4:	e9 88 fd ff ff       	jmp    c0022531 <intr_entry>

c00227a9 <intr3a_stub>:
c00227a9:	55                   	push   %ebp
c00227aa:	6a 00                	push   $0x0
c00227ac:	6a 3a                	push   $0x3a
c00227ae:	e9 7e fd ff ff       	jmp    c0022531 <intr_entry>

c00227b3 <intr3b_stub>:
c00227b3:	55                   	push   %ebp
c00227b4:	6a 00                	push   $0x0
c00227b6:	6a 3b                	push   $0x3b
c00227b8:	e9 74 fd ff ff       	jmp    c0022531 <intr_entry>

c00227bd <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c00227bd:	55                   	push   %ebp
c00227be:	6a 00                	push   $0x0
c00227c0:	6a 3c                	push   $0x3c
c00227c2:	e9 6a fd ff ff       	jmp    c0022531 <intr_entry>

c00227c7 <intr3d_stub>:
c00227c7:	55                   	push   %ebp
c00227c8:	6a 00                	push   $0x0
c00227ca:	6a 3d                	push   $0x3d
c00227cc:	e9 60 fd ff ff       	jmp    c0022531 <intr_entry>

c00227d1 <intr3e_stub>:
c00227d1:	55                   	push   %ebp
c00227d2:	6a 00                	push   $0x0
c00227d4:	6a 3e                	push   $0x3e
c00227d6:	e9 56 fd ff ff       	jmp    c0022531 <intr_entry>

c00227db <intr3f_stub>:
c00227db:	55                   	push   %ebp
c00227dc:	6a 00                	push   $0x0
c00227de:	6a 3f                	push   $0x3f
c00227e0:	e9 4c fd ff ff       	jmp    c0022531 <intr_entry>

c00227e5 <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c00227e5:	55                   	push   %ebp
c00227e6:	6a 00                	push   $0x0
c00227e8:	6a 40                	push   $0x40
c00227ea:	e9 42 fd ff ff       	jmp    c0022531 <intr_entry>

c00227ef <intr41_stub>:
c00227ef:	55                   	push   %ebp
c00227f0:	6a 00                	push   $0x0
c00227f2:	6a 41                	push   $0x41
c00227f4:	e9 38 fd ff ff       	jmp    c0022531 <intr_entry>

c00227f9 <intr42_stub>:
c00227f9:	55                   	push   %ebp
c00227fa:	6a 00                	push   $0x0
c00227fc:	6a 42                	push   $0x42
c00227fe:	e9 2e fd ff ff       	jmp    c0022531 <intr_entry>

c0022803 <intr43_stub>:
c0022803:	55                   	push   %ebp
c0022804:	6a 00                	push   $0x0
c0022806:	6a 43                	push   $0x43
c0022808:	e9 24 fd ff ff       	jmp    c0022531 <intr_entry>

c002280d <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c002280d:	55                   	push   %ebp
c002280e:	6a 00                	push   $0x0
c0022810:	6a 44                	push   $0x44
c0022812:	e9 1a fd ff ff       	jmp    c0022531 <intr_entry>

c0022817 <intr45_stub>:
c0022817:	55                   	push   %ebp
c0022818:	6a 00                	push   $0x0
c002281a:	6a 45                	push   $0x45
c002281c:	e9 10 fd ff ff       	jmp    c0022531 <intr_entry>

c0022821 <intr46_stub>:
c0022821:	55                   	push   %ebp
c0022822:	6a 00                	push   $0x0
c0022824:	6a 46                	push   $0x46
c0022826:	e9 06 fd ff ff       	jmp    c0022531 <intr_entry>

c002282b <intr47_stub>:
c002282b:	55                   	push   %ebp
c002282c:	6a 00                	push   $0x0
c002282e:	6a 47                	push   $0x47
c0022830:	e9 fc fc ff ff       	jmp    c0022531 <intr_entry>

c0022835 <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c0022835:	55                   	push   %ebp
c0022836:	6a 00                	push   $0x0
c0022838:	6a 48                	push   $0x48
c002283a:	e9 f2 fc ff ff       	jmp    c0022531 <intr_entry>

c002283f <intr49_stub>:
c002283f:	55                   	push   %ebp
c0022840:	6a 00                	push   $0x0
c0022842:	6a 49                	push   $0x49
c0022844:	e9 e8 fc ff ff       	jmp    c0022531 <intr_entry>

c0022849 <intr4a_stub>:
c0022849:	55                   	push   %ebp
c002284a:	6a 00                	push   $0x0
c002284c:	6a 4a                	push   $0x4a
c002284e:	e9 de fc ff ff       	jmp    c0022531 <intr_entry>

c0022853 <intr4b_stub>:
c0022853:	55                   	push   %ebp
c0022854:	6a 00                	push   $0x0
c0022856:	6a 4b                	push   $0x4b
c0022858:	e9 d4 fc ff ff       	jmp    c0022531 <intr_entry>

c002285d <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c002285d:	55                   	push   %ebp
c002285e:	6a 00                	push   $0x0
c0022860:	6a 4c                	push   $0x4c
c0022862:	e9 ca fc ff ff       	jmp    c0022531 <intr_entry>

c0022867 <intr4d_stub>:
c0022867:	55                   	push   %ebp
c0022868:	6a 00                	push   $0x0
c002286a:	6a 4d                	push   $0x4d
c002286c:	e9 c0 fc ff ff       	jmp    c0022531 <intr_entry>

c0022871 <intr4e_stub>:
c0022871:	55                   	push   %ebp
c0022872:	6a 00                	push   $0x0
c0022874:	6a 4e                	push   $0x4e
c0022876:	e9 b6 fc ff ff       	jmp    c0022531 <intr_entry>

c002287b <intr4f_stub>:
c002287b:	55                   	push   %ebp
c002287c:	6a 00                	push   $0x0
c002287e:	6a 4f                	push   $0x4f
c0022880:	e9 ac fc ff ff       	jmp    c0022531 <intr_entry>

c0022885 <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c0022885:	55                   	push   %ebp
c0022886:	6a 00                	push   $0x0
c0022888:	6a 50                	push   $0x50
c002288a:	e9 a2 fc ff ff       	jmp    c0022531 <intr_entry>

c002288f <intr51_stub>:
c002288f:	55                   	push   %ebp
c0022890:	6a 00                	push   $0x0
c0022892:	6a 51                	push   $0x51
c0022894:	e9 98 fc ff ff       	jmp    c0022531 <intr_entry>

c0022899 <intr52_stub>:
c0022899:	55                   	push   %ebp
c002289a:	6a 00                	push   $0x0
c002289c:	6a 52                	push   $0x52
c002289e:	e9 8e fc ff ff       	jmp    c0022531 <intr_entry>

c00228a3 <intr53_stub>:
c00228a3:	55                   	push   %ebp
c00228a4:	6a 00                	push   $0x0
c00228a6:	6a 53                	push   $0x53
c00228a8:	e9 84 fc ff ff       	jmp    c0022531 <intr_entry>

c00228ad <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c00228ad:	55                   	push   %ebp
c00228ae:	6a 00                	push   $0x0
c00228b0:	6a 54                	push   $0x54
c00228b2:	e9 7a fc ff ff       	jmp    c0022531 <intr_entry>

c00228b7 <intr55_stub>:
c00228b7:	55                   	push   %ebp
c00228b8:	6a 00                	push   $0x0
c00228ba:	6a 55                	push   $0x55
c00228bc:	e9 70 fc ff ff       	jmp    c0022531 <intr_entry>

c00228c1 <intr56_stub>:
c00228c1:	55                   	push   %ebp
c00228c2:	6a 00                	push   $0x0
c00228c4:	6a 56                	push   $0x56
c00228c6:	e9 66 fc ff ff       	jmp    c0022531 <intr_entry>

c00228cb <intr57_stub>:
c00228cb:	55                   	push   %ebp
c00228cc:	6a 00                	push   $0x0
c00228ce:	6a 57                	push   $0x57
c00228d0:	e9 5c fc ff ff       	jmp    c0022531 <intr_entry>

c00228d5 <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c00228d5:	55                   	push   %ebp
c00228d6:	6a 00                	push   $0x0
c00228d8:	6a 58                	push   $0x58
c00228da:	e9 52 fc ff ff       	jmp    c0022531 <intr_entry>

c00228df <intr59_stub>:
c00228df:	55                   	push   %ebp
c00228e0:	6a 00                	push   $0x0
c00228e2:	6a 59                	push   $0x59
c00228e4:	e9 48 fc ff ff       	jmp    c0022531 <intr_entry>

c00228e9 <intr5a_stub>:
c00228e9:	55                   	push   %ebp
c00228ea:	6a 00                	push   $0x0
c00228ec:	6a 5a                	push   $0x5a
c00228ee:	e9 3e fc ff ff       	jmp    c0022531 <intr_entry>

c00228f3 <intr5b_stub>:
c00228f3:	55                   	push   %ebp
c00228f4:	6a 00                	push   $0x0
c00228f6:	6a 5b                	push   $0x5b
c00228f8:	e9 34 fc ff ff       	jmp    c0022531 <intr_entry>

c00228fd <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c00228fd:	55                   	push   %ebp
c00228fe:	6a 00                	push   $0x0
c0022900:	6a 5c                	push   $0x5c
c0022902:	e9 2a fc ff ff       	jmp    c0022531 <intr_entry>

c0022907 <intr5d_stub>:
c0022907:	55                   	push   %ebp
c0022908:	6a 00                	push   $0x0
c002290a:	6a 5d                	push   $0x5d
c002290c:	e9 20 fc ff ff       	jmp    c0022531 <intr_entry>

c0022911 <intr5e_stub>:
c0022911:	55                   	push   %ebp
c0022912:	6a 00                	push   $0x0
c0022914:	6a 5e                	push   $0x5e
c0022916:	e9 16 fc ff ff       	jmp    c0022531 <intr_entry>

c002291b <intr5f_stub>:
c002291b:	55                   	push   %ebp
c002291c:	6a 00                	push   $0x0
c002291e:	6a 5f                	push   $0x5f
c0022920:	e9 0c fc ff ff       	jmp    c0022531 <intr_entry>

c0022925 <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c0022925:	55                   	push   %ebp
c0022926:	6a 00                	push   $0x0
c0022928:	6a 60                	push   $0x60
c002292a:	e9 02 fc ff ff       	jmp    c0022531 <intr_entry>

c002292f <intr61_stub>:
c002292f:	55                   	push   %ebp
c0022930:	6a 00                	push   $0x0
c0022932:	6a 61                	push   $0x61
c0022934:	e9 f8 fb ff ff       	jmp    c0022531 <intr_entry>

c0022939 <intr62_stub>:
c0022939:	55                   	push   %ebp
c002293a:	6a 00                	push   $0x0
c002293c:	6a 62                	push   $0x62
c002293e:	e9 ee fb ff ff       	jmp    c0022531 <intr_entry>

c0022943 <intr63_stub>:
c0022943:	55                   	push   %ebp
c0022944:	6a 00                	push   $0x0
c0022946:	6a 63                	push   $0x63
c0022948:	e9 e4 fb ff ff       	jmp    c0022531 <intr_entry>

c002294d <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c002294d:	55                   	push   %ebp
c002294e:	6a 00                	push   $0x0
c0022950:	6a 64                	push   $0x64
c0022952:	e9 da fb ff ff       	jmp    c0022531 <intr_entry>

c0022957 <intr65_stub>:
c0022957:	55                   	push   %ebp
c0022958:	6a 00                	push   $0x0
c002295a:	6a 65                	push   $0x65
c002295c:	e9 d0 fb ff ff       	jmp    c0022531 <intr_entry>

c0022961 <intr66_stub>:
c0022961:	55                   	push   %ebp
c0022962:	6a 00                	push   $0x0
c0022964:	6a 66                	push   $0x66
c0022966:	e9 c6 fb ff ff       	jmp    c0022531 <intr_entry>

c002296b <intr67_stub>:
c002296b:	55                   	push   %ebp
c002296c:	6a 00                	push   $0x0
c002296e:	6a 67                	push   $0x67
c0022970:	e9 bc fb ff ff       	jmp    c0022531 <intr_entry>

c0022975 <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c0022975:	55                   	push   %ebp
c0022976:	6a 00                	push   $0x0
c0022978:	6a 68                	push   $0x68
c002297a:	e9 b2 fb ff ff       	jmp    c0022531 <intr_entry>

c002297f <intr69_stub>:
c002297f:	55                   	push   %ebp
c0022980:	6a 00                	push   $0x0
c0022982:	6a 69                	push   $0x69
c0022984:	e9 a8 fb ff ff       	jmp    c0022531 <intr_entry>

c0022989 <intr6a_stub>:
c0022989:	55                   	push   %ebp
c002298a:	6a 00                	push   $0x0
c002298c:	6a 6a                	push   $0x6a
c002298e:	e9 9e fb ff ff       	jmp    c0022531 <intr_entry>

c0022993 <intr6b_stub>:
c0022993:	55                   	push   %ebp
c0022994:	6a 00                	push   $0x0
c0022996:	6a 6b                	push   $0x6b
c0022998:	e9 94 fb ff ff       	jmp    c0022531 <intr_entry>

c002299d <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c002299d:	55                   	push   %ebp
c002299e:	6a 00                	push   $0x0
c00229a0:	6a 6c                	push   $0x6c
c00229a2:	e9 8a fb ff ff       	jmp    c0022531 <intr_entry>

c00229a7 <intr6d_stub>:
c00229a7:	55                   	push   %ebp
c00229a8:	6a 00                	push   $0x0
c00229aa:	6a 6d                	push   $0x6d
c00229ac:	e9 80 fb ff ff       	jmp    c0022531 <intr_entry>

c00229b1 <intr6e_stub>:
c00229b1:	55                   	push   %ebp
c00229b2:	6a 00                	push   $0x0
c00229b4:	6a 6e                	push   $0x6e
c00229b6:	e9 76 fb ff ff       	jmp    c0022531 <intr_entry>

c00229bb <intr6f_stub>:
c00229bb:	55                   	push   %ebp
c00229bc:	6a 00                	push   $0x0
c00229be:	6a 6f                	push   $0x6f
c00229c0:	e9 6c fb ff ff       	jmp    c0022531 <intr_entry>

c00229c5 <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c00229c5:	55                   	push   %ebp
c00229c6:	6a 00                	push   $0x0
c00229c8:	6a 70                	push   $0x70
c00229ca:	e9 62 fb ff ff       	jmp    c0022531 <intr_entry>

c00229cf <intr71_stub>:
c00229cf:	55                   	push   %ebp
c00229d0:	6a 00                	push   $0x0
c00229d2:	6a 71                	push   $0x71
c00229d4:	e9 58 fb ff ff       	jmp    c0022531 <intr_entry>

c00229d9 <intr72_stub>:
c00229d9:	55                   	push   %ebp
c00229da:	6a 00                	push   $0x0
c00229dc:	6a 72                	push   $0x72
c00229de:	e9 4e fb ff ff       	jmp    c0022531 <intr_entry>

c00229e3 <intr73_stub>:
c00229e3:	55                   	push   %ebp
c00229e4:	6a 00                	push   $0x0
c00229e6:	6a 73                	push   $0x73
c00229e8:	e9 44 fb ff ff       	jmp    c0022531 <intr_entry>

c00229ed <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c00229ed:	55                   	push   %ebp
c00229ee:	6a 00                	push   $0x0
c00229f0:	6a 74                	push   $0x74
c00229f2:	e9 3a fb ff ff       	jmp    c0022531 <intr_entry>

c00229f7 <intr75_stub>:
c00229f7:	55                   	push   %ebp
c00229f8:	6a 00                	push   $0x0
c00229fa:	6a 75                	push   $0x75
c00229fc:	e9 30 fb ff ff       	jmp    c0022531 <intr_entry>

c0022a01 <intr76_stub>:
c0022a01:	55                   	push   %ebp
c0022a02:	6a 00                	push   $0x0
c0022a04:	6a 76                	push   $0x76
c0022a06:	e9 26 fb ff ff       	jmp    c0022531 <intr_entry>

c0022a0b <intr77_stub>:
c0022a0b:	55                   	push   %ebp
c0022a0c:	6a 00                	push   $0x0
c0022a0e:	6a 77                	push   $0x77
c0022a10:	e9 1c fb ff ff       	jmp    c0022531 <intr_entry>

c0022a15 <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c0022a15:	55                   	push   %ebp
c0022a16:	6a 00                	push   $0x0
c0022a18:	6a 78                	push   $0x78
c0022a1a:	e9 12 fb ff ff       	jmp    c0022531 <intr_entry>

c0022a1f <intr79_stub>:
c0022a1f:	55                   	push   %ebp
c0022a20:	6a 00                	push   $0x0
c0022a22:	6a 79                	push   $0x79
c0022a24:	e9 08 fb ff ff       	jmp    c0022531 <intr_entry>

c0022a29 <intr7a_stub>:
c0022a29:	55                   	push   %ebp
c0022a2a:	6a 00                	push   $0x0
c0022a2c:	6a 7a                	push   $0x7a
c0022a2e:	e9 fe fa ff ff       	jmp    c0022531 <intr_entry>

c0022a33 <intr7b_stub>:
c0022a33:	55                   	push   %ebp
c0022a34:	6a 00                	push   $0x0
c0022a36:	6a 7b                	push   $0x7b
c0022a38:	e9 f4 fa ff ff       	jmp    c0022531 <intr_entry>

c0022a3d <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c0022a3d:	55                   	push   %ebp
c0022a3e:	6a 00                	push   $0x0
c0022a40:	6a 7c                	push   $0x7c
c0022a42:	e9 ea fa ff ff       	jmp    c0022531 <intr_entry>

c0022a47 <intr7d_stub>:
c0022a47:	55                   	push   %ebp
c0022a48:	6a 00                	push   $0x0
c0022a4a:	6a 7d                	push   $0x7d
c0022a4c:	e9 e0 fa ff ff       	jmp    c0022531 <intr_entry>

c0022a51 <intr7e_stub>:
c0022a51:	55                   	push   %ebp
c0022a52:	6a 00                	push   $0x0
c0022a54:	6a 7e                	push   $0x7e
c0022a56:	e9 d6 fa ff ff       	jmp    c0022531 <intr_entry>

c0022a5b <intr7f_stub>:
c0022a5b:	55                   	push   %ebp
c0022a5c:	6a 00                	push   $0x0
c0022a5e:	6a 7f                	push   $0x7f
c0022a60:	e9 cc fa ff ff       	jmp    c0022531 <intr_entry>

c0022a65 <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c0022a65:	55                   	push   %ebp
c0022a66:	6a 00                	push   $0x0
c0022a68:	68 80 00 00 00       	push   $0x80
c0022a6d:	e9 bf fa ff ff       	jmp    c0022531 <intr_entry>

c0022a72 <intr81_stub>:
c0022a72:	55                   	push   %ebp
c0022a73:	6a 00                	push   $0x0
c0022a75:	68 81 00 00 00       	push   $0x81
c0022a7a:	e9 b2 fa ff ff       	jmp    c0022531 <intr_entry>

c0022a7f <intr82_stub>:
c0022a7f:	55                   	push   %ebp
c0022a80:	6a 00                	push   $0x0
c0022a82:	68 82 00 00 00       	push   $0x82
c0022a87:	e9 a5 fa ff ff       	jmp    c0022531 <intr_entry>

c0022a8c <intr83_stub>:
c0022a8c:	55                   	push   %ebp
c0022a8d:	6a 00                	push   $0x0
c0022a8f:	68 83 00 00 00       	push   $0x83
c0022a94:	e9 98 fa ff ff       	jmp    c0022531 <intr_entry>

c0022a99 <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c0022a99:	55                   	push   %ebp
c0022a9a:	6a 00                	push   $0x0
c0022a9c:	68 84 00 00 00       	push   $0x84
c0022aa1:	e9 8b fa ff ff       	jmp    c0022531 <intr_entry>

c0022aa6 <intr85_stub>:
c0022aa6:	55                   	push   %ebp
c0022aa7:	6a 00                	push   $0x0
c0022aa9:	68 85 00 00 00       	push   $0x85
c0022aae:	e9 7e fa ff ff       	jmp    c0022531 <intr_entry>

c0022ab3 <intr86_stub>:
c0022ab3:	55                   	push   %ebp
c0022ab4:	6a 00                	push   $0x0
c0022ab6:	68 86 00 00 00       	push   $0x86
c0022abb:	e9 71 fa ff ff       	jmp    c0022531 <intr_entry>

c0022ac0 <intr87_stub>:
c0022ac0:	55                   	push   %ebp
c0022ac1:	6a 00                	push   $0x0
c0022ac3:	68 87 00 00 00       	push   $0x87
c0022ac8:	e9 64 fa ff ff       	jmp    c0022531 <intr_entry>

c0022acd <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c0022acd:	55                   	push   %ebp
c0022ace:	6a 00                	push   $0x0
c0022ad0:	68 88 00 00 00       	push   $0x88
c0022ad5:	e9 57 fa ff ff       	jmp    c0022531 <intr_entry>

c0022ada <intr89_stub>:
c0022ada:	55                   	push   %ebp
c0022adb:	6a 00                	push   $0x0
c0022add:	68 89 00 00 00       	push   $0x89
c0022ae2:	e9 4a fa ff ff       	jmp    c0022531 <intr_entry>

c0022ae7 <intr8a_stub>:
c0022ae7:	55                   	push   %ebp
c0022ae8:	6a 00                	push   $0x0
c0022aea:	68 8a 00 00 00       	push   $0x8a
c0022aef:	e9 3d fa ff ff       	jmp    c0022531 <intr_entry>

c0022af4 <intr8b_stub>:
c0022af4:	55                   	push   %ebp
c0022af5:	6a 00                	push   $0x0
c0022af7:	68 8b 00 00 00       	push   $0x8b
c0022afc:	e9 30 fa ff ff       	jmp    c0022531 <intr_entry>

c0022b01 <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c0022b01:	55                   	push   %ebp
c0022b02:	6a 00                	push   $0x0
c0022b04:	68 8c 00 00 00       	push   $0x8c
c0022b09:	e9 23 fa ff ff       	jmp    c0022531 <intr_entry>

c0022b0e <intr8d_stub>:
c0022b0e:	55                   	push   %ebp
c0022b0f:	6a 00                	push   $0x0
c0022b11:	68 8d 00 00 00       	push   $0x8d
c0022b16:	e9 16 fa ff ff       	jmp    c0022531 <intr_entry>

c0022b1b <intr8e_stub>:
c0022b1b:	55                   	push   %ebp
c0022b1c:	6a 00                	push   $0x0
c0022b1e:	68 8e 00 00 00       	push   $0x8e
c0022b23:	e9 09 fa ff ff       	jmp    c0022531 <intr_entry>

c0022b28 <intr8f_stub>:
c0022b28:	55                   	push   %ebp
c0022b29:	6a 00                	push   $0x0
c0022b2b:	68 8f 00 00 00       	push   $0x8f
c0022b30:	e9 fc f9 ff ff       	jmp    c0022531 <intr_entry>

c0022b35 <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c0022b35:	55                   	push   %ebp
c0022b36:	6a 00                	push   $0x0
c0022b38:	68 90 00 00 00       	push   $0x90
c0022b3d:	e9 ef f9 ff ff       	jmp    c0022531 <intr_entry>

c0022b42 <intr91_stub>:
c0022b42:	55                   	push   %ebp
c0022b43:	6a 00                	push   $0x0
c0022b45:	68 91 00 00 00       	push   $0x91
c0022b4a:	e9 e2 f9 ff ff       	jmp    c0022531 <intr_entry>

c0022b4f <intr92_stub>:
c0022b4f:	55                   	push   %ebp
c0022b50:	6a 00                	push   $0x0
c0022b52:	68 92 00 00 00       	push   $0x92
c0022b57:	e9 d5 f9 ff ff       	jmp    c0022531 <intr_entry>

c0022b5c <intr93_stub>:
c0022b5c:	55                   	push   %ebp
c0022b5d:	6a 00                	push   $0x0
c0022b5f:	68 93 00 00 00       	push   $0x93
c0022b64:	e9 c8 f9 ff ff       	jmp    c0022531 <intr_entry>

c0022b69 <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c0022b69:	55                   	push   %ebp
c0022b6a:	6a 00                	push   $0x0
c0022b6c:	68 94 00 00 00       	push   $0x94
c0022b71:	e9 bb f9 ff ff       	jmp    c0022531 <intr_entry>

c0022b76 <intr95_stub>:
c0022b76:	55                   	push   %ebp
c0022b77:	6a 00                	push   $0x0
c0022b79:	68 95 00 00 00       	push   $0x95
c0022b7e:	e9 ae f9 ff ff       	jmp    c0022531 <intr_entry>

c0022b83 <intr96_stub>:
c0022b83:	55                   	push   %ebp
c0022b84:	6a 00                	push   $0x0
c0022b86:	68 96 00 00 00       	push   $0x96
c0022b8b:	e9 a1 f9 ff ff       	jmp    c0022531 <intr_entry>

c0022b90 <intr97_stub>:
c0022b90:	55                   	push   %ebp
c0022b91:	6a 00                	push   $0x0
c0022b93:	68 97 00 00 00       	push   $0x97
c0022b98:	e9 94 f9 ff ff       	jmp    c0022531 <intr_entry>

c0022b9d <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c0022b9d:	55                   	push   %ebp
c0022b9e:	6a 00                	push   $0x0
c0022ba0:	68 98 00 00 00       	push   $0x98
c0022ba5:	e9 87 f9 ff ff       	jmp    c0022531 <intr_entry>

c0022baa <intr99_stub>:
c0022baa:	55                   	push   %ebp
c0022bab:	6a 00                	push   $0x0
c0022bad:	68 99 00 00 00       	push   $0x99
c0022bb2:	e9 7a f9 ff ff       	jmp    c0022531 <intr_entry>

c0022bb7 <intr9a_stub>:
c0022bb7:	55                   	push   %ebp
c0022bb8:	6a 00                	push   $0x0
c0022bba:	68 9a 00 00 00       	push   $0x9a
c0022bbf:	e9 6d f9 ff ff       	jmp    c0022531 <intr_entry>

c0022bc4 <intr9b_stub>:
c0022bc4:	55                   	push   %ebp
c0022bc5:	6a 00                	push   $0x0
c0022bc7:	68 9b 00 00 00       	push   $0x9b
c0022bcc:	e9 60 f9 ff ff       	jmp    c0022531 <intr_entry>

c0022bd1 <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c0022bd1:	55                   	push   %ebp
c0022bd2:	6a 00                	push   $0x0
c0022bd4:	68 9c 00 00 00       	push   $0x9c
c0022bd9:	e9 53 f9 ff ff       	jmp    c0022531 <intr_entry>

c0022bde <intr9d_stub>:
c0022bde:	55                   	push   %ebp
c0022bdf:	6a 00                	push   $0x0
c0022be1:	68 9d 00 00 00       	push   $0x9d
c0022be6:	e9 46 f9 ff ff       	jmp    c0022531 <intr_entry>

c0022beb <intr9e_stub>:
c0022beb:	55                   	push   %ebp
c0022bec:	6a 00                	push   $0x0
c0022bee:	68 9e 00 00 00       	push   $0x9e
c0022bf3:	e9 39 f9 ff ff       	jmp    c0022531 <intr_entry>

c0022bf8 <intr9f_stub>:
c0022bf8:	55                   	push   %ebp
c0022bf9:	6a 00                	push   $0x0
c0022bfb:	68 9f 00 00 00       	push   $0x9f
c0022c00:	e9 2c f9 ff ff       	jmp    c0022531 <intr_entry>

c0022c05 <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c0022c05:	55                   	push   %ebp
c0022c06:	6a 00                	push   $0x0
c0022c08:	68 a0 00 00 00       	push   $0xa0
c0022c0d:	e9 1f f9 ff ff       	jmp    c0022531 <intr_entry>

c0022c12 <intra1_stub>:
c0022c12:	55                   	push   %ebp
c0022c13:	6a 00                	push   $0x0
c0022c15:	68 a1 00 00 00       	push   $0xa1
c0022c1a:	e9 12 f9 ff ff       	jmp    c0022531 <intr_entry>

c0022c1f <intra2_stub>:
c0022c1f:	55                   	push   %ebp
c0022c20:	6a 00                	push   $0x0
c0022c22:	68 a2 00 00 00       	push   $0xa2
c0022c27:	e9 05 f9 ff ff       	jmp    c0022531 <intr_entry>

c0022c2c <intra3_stub>:
c0022c2c:	55                   	push   %ebp
c0022c2d:	6a 00                	push   $0x0
c0022c2f:	68 a3 00 00 00       	push   $0xa3
c0022c34:	e9 f8 f8 ff ff       	jmp    c0022531 <intr_entry>

c0022c39 <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c0022c39:	55                   	push   %ebp
c0022c3a:	6a 00                	push   $0x0
c0022c3c:	68 a4 00 00 00       	push   $0xa4
c0022c41:	e9 eb f8 ff ff       	jmp    c0022531 <intr_entry>

c0022c46 <intra5_stub>:
c0022c46:	55                   	push   %ebp
c0022c47:	6a 00                	push   $0x0
c0022c49:	68 a5 00 00 00       	push   $0xa5
c0022c4e:	e9 de f8 ff ff       	jmp    c0022531 <intr_entry>

c0022c53 <intra6_stub>:
c0022c53:	55                   	push   %ebp
c0022c54:	6a 00                	push   $0x0
c0022c56:	68 a6 00 00 00       	push   $0xa6
c0022c5b:	e9 d1 f8 ff ff       	jmp    c0022531 <intr_entry>

c0022c60 <intra7_stub>:
c0022c60:	55                   	push   %ebp
c0022c61:	6a 00                	push   $0x0
c0022c63:	68 a7 00 00 00       	push   $0xa7
c0022c68:	e9 c4 f8 ff ff       	jmp    c0022531 <intr_entry>

c0022c6d <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c0022c6d:	55                   	push   %ebp
c0022c6e:	6a 00                	push   $0x0
c0022c70:	68 a8 00 00 00       	push   $0xa8
c0022c75:	e9 b7 f8 ff ff       	jmp    c0022531 <intr_entry>

c0022c7a <intra9_stub>:
c0022c7a:	55                   	push   %ebp
c0022c7b:	6a 00                	push   $0x0
c0022c7d:	68 a9 00 00 00       	push   $0xa9
c0022c82:	e9 aa f8 ff ff       	jmp    c0022531 <intr_entry>

c0022c87 <intraa_stub>:
c0022c87:	55                   	push   %ebp
c0022c88:	6a 00                	push   $0x0
c0022c8a:	68 aa 00 00 00       	push   $0xaa
c0022c8f:	e9 9d f8 ff ff       	jmp    c0022531 <intr_entry>

c0022c94 <intrab_stub>:
c0022c94:	55                   	push   %ebp
c0022c95:	6a 00                	push   $0x0
c0022c97:	68 ab 00 00 00       	push   $0xab
c0022c9c:	e9 90 f8 ff ff       	jmp    c0022531 <intr_entry>

c0022ca1 <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c0022ca1:	55                   	push   %ebp
c0022ca2:	6a 00                	push   $0x0
c0022ca4:	68 ac 00 00 00       	push   $0xac
c0022ca9:	e9 83 f8 ff ff       	jmp    c0022531 <intr_entry>

c0022cae <intrad_stub>:
c0022cae:	55                   	push   %ebp
c0022caf:	6a 00                	push   $0x0
c0022cb1:	68 ad 00 00 00       	push   $0xad
c0022cb6:	e9 76 f8 ff ff       	jmp    c0022531 <intr_entry>

c0022cbb <intrae_stub>:
c0022cbb:	55                   	push   %ebp
c0022cbc:	6a 00                	push   $0x0
c0022cbe:	68 ae 00 00 00       	push   $0xae
c0022cc3:	e9 69 f8 ff ff       	jmp    c0022531 <intr_entry>

c0022cc8 <intraf_stub>:
c0022cc8:	55                   	push   %ebp
c0022cc9:	6a 00                	push   $0x0
c0022ccb:	68 af 00 00 00       	push   $0xaf
c0022cd0:	e9 5c f8 ff ff       	jmp    c0022531 <intr_entry>

c0022cd5 <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c0022cd5:	55                   	push   %ebp
c0022cd6:	6a 00                	push   $0x0
c0022cd8:	68 b0 00 00 00       	push   $0xb0
c0022cdd:	e9 4f f8 ff ff       	jmp    c0022531 <intr_entry>

c0022ce2 <intrb1_stub>:
c0022ce2:	55                   	push   %ebp
c0022ce3:	6a 00                	push   $0x0
c0022ce5:	68 b1 00 00 00       	push   $0xb1
c0022cea:	e9 42 f8 ff ff       	jmp    c0022531 <intr_entry>

c0022cef <intrb2_stub>:
c0022cef:	55                   	push   %ebp
c0022cf0:	6a 00                	push   $0x0
c0022cf2:	68 b2 00 00 00       	push   $0xb2
c0022cf7:	e9 35 f8 ff ff       	jmp    c0022531 <intr_entry>

c0022cfc <intrb3_stub>:
c0022cfc:	55                   	push   %ebp
c0022cfd:	6a 00                	push   $0x0
c0022cff:	68 b3 00 00 00       	push   $0xb3
c0022d04:	e9 28 f8 ff ff       	jmp    c0022531 <intr_entry>

c0022d09 <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c0022d09:	55                   	push   %ebp
c0022d0a:	6a 00                	push   $0x0
c0022d0c:	68 b4 00 00 00       	push   $0xb4
c0022d11:	e9 1b f8 ff ff       	jmp    c0022531 <intr_entry>

c0022d16 <intrb5_stub>:
c0022d16:	55                   	push   %ebp
c0022d17:	6a 00                	push   $0x0
c0022d19:	68 b5 00 00 00       	push   $0xb5
c0022d1e:	e9 0e f8 ff ff       	jmp    c0022531 <intr_entry>

c0022d23 <intrb6_stub>:
c0022d23:	55                   	push   %ebp
c0022d24:	6a 00                	push   $0x0
c0022d26:	68 b6 00 00 00       	push   $0xb6
c0022d2b:	e9 01 f8 ff ff       	jmp    c0022531 <intr_entry>

c0022d30 <intrb7_stub>:
c0022d30:	55                   	push   %ebp
c0022d31:	6a 00                	push   $0x0
c0022d33:	68 b7 00 00 00       	push   $0xb7
c0022d38:	e9 f4 f7 ff ff       	jmp    c0022531 <intr_entry>

c0022d3d <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c0022d3d:	55                   	push   %ebp
c0022d3e:	6a 00                	push   $0x0
c0022d40:	68 b8 00 00 00       	push   $0xb8
c0022d45:	e9 e7 f7 ff ff       	jmp    c0022531 <intr_entry>

c0022d4a <intrb9_stub>:
c0022d4a:	55                   	push   %ebp
c0022d4b:	6a 00                	push   $0x0
c0022d4d:	68 b9 00 00 00       	push   $0xb9
c0022d52:	e9 da f7 ff ff       	jmp    c0022531 <intr_entry>

c0022d57 <intrba_stub>:
c0022d57:	55                   	push   %ebp
c0022d58:	6a 00                	push   $0x0
c0022d5a:	68 ba 00 00 00       	push   $0xba
c0022d5f:	e9 cd f7 ff ff       	jmp    c0022531 <intr_entry>

c0022d64 <intrbb_stub>:
c0022d64:	55                   	push   %ebp
c0022d65:	6a 00                	push   $0x0
c0022d67:	68 bb 00 00 00       	push   $0xbb
c0022d6c:	e9 c0 f7 ff ff       	jmp    c0022531 <intr_entry>

c0022d71 <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c0022d71:	55                   	push   %ebp
c0022d72:	6a 00                	push   $0x0
c0022d74:	68 bc 00 00 00       	push   $0xbc
c0022d79:	e9 b3 f7 ff ff       	jmp    c0022531 <intr_entry>

c0022d7e <intrbd_stub>:
c0022d7e:	55                   	push   %ebp
c0022d7f:	6a 00                	push   $0x0
c0022d81:	68 bd 00 00 00       	push   $0xbd
c0022d86:	e9 a6 f7 ff ff       	jmp    c0022531 <intr_entry>

c0022d8b <intrbe_stub>:
c0022d8b:	55                   	push   %ebp
c0022d8c:	6a 00                	push   $0x0
c0022d8e:	68 be 00 00 00       	push   $0xbe
c0022d93:	e9 99 f7 ff ff       	jmp    c0022531 <intr_entry>

c0022d98 <intrbf_stub>:
c0022d98:	55                   	push   %ebp
c0022d99:	6a 00                	push   $0x0
c0022d9b:	68 bf 00 00 00       	push   $0xbf
c0022da0:	e9 8c f7 ff ff       	jmp    c0022531 <intr_entry>

c0022da5 <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c0022da5:	55                   	push   %ebp
c0022da6:	6a 00                	push   $0x0
c0022da8:	68 c0 00 00 00       	push   $0xc0
c0022dad:	e9 7f f7 ff ff       	jmp    c0022531 <intr_entry>

c0022db2 <intrc1_stub>:
c0022db2:	55                   	push   %ebp
c0022db3:	6a 00                	push   $0x0
c0022db5:	68 c1 00 00 00       	push   $0xc1
c0022dba:	e9 72 f7 ff ff       	jmp    c0022531 <intr_entry>

c0022dbf <intrc2_stub>:
c0022dbf:	55                   	push   %ebp
c0022dc0:	6a 00                	push   $0x0
c0022dc2:	68 c2 00 00 00       	push   $0xc2
c0022dc7:	e9 65 f7 ff ff       	jmp    c0022531 <intr_entry>

c0022dcc <intrc3_stub>:
c0022dcc:	55                   	push   %ebp
c0022dcd:	6a 00                	push   $0x0
c0022dcf:	68 c3 00 00 00       	push   $0xc3
c0022dd4:	e9 58 f7 ff ff       	jmp    c0022531 <intr_entry>

c0022dd9 <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c0022dd9:	55                   	push   %ebp
c0022dda:	6a 00                	push   $0x0
c0022ddc:	68 c4 00 00 00       	push   $0xc4
c0022de1:	e9 4b f7 ff ff       	jmp    c0022531 <intr_entry>

c0022de6 <intrc5_stub>:
c0022de6:	55                   	push   %ebp
c0022de7:	6a 00                	push   $0x0
c0022de9:	68 c5 00 00 00       	push   $0xc5
c0022dee:	e9 3e f7 ff ff       	jmp    c0022531 <intr_entry>

c0022df3 <intrc6_stub>:
c0022df3:	55                   	push   %ebp
c0022df4:	6a 00                	push   $0x0
c0022df6:	68 c6 00 00 00       	push   $0xc6
c0022dfb:	e9 31 f7 ff ff       	jmp    c0022531 <intr_entry>

c0022e00 <intrc7_stub>:
c0022e00:	55                   	push   %ebp
c0022e01:	6a 00                	push   $0x0
c0022e03:	68 c7 00 00 00       	push   $0xc7
c0022e08:	e9 24 f7 ff ff       	jmp    c0022531 <intr_entry>

c0022e0d <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c0022e0d:	55                   	push   %ebp
c0022e0e:	6a 00                	push   $0x0
c0022e10:	68 c8 00 00 00       	push   $0xc8
c0022e15:	e9 17 f7 ff ff       	jmp    c0022531 <intr_entry>

c0022e1a <intrc9_stub>:
c0022e1a:	55                   	push   %ebp
c0022e1b:	6a 00                	push   $0x0
c0022e1d:	68 c9 00 00 00       	push   $0xc9
c0022e22:	e9 0a f7 ff ff       	jmp    c0022531 <intr_entry>

c0022e27 <intrca_stub>:
c0022e27:	55                   	push   %ebp
c0022e28:	6a 00                	push   $0x0
c0022e2a:	68 ca 00 00 00       	push   $0xca
c0022e2f:	e9 fd f6 ff ff       	jmp    c0022531 <intr_entry>

c0022e34 <intrcb_stub>:
c0022e34:	55                   	push   %ebp
c0022e35:	6a 00                	push   $0x0
c0022e37:	68 cb 00 00 00       	push   $0xcb
c0022e3c:	e9 f0 f6 ff ff       	jmp    c0022531 <intr_entry>

c0022e41 <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c0022e41:	55                   	push   %ebp
c0022e42:	6a 00                	push   $0x0
c0022e44:	68 cc 00 00 00       	push   $0xcc
c0022e49:	e9 e3 f6 ff ff       	jmp    c0022531 <intr_entry>

c0022e4e <intrcd_stub>:
c0022e4e:	55                   	push   %ebp
c0022e4f:	6a 00                	push   $0x0
c0022e51:	68 cd 00 00 00       	push   $0xcd
c0022e56:	e9 d6 f6 ff ff       	jmp    c0022531 <intr_entry>

c0022e5b <intrce_stub>:
c0022e5b:	55                   	push   %ebp
c0022e5c:	6a 00                	push   $0x0
c0022e5e:	68 ce 00 00 00       	push   $0xce
c0022e63:	e9 c9 f6 ff ff       	jmp    c0022531 <intr_entry>

c0022e68 <intrcf_stub>:
c0022e68:	55                   	push   %ebp
c0022e69:	6a 00                	push   $0x0
c0022e6b:	68 cf 00 00 00       	push   $0xcf
c0022e70:	e9 bc f6 ff ff       	jmp    c0022531 <intr_entry>

c0022e75 <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c0022e75:	55                   	push   %ebp
c0022e76:	6a 00                	push   $0x0
c0022e78:	68 d0 00 00 00       	push   $0xd0
c0022e7d:	e9 af f6 ff ff       	jmp    c0022531 <intr_entry>

c0022e82 <intrd1_stub>:
c0022e82:	55                   	push   %ebp
c0022e83:	6a 00                	push   $0x0
c0022e85:	68 d1 00 00 00       	push   $0xd1
c0022e8a:	e9 a2 f6 ff ff       	jmp    c0022531 <intr_entry>

c0022e8f <intrd2_stub>:
c0022e8f:	55                   	push   %ebp
c0022e90:	6a 00                	push   $0x0
c0022e92:	68 d2 00 00 00       	push   $0xd2
c0022e97:	e9 95 f6 ff ff       	jmp    c0022531 <intr_entry>

c0022e9c <intrd3_stub>:
c0022e9c:	55                   	push   %ebp
c0022e9d:	6a 00                	push   $0x0
c0022e9f:	68 d3 00 00 00       	push   $0xd3
c0022ea4:	e9 88 f6 ff ff       	jmp    c0022531 <intr_entry>

c0022ea9 <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c0022ea9:	55                   	push   %ebp
c0022eaa:	6a 00                	push   $0x0
c0022eac:	68 d4 00 00 00       	push   $0xd4
c0022eb1:	e9 7b f6 ff ff       	jmp    c0022531 <intr_entry>

c0022eb6 <intrd5_stub>:
c0022eb6:	55                   	push   %ebp
c0022eb7:	6a 00                	push   $0x0
c0022eb9:	68 d5 00 00 00       	push   $0xd5
c0022ebe:	e9 6e f6 ff ff       	jmp    c0022531 <intr_entry>

c0022ec3 <intrd6_stub>:
c0022ec3:	55                   	push   %ebp
c0022ec4:	6a 00                	push   $0x0
c0022ec6:	68 d6 00 00 00       	push   $0xd6
c0022ecb:	e9 61 f6 ff ff       	jmp    c0022531 <intr_entry>

c0022ed0 <intrd7_stub>:
c0022ed0:	55                   	push   %ebp
c0022ed1:	6a 00                	push   $0x0
c0022ed3:	68 d7 00 00 00       	push   $0xd7
c0022ed8:	e9 54 f6 ff ff       	jmp    c0022531 <intr_entry>

c0022edd <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c0022edd:	55                   	push   %ebp
c0022ede:	6a 00                	push   $0x0
c0022ee0:	68 d8 00 00 00       	push   $0xd8
c0022ee5:	e9 47 f6 ff ff       	jmp    c0022531 <intr_entry>

c0022eea <intrd9_stub>:
c0022eea:	55                   	push   %ebp
c0022eeb:	6a 00                	push   $0x0
c0022eed:	68 d9 00 00 00       	push   $0xd9
c0022ef2:	e9 3a f6 ff ff       	jmp    c0022531 <intr_entry>

c0022ef7 <intrda_stub>:
c0022ef7:	55                   	push   %ebp
c0022ef8:	6a 00                	push   $0x0
c0022efa:	68 da 00 00 00       	push   $0xda
c0022eff:	e9 2d f6 ff ff       	jmp    c0022531 <intr_entry>

c0022f04 <intrdb_stub>:
c0022f04:	55                   	push   %ebp
c0022f05:	6a 00                	push   $0x0
c0022f07:	68 db 00 00 00       	push   $0xdb
c0022f0c:	e9 20 f6 ff ff       	jmp    c0022531 <intr_entry>

c0022f11 <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c0022f11:	55                   	push   %ebp
c0022f12:	6a 00                	push   $0x0
c0022f14:	68 dc 00 00 00       	push   $0xdc
c0022f19:	e9 13 f6 ff ff       	jmp    c0022531 <intr_entry>

c0022f1e <intrdd_stub>:
c0022f1e:	55                   	push   %ebp
c0022f1f:	6a 00                	push   $0x0
c0022f21:	68 dd 00 00 00       	push   $0xdd
c0022f26:	e9 06 f6 ff ff       	jmp    c0022531 <intr_entry>

c0022f2b <intrde_stub>:
c0022f2b:	55                   	push   %ebp
c0022f2c:	6a 00                	push   $0x0
c0022f2e:	68 de 00 00 00       	push   $0xde
c0022f33:	e9 f9 f5 ff ff       	jmp    c0022531 <intr_entry>

c0022f38 <intrdf_stub>:
c0022f38:	55                   	push   %ebp
c0022f39:	6a 00                	push   $0x0
c0022f3b:	68 df 00 00 00       	push   $0xdf
c0022f40:	e9 ec f5 ff ff       	jmp    c0022531 <intr_entry>

c0022f45 <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c0022f45:	55                   	push   %ebp
c0022f46:	6a 00                	push   $0x0
c0022f48:	68 e0 00 00 00       	push   $0xe0
c0022f4d:	e9 df f5 ff ff       	jmp    c0022531 <intr_entry>

c0022f52 <intre1_stub>:
c0022f52:	55                   	push   %ebp
c0022f53:	6a 00                	push   $0x0
c0022f55:	68 e1 00 00 00       	push   $0xe1
c0022f5a:	e9 d2 f5 ff ff       	jmp    c0022531 <intr_entry>

c0022f5f <intre2_stub>:
c0022f5f:	55                   	push   %ebp
c0022f60:	6a 00                	push   $0x0
c0022f62:	68 e2 00 00 00       	push   $0xe2
c0022f67:	e9 c5 f5 ff ff       	jmp    c0022531 <intr_entry>

c0022f6c <intre3_stub>:
c0022f6c:	55                   	push   %ebp
c0022f6d:	6a 00                	push   $0x0
c0022f6f:	68 e3 00 00 00       	push   $0xe3
c0022f74:	e9 b8 f5 ff ff       	jmp    c0022531 <intr_entry>

c0022f79 <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c0022f79:	55                   	push   %ebp
c0022f7a:	6a 00                	push   $0x0
c0022f7c:	68 e4 00 00 00       	push   $0xe4
c0022f81:	e9 ab f5 ff ff       	jmp    c0022531 <intr_entry>

c0022f86 <intre5_stub>:
c0022f86:	55                   	push   %ebp
c0022f87:	6a 00                	push   $0x0
c0022f89:	68 e5 00 00 00       	push   $0xe5
c0022f8e:	e9 9e f5 ff ff       	jmp    c0022531 <intr_entry>

c0022f93 <intre6_stub>:
c0022f93:	55                   	push   %ebp
c0022f94:	6a 00                	push   $0x0
c0022f96:	68 e6 00 00 00       	push   $0xe6
c0022f9b:	e9 91 f5 ff ff       	jmp    c0022531 <intr_entry>

c0022fa0 <intre7_stub>:
c0022fa0:	55                   	push   %ebp
c0022fa1:	6a 00                	push   $0x0
c0022fa3:	68 e7 00 00 00       	push   $0xe7
c0022fa8:	e9 84 f5 ff ff       	jmp    c0022531 <intr_entry>

c0022fad <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c0022fad:	55                   	push   %ebp
c0022fae:	6a 00                	push   $0x0
c0022fb0:	68 e8 00 00 00       	push   $0xe8
c0022fb5:	e9 77 f5 ff ff       	jmp    c0022531 <intr_entry>

c0022fba <intre9_stub>:
c0022fba:	55                   	push   %ebp
c0022fbb:	6a 00                	push   $0x0
c0022fbd:	68 e9 00 00 00       	push   $0xe9
c0022fc2:	e9 6a f5 ff ff       	jmp    c0022531 <intr_entry>

c0022fc7 <intrea_stub>:
c0022fc7:	55                   	push   %ebp
c0022fc8:	6a 00                	push   $0x0
c0022fca:	68 ea 00 00 00       	push   $0xea
c0022fcf:	e9 5d f5 ff ff       	jmp    c0022531 <intr_entry>

c0022fd4 <intreb_stub>:
c0022fd4:	55                   	push   %ebp
c0022fd5:	6a 00                	push   $0x0
c0022fd7:	68 eb 00 00 00       	push   $0xeb
c0022fdc:	e9 50 f5 ff ff       	jmp    c0022531 <intr_entry>

c0022fe1 <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c0022fe1:	55                   	push   %ebp
c0022fe2:	6a 00                	push   $0x0
c0022fe4:	68 ec 00 00 00       	push   $0xec
c0022fe9:	e9 43 f5 ff ff       	jmp    c0022531 <intr_entry>

c0022fee <intred_stub>:
c0022fee:	55                   	push   %ebp
c0022fef:	6a 00                	push   $0x0
c0022ff1:	68 ed 00 00 00       	push   $0xed
c0022ff6:	e9 36 f5 ff ff       	jmp    c0022531 <intr_entry>

c0022ffb <intree_stub>:
c0022ffb:	55                   	push   %ebp
c0022ffc:	6a 00                	push   $0x0
c0022ffe:	68 ee 00 00 00       	push   $0xee
c0023003:	e9 29 f5 ff ff       	jmp    c0022531 <intr_entry>

c0023008 <intref_stub>:
c0023008:	55                   	push   %ebp
c0023009:	6a 00                	push   $0x0
c002300b:	68 ef 00 00 00       	push   $0xef
c0023010:	e9 1c f5 ff ff       	jmp    c0022531 <intr_entry>

c0023015 <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c0023015:	55                   	push   %ebp
c0023016:	6a 00                	push   $0x0
c0023018:	68 f0 00 00 00       	push   $0xf0
c002301d:	e9 0f f5 ff ff       	jmp    c0022531 <intr_entry>

c0023022 <intrf1_stub>:
c0023022:	55                   	push   %ebp
c0023023:	6a 00                	push   $0x0
c0023025:	68 f1 00 00 00       	push   $0xf1
c002302a:	e9 02 f5 ff ff       	jmp    c0022531 <intr_entry>

c002302f <intrf2_stub>:
c002302f:	55                   	push   %ebp
c0023030:	6a 00                	push   $0x0
c0023032:	68 f2 00 00 00       	push   $0xf2
c0023037:	e9 f5 f4 ff ff       	jmp    c0022531 <intr_entry>

c002303c <intrf3_stub>:
c002303c:	55                   	push   %ebp
c002303d:	6a 00                	push   $0x0
c002303f:	68 f3 00 00 00       	push   $0xf3
c0023044:	e9 e8 f4 ff ff       	jmp    c0022531 <intr_entry>

c0023049 <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c0023049:	55                   	push   %ebp
c002304a:	6a 00                	push   $0x0
c002304c:	68 f4 00 00 00       	push   $0xf4
c0023051:	e9 db f4 ff ff       	jmp    c0022531 <intr_entry>

c0023056 <intrf5_stub>:
c0023056:	55                   	push   %ebp
c0023057:	6a 00                	push   $0x0
c0023059:	68 f5 00 00 00       	push   $0xf5
c002305e:	e9 ce f4 ff ff       	jmp    c0022531 <intr_entry>

c0023063 <intrf6_stub>:
c0023063:	55                   	push   %ebp
c0023064:	6a 00                	push   $0x0
c0023066:	68 f6 00 00 00       	push   $0xf6
c002306b:	e9 c1 f4 ff ff       	jmp    c0022531 <intr_entry>

c0023070 <intrf7_stub>:
c0023070:	55                   	push   %ebp
c0023071:	6a 00                	push   $0x0
c0023073:	68 f7 00 00 00       	push   $0xf7
c0023078:	e9 b4 f4 ff ff       	jmp    c0022531 <intr_entry>

c002307d <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c002307d:	55                   	push   %ebp
c002307e:	6a 00                	push   $0x0
c0023080:	68 f8 00 00 00       	push   $0xf8
c0023085:	e9 a7 f4 ff ff       	jmp    c0022531 <intr_entry>

c002308a <intrf9_stub>:
c002308a:	55                   	push   %ebp
c002308b:	6a 00                	push   $0x0
c002308d:	68 f9 00 00 00       	push   $0xf9
c0023092:	e9 9a f4 ff ff       	jmp    c0022531 <intr_entry>

c0023097 <intrfa_stub>:
c0023097:	55                   	push   %ebp
c0023098:	6a 00                	push   $0x0
c002309a:	68 fa 00 00 00       	push   $0xfa
c002309f:	e9 8d f4 ff ff       	jmp    c0022531 <intr_entry>

c00230a4 <intrfb_stub>:
c00230a4:	55                   	push   %ebp
c00230a5:	6a 00                	push   $0x0
c00230a7:	68 fb 00 00 00       	push   $0xfb
c00230ac:	e9 80 f4 ff ff       	jmp    c0022531 <intr_entry>

c00230b1 <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c00230b1:	55                   	push   %ebp
c00230b2:	6a 00                	push   $0x0
c00230b4:	68 fc 00 00 00       	push   $0xfc
c00230b9:	e9 73 f4 ff ff       	jmp    c0022531 <intr_entry>

c00230be <intrfd_stub>:
c00230be:	55                   	push   %ebp
c00230bf:	6a 00                	push   $0x0
c00230c1:	68 fd 00 00 00       	push   $0xfd
c00230c6:	e9 66 f4 ff ff       	jmp    c0022531 <intr_entry>

c00230cb <intrfe_stub>:
c00230cb:	55                   	push   %ebp
c00230cc:	6a 00                	push   $0x0
c00230ce:	68 fe 00 00 00       	push   $0xfe
c00230d3:	e9 59 f4 ff ff       	jmp    c0022531 <intr_entry>

c00230d8 <intrff_stub>:
c00230d8:	55                   	push   %ebp
c00230d9:	6a 00                	push   $0x0
c00230db:	68 ff 00 00 00       	push   $0xff
c00230e0:	e9 4c f4 ff ff       	jmp    c0022531 <intr_entry>

c00230e5 <notify_dad>:


/* The thread (with thread_lockers ID : tpos) has had a new donation,
   now it need to pass that back to its father along the chain in the waiting DAG. */
static void notify_dad(struct thread *t)
{
c00230e5:	55                   	push   %ebp
c00230e6:	57                   	push   %edi
c00230e7:	56                   	push   %esi
c00230e8:	53                   	push   %ebx
c00230e9:	83 ec 1c             	sub    $0x1c,%esp
c00230ec:	e8 f5 f3 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00230f1:	81 c3 4b db 01 00    	add    $0x1db4b,%ebx
  if (t == NULL)
c00230f7:	85 c0                	test   %eax,%eax
c00230f9:	0f 84 b2 00 00 00    	je     c00231b1 <notify_dad+0xcc>
    return;
  struct thread *father = t->father;
c00230ff:	8b 40 64             	mov    0x64(%eax),%eax
c0023102:	89 44 24 04          	mov    %eax,0x4(%esp)
  if (father == NULL)
c0023106:	85 c0                	test   %eax,%eax
c0023108:	0f 84 a3 00 00 00    	je     c00231b1 <notify_dad+0xcc>
    return;
  int old_donate = father->max_donate;
c002310e:	8b 48 60             	mov    0x60(%eax),%ecx
c0023111:	89 4c 24 0c          	mov    %ecx,0xc(%esp)

  struct list_elem *el, *ed;
  struct lock *l;
  struct thread *tmp;
  for (el = list_begin(&father->lock_list); el != list_end(&father->lock_list); el = list_next(el))
c0023115:	83 c0 48             	add    $0x48,%eax
c0023118:	89 44 24 08          	mov    %eax,0x8(%esp)
c002311c:	83 ec 0c             	sub    $0xc,%esp
c002311f:	50                   	push   %eax
c0023120:	e8 95 68 00 00       	call   c00299ba <list_begin>
c0023125:	89 c7                	mov    %eax,%edi
c0023127:	83 c4 10             	add    $0x10,%esp
c002312a:	eb 52                	jmp    c002317e <notify_dad+0x99>
  {
    l = list_entry(el, struct lock, elem);
    for (ed = list_begin(&l->donaters); ed != list_end(&l->donaters); ed = list_next(ed))
c002312c:	83 ec 0c             	sub    $0xc,%esp
c002312f:	56                   	push   %esi
c0023130:	e8 ca 68 00 00       	call   c00299ff <list_next>
c0023135:	89 c6                	mov    %eax,%esi
c0023137:	83 c4 10             	add    $0x10,%esp
c002313a:	83 ec 0c             	sub    $0xc,%esp
c002313d:	55                   	push   %ebp
c002313e:	e8 19 69 00 00       	call   c0029a5c <list_end>
c0023143:	83 c4 10             	add    $0x10,%esp
c0023146:	39 f0                	cmp    %esi,%eax
c0023148:	74 17                	je     c0023161 <notify_dad+0x7c>
    {
      tmp = list_entry(ed, struct thread, donate_elem);
      if (tmp->priority + tmp->max_donate - father->priority > l->max_donate)
c002314a:	8b 46 f8             	mov    -0x8(%esi),%eax
c002314d:	03 46 b4             	add    -0x4c(%esi),%eax
c0023150:	8b 54 24 04          	mov    0x4(%esp),%edx
c0023154:	2b 42 1c             	sub    0x1c(%edx),%eax
c0023157:	3b 47 ec             	cmp    -0x14(%edi),%eax
c002315a:	7e d0                	jle    c002312c <notify_dad+0x47>
        l->max_donate = tmp->priority + tmp->max_donate - father->priority;
c002315c:	89 47 ec             	mov    %eax,-0x14(%edi)
c002315f:	eb cb                	jmp    c002312c <notify_dad+0x47>
    }
    if (l->max_donate > father->max_donate)
c0023161:	8b 47 ec             	mov    -0x14(%edi),%eax
c0023164:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0023168:	3b 41 60             	cmp    0x60(%ecx),%eax
c002316b:	7e 03                	jle    c0023170 <notify_dad+0x8b>
      father->max_donate = l->max_donate;
c002316d:	89 41 60             	mov    %eax,0x60(%ecx)
  for (el = list_begin(&father->lock_list); el != list_end(&father->lock_list); el = list_next(el))
c0023170:	83 ec 0c             	sub    $0xc,%esp
c0023173:	57                   	push   %edi
c0023174:	e8 86 68 00 00       	call   c00299ff <list_next>
c0023179:	89 c7                	mov    %eax,%edi
c002317b:	83 c4 10             	add    $0x10,%esp
c002317e:	83 ec 0c             	sub    $0xc,%esp
c0023181:	ff 74 24 14          	pushl  0x14(%esp)
c0023185:	e8 d2 68 00 00       	call   c0029a5c <list_end>
c002318a:	83 c4 10             	add    $0x10,%esp
c002318d:	39 f8                	cmp    %edi,%eax
c002318f:	74 13                	je     c00231a4 <notify_dad+0xbf>
    for (ed = list_begin(&l->donaters); ed != list_end(&l->donaters); ed = list_next(ed))
c0023191:	8d 6f f0             	lea    -0x10(%edi),%ebp
c0023194:	83 ec 0c             	sub    $0xc,%esp
c0023197:	55                   	push   %ebp
c0023198:	e8 1d 68 00 00       	call   c00299ba <list_begin>
c002319d:	89 c6                	mov    %eax,%esi
c002319f:	83 c4 10             	add    $0x10,%esp
c00231a2:	eb 96                	jmp    c002313a <notify_dad+0x55>
  }
  if (father->max_donate != old_donate)
c00231a4:	8b 44 24 04          	mov    0x4(%esp),%eax
c00231a8:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c00231ac:	39 48 60             	cmp    %ecx,0x60(%eax)
c00231af:	75 08                	jne    c00231b9 <notify_dad+0xd4>
    notify_dad(father);
c00231b1:	83 c4 1c             	add    $0x1c,%esp
c00231b4:	5b                   	pop    %ebx
c00231b5:	5e                   	pop    %esi
c00231b6:	5f                   	pop    %edi
c00231b7:	5d                   	pop    %ebp
c00231b8:	c3                   	ret    
    notify_dad(father);
c00231b9:	e8 27 ff ff ff       	call   c00230e5 <notify_dad>
c00231be:	eb f1                	jmp    c00231b1 <notify_dad+0xcc>

c00231c0 <sema_init>:
{
c00231c0:	53                   	push   %ebx
c00231c1:	83 ec 08             	sub    $0x8,%esp
c00231c4:	e8 1d f3 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00231c9:	81 c3 73 da 01 00    	add    $0x1da73,%ebx
c00231cf:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(sema != NULL);
c00231d3:	85 c0                	test   %eax,%eax
c00231d5:	74 17                	je     c00231ee <sema_init+0x2e>
  sema->value = value;
c00231d7:	8b 54 24 14          	mov    0x14(%esp),%edx
c00231db:	89 10                	mov    %edx,(%eax)
  list_init(&sema->waiters);
c00231dd:	83 ec 0c             	sub    $0xc,%esp
c00231e0:	83 c0 04             	add    $0x4,%eax
c00231e3:	50                   	push   %eax
c00231e4:	e8 79 67 00 00       	call   c0029962 <list_init>
}
c00231e9:	83 c4 18             	add    $0x18,%esp
c00231ec:	5b                   	pop    %ebx
c00231ed:	c3                   	ret    
  ASSERT(sema != NULL);
c00231ee:	83 ec 0c             	sub    $0xc,%esp
c00231f1:	8d 83 2a 38 ff ff    	lea    -0xc7d6(%ebx),%eax
c00231f7:	50                   	push   %eax
c00231f8:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00231fe:	50                   	push   %eax
c00231ff:	8d 83 ac 1b ff ff    	lea    -0xe454(%ebx),%eax
c0023205:	50                   	push   %eax
c0023206:	6a 30                	push   $0x30
c0023208:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c002320e:	50                   	push   %eax
c002320f:	e8 81 66 00 00       	call   c0029895 <debug_panic>

c0023214 <sema_down>:
{
c0023214:	55                   	push   %ebp
c0023215:	57                   	push   %edi
c0023216:	56                   	push   %esi
c0023217:	53                   	push   %ebx
c0023218:	83 ec 0c             	sub    $0xc,%esp
c002321b:	e8 c6 f2 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0023220:	81 c3 1c da 01 00    	add    $0x1da1c,%ebx
c0023226:	8b 74 24 20          	mov    0x20(%esp),%esi
  ASSERT(sema != NULL);
c002322a:	85 f6                	test   %esi,%esi
c002322c:	74 4f                	je     c002327d <sema_down+0x69>
  ASSERT(!intr_context());
c002322e:	e8 1c f0 ff ff       	call   c002224f <intr_context>
c0023233:	84 c0                	test   %al,%al
c0023235:	75 6c                	jne    c00232a3 <sema_down+0x8f>
  old_level = intr_disable();
c0023237:	e8 6f ed ff ff       	call   c0021fab <intr_disable>
c002323c:	89 c5                	mov    %eax,%ebp
  while (sema->value == 0)
c002323e:	8b 06                	mov    (%esi),%eax
c0023240:	85 c0                	test   %eax,%eax
c0023242:	75 23                	jne    c0023267 <sema_down+0x53>
    list_push_back(&sema->waiters, &thread_current()->elem);
c0023244:	8d 7e 04             	lea    0x4(%esi),%edi
c0023247:	e8 f9 dd ff ff       	call   c0021045 <thread_current>
c002324c:	83 ec 08             	sub    $0x8,%esp
c002324f:	83 c0 28             	add    $0x28,%eax
c0023252:	50                   	push   %eax
c0023253:	57                   	push   %edi
c0023254:	e8 ef 6c 00 00       	call   c0029f48 <list_push_back>
    thread_block();
c0023259:	e8 5c e3 ff ff       	call   c00215ba <thread_block>
  while (sema->value == 0)
c002325e:	8b 06                	mov    (%esi),%eax
c0023260:	83 c4 10             	add    $0x10,%esp
c0023263:	85 c0                	test   %eax,%eax
c0023265:	74 e0                	je     c0023247 <sema_down+0x33>
  sema->value--;
c0023267:	83 e8 01             	sub    $0x1,%eax
c002326a:	89 06                	mov    %eax,(%esi)
  intr_set_level(old_level);
c002326c:	83 ec 0c             	sub    $0xc,%esp
c002326f:	55                   	push   %ebp
c0023270:	e8 3d ed ff ff       	call   c0021fb2 <intr_set_level>
}
c0023275:	83 c4 1c             	add    $0x1c,%esp
c0023278:	5b                   	pop    %ebx
c0023279:	5e                   	pop    %esi
c002327a:	5f                   	pop    %edi
c002327b:	5d                   	pop    %ebp
c002327c:	c3                   	ret    
  ASSERT(sema != NULL);
c002327d:	83 ec 0c             	sub    $0xc,%esp
c0023280:	8d 83 2a 38 ff ff    	lea    -0xc7d6(%ebx),%eax
c0023286:	50                   	push   %eax
c0023287:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002328d:	50                   	push   %eax
c002328e:	8d 83 a0 1b ff ff    	lea    -0xe460(%ebx),%eax
c0023294:	50                   	push   %eax
c0023295:	6a 41                	push   $0x41
c0023297:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c002329d:	50                   	push   %eax
c002329e:	e8 f2 65 00 00       	call   c0029895 <debug_panic>
  ASSERT(!intr_context());
c00232a3:	83 ec 0c             	sub    $0xc,%esp
c00232a6:	8d 83 ce 33 ff ff    	lea    -0xcc32(%ebx),%eax
c00232ac:	50                   	push   %eax
c00232ad:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00232b3:	50                   	push   %eax
c00232b4:	8d 83 a0 1b ff ff    	lea    -0xe460(%ebx),%eax
c00232ba:	50                   	push   %eax
c00232bb:	6a 42                	push   $0x42
c00232bd:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c00232c3:	50                   	push   %eax
c00232c4:	e8 cc 65 00 00       	call   c0029895 <debug_panic>

c00232c9 <sema_try_down>:
{
c00232c9:	57                   	push   %edi
c00232ca:	56                   	push   %esi
c00232cb:	53                   	push   %ebx
c00232cc:	e8 15 f2 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00232d1:	81 c3 6b d9 01 00    	add    $0x1d96b,%ebx
c00232d7:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT(sema != NULL);
c00232db:	85 f6                	test   %esi,%esi
c00232dd:	74 2c                	je     c002330b <sema_try_down+0x42>
  old_level = intr_disable();
c00232df:	e8 c7 ec ff ff       	call   c0021fab <intr_disable>
  if (sema->value > 0)
c00232e4:	8b 16                	mov    (%esi),%edx
    success = false;
c00232e6:	bf 00 00 00 00       	mov    $0x0,%edi
  if (sema->value > 0)
c00232eb:	85 d2                	test   %edx,%edx
c00232ed:	74 0a                	je     c00232f9 <sema_try_down+0x30>
    sema->value--;
c00232ef:	83 ea 01             	sub    $0x1,%edx
c00232f2:	89 16                	mov    %edx,(%esi)
    success = true;
c00232f4:	bf 01 00 00 00       	mov    $0x1,%edi
  intr_set_level(old_level);
c00232f9:	83 ec 0c             	sub    $0xc,%esp
c00232fc:	50                   	push   %eax
c00232fd:	e8 b0 ec ff ff       	call   c0021fb2 <intr_set_level>
  return success;
c0023302:	83 c4 10             	add    $0x10,%esp
}
c0023305:	89 f8                	mov    %edi,%eax
c0023307:	5b                   	pop    %ebx
c0023308:	5e                   	pop    %esi
c0023309:	5f                   	pop    %edi
c002330a:	c3                   	ret    
  ASSERT(sema != NULL);
c002330b:	83 ec 0c             	sub    $0xc,%esp
c002330e:	8d 83 2a 38 ff ff    	lea    -0xc7d6(%ebx),%eax
c0023314:	50                   	push   %eax
c0023315:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002331b:	50                   	push   %eax
c002331c:	8d 83 90 1b ff ff    	lea    -0xe470(%ebx),%eax
c0023322:	50                   	push   %eax
c0023323:	6a 58                	push   $0x58
c0023325:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c002332b:	50                   	push   %eax
c002332c:	e8 64 65 00 00       	call   c0029895 <debug_panic>

c0023331 <sema_up>:
{
c0023331:	55                   	push   %ebp
c0023332:	57                   	push   %edi
c0023333:	56                   	push   %esi
c0023334:	53                   	push   %ebx
c0023335:	83 ec 1c             	sub    $0x1c,%esp
c0023338:	e8 a9 f1 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002333d:	81 c3 ff d8 01 00    	add    $0x1d8ff,%ebx
c0023343:	8b 74 24 30          	mov    0x30(%esp),%esi
  ASSERT(sema != NULL);
c0023347:	85 f6                	test   %esi,%esi
c0023349:	74 33                	je     c002337e <sema_up+0x4d>
  sema->value++;
c002334b:	83 06 01             	addl   $0x1,(%esi)
  old_level = intr_disable();
c002334e:	e8 58 ec ff ff       	call   c0021fab <intr_disable>
c0023353:	89 44 24 08          	mov    %eax,0x8(%esp)
  if (!list_empty(&sema->waiters))
c0023357:	83 c6 04             	add    $0x4,%esi
c002335a:	83 ec 0c             	sub    $0xc,%esp
c002335d:	56                   	push   %esi
c002335e:	e8 a4 6c 00 00       	call   c002a007 <list_empty>
c0023363:	83 c4 10             	add    $0x10,%esp
c0023366:	84 c0                	test   %al,%al
c0023368:	74 3a                	je     c00233a4 <sema_up+0x73>
  intr_set_level(old_level);
c002336a:	83 ec 0c             	sub    $0xc,%esp
c002336d:	ff 74 24 14          	pushl  0x14(%esp)
c0023371:	e8 3c ec ff ff       	call   c0021fb2 <intr_set_level>
}
c0023376:	83 c4 2c             	add    $0x2c,%esp
c0023379:	5b                   	pop    %ebx
c002337a:	5e                   	pop    %esi
c002337b:	5f                   	pop    %edi
c002337c:	5d                   	pop    %ebp
c002337d:	c3                   	ret    
  ASSERT(sema != NULL);
c002337e:	83 ec 0c             	sub    $0xc,%esp
c0023381:	8d 83 2a 38 ff ff    	lea    -0xc7d6(%ebx),%eax
c0023387:	50                   	push   %eax
c0023388:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002338e:	50                   	push   %eax
c002338f:	8d 83 88 1b ff ff    	lea    -0xe478(%ebx),%eax
c0023395:	50                   	push   %eax
c0023396:	6a 6f                	push   $0x6f
c0023398:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c002339e:	50                   	push   %eax
c002339f:	e8 f1 64 00 00       	call   c0029895 <debug_panic>
    struct thread *t = list_entry(list_pop_front(&sema->waiters), struct thread, elem);
c00233a4:	83 ec 0c             	sub    $0xc,%esp
c00233a7:	56                   	push   %esi
c00233a8:	e8 d1 6c 00 00       	call   c002a07e <list_pop_front>
c00233ad:	89 c7                	mov    %eax,%edi
c00233af:	8d 68 d8             	lea    -0x28(%eax),%ebp
    int max = thread_get_certain_priority(t);
c00233b2:	89 2c 24             	mov    %ebp,(%esp)
c00233b5:	e8 2b de ff ff       	call   c00211e5 <thread_get_certain_priority>
c00233ba:	89 44 24 14          	mov    %eax,0x14(%esp)
    list_push_back(&sema->waiters, &t->elem);
c00233be:	83 c4 08             	add    $0x8,%esp
c00233c1:	57                   	push   %edi
c00233c2:	56                   	push   %esi
c00233c3:	e8 80 6b 00 00       	call   c0029f48 <list_push_back>
c00233c8:	83 c4 10             	add    $0x10,%esp
    struct thread *t_max = t;
c00233cb:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
      t_tmp = list_entry(list_pop_front(&sema->waiters), struct thread, elem);
c00233cf:	83 ec 0c             	sub    $0xc,%esp
c00233d2:	56                   	push   %esi
c00233d3:	e8 a6 6c 00 00       	call   c002a07e <list_pop_front>
c00233d8:	8d 78 d8             	lea    -0x28(%eax),%edi
      list_push_back(&sema->waiters, &t_tmp->elem);
c00233db:	83 c4 08             	add    $0x8,%esp
c00233de:	50                   	push   %eax
c00233df:	56                   	push   %esi
c00233e0:	e8 63 6b 00 00       	call   c0029f48 <list_push_back>
      if (t_tmp == t)
c00233e5:	83 c4 10             	add    $0x10,%esp
c00233e8:	39 fd                	cmp    %edi,%ebp
c00233ea:	74 1c                	je     c0023408 <sema_up+0xd7>
      tmp = thread_get_certain_priority(t_tmp);
c00233ec:	83 ec 0c             	sub    $0xc,%esp
c00233ef:	57                   	push   %edi
c00233f0:	e8 f0 dd ff ff       	call   c00211e5 <thread_get_certain_priority>
      if (tmp > max)
c00233f5:	83 c4 10             	add    $0x10,%esp
c00233f8:	39 44 24 04          	cmp    %eax,0x4(%esp)
c00233fc:	7d d1                	jge    c00233cf <sema_up+0x9e>
        t_max = t_tmp;
c00233fe:	89 7c 24 0c          	mov    %edi,0xc(%esp)
        max = tmp;
c0023402:	89 44 24 04          	mov    %eax,0x4(%esp)
c0023406:	eb c7                	jmp    c00233cf <sema_up+0x9e>
c0023408:	8b 7c 24 0c          	mov    0xc(%esp),%edi
      t_tmp = list_entry(list_pop_front(&sema->waiters), struct thread, elem);
c002340c:	83 ec 0c             	sub    $0xc,%esp
c002340f:	56                   	push   %esi
c0023410:	e8 69 6c 00 00       	call   c002a07e <list_pop_front>
c0023415:	8d 50 d8             	lea    -0x28(%eax),%edx
      if (t_tmp == t_max)
c0023418:	83 c4 10             	add    $0x10,%esp
c002341b:	39 d7                	cmp    %edx,%edi
c002341d:	74 0f                	je     c002342e <sema_up+0xfd>
      list_push_back(&sema->waiters, &t_tmp->elem);
c002341f:	83 ec 08             	sub    $0x8,%esp
c0023422:	50                   	push   %eax
c0023423:	56                   	push   %esi
c0023424:	e8 1f 6b 00 00       	call   c0029f48 <list_push_back>
      t_tmp = list_entry(list_pop_front(&sema->waiters), struct thread, elem);
c0023429:	83 c4 10             	add    $0x10,%esp
c002342c:	eb de                	jmp    c002340c <sema_up+0xdb>
    thread_unblock(t_tmp);
c002342e:	83 ec 0c             	sub    $0xc,%esp
c0023431:	57                   	push   %edi
c0023432:	e8 2f db ff ff       	call   c0020f66 <thread_unblock>
    thread_revolt();
c0023437:	e8 59 e4 ff ff       	call   c0021895 <thread_revolt>
c002343c:	83 c4 10             	add    $0x10,%esp
c002343f:	e9 26 ff ff ff       	jmp    c002336a <sema_up+0x39>

c0023444 <sema_test_helper>:
{
c0023444:	57                   	push   %edi
c0023445:	56                   	push   %esi
c0023446:	53                   	push   %ebx
c0023447:	8b 74 24 10          	mov    0x10(%esp),%esi
c002344b:	bb 0a 00 00 00       	mov    $0xa,%ebx
    sema_up(&sema[1]);
c0023450:	8d 7e 14             	lea    0x14(%esi),%edi
    sema_down(&sema[0]);
c0023453:	83 ec 0c             	sub    $0xc,%esp
c0023456:	56                   	push   %esi
c0023457:	e8 b8 fd ff ff       	call   c0023214 <sema_down>
    sema_up(&sema[1]);
c002345c:	89 3c 24             	mov    %edi,(%esp)
c002345f:	e8 cd fe ff ff       	call   c0023331 <sema_up>
  for (i = 0; i < 10; i++)
c0023464:	83 c4 10             	add    $0x10,%esp
c0023467:	83 eb 01             	sub    $0x1,%ebx
c002346a:	75 e7                	jne    c0023453 <sema_test_helper+0xf>
}
c002346c:	5b                   	pop    %ebx
c002346d:	5e                   	pop    %esi
c002346e:	5f                   	pop    %edi
c002346f:	c3                   	ret    

c0023470 <sema_self_test>:
{
c0023470:	55                   	push   %ebp
c0023471:	57                   	push   %edi
c0023472:	56                   	push   %esi
c0023473:	53                   	push   %ebx
c0023474:	83 ec 48             	sub    $0x48,%esp
c0023477:	e8 6a f0 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002347c:	81 c3 c0 d7 01 00    	add    $0x1d7c0,%ebx
  printf("Testing semaphores...");
c0023482:	8d 83 4d 38 ff ff    	lea    -0xc7b3(%ebx),%eax
c0023488:	50                   	push   %eax
c0023489:	e8 70 46 00 00       	call   c0027afe <printf>
  sema_init(&sema[0], 0);
c002348e:	83 c4 08             	add    $0x8,%esp
c0023491:	6a 00                	push   $0x0
c0023493:	8d 74 24 14          	lea    0x14(%esp),%esi
c0023497:	56                   	push   %esi
c0023498:	e8 23 fd ff ff       	call   c00231c0 <sema_init>
  sema_init(&sema[1], 0);
c002349d:	83 c4 08             	add    $0x8,%esp
c00234a0:	6a 00                	push   $0x0
c00234a2:	8d 44 24 28          	lea    0x28(%esp),%eax
c00234a6:	50                   	push   %eax
c00234a7:	e8 14 fd ff ff       	call   c00231c0 <sema_init>
  thread_create("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c00234ac:	56                   	push   %esi
c00234ad:	8d 83 08 28 fe ff    	lea    -0x1d7f8(%ebx),%eax
c00234b3:	50                   	push   %eax
c00234b4:	6a 1f                	push   $0x1f
c00234b6:	8d 83 63 38 ff ff    	lea    -0xc79d(%ebx),%eax
c00234bc:	50                   	push   %eax
c00234bd:	e8 3b e4 ff ff       	call   c00218fd <thread_create>
c00234c2:	83 c4 20             	add    $0x20,%esp
c00234c5:	be 0a 00 00 00       	mov    $0xa,%esi
    sema_up(&sema[0]);
c00234ca:	8d 6c 24 08          	lea    0x8(%esp),%ebp
    sema_down(&sema[1]);
c00234ce:	8d 7c 24 1c          	lea    0x1c(%esp),%edi
    sema_up(&sema[0]);
c00234d2:	83 ec 0c             	sub    $0xc,%esp
c00234d5:	55                   	push   %ebp
c00234d6:	e8 56 fe ff ff       	call   c0023331 <sema_up>
    sema_down(&sema[1]);
c00234db:	89 3c 24             	mov    %edi,(%esp)
c00234de:	e8 31 fd ff ff       	call   c0023214 <sema_down>
  for (i = 0; i < 10; i++)
c00234e3:	83 c4 10             	add    $0x10,%esp
c00234e6:	83 ee 01             	sub    $0x1,%esi
c00234e9:	75 e7                	jne    c00234d2 <sema_self_test+0x62>
  printf("done.\n");
c00234eb:	83 ec 0c             	sub    $0xc,%esp
c00234ee:	8d 83 6d 38 ff ff    	lea    -0xc793(%ebx),%eax
c00234f4:	50                   	push   %eax
c00234f5:	e8 74 83 00 00       	call   c002b86e <puts>
}
c00234fa:	83 c4 4c             	add    $0x4c,%esp
c00234fd:	5b                   	pop    %ebx
c00234fe:	5e                   	pop    %esi
c00234ff:	5f                   	pop    %edi
c0023500:	5d                   	pop    %ebp
c0023501:	c3                   	ret    

c0023502 <lock_init>:
{
c0023502:	56                   	push   %esi
c0023503:	53                   	push   %ebx
c0023504:	83 ec 04             	sub    $0x4,%esp
c0023507:	e8 da ef 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002350c:	81 c3 30 d7 01 00    	add    $0x1d730,%ebx
c0023512:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT(lock != NULL);
c0023516:	85 f6                	test   %esi,%esi
c0023518:	74 2c                	je     c0023546 <lock_init+0x44>
  lock->holder = NULL;
c002351a:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  sema_init(&lock->semaphore, 1);
c0023520:	83 ec 08             	sub    $0x8,%esp
c0023523:	6a 01                	push   $0x1
c0023525:	8d 46 04             	lea    0x4(%esi),%eax
c0023528:	50                   	push   %eax
c0023529:	e8 92 fc ff ff       	call   c00231c0 <sema_init>
  lock->max_donate = 0;
c002352e:	c7 46 18 00 00 00 00 	movl   $0x0,0x18(%esi)
  list_init(&lock->donaters);
c0023535:	83 c6 1c             	add    $0x1c,%esi
c0023538:	89 34 24             	mov    %esi,(%esp)
c002353b:	e8 22 64 00 00       	call   c0029962 <list_init>
}
c0023540:	83 c4 14             	add    $0x14,%esp
c0023543:	5b                   	pop    %ebx
c0023544:	5e                   	pop    %esi
c0023545:	c3                   	ret    
  ASSERT(lock != NULL);
c0023546:	83 ec 0c             	sub    $0xc,%esp
c0023549:	8d 83 d0 56 ff ff    	lea    -0xa930(%ebx),%eax
c002354f:	50                   	push   %eax
c0023550:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023556:	50                   	push   %eax
c0023557:	8d 83 7c 1b ff ff    	lea    -0xe484(%ebx),%eax
c002355d:	50                   	push   %eax
c002355e:	68 cf 00 00 00       	push   $0xcf
c0023563:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023569:	50                   	push   %eax
c002356a:	e8 26 63 00 00       	call   c0029895 <debug_panic>

c002356f <lock_held_by_current_thread>:
{
c002356f:	56                   	push   %esi
c0023570:	53                   	push   %ebx
c0023571:	83 ec 04             	sub    $0x4,%esp
c0023574:	e8 6d ef 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0023579:	81 c3 c3 d6 01 00    	add    $0x1d6c3,%ebx
c002357f:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(lock != NULL);
c0023583:	85 c0                	test   %eax,%eax
c0023585:	74 12                	je     c0023599 <lock_held_by_current_thread+0x2a>
  return lock->holder == thread_current();
c0023587:	8b 30                	mov    (%eax),%esi
c0023589:	e8 b7 da ff ff       	call   c0021045 <thread_current>
c002358e:	39 c6                	cmp    %eax,%esi
c0023590:	0f 94 c0             	sete   %al
}
c0023593:	83 c4 04             	add    $0x4,%esp
c0023596:	5b                   	pop    %ebx
c0023597:	5e                   	pop    %esi
c0023598:	c3                   	ret    
  ASSERT(lock != NULL);
c0023599:	83 ec 0c             	sub    $0xc,%esp
c002359c:	8d 83 d0 56 ff ff    	lea    -0xa930(%ebx),%eax
c00235a2:	50                   	push   %eax
c00235a3:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00235a9:	50                   	push   %eax
c00235aa:	8d 83 2c 1b ff ff    	lea    -0xe4d4(%ebx),%eax
c00235b0:	50                   	push   %eax
c00235b1:	68 4d 01 00 00       	push   $0x14d
c00235b6:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c00235bc:	50                   	push   %eax
c00235bd:	e8 d3 62 00 00       	call   c0029895 <debug_panic>

c00235c2 <lock_acquire>:
{
c00235c2:	57                   	push   %edi
c00235c3:	56                   	push   %esi
c00235c4:	53                   	push   %ebx
c00235c5:	e8 1c ef 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00235ca:	81 c3 72 d6 01 00    	add    $0x1d672,%ebx
c00235d0:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT(lock != NULL);
c00235d4:	85 f6                	test   %esi,%esi
c00235d6:	74 5c                	je     c0023634 <lock_acquire+0x72>
  ASSERT(!intr_context());
c00235d8:	e8 72 ec ff ff       	call   c002224f <intr_context>
c00235dd:	84 c0                	test   %al,%al
c00235df:	75 7c                	jne    c002365d <lock_acquire+0x9b>
  ASSERT(!lock_held_by_current_thread(lock));
c00235e1:	83 ec 0c             	sub    $0xc,%esp
c00235e4:	56                   	push   %esi
c00235e5:	e8 85 ff ff ff       	call   c002356f <lock_held_by_current_thread>
c00235ea:	83 c4 10             	add    $0x10,%esp
c00235ed:	84 c0                	test   %al,%al
c00235ef:	0f 85 91 00 00 00    	jne    c0023686 <lock_acquire+0xc4>
  if (lock->holder != NULL && thread_get_priority() > lock->holder->priority)
c00235f5:	83 3e 00             	cmpl   $0x0,(%esi)
c00235f8:	74 10                	je     c002360a <lock_acquire+0x48>
c00235fa:	e8 39 dc ff ff       	call   c0021238 <thread_get_priority>
c00235ff:	8b 16                	mov    (%esi),%edx
c0023601:	3b 42 1c             	cmp    0x1c(%edx),%eax
c0023604:	0f 8f a5 00 00 00    	jg     c00236af <lock_acquire+0xed>
  sema_down(&lock->semaphore);
c002360a:	83 ec 0c             	sub    $0xc,%esp
c002360d:	8d 46 04             	lea    0x4(%esi),%eax
c0023610:	50                   	push   %eax
c0023611:	e8 fe fb ff ff       	call   c0023214 <sema_down>
  lock->holder = thread_current();
c0023616:	e8 2a da ff ff       	call   c0021045 <thread_current>
c002361b:	89 06                	mov    %eax,(%esi)
  list_push_back(&lock->holder->lock_list, &lock->elem);
c002361d:	83 c4 08             	add    $0x8,%esp
c0023620:	83 c6 2c             	add    $0x2c,%esi
c0023623:	56                   	push   %esi
c0023624:	83 c0 48             	add    $0x48,%eax
c0023627:	50                   	push   %eax
c0023628:	e8 1b 69 00 00       	call   c0029f48 <list_push_back>
}
c002362d:	83 c4 10             	add    $0x10,%esp
c0023630:	5b                   	pop    %ebx
c0023631:	5e                   	pop    %esi
c0023632:	5f                   	pop    %edi
c0023633:	c3                   	ret    
  ASSERT(lock != NULL);
c0023634:	83 ec 0c             	sub    $0xc,%esp
c0023637:	8d 83 d0 56 ff ff    	lea    -0xa930(%ebx),%eax
c002363d:	50                   	push   %eax
c002363e:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023644:	50                   	push   %eax
c0023645:	8d 83 6c 1b ff ff    	lea    -0xe494(%ebx),%eax
c002364b:	50                   	push   %eax
c002364c:	68 e2 00 00 00       	push   $0xe2
c0023651:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023657:	50                   	push   %eax
c0023658:	e8 38 62 00 00       	call   c0029895 <debug_panic>
  ASSERT(!intr_context());
c002365d:	83 ec 0c             	sub    $0xc,%esp
c0023660:	8d 83 ce 33 ff ff    	lea    -0xcc32(%ebx),%eax
c0023666:	50                   	push   %eax
c0023667:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002366d:	50                   	push   %eax
c002366e:	8d 83 6c 1b ff ff    	lea    -0xe494(%ebx),%eax
c0023674:	50                   	push   %eax
c0023675:	68 e3 00 00 00       	push   $0xe3
c002367a:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023680:	50                   	push   %eax
c0023681:	e8 0f 62 00 00       	call   c0029895 <debug_panic>
  ASSERT(!lock_held_by_current_thread(lock));
c0023686:	83 ec 0c             	sub    $0xc,%esp
c0023689:	8d 83 80 38 ff ff    	lea    -0xc780(%ebx),%eax
c002368f:	50                   	push   %eax
c0023690:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023696:	50                   	push   %eax
c0023697:	8d 83 6c 1b ff ff    	lea    -0xe494(%ebx),%eax
c002369d:	50                   	push   %eax
c002369e:	68 e4 00 00 00       	push   $0xe4
c00236a3:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c00236a9:	50                   	push   %eax
c00236aa:	e8 e6 61 00 00       	call   c0029895 <debug_panic>
    int delta = thread_get_priority() - lock->holder->priority;
c00236af:	e8 84 db ff ff       	call   c0021238 <thread_get_priority>
c00236b4:	8b 16                	mov    (%esi),%edx
c00236b6:	2b 42 1c             	sub    0x1c(%edx),%eax
c00236b9:	89 c7                	mov    %eax,%edi
    struct thread *t = thread_current();
c00236bb:	e8 85 d9 ff ff       	call   c0021045 <thread_current>
    t->father = lock->holder;
c00236c0:	8b 16                	mov    (%esi),%edx
c00236c2:	89 50 64             	mov    %edx,0x64(%eax)
    list_push_back(&lock->donaters, &t->donate_elem);
c00236c5:	83 ec 08             	sub    $0x8,%esp
c00236c8:	83 c0 68             	add    $0x68,%eax
c00236cb:	50                   	push   %eax
c00236cc:	8d 46 1c             	lea    0x1c(%esi),%eax
c00236cf:	50                   	push   %eax
c00236d0:	e8 73 68 00 00       	call   c0029f48 <list_push_back>
    if (delta > lock->max_donate)
c00236d5:	83 c4 10             	add    $0x10,%esp
c00236d8:	39 7e 18             	cmp    %edi,0x18(%esi)
c00236db:	7d 03                	jge    c00236e0 <lock_acquire+0x11e>
      lock->max_donate = delta;
c00236dd:	89 7e 18             	mov    %edi,0x18(%esi)
    if (delta > lock->holder->max_donate)
c00236e0:	8b 06                	mov    (%esi),%eax
c00236e2:	39 78 60             	cmp    %edi,0x60(%eax)
c00236e5:	0f 8d 1f ff ff ff    	jge    c002360a <lock_acquire+0x48>
      lock->holder->max_donate = delta;
c00236eb:	89 78 60             	mov    %edi,0x60(%eax)
      notify_dad(lock->holder);
c00236ee:	8b 06                	mov    (%esi),%eax
c00236f0:	e8 f0 f9 ff ff       	call   c00230e5 <notify_dad>
c00236f5:	e9 10 ff ff ff       	jmp    c002360a <lock_acquire+0x48>

c00236fa <lock_try_acquire>:
{
c00236fa:	57                   	push   %edi
c00236fb:	56                   	push   %esi
c00236fc:	53                   	push   %ebx
c00236fd:	e8 e4 ed 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0023702:	81 c3 3a d5 01 00    	add    $0x1d53a,%ebx
c0023708:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT(lock != NULL);
c002370c:	85 f6                	test   %esi,%esi
c002370e:	74 2b                	je     c002373b <lock_try_acquire+0x41>
  ASSERT(!lock_held_by_current_thread(lock));
c0023710:	83 ec 0c             	sub    $0xc,%esp
c0023713:	56                   	push   %esi
c0023714:	e8 56 fe ff ff       	call   c002356f <lock_held_by_current_thread>
c0023719:	83 c4 10             	add    $0x10,%esp
c002371c:	84 c0                	test   %al,%al
c002371e:	75 44                	jne    c0023764 <lock_try_acquire+0x6a>
  success = sema_try_down(&lock->semaphore);
c0023720:	83 ec 0c             	sub    $0xc,%esp
c0023723:	8d 46 04             	lea    0x4(%esi),%eax
c0023726:	50                   	push   %eax
c0023727:	e8 9d fb ff ff       	call   c00232c9 <sema_try_down>
c002372c:	89 c7                	mov    %eax,%edi
  if (success)
c002372e:	83 c4 10             	add    $0x10,%esp
c0023731:	84 c0                	test   %al,%al
c0023733:	75 58                	jne    c002378d <lock_try_acquire+0x93>
}
c0023735:	89 f8                	mov    %edi,%eax
c0023737:	5b                   	pop    %ebx
c0023738:	5e                   	pop    %esi
c0023739:	5f                   	pop    %edi
c002373a:	c3                   	ret    
  ASSERT(lock != NULL);
c002373b:	83 ec 0c             	sub    $0xc,%esp
c002373e:	8d 83 d0 56 ff ff    	lea    -0xa930(%ebx),%eax
c0023744:	50                   	push   %eax
c0023745:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002374b:	50                   	push   %eax
c002374c:	8d 83 58 1b ff ff    	lea    -0xe4a8(%ebx),%eax
c0023752:	50                   	push   %eax
c0023753:	68 0c 01 00 00       	push   $0x10c
c0023758:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c002375e:	50                   	push   %eax
c002375f:	e8 31 61 00 00       	call   c0029895 <debug_panic>
  ASSERT(!lock_held_by_current_thread(lock));
c0023764:	83 ec 0c             	sub    $0xc,%esp
c0023767:	8d 83 80 38 ff ff    	lea    -0xc780(%ebx),%eax
c002376d:	50                   	push   %eax
c002376e:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023774:	50                   	push   %eax
c0023775:	8d 83 58 1b ff ff    	lea    -0xe4a8(%ebx),%eax
c002377b:	50                   	push   %eax
c002377c:	68 0d 01 00 00       	push   $0x10d
c0023781:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023787:	50                   	push   %eax
c0023788:	e8 08 61 00 00       	call   c0029895 <debug_panic>
    lock->holder = thread_current();
c002378d:	e8 b3 d8 ff ff       	call   c0021045 <thread_current>
c0023792:	89 06                	mov    %eax,(%esi)
  return success;
c0023794:	eb 9f                	jmp    c0023735 <lock_try_acquire+0x3b>

c0023796 <lock_release>:
{
c0023796:	55                   	push   %ebp
c0023797:	57                   	push   %edi
c0023798:	56                   	push   %esi
c0023799:	53                   	push   %ebx
c002379a:	83 ec 1c             	sub    $0x1c,%esp
c002379d:	e8 44 ed 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00237a2:	81 c3 9a d4 01 00    	add    $0x1d49a,%ebx
  ASSERT(lock != NULL);
c00237a8:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c00237ad:	74 2c                	je     c00237db <lock_release+0x45>
  ASSERT(lock_held_by_current_thread(lock));
c00237af:	83 ec 0c             	sub    $0xc,%esp
c00237b2:	ff 74 24 3c          	pushl  0x3c(%esp)
c00237b6:	e8 b4 fd ff ff       	call   c002356f <lock_held_by_current_thread>
c00237bb:	83 c4 10             	add    $0x10,%esp
c00237be:	84 c0                	test   %al,%al
c00237c0:	74 42                	je     c0023804 <lock_release+0x6e>
  struct thread *t = lock->holder;
c00237c2:	8b 44 24 30          	mov    0x30(%esp),%eax
c00237c6:	8b 28                	mov    (%eax),%ebp
  for (e = list_begin(&lock->donaters); e != list_end(&lock->donaters); e = list_next(e))
c00237c8:	8d 78 1c             	lea    0x1c(%eax),%edi
c00237cb:	83 ec 0c             	sub    $0xc,%esp
c00237ce:	57                   	push   %edi
c00237cf:	e8 e6 61 00 00       	call   c00299ba <list_begin>
c00237d4:	89 c6                	mov    %eax,%esi
c00237d6:	83 c4 10             	add    $0x10,%esp
c00237d9:	eb 67                	jmp    c0023842 <lock_release+0xac>
  ASSERT(lock != NULL);
c00237db:	83 ec 0c             	sub    $0xc,%esp
c00237de:	8d 83 d0 56 ff ff    	lea    -0xa930(%ebx),%eax
c00237e4:	50                   	push   %eax
c00237e5:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00237eb:	50                   	push   %eax
c00237ec:	8d 83 48 1b ff ff    	lea    -0xe4b8(%ebx),%eax
c00237f2:	50                   	push   %eax
c00237f3:	68 1c 01 00 00       	push   $0x11c
c00237f8:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c00237fe:	50                   	push   %eax
c00237ff:	e8 91 60 00 00       	call   c0029895 <debug_panic>
  ASSERT(lock_held_by_current_thread(lock));
c0023804:	83 ec 0c             	sub    $0xc,%esp
c0023807:	8d 83 a4 38 ff ff    	lea    -0xc75c(%ebx),%eax
c002380d:	50                   	push   %eax
c002380e:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023814:	50                   	push   %eax
c0023815:	8d 83 48 1b ff ff    	lea    -0xe4b8(%ebx),%eax
c002381b:	50                   	push   %eax
c002381c:	68 1d 01 00 00       	push   $0x11d
c0023821:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023827:	50                   	push   %eax
c0023828:	e8 68 60 00 00       	call   c0029895 <debug_panic>
    son->father = NULL;
c002382d:	c7 46 fc 00 00 00 00 	movl   $0x0,-0x4(%esi)
  for (e = list_begin(&lock->donaters); e != list_end(&lock->donaters); e = list_next(e))
c0023834:	83 ec 0c             	sub    $0xc,%esp
c0023837:	56                   	push   %esi
c0023838:	e8 c2 61 00 00       	call   c00299ff <list_next>
c002383d:	89 c6                	mov    %eax,%esi
c002383f:	83 c4 10             	add    $0x10,%esp
c0023842:	83 ec 0c             	sub    $0xc,%esp
c0023845:	57                   	push   %edi
c0023846:	e8 11 62 00 00       	call   c0029a5c <list_end>
c002384b:	83 c4 10             	add    $0x10,%esp
c002384e:	39 f0                	cmp    %esi,%eax
c0023850:	75 db                	jne    c002382d <lock_release+0x97>
c0023852:	eb 0c                	jmp    c0023860 <lock_release+0xca>
    list_pop_front(&lock->donaters);
c0023854:	83 ec 0c             	sub    $0xc,%esp
c0023857:	57                   	push   %edi
c0023858:	e8 21 68 00 00       	call   c002a07e <list_pop_front>
c002385d:	83 c4 10             	add    $0x10,%esp
  while (!list_empty(&lock->donaters))
c0023860:	83 ec 0c             	sub    $0xc,%esp
c0023863:	57                   	push   %edi
c0023864:	e8 9e 67 00 00       	call   c002a007 <list_empty>
c0023869:	83 c4 10             	add    $0x10,%esp
c002386c:	84 c0                	test   %al,%al
c002386e:	74 e4                	je     c0023854 <lock_release+0xbe>
  list_remove(&lock->elem);
c0023870:	83 ec 0c             	sub    $0xc,%esp
c0023873:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0023877:	83 c0 2c             	add    $0x2c,%eax
c002387a:	50                   	push   %eax
c002387b:	e8 e5 66 00 00       	call   c0029f65 <list_remove>
  lock->max_donate = 0;
c0023880:	8b 44 24 40          	mov    0x40(%esp),%eax
c0023884:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  lock->holder = NULL;
c002388b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_up(&lock->semaphore);
c0023891:	8b 44 24 40          	mov    0x40(%esp),%eax
c0023895:	83 c0 04             	add    $0x4,%eax
c0023898:	89 04 24             	mov    %eax,(%esp)
c002389b:	e8 91 fa ff ff       	call   c0023331 <sema_up>
  int old_donate = t->max_donate;
c00238a0:	8b 45 60             	mov    0x60(%ebp),%eax
c00238a3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  t->max_donate = 0;
c00238a7:	c7 45 60 00 00 00 00 	movl   $0x0,0x60(%ebp)
  for (e = list_begin(&t->lock_list); e != list_end(&t->lock_list); e = list_next(e))
c00238ae:	8d 7d 48             	lea    0x48(%ebp),%edi
c00238b1:	89 3c 24             	mov    %edi,(%esp)
c00238b4:	e8 01 61 00 00       	call   c00299ba <list_begin>
c00238b9:	89 c6                	mov    %eax,%esi
c00238bb:	83 c4 10             	add    $0x10,%esp
c00238be:	eb 0e                	jmp    c00238ce <lock_release+0x138>
c00238c0:	83 ec 0c             	sub    $0xc,%esp
c00238c3:	56                   	push   %esi
c00238c4:	e8 36 61 00 00       	call   c00299ff <list_next>
c00238c9:	89 c6                	mov    %eax,%esi
c00238cb:	83 c4 10             	add    $0x10,%esp
c00238ce:	83 ec 0c             	sub    $0xc,%esp
c00238d1:	57                   	push   %edi
c00238d2:	e8 85 61 00 00       	call   c0029a5c <list_end>
c00238d7:	83 c4 10             	add    $0x10,%esp
c00238da:	39 f0                	cmp    %esi,%eax
c00238dc:	74 0d                	je     c00238eb <lock_release+0x155>
    if (l->max_donate > t->max_donate)
c00238de:	8b 46 ec             	mov    -0x14(%esi),%eax
c00238e1:	3b 45 60             	cmp    0x60(%ebp),%eax
c00238e4:	7e da                	jle    c00238c0 <lock_release+0x12a>
      t->max_donate = l->max_donate;
c00238e6:	89 45 60             	mov    %eax,0x60(%ebp)
c00238e9:	eb d5                	jmp    c00238c0 <lock_release+0x12a>
  if (t->max_donate != old_donate)
c00238eb:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00238ef:	39 45 60             	cmp    %eax,0x60(%ebp)
c00238f2:	75 24                	jne    c0023918 <lock_release+0x182>
  if (t->max_donate == 0 && t->priority_to_set > -1)
c00238f4:	83 7d 60 00          	cmpl   $0x0,0x60(%ebp)
c00238f8:	75 11                	jne    c002390b <lock_release+0x175>
c00238fa:	8b 45 58             	mov    0x58(%ebp),%eax
c00238fd:	85 c0                	test   %eax,%eax
c00238ff:	78 0a                	js     c002390b <lock_release+0x175>
    t->priority = t->priority_to_set;
c0023901:	89 45 1c             	mov    %eax,0x1c(%ebp)
    t->priority_to_set = -1;
c0023904:	c7 45 58 ff ff ff ff 	movl   $0xffffffff,0x58(%ebp)
  thread_revolt();
c002390b:	e8 85 df ff ff       	call   c0021895 <thread_revolt>
}
c0023910:	83 c4 1c             	add    $0x1c,%esp
c0023913:	5b                   	pop    %ebx
c0023914:	5e                   	pop    %esi
c0023915:	5f                   	pop    %edi
c0023916:	5d                   	pop    %ebp
c0023917:	c3                   	ret    
    notify_dad(t);
c0023918:	89 e8                	mov    %ebp,%eax
c002391a:	e8 c6 f7 ff ff       	call   c00230e5 <notify_dad>
c002391f:	eb d3                	jmp    c00238f4 <lock_release+0x15e>

c0023921 <cond_init>:
{
c0023921:	53                   	push   %ebx
c0023922:	83 ec 08             	sub    $0x8,%esp
c0023925:	e8 bc eb 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002392a:	81 c3 12 d3 01 00    	add    $0x1d312,%ebx
c0023930:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(cond != NULL);
c0023934:	85 c0                	test   %eax,%eax
c0023936:	74 0e                	je     c0023946 <cond_init+0x25>
  list_init(&cond->waiters);
c0023938:	83 ec 0c             	sub    $0xc,%esp
c002393b:	50                   	push   %eax
c002393c:	e8 21 60 00 00       	call   c0029962 <list_init>
}
c0023941:	83 c4 18             	add    $0x18,%esp
c0023944:	5b                   	pop    %ebx
c0023945:	c3                   	ret    
  ASSERT(cond != NULL);
c0023946:	83 ec 0c             	sub    $0xc,%esp
c0023949:	8d 83 73 38 ff ff    	lea    -0xc78d(%ebx),%eax
c002394f:	50                   	push   %eax
c0023950:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023956:	50                   	push   %eax
c0023957:	8d 83 20 1b ff ff    	lea    -0xe4e0(%ebx),%eax
c002395d:	50                   	push   %eax
c002395e:	68 60 01 00 00       	push   $0x160
c0023963:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023969:	50                   	push   %eax
c002396a:	e8 26 5f 00 00       	call   c0029895 <debug_panic>

c002396f <cond_wait>:
{
c002396f:	55                   	push   %ebp
c0023970:	57                   	push   %edi
c0023971:	56                   	push   %esi
c0023972:	53                   	push   %ebx
c0023973:	83 ec 2c             	sub    $0x2c,%esp
c0023976:	e8 6b eb 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002397b:	81 c3 c1 d2 01 00    	add    $0x1d2c1,%ebx
c0023981:	8b 74 24 44          	mov    0x44(%esp),%esi
  ASSERT(cond != NULL);
c0023985:	83 7c 24 40 00       	cmpl   $0x0,0x40(%esp)
c002398a:	74 72                	je     c00239fe <cond_wait+0x8f>
  ASSERT(lock != NULL);
c002398c:	85 f6                	test   %esi,%esi
c002398e:	0f 84 93 00 00 00    	je     c0023a27 <cond_wait+0xb8>
  ASSERT(!intr_context());
c0023994:	e8 b6 e8 ff ff       	call   c002224f <intr_context>
c0023999:	84 c0                	test   %al,%al
c002399b:	0f 85 af 00 00 00    	jne    c0023a50 <cond_wait+0xe1>
  ASSERT(lock_held_by_current_thread(lock));
c00239a1:	83 ec 0c             	sub    $0xc,%esp
c00239a4:	56                   	push   %esi
c00239a5:	e8 c5 fb ff ff       	call   c002356f <lock_held_by_current_thread>
c00239aa:	83 c4 10             	add    $0x10,%esp
c00239ad:	84 c0                	test   %al,%al
c00239af:	0f 84 c4 00 00 00    	je     c0023a79 <cond_wait+0x10a>
  sema_init(&waiter.semaphore, 0);
c00239b5:	83 ec 08             	sub    $0x8,%esp
c00239b8:	6a 00                	push   $0x0
c00239ba:	8d 6c 24 0c          	lea    0xc(%esp),%ebp
c00239be:	8d 7c 24 14          	lea    0x14(%esp),%edi
c00239c2:	57                   	push   %edi
c00239c3:	e8 f8 f7 ff ff       	call   c00231c0 <sema_init>
  list_push_back(&cond->waiters, &waiter.elem);
c00239c8:	83 c4 08             	add    $0x8,%esp
c00239cb:	55                   	push   %ebp
c00239cc:	ff 74 24 4c          	pushl  0x4c(%esp)
c00239d0:	e8 73 65 00 00       	call   c0029f48 <list_push_back>
  lock_release(lock);
c00239d5:	89 34 24             	mov    %esi,(%esp)
c00239d8:	e8 b9 fd ff ff       	call   c0023796 <lock_release>
  waiter.pthread = thread_current();
c00239dd:	e8 63 d6 ff ff       	call   c0021045 <thread_current>
c00239e2:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  sema_down(&waiter.semaphore);
c00239e6:	89 3c 24             	mov    %edi,(%esp)
c00239e9:	e8 26 f8 ff ff       	call   c0023214 <sema_down>
  lock_acquire(lock);
c00239ee:	89 34 24             	mov    %esi,(%esp)
c00239f1:	e8 cc fb ff ff       	call   c00235c2 <lock_acquire>
}
c00239f6:	83 c4 3c             	add    $0x3c,%esp
c00239f9:	5b                   	pop    %ebx
c00239fa:	5e                   	pop    %esi
c00239fb:	5f                   	pop    %edi
c00239fc:	5d                   	pop    %ebp
c00239fd:	c3                   	ret    
  ASSERT(cond != NULL);
c00239fe:	83 ec 0c             	sub    $0xc,%esp
c0023a01:	8d 83 73 38 ff ff    	lea    -0xc78d(%ebx),%eax
c0023a07:	50                   	push   %eax
c0023a08:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023a0e:	50                   	push   %eax
c0023a0f:	8d 83 14 1b ff ff    	lea    -0xe4ec(%ebx),%eax
c0023a15:	50                   	push   %eax
c0023a16:	68 7d 01 00 00       	push   $0x17d
c0023a1b:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023a21:	50                   	push   %eax
c0023a22:	e8 6e 5e 00 00       	call   c0029895 <debug_panic>
  ASSERT(lock != NULL);
c0023a27:	83 ec 0c             	sub    $0xc,%esp
c0023a2a:	8d 83 d0 56 ff ff    	lea    -0xa930(%ebx),%eax
c0023a30:	50                   	push   %eax
c0023a31:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023a37:	50                   	push   %eax
c0023a38:	8d 83 14 1b ff ff    	lea    -0xe4ec(%ebx),%eax
c0023a3e:	50                   	push   %eax
c0023a3f:	68 7e 01 00 00       	push   $0x17e
c0023a44:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023a4a:	50                   	push   %eax
c0023a4b:	e8 45 5e 00 00       	call   c0029895 <debug_panic>
  ASSERT(!intr_context());
c0023a50:	83 ec 0c             	sub    $0xc,%esp
c0023a53:	8d 83 ce 33 ff ff    	lea    -0xcc32(%ebx),%eax
c0023a59:	50                   	push   %eax
c0023a5a:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023a60:	50                   	push   %eax
c0023a61:	8d 83 14 1b ff ff    	lea    -0xe4ec(%ebx),%eax
c0023a67:	50                   	push   %eax
c0023a68:	68 7f 01 00 00       	push   $0x17f
c0023a6d:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023a73:	50                   	push   %eax
c0023a74:	e8 1c 5e 00 00       	call   c0029895 <debug_panic>
  ASSERT(lock_held_by_current_thread(lock));
c0023a79:	83 ec 0c             	sub    $0xc,%esp
c0023a7c:	8d 83 a4 38 ff ff    	lea    -0xc75c(%ebx),%eax
c0023a82:	50                   	push   %eax
c0023a83:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023a89:	50                   	push   %eax
c0023a8a:	8d 83 14 1b ff ff    	lea    -0xe4ec(%ebx),%eax
c0023a90:	50                   	push   %eax
c0023a91:	68 80 01 00 00       	push   $0x180
c0023a96:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023a9c:	50                   	push   %eax
c0023a9d:	e8 f3 5d 00 00       	call   c0029895 <debug_panic>

c0023aa2 <cond_signal>:
{
c0023aa2:	55                   	push   %ebp
c0023aa3:	57                   	push   %edi
c0023aa4:	56                   	push   %esi
c0023aa5:	53                   	push   %ebx
c0023aa6:	83 ec 1c             	sub    $0x1c,%esp
c0023aa9:	e8 38 ea 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0023aae:	81 c3 8e d1 01 00    	add    $0x1d18e,%ebx
c0023ab4:	8b 74 24 30          	mov    0x30(%esp),%esi
c0023ab8:	8b 7c 24 34          	mov    0x34(%esp),%edi
  ASSERT(cond != NULL);
c0023abc:	85 f6                	test   %esi,%esi
c0023abe:	74 43                	je     c0023b03 <cond_signal+0x61>
  ASSERT(lock != NULL);
c0023ac0:	85 ff                	test   %edi,%edi
c0023ac2:	74 68                	je     c0023b2c <cond_signal+0x8a>
  ASSERT(!intr_context());
c0023ac4:	e8 86 e7 ff ff       	call   c002224f <intr_context>
c0023ac9:	84 c0                	test   %al,%al
c0023acb:	0f 85 84 00 00 00    	jne    c0023b55 <cond_signal+0xb3>
  ASSERT(lock_held_by_current_thread(lock));
c0023ad1:	83 ec 0c             	sub    $0xc,%esp
c0023ad4:	57                   	push   %edi
c0023ad5:	e8 95 fa ff ff       	call   c002356f <lock_held_by_current_thread>
c0023ada:	83 c4 10             	add    $0x10,%esp
c0023add:	84 c0                	test   %al,%al
c0023adf:	0f 84 99 00 00 00    	je     c0023b7e <cond_signal+0xdc>
  if (!list_empty(&cond->waiters))
c0023ae5:	89 f7                	mov    %esi,%edi
c0023ae7:	83 ec 0c             	sub    $0xc,%esp
c0023aea:	56                   	push   %esi
c0023aeb:	e8 17 65 00 00       	call   c002a007 <list_empty>
c0023af0:	83 c4 10             	add    $0x10,%esp
c0023af3:	84 c0                	test   %al,%al
c0023af5:	0f 84 ac 00 00 00    	je     c0023ba7 <cond_signal+0x105>
}
c0023afb:	83 c4 1c             	add    $0x1c,%esp
c0023afe:	5b                   	pop    %ebx
c0023aff:	5e                   	pop    %esi
c0023b00:	5f                   	pop    %edi
c0023b01:	5d                   	pop    %ebp
c0023b02:	c3                   	ret    
  ASSERT(cond != NULL);
c0023b03:	83 ec 0c             	sub    $0xc,%esp
c0023b06:	8d 83 73 38 ff ff    	lea    -0xc78d(%ebx),%eax
c0023b0c:	50                   	push   %eax
c0023b0d:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023b13:	50                   	push   %eax
c0023b14:	8d 83 08 1b ff ff    	lea    -0xe4f8(%ebx),%eax
c0023b1a:	50                   	push   %eax
c0023b1b:	68 94 01 00 00       	push   $0x194
c0023b20:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023b26:	50                   	push   %eax
c0023b27:	e8 69 5d 00 00       	call   c0029895 <debug_panic>
  ASSERT(lock != NULL);
c0023b2c:	83 ec 0c             	sub    $0xc,%esp
c0023b2f:	8d 83 d0 56 ff ff    	lea    -0xa930(%ebx),%eax
c0023b35:	50                   	push   %eax
c0023b36:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023b3c:	50                   	push   %eax
c0023b3d:	8d 83 08 1b ff ff    	lea    -0xe4f8(%ebx),%eax
c0023b43:	50                   	push   %eax
c0023b44:	68 95 01 00 00       	push   $0x195
c0023b49:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023b4f:	50                   	push   %eax
c0023b50:	e8 40 5d 00 00       	call   c0029895 <debug_panic>
  ASSERT(!intr_context());
c0023b55:	83 ec 0c             	sub    $0xc,%esp
c0023b58:	8d 83 ce 33 ff ff    	lea    -0xcc32(%ebx),%eax
c0023b5e:	50                   	push   %eax
c0023b5f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023b65:	50                   	push   %eax
c0023b66:	8d 83 08 1b ff ff    	lea    -0xe4f8(%ebx),%eax
c0023b6c:	50                   	push   %eax
c0023b6d:	68 96 01 00 00       	push   $0x196
c0023b72:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023b78:	50                   	push   %eax
c0023b79:	e8 17 5d 00 00       	call   c0029895 <debug_panic>
  ASSERT(lock_held_by_current_thread(lock));
c0023b7e:	83 ec 0c             	sub    $0xc,%esp
c0023b81:	8d 83 a4 38 ff ff    	lea    -0xc75c(%ebx),%eax
c0023b87:	50                   	push   %eax
c0023b88:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023b8e:	50                   	push   %eax
c0023b8f:	8d 83 08 1b ff ff    	lea    -0xe4f8(%ebx),%eax
c0023b95:	50                   	push   %eax
c0023b96:	68 97 01 00 00       	push   $0x197
c0023b9b:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023ba1:	50                   	push   %eax
c0023ba2:	e8 ee 5c 00 00       	call   c0029895 <debug_panic>
    struct semaphore_elem *t = list_entry(list_pop_front(&cond->waiters), struct semaphore_elem, elem);
c0023ba7:	83 ec 0c             	sub    $0xc,%esp
c0023baa:	56                   	push   %esi
c0023bab:	e8 ce 64 00 00       	call   c002a07e <list_pop_front>
c0023bb0:	89 c5                	mov    %eax,%ebp
    int max = thread_get_certain_priority(t->pthread);
c0023bb2:	83 c4 04             	add    $0x4,%esp
c0023bb5:	ff 70 1c             	pushl  0x1c(%eax)
c0023bb8:	e8 28 d6 ff ff       	call   c00211e5 <thread_get_certain_priority>
c0023bbd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    list_push_back(&cond->waiters, &t->elem);
c0023bc1:	83 c4 08             	add    $0x8,%esp
c0023bc4:	55                   	push   %ebp
c0023bc5:	56                   	push   %esi
c0023bc6:	e8 7d 63 00 00       	call   c0029f48 <list_push_back>
c0023bcb:	83 c4 10             	add    $0x10,%esp
    struct semaphore_elem *t_max = t;
c0023bce:	89 6c 24 08          	mov    %ebp,0x8(%esp)
      t_tmp = list_entry(list_pop_front(&cond->waiters), struct semaphore_elem, elem);
c0023bd2:	83 ec 0c             	sub    $0xc,%esp
c0023bd5:	57                   	push   %edi
c0023bd6:	e8 a3 64 00 00       	call   c002a07e <list_pop_front>
c0023bdb:	89 c6                	mov    %eax,%esi
      list_push_back(&cond->waiters, &t_tmp->elem);
c0023bdd:	83 c4 08             	add    $0x8,%esp
c0023be0:	50                   	push   %eax
c0023be1:	57                   	push   %edi
c0023be2:	e8 61 63 00 00       	call   c0029f48 <list_push_back>
      if (t_tmp == t)
c0023be7:	83 c4 10             	add    $0x10,%esp
c0023bea:	39 f5                	cmp    %esi,%ebp
c0023bec:	74 1e                	je     c0023c0c <cond_signal+0x16a>
      tmp = thread_get_certain_priority(t_tmp->pthread);
c0023bee:	83 ec 0c             	sub    $0xc,%esp
c0023bf1:	ff 76 1c             	pushl  0x1c(%esi)
c0023bf4:	e8 ec d5 ff ff       	call   c00211e5 <thread_get_certain_priority>
      if (tmp > max)
c0023bf9:	83 c4 10             	add    $0x10,%esp
c0023bfc:	39 44 24 0c          	cmp    %eax,0xc(%esp)
c0023c00:	7d d0                	jge    c0023bd2 <cond_signal+0x130>
        t_max = t_tmp;
c0023c02:	89 74 24 08          	mov    %esi,0x8(%esp)
        max = tmp;
c0023c06:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0023c0a:	eb c6                	jmp    c0023bd2 <cond_signal+0x130>
      t_tmp = (list_entry(list_pop_front(&cond->waiters), struct semaphore_elem, elem));
c0023c0c:	83 ec 0c             	sub    $0xc,%esp
c0023c0f:	57                   	push   %edi
c0023c10:	e8 69 64 00 00       	call   c002a07e <list_pop_front>
      if (t_tmp == t_max)
c0023c15:	83 c4 10             	add    $0x10,%esp
c0023c18:	3b 44 24 08          	cmp    0x8(%esp),%eax
c0023c1c:	74 0f                	je     c0023c2d <cond_signal+0x18b>
      list_push_back(&cond->waiters, &t_tmp->elem);
c0023c1e:	83 ec 08             	sub    $0x8,%esp
c0023c21:	50                   	push   %eax
c0023c22:	57                   	push   %edi
c0023c23:	e8 20 63 00 00       	call   c0029f48 <list_push_back>
      t_tmp = (list_entry(list_pop_front(&cond->waiters), struct semaphore_elem, elem));
c0023c28:	83 c4 10             	add    $0x10,%esp
c0023c2b:	eb df                	jmp    c0023c0c <cond_signal+0x16a>
    sema_up(&t_tmp->semaphore);
c0023c2d:	83 ec 0c             	sub    $0xc,%esp
c0023c30:	8b 44 24 14          	mov    0x14(%esp),%eax
c0023c34:	83 c0 08             	add    $0x8,%eax
c0023c37:	50                   	push   %eax
c0023c38:	e8 f4 f6 ff ff       	call   c0023331 <sema_up>
c0023c3d:	83 c4 10             	add    $0x10,%esp
}
c0023c40:	e9 b6 fe ff ff       	jmp    c0023afb <cond_signal+0x59>

c0023c45 <cond_broadcast>:
{
c0023c45:	57                   	push   %edi
c0023c46:	56                   	push   %esi
c0023c47:	53                   	push   %ebx
c0023c48:	e8 99 e8 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0023c4d:	81 c3 ef cf 01 00    	add    $0x1cfef,%ebx
c0023c53:	8b 74 24 10          	mov    0x10(%esp),%esi
c0023c57:	8b 7c 24 14          	mov    0x14(%esp),%edi
  ASSERT(cond != NULL);
c0023c5b:	85 f6                	test   %esi,%esi
c0023c5d:	74 2d                	je     c0023c8c <cond_broadcast+0x47>
  ASSERT(lock != NULL);
c0023c5f:	85 ff                	test   %edi,%edi
c0023c61:	75 5f                	jne    c0023cc2 <cond_broadcast+0x7d>
c0023c63:	83 ec 0c             	sub    $0xc,%esp
c0023c66:	8d 83 d0 56 ff ff    	lea    -0xa930(%ebx),%eax
c0023c6c:	50                   	push   %eax
c0023c6d:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023c73:	50                   	push   %eax
c0023c74:	8d 83 f8 1a ff ff    	lea    -0xe508(%ebx),%eax
c0023c7a:	50                   	push   %eax
c0023c7b:	68 c6 01 00 00       	push   $0x1c6
c0023c80:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023c86:	50                   	push   %eax
c0023c87:	e8 09 5c 00 00       	call   c0029895 <debug_panic>
  ASSERT(cond != NULL);
c0023c8c:	83 ec 0c             	sub    $0xc,%esp
c0023c8f:	8d 83 73 38 ff ff    	lea    -0xc78d(%ebx),%eax
c0023c95:	50                   	push   %eax
c0023c96:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023c9c:	50                   	push   %eax
c0023c9d:	8d 83 f8 1a ff ff    	lea    -0xe508(%ebx),%eax
c0023ca3:	50                   	push   %eax
c0023ca4:	68 c5 01 00 00       	push   $0x1c5
c0023ca9:	8d 83 37 38 ff ff    	lea    -0xc7c9(%ebx),%eax
c0023caf:	50                   	push   %eax
c0023cb0:	e8 e0 5b 00 00       	call   c0029895 <debug_panic>
    cond_signal(cond, lock);
c0023cb5:	83 ec 08             	sub    $0x8,%esp
c0023cb8:	57                   	push   %edi
c0023cb9:	56                   	push   %esi
c0023cba:	e8 e3 fd ff ff       	call   c0023aa2 <cond_signal>
c0023cbf:	83 c4 10             	add    $0x10,%esp
  while (!list_empty(&cond->waiters))
c0023cc2:	83 ec 0c             	sub    $0xc,%esp
c0023cc5:	56                   	push   %esi
c0023cc6:	e8 3c 63 00 00       	call   c002a007 <list_empty>
c0023ccb:	83 c4 10             	add    $0x10,%esp
c0023cce:	84 c0                	test   %al,%al
c0023cd0:	74 e3                	je     c0023cb5 <cond_broadcast+0x70>
}
c0023cd2:	5b                   	pop    %ebx
c0023cd3:	5e                   	pop    %esi
c0023cd4:	5f                   	pop    %edi
c0023cd5:	c3                   	ret    

c0023cd6 <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool(struct pool *p, void *base, size_t page_cnt, const char *name)
{
c0023cd6:	55                   	push   %ebp
c0023cd7:	57                   	push   %edi
c0023cd8:	56                   	push   %esi
c0023cd9:	53                   	push   %ebx
c0023cda:	83 ec 28             	sub    $0x28,%esp
c0023cdd:	e8 04 e8 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0023ce2:	81 c3 5a cf 01 00    	add    $0x1cf5a,%ebx
c0023ce8:	89 c5                	mov    %eax,%ebp
c0023cea:	89 54 24 18          	mov    %edx,0x18(%esp)
c0023cee:	89 cf                	mov    %ecx,%edi
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP(bitmap_buf_size(page_cnt), PGSIZE);
c0023cf0:	51                   	push   %ecx
c0023cf1:	e8 4a 6a 00 00       	call   c002a740 <bitmap_buf_size>
c0023cf6:	8d b0 ff 0f 00 00    	lea    0xfff(%eax),%esi
c0023cfc:	89 f0                	mov    %esi,%eax
c0023cfe:	c1 e8 0c             	shr    $0xc,%eax
  if (bm_pages > page_cnt)
c0023d01:	83 c4 10             	add    $0x10,%esp
c0023d04:	39 c7                	cmp    %eax,%edi
c0023d06:	72 44                	jb     c0023d4c <init_pool+0x76>
    PANIC("Not enough memory in %s for bitmap.", name);
  page_cnt -= bm_pages;
c0023d08:	29 c7                	sub    %eax,%edi

  printf("%zu pages available in %s.\n", page_cnt, name);
c0023d0a:	83 ec 04             	sub    $0x4,%esp
c0023d0d:	ff 74 24 34          	pushl  0x34(%esp)
c0023d11:	57                   	push   %edi
c0023d12:	8d 83 32 39 ff ff    	lea    -0xc6ce(%ebx),%eax
c0023d18:	50                   	push   %eax
c0023d19:	e8 e0 3d 00 00       	call   c0027afe <printf>

  /* Initialize the pool. */
  lock_init(&p->lock);
c0023d1e:	89 2c 24             	mov    %ebp,(%esp)
c0023d21:	e8 dc f7 ff ff       	call   c0023502 <lock_init>
  p->used_map = bitmap_create_in_buf(page_cnt, base, bm_pages * PGSIZE);
c0023d26:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
c0023d2c:	83 c4 0c             	add    $0xc,%esp
c0023d2f:	56                   	push   %esi
c0023d30:	ff 74 24 14          	pushl  0x14(%esp)
c0023d34:	57                   	push   %edi
c0023d35:	e8 6f 6d 00 00       	call   c002aaa9 <bitmap_create_in_buf>
c0023d3a:	89 45 34             	mov    %eax,0x34(%ebp)
  p->base = base + bm_pages * PGSIZE;
c0023d3d:	03 74 24 1c          	add    0x1c(%esp),%esi
c0023d41:	89 75 38             	mov    %esi,0x38(%ebp)
}
c0023d44:	83 c4 2c             	add    $0x2c,%esp
c0023d47:	5b                   	pop    %ebx
c0023d48:	5e                   	pop    %esi
c0023d49:	5f                   	pop    %edi
c0023d4a:	5d                   	pop    %ebp
c0023d4b:	c3                   	ret    
    PANIC("Not enough memory in %s for bitmap.", name);
c0023d4c:	83 ec 0c             	sub    $0xc,%esp
c0023d4f:	ff 74 24 3c          	pushl  0x3c(%esp)
c0023d53:	8d 83 c8 38 ff ff    	lea    -0xc738(%ebx),%eax
c0023d59:	50                   	push   %eax
c0023d5a:	8d 83 e4 1b ff ff    	lea    -0xe41c(%ebx),%eax
c0023d60:	50                   	push   %eax
c0023d61:	68 9e 00 00 00       	push   $0x9e
c0023d66:	8d 83 1b 39 ff ff    	lea    -0xc6e5(%ebx),%eax
c0023d6c:	50                   	push   %eax
c0023d6d:	e8 23 5b 00 00       	call   c0029895 <debug_panic>

c0023d72 <palloc_init>:
{
c0023d72:	57                   	push   %edi
c0023d73:	56                   	push   %esi
c0023d74:	53                   	push   %ebx
c0023d75:	e8 6c e7 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0023d7a:	81 c3 c2 ce 01 00    	add    $0x1cec2,%ebx
c0023d80:	8b 54 24 10          	mov    0x10(%esp),%edx
  uint8_t *free_end = ptov(init_ram_pages * PGSIZE);
c0023d84:	c7 c0 7e 01 02 c0    	mov    $0xc002017e,%eax
c0023d8a:	8b 00                	mov    (%eax),%eax
c0023d8c:	c1 e0 0c             	shl    $0xc,%eax
  ASSERT((void *)paddr < PHYS_BASE);
c0023d8f:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0023d94:	77 5e                	ja     c0023df4 <palloc_init+0x82>
  size_t free_pages = (free_end - free_start) / PGSIZE;
c0023d96:	8d b0 ff 0f f0 ff    	lea    -0xff001(%eax),%esi
c0023d9c:	2d 00 00 10 00       	sub    $0x100000,%eax
c0023da1:	0f 49 f0             	cmovns %eax,%esi
c0023da4:	c1 fe 0c             	sar    $0xc,%esi
  size_t user_pages = free_pages / 2;
c0023da7:	89 f7                	mov    %esi,%edi
c0023da9:	d1 ef                	shr    %edi
c0023dab:	39 d7                	cmp    %edx,%edi
c0023dad:	0f 47 fa             	cmova  %edx,%edi
  kernel_pages = free_pages - user_pages;
c0023db0:	29 fe                	sub    %edi,%esi
  init_pool(&kernel_pool, free_start, kernel_pages, "kernel pool");
c0023db2:	83 ec 0c             	sub    $0xc,%esp
c0023db5:	8d 83 68 39 ff ff    	lea    -0xc698(%ebx),%eax
c0023dbb:	50                   	push   %eax
c0023dbc:	89 f1                	mov    %esi,%ecx
c0023dbe:	ba 00 00 10 c0       	mov    $0xc0100000,%edx
c0023dc3:	8d 83 44 16 00 00    	lea    0x1644(%ebx),%eax
c0023dc9:	e8 08 ff ff ff       	call   c0023cd6 <init_pool>
  init_pool(&user_pool, free_start + kernel_pages * PGSIZE,
c0023dce:	c1 e6 0c             	shl    $0xc,%esi
c0023dd1:	8d 96 00 00 10 c0    	lea    -0x3ff00000(%esi),%edx
c0023dd7:	8d 83 74 39 ff ff    	lea    -0xc68c(%ebx),%eax
c0023ddd:	89 04 24             	mov    %eax,(%esp)
c0023de0:	89 f9                	mov    %edi,%ecx
c0023de2:	8d 83 04 16 00 00    	lea    0x1604(%ebx),%eax
c0023de8:	e8 e9 fe ff ff       	call   c0023cd6 <init_pool>
}
c0023ded:	83 c4 10             	add    $0x10,%esp
c0023df0:	5b                   	pop    %ebx
c0023df1:	5e                   	pop    %esi
c0023df2:	5f                   	pop    %edi
c0023df3:	c3                   	ret    
c0023df4:	83 ec 0c             	sub    $0xc,%esp
c0023df7:	8d 83 4e 39 ff ff    	lea    -0xc6b2(%ebx),%eax
c0023dfd:	50                   	push   %eax
c0023dfe:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023e04:	50                   	push   %eax
c0023e05:	8d 83 f0 1b ff ff    	lea    -0xe410(%ebx),%eax
c0023e0b:	50                   	push   %eax
c0023e0c:	6a 4e                	push   $0x4e
c0023e0e:	8d 83 3e 2d ff ff    	lea    -0xd2c2(%ebx),%eax
c0023e14:	50                   	push   %eax
c0023e15:	e8 7b 5a 00 00       	call   c0029895 <debug_panic>

c0023e1a <palloc_get_multiple>:
{
c0023e1a:	55                   	push   %ebp
c0023e1b:	57                   	push   %edi
c0023e1c:	56                   	push   %esi
c0023e1d:	53                   	push   %ebx
c0023e1e:	83 ec 0c             	sub    $0xc,%esp
c0023e21:	e8 c0 e6 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0023e26:	81 c3 16 ce 01 00    	add    $0x1ce16,%ebx
c0023e2c:	8b 6c 24 24          	mov    0x24(%esp),%ebp
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c0023e30:	8b 44 24 20          	mov    0x20(%esp),%eax
c0023e34:	83 e0 04             	and    $0x4,%eax
c0023e37:	8d b3 04 16 00 00    	lea    0x1604(%ebx),%esi
c0023e3d:	8d 83 44 16 00 00    	lea    0x1644(%ebx),%eax
c0023e43:	0f 44 f0             	cmove  %eax,%esi
  if (page_cnt == 0)
c0023e46:	85 ed                	test   %ebp,%ebp
c0023e48:	74 7e                	je     c0023ec8 <palloc_get_multiple+0xae>
  lock_acquire(&pool->lock);
c0023e4a:	83 ec 0c             	sub    $0xc,%esp
c0023e4d:	56                   	push   %esi
c0023e4e:	e8 6f f7 ff ff       	call   c00235c2 <lock_acquire>
  page_idx = bitmap_scan_and_flip(pool->used_map, 0, page_cnt, false);
c0023e53:	6a 00                	push   $0x0
c0023e55:	55                   	push   %ebp
c0023e56:	6a 00                	push   $0x0
c0023e58:	ff 76 34             	pushl  0x34(%esi)
c0023e5b:	e8 b6 6f 00 00       	call   c002ae16 <bitmap_scan_and_flip>
c0023e60:	89 c7                	mov    %eax,%edi
  lock_release(&pool->lock);
c0023e62:	83 c4 14             	add    $0x14,%esp
c0023e65:	56                   	push   %esi
c0023e66:	e8 2b f9 ff ff       	call   c0023796 <lock_release>
  if (page_idx != BITMAP_ERROR)
c0023e6b:	83 c4 10             	add    $0x10,%esp
c0023e6e:	83 ff ff             	cmp    $0xffffffff,%edi
c0023e71:	74 23                	je     c0023e96 <palloc_get_multiple+0x7c>
    pages = pool->base + PGSIZE * page_idx;
c0023e73:	c1 e7 0c             	shl    $0xc,%edi
  if (pages != NULL)
c0023e76:	03 7e 38             	add    0x38(%esi),%edi
c0023e79:	74 1b                	je     c0023e96 <palloc_get_multiple+0x7c>
    if (flags & PAL_ZERO)
c0023e7b:	f6 44 24 20 02       	testb  $0x2,0x20(%esp)
c0023e80:	74 20                	je     c0023ea2 <palloc_get_multiple+0x88>
      memset(pages, 0, PGSIZE * page_cnt);
c0023e82:	c1 e5 0c             	shl    $0xc,%ebp
c0023e85:	83 ec 04             	sub    $0x4,%esp
c0023e88:	55                   	push   %ebp
c0023e89:	6a 00                	push   $0x0
c0023e8b:	57                   	push   %edi
c0023e8c:	e8 83 4f 00 00       	call   c0028e14 <memset>
c0023e91:	83 c4 10             	add    $0x10,%esp
c0023e94:	eb 0c                	jmp    c0023ea2 <palloc_get_multiple+0x88>
    if (flags & PAL_ASSERT)
c0023e96:	f6 44 24 20 01       	testb  $0x1,0x20(%esp)
c0023e9b:	75 0f                	jne    c0023eac <palloc_get_multiple+0x92>
c0023e9d:	bf 00 00 00 00       	mov    $0x0,%edi
}
c0023ea2:	89 f8                	mov    %edi,%eax
c0023ea4:	83 c4 0c             	add    $0xc,%esp
c0023ea7:	5b                   	pop    %ebx
c0023ea8:	5e                   	pop    %esi
c0023ea9:	5f                   	pop    %edi
c0023eaa:	5d                   	pop    %ebp
c0023eab:	c3                   	ret    
      PANIC("palloc_get: out of pages");
c0023eac:	8d 83 7e 39 ff ff    	lea    -0xc682(%ebx),%eax
c0023eb2:	50                   	push   %eax
c0023eb3:	8d 83 d0 1b ff ff    	lea    -0xe430(%ebx),%eax
c0023eb9:	50                   	push   %eax
c0023eba:	6a 60                	push   $0x60
c0023ebc:	8d 83 1b 39 ff ff    	lea    -0xc6e5(%ebx),%eax
c0023ec2:	50                   	push   %eax
c0023ec3:	e8 cd 59 00 00       	call   c0029895 <debug_panic>
    return NULL;
c0023ec8:	bf 00 00 00 00       	mov    $0x0,%edi
c0023ecd:	eb d3                	jmp    c0023ea2 <palloc_get_multiple+0x88>

c0023ecf <palloc_get_page>:
{
c0023ecf:	83 ec 14             	sub    $0x14,%esp
  return palloc_get_multiple(flags, 1);
c0023ed2:	6a 01                	push   $0x1
c0023ed4:	ff 74 24 1c          	pushl  0x1c(%esp)
c0023ed8:	e8 3d ff ff ff       	call   c0023e1a <palloc_get_multiple>
}
c0023edd:	83 c4 1c             	add    $0x1c,%esp
c0023ee0:	c3                   	ret    

c0023ee1 <palloc_free_multiple>:
{
c0023ee1:	55                   	push   %ebp
c0023ee2:	57                   	push   %edi
c0023ee3:	56                   	push   %esi
c0023ee4:	53                   	push   %ebx
c0023ee5:	83 ec 0c             	sub    $0xc,%esp
c0023ee8:	e8 f9 e5 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0023eed:	81 c3 4f cd 01 00    	add    $0x1cd4f,%ebx
c0023ef3:	8b 74 24 20          	mov    0x20(%esp),%esi
  ASSERT(pg_ofs(pages) == 0);
c0023ef7:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
c0023efd:	0f 85 9d 00 00 00    	jne    c0023fa0 <palloc_free_multiple+0xbf>
  if (pages == NULL || page_cnt == 0)
c0023f03:	85 f6                	test   %esi,%esi
c0023f05:	0f 84 8d 00 00 00    	je     c0023f98 <palloc_free_multiple+0xb7>
c0023f0b:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0023f10:	0f 84 82 00 00 00    	je     c0023f98 <palloc_free_multiple+0xb7>
  return (uintptr_t)va >> PGBITS;
c0023f16:	89 f7                	mov    %esi,%edi
c0023f18:	c1 ef 0c             	shr    $0xc,%edi
c0023f1b:	8b 83 7c 16 00 00    	mov    0x167c(%ebx),%eax
c0023f21:	c1 e8 0c             	shr    $0xc,%eax
c0023f24:	89 c5                	mov    %eax,%ebp
static bool
page_from_pool(const struct pool *pool, void *page)
{
  size_t page_no = pg_no(page);
  size_t start_page = pg_no(pool->base);
  size_t end_page = start_page + bitmap_size(pool->used_map);
c0023f26:	83 ec 0c             	sub    $0xc,%esp
c0023f29:	ff b3 78 16 00 00    	pushl  0x1678(%ebx)
c0023f2f:	e8 52 68 00 00       	call   c002a786 <bitmap_size>
c0023f34:	89 ea                	mov    %ebp,%edx
c0023f36:	01 e8                	add    %ebp,%eax

  return page_no >= start_page && page_no < end_page;
c0023f38:	83 c4 10             	add    $0x10,%esp
  if (page_from_pool(&kernel_pool, pages))
c0023f3b:	39 c7                	cmp    %eax,%edi
c0023f3d:	0f 83 83 00 00 00    	jae    c0023fc6 <palloc_free_multiple+0xe5>
    pool = &kernel_pool;
c0023f43:	8d ab 44 16 00 00    	lea    0x1644(%ebx),%ebp
  if (page_from_pool(&kernel_pool, pages))
c0023f49:	39 d7                	cmp    %edx,%edi
c0023f4b:	72 79                	jb     c0023fc6 <palloc_free_multiple+0xe5>
c0023f4d:	8b 45 38             	mov    0x38(%ebp),%eax
c0023f50:	c1 e8 0c             	shr    $0xc,%eax
  page_idx = pg_no(pages) - pg_no(pool->base);
c0023f53:	29 c7                	sub    %eax,%edi
  memset(pages, 0xcc, PGSIZE * page_cnt);
c0023f55:	83 ec 04             	sub    $0x4,%esp
c0023f58:	8b 44 24 28          	mov    0x28(%esp),%eax
c0023f5c:	c1 e0 0c             	shl    $0xc,%eax
c0023f5f:	50                   	push   %eax
c0023f60:	68 cc 00 00 00       	push   $0xcc
c0023f65:	56                   	push   %esi
c0023f66:	e8 a9 4e 00 00       	call   c0028e14 <memset>
  ASSERT(bitmap_all(pool->used_map, page_idx, page_cnt));
c0023f6b:	83 c4 0c             	add    $0xc,%esp
c0023f6e:	ff 74 24 28          	pushl  0x28(%esp)
c0023f72:	57                   	push   %edi
c0023f73:	ff 75 34             	pushl  0x34(%ebp)
c0023f76:	e8 ae 6d 00 00       	call   c002ad29 <bitmap_all>
c0023f7b:	83 c4 10             	add    $0x10,%esp
c0023f7e:	84 c0                	test   %al,%al
c0023f80:	0f 84 8e 00 00 00    	je     c0024014 <palloc_free_multiple+0x133>
  bitmap_set_multiple(pool->used_map, page_idx, page_cnt, false);
c0023f86:	6a 00                	push   $0x0
c0023f88:	ff 74 24 28          	pushl  0x28(%esp)
c0023f8c:	57                   	push   %edi
c0023f8d:	ff 75 34             	pushl  0x34(%ebp)
c0023f90:	e8 76 69 00 00       	call   c002a90b <bitmap_set_multiple>
c0023f95:	83 c4 10             	add    $0x10,%esp
}
c0023f98:	83 c4 0c             	add    $0xc,%esp
c0023f9b:	5b                   	pop    %ebx
c0023f9c:	5e                   	pop    %esi
c0023f9d:	5f                   	pop    %edi
c0023f9e:	5d                   	pop    %ebp
c0023f9f:	c3                   	ret    
  ASSERT(pg_ofs(pages) == 0);
c0023fa0:	83 ec 0c             	sub    $0xc,%esp
c0023fa3:	8d 83 97 39 ff ff    	lea    -0xc669(%ebx),%eax
c0023fa9:	50                   	push   %eax
c0023faa:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0023fb0:	50                   	push   %eax
c0023fb1:	8d 83 b8 1b ff ff    	lea    -0xe448(%ebx),%eax
c0023fb7:	50                   	push   %eax
c0023fb8:	6a 79                	push   $0x79
c0023fba:	8d 83 1b 39 ff ff    	lea    -0xc6e5(%ebx),%eax
c0023fc0:	50                   	push   %eax
c0023fc1:	e8 cf 58 00 00       	call   c0029895 <debug_panic>
c0023fc6:	8b ab 3c 16 00 00    	mov    0x163c(%ebx),%ebp
c0023fcc:	c1 ed 0c             	shr    $0xc,%ebp
  size_t end_page = start_page + bitmap_size(pool->used_map);
c0023fcf:	83 ec 0c             	sub    $0xc,%esp
c0023fd2:	ff b3 38 16 00 00    	pushl  0x1638(%ebx)
c0023fd8:	e8 a9 67 00 00       	call   c002a786 <bitmap_size>
c0023fdd:	01 e8                	add    %ebp,%eax
  return page_no >= start_page && page_no < end_page;
c0023fdf:	83 c4 10             	add    $0x10,%esp
  else if (page_from_pool(&user_pool, pages))
c0023fe2:	39 c7                	cmp    %eax,%edi
c0023fe4:	73 0f                	jae    c0023ff5 <palloc_free_multiple+0x114>
c0023fe6:	39 ef                	cmp    %ebp,%edi
c0023fe8:	72 0b                	jb     c0023ff5 <palloc_free_multiple+0x114>
    pool = &user_pool;
c0023fea:	8d ab 04 16 00 00    	lea    0x1604(%ebx),%ebp
c0023ff0:	e9 58 ff ff ff       	jmp    c0023f4d <palloc_free_multiple+0x6c>
    NOT_REACHED();
c0023ff5:	8d 83 60 34 ff ff    	lea    -0xcba0(%ebx),%eax
c0023ffb:	50                   	push   %eax
c0023ffc:	8d 83 b8 1b ff ff    	lea    -0xe448(%ebx),%eax
c0024002:	50                   	push   %eax
c0024003:	68 82 00 00 00       	push   $0x82
c0024008:	8d 83 1b 39 ff ff    	lea    -0xc6e5(%ebx),%eax
c002400e:	50                   	push   %eax
c002400f:	e8 81 58 00 00       	call   c0029895 <debug_panic>
  ASSERT(bitmap_all(pool->used_map, page_idx, page_cnt));
c0024014:	83 ec 0c             	sub    $0xc,%esp
c0024017:	8d 83 ec 38 ff ff    	lea    -0xc714(%ebx),%eax
c002401d:	50                   	push   %eax
c002401e:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0024024:	50                   	push   %eax
c0024025:	8d 83 b8 1b ff ff    	lea    -0xe448(%ebx),%eax
c002402b:	50                   	push   %eax
c002402c:	68 8a 00 00 00       	push   $0x8a
c0024031:	8d 83 1b 39 ff ff    	lea    -0xc6e5(%ebx),%eax
c0024037:	50                   	push   %eax
c0024038:	e8 58 58 00 00       	call   c0029895 <debug_panic>

c002403d <palloc_free_page>:
{
c002403d:	83 ec 14             	sub    $0x14,%esp
  palloc_free_multiple(page, 1);
c0024040:	6a 01                	push   $0x1
c0024042:	ff 74 24 1c          	pushl  0x1c(%esp)
c0024046:	e8 96 fe ff ff       	call   c0023ee1 <palloc_free_multiple>
}
c002404b:	83 c4 1c             	add    $0x1c,%esp
c002404e:	c3                   	ret    

c002404f <arena_to_block>:
}

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block(struct arena *a, size_t idx)
{
c002404f:	53                   	push   %ebx
c0024050:	83 ec 08             	sub    $0x8,%esp
c0024053:	e8 8e e4 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0024058:	81 c3 e4 cb 01 00    	add    $0x1cbe4,%ebx
  ASSERT(a != NULL);
c002405e:	85 c0                	test   %eax,%eax
c0024060:	74 1c                	je     c002407e <arena_to_block+0x2f>
  ASSERT(a->magic == ARENA_MAGIC);
c0024062:	81 38 ed 8e 54 9a    	cmpl   $0x9a548eed,(%eax)
c0024068:	75 3d                	jne    c00240a7 <arena_to_block+0x58>
  ASSERT(idx < a->desc->blocks_per_arena);
c002406a:	8b 48 04             	mov    0x4(%eax),%ecx
c002406d:	39 51 04             	cmp    %edx,0x4(%ecx)
c0024070:	76 5e                	jbe    c00240d0 <arena_to_block+0x81>
  return (struct block *)((uint8_t *)a + sizeof *a + idx * a->desc->block_size);
c0024072:	0f af 11             	imul   (%ecx),%edx
c0024075:	8d 44 10 0c          	lea    0xc(%eax,%edx,1),%eax
}
c0024079:	83 c4 08             	add    $0x8,%esp
c002407c:	5b                   	pop    %ebx
c002407d:	c3                   	ret    
  ASSERT(a != NULL);
c002407e:	83 ec 0c             	sub    $0xc,%esp
c0024081:	8d 83 67 57 ff ff    	lea    -0xa899(%ebx),%eax
c0024087:	50                   	push   %eax
c0024088:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002408e:	50                   	push   %eax
c002408f:	8d 83 10 1c ff ff    	lea    -0xe3f0(%ebx),%eax
c0024095:	50                   	push   %eax
c0024096:	68 1d 01 00 00       	push   $0x11d
c002409b:	8d 83 aa 39 ff ff    	lea    -0xc656(%ebx),%eax
c00240a1:	50                   	push   %eax
c00240a2:	e8 ee 57 00 00       	call   c0029895 <debug_panic>
  ASSERT(a->magic == ARENA_MAGIC);
c00240a7:	83 ec 0c             	sub    $0xc,%esp
c00240aa:	8d 83 c1 39 ff ff    	lea    -0xc63f(%ebx),%eax
c00240b0:	50                   	push   %eax
c00240b1:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00240b7:	50                   	push   %eax
c00240b8:	8d 83 10 1c ff ff    	lea    -0xe3f0(%ebx),%eax
c00240be:	50                   	push   %eax
c00240bf:	68 1e 01 00 00       	push   $0x11e
c00240c4:	8d 83 aa 39 ff ff    	lea    -0xc656(%ebx),%eax
c00240ca:	50                   	push   %eax
c00240cb:	e8 c5 57 00 00       	call   c0029895 <debug_panic>
  ASSERT(idx < a->desc->blocks_per_arena);
c00240d0:	83 ec 0c             	sub    $0xc,%esp
c00240d3:	8d 83 dc 39 ff ff    	lea    -0xc624(%ebx),%eax
c00240d9:	50                   	push   %eax
c00240da:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00240e0:	50                   	push   %eax
c00240e1:	8d 83 10 1c ff ff    	lea    -0xe3f0(%ebx),%eax
c00240e7:	50                   	push   %eax
c00240e8:	68 1f 01 00 00       	push   $0x11f
c00240ed:	8d 83 aa 39 ff ff    	lea    -0xc656(%ebx),%eax
c00240f3:	50                   	push   %eax
c00240f4:	e8 9c 57 00 00       	call   c0029895 <debug_panic>

c00240f9 <block_to_arena>:
{
c00240f9:	56                   	push   %esi
c00240fa:	53                   	push   %ebx
c00240fb:	83 ec 04             	sub    $0x4,%esp
c00240fe:	e8 e3 e3 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0024103:	81 c3 39 cb 01 00    	add    $0x1cb39,%ebx
  ASSERT(a != NULL);
c0024109:	89 c1                	mov    %eax,%ecx
c002410b:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c0024111:	74 2e                	je     c0024141 <block_to_arena+0x48>
  ASSERT(a->magic == ARENA_MAGIC);
c0024113:	81 39 ed 8e 54 9a    	cmpl   $0x9a548eed,(%ecx)
c0024119:	75 4f                	jne    c002416a <block_to_arena+0x71>
  ASSERT(a->desc == NULL || (pg_ofs(b) - sizeof *a) % a->desc->block_size == 0);
c002411b:	8b 71 04             	mov    0x4(%ecx),%esi
c002411e:	85 f6                	test   %esi,%esi
c0024120:	0f 84 96 00 00 00    	je     c00241bc <block_to_arena+0xc3>
  return (uintptr_t)va & PGMASK;
c0024126:	25 ff 0f 00 00       	and    $0xfff,%eax
c002412b:	83 e8 0c             	sub    $0xc,%eax
c002412e:	ba 00 00 00 00       	mov    $0x0,%edx
c0024133:	f7 36                	divl   (%esi)
c0024135:	85 d2                	test   %edx,%edx
c0024137:	75 5a                	jne    c0024193 <block_to_arena+0x9a>
}
c0024139:	89 c8                	mov    %ecx,%eax
c002413b:	83 c4 04             	add    $0x4,%esp
c002413e:	5b                   	pop    %ebx
c002413f:	5e                   	pop    %esi
c0024140:	c3                   	ret    
  ASSERT(a != NULL);
c0024141:	83 ec 0c             	sub    $0xc,%esp
c0024144:	8d 83 67 57 ff ff    	lea    -0xa899(%ebx),%eax
c002414a:	50                   	push   %eax
c002414b:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0024151:	50                   	push   %eax
c0024152:	8d 83 00 1c ff ff    	lea    -0xe400(%ebx),%eax
c0024158:	50                   	push   %eax
c0024159:	68 0f 01 00 00       	push   $0x10f
c002415e:	8d 83 aa 39 ff ff    	lea    -0xc656(%ebx),%eax
c0024164:	50                   	push   %eax
c0024165:	e8 2b 57 00 00       	call   c0029895 <debug_panic>
  ASSERT(a->magic == ARENA_MAGIC);
c002416a:	83 ec 0c             	sub    $0xc,%esp
c002416d:	8d 83 c1 39 ff ff    	lea    -0xc63f(%ebx),%eax
c0024173:	50                   	push   %eax
c0024174:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002417a:	50                   	push   %eax
c002417b:	8d 83 00 1c ff ff    	lea    -0xe400(%ebx),%eax
c0024181:	50                   	push   %eax
c0024182:	68 10 01 00 00       	push   $0x110
c0024187:	8d 83 aa 39 ff ff    	lea    -0xc656(%ebx),%eax
c002418d:	50                   	push   %eax
c002418e:	e8 02 57 00 00       	call   c0029895 <debug_panic>
  ASSERT(a->desc == NULL || (pg_ofs(b) - sizeof *a) % a->desc->block_size == 0);
c0024193:	83 ec 0c             	sub    $0xc,%esp
c0024196:	8d 83 fc 39 ff ff    	lea    -0xc604(%ebx),%eax
c002419c:	50                   	push   %eax
c002419d:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00241a3:	50                   	push   %eax
c00241a4:	8d 83 00 1c ff ff    	lea    -0xe400(%ebx),%eax
c00241aa:	50                   	push   %eax
c00241ab:	68 13 01 00 00       	push   $0x113
c00241b0:	8d 83 aa 39 ff ff    	lea    -0xc656(%ebx),%eax
c00241b6:	50                   	push   %eax
c00241b7:	e8 d9 56 00 00       	call   c0029895 <debug_panic>
c00241bc:	25 ff 0f 00 00       	and    $0xfff,%eax
  ASSERT(a->desc != NULL || pg_ofs(b) == sizeof *a);
c00241c1:	83 f8 0c             	cmp    $0xc,%eax
c00241c4:	0f 84 6f ff ff ff    	je     c0024139 <block_to_arena+0x40>
c00241ca:	83 ec 0c             	sub    $0xc,%esp
c00241cd:	8d 83 44 3a ff ff    	lea    -0xc5bc(%ebx),%eax
c00241d3:	50                   	push   %eax
c00241d4:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00241da:	50                   	push   %eax
c00241db:	8d 83 00 1c ff ff    	lea    -0xe400(%ebx),%eax
c00241e1:	50                   	push   %eax
c00241e2:	68 14 01 00 00       	push   $0x114
c00241e7:	8d 83 aa 39 ff ff    	lea    -0xc656(%ebx),%eax
c00241ed:	50                   	push   %eax
c00241ee:	e8 a2 56 00 00       	call   c0029895 <debug_panic>

c00241f3 <malloc_init>:
{
c00241f3:	55                   	push   %ebp
c00241f4:	57                   	push   %edi
c00241f5:	56                   	push   %esi
c00241f6:	53                   	push   %ebx
c00241f7:	83 ec 0c             	sub    $0xc,%esp
c00241fa:	e8 e7 e2 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00241ff:	81 c3 3d ca 01 00    	add    $0x1ca3d,%ebx
    struct desc *d = &descs[desc_cnt++];
c0024205:	8b b3 84 16 00 00    	mov    0x1684(%ebx),%esi
c002420b:	8d 46 01             	lea    0x1(%esi),%eax
c002420e:	89 83 84 16 00 00    	mov    %eax,0x1684(%ebx)
    ASSERT(desc_cnt <= sizeof descs / sizeof *descs);
c0024214:	83 f8 0a             	cmp    $0xa,%eax
c0024217:	0f 87 a1 00 00 00    	ja     c00242be <malloc_init+0xcb>
    d->block_size = block_size;
c002421d:	8d bb a4 16 00 00    	lea    0x16a4(%ebx),%edi
c0024223:	6b f6 4c             	imul   $0x4c,%esi,%esi
c0024226:	c7 84 33 a4 16 00 00 	movl   $0x10,0x16a4(%ebx,%esi,1)
c002422d:	10 00 00 00 
    d->blocks_per_arena = (PGSIZE - sizeof(struct arena)) / block_size;
c0024231:	c7 84 33 a8 16 00 00 	movl   $0xff,0x16a8(%ebx,%esi,1)
c0024238:	ff 00 00 00 
    list_init(&d->free_list);
c002423c:	83 ec 0c             	sub    $0xc,%esp
c002423f:	8d 44 37 08          	lea    0x8(%edi,%esi,1),%eax
c0024243:	50                   	push   %eax
c0024244:	e8 19 57 00 00       	call   c0029962 <list_init>
    lock_init(&d->lock);
c0024249:	8d 44 37 18          	lea    0x18(%edi,%esi,1),%eax
c002424d:	89 04 24             	mov    %eax,(%esp)
c0024250:	e8 ad f2 ff ff       	call   c0023502 <lock_init>
c0024255:	83 c4 10             	add    $0x10,%esp
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c0024258:	bf 20 00 00 00       	mov    $0x20,%edi
    d->block_size = block_size;
c002425d:	8d ab a4 16 00 00    	lea    0x16a4(%ebx),%ebp
    struct desc *d = &descs[desc_cnt++];
c0024263:	8b b3 84 16 00 00    	mov    0x1684(%ebx),%esi
c0024269:	8d 46 01             	lea    0x1(%esi),%eax
c002426c:	89 83 84 16 00 00    	mov    %eax,0x1684(%ebx)
    ASSERT(desc_cnt <= sizeof descs / sizeof *descs);
c0024272:	83 f8 0a             	cmp    $0xa,%eax
c0024275:	77 47                	ja     c00242be <malloc_init+0xcb>
    d->block_size = block_size;
c0024277:	6b f6 4c             	imul   $0x4c,%esi,%esi
c002427a:	89 3c 2e             	mov    %edi,(%esi,%ebp,1)
    d->blocks_per_arena = (PGSIZE - sizeof(struct arena)) / block_size;
c002427d:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c0024282:	ba 00 00 00 00       	mov    $0x0,%edx
c0024287:	f7 f7                	div    %edi
c0024289:	89 84 33 a8 16 00 00 	mov    %eax,0x16a8(%ebx,%esi,1)
    list_init(&d->free_list);
c0024290:	83 ec 0c             	sub    $0xc,%esp
c0024293:	8d 44 2e 08          	lea    0x8(%esi,%ebp,1),%eax
c0024297:	50                   	push   %eax
c0024298:	e8 c5 56 00 00       	call   c0029962 <list_init>
    lock_init(&d->lock);
c002429d:	8d 44 2e 18          	lea    0x18(%esi,%ebp,1),%eax
c00242a1:	89 04 24             	mov    %eax,(%esp)
c00242a4:	e8 59 f2 ff ff       	call   c0023502 <lock_init>
  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c00242a9:	01 ff                	add    %edi,%edi
c00242ab:	83 c4 10             	add    $0x10,%esp
c00242ae:	81 ff ff 07 00 00    	cmp    $0x7ff,%edi
c00242b4:	76 ad                	jbe    c0024263 <malloc_init+0x70>
}
c00242b6:	83 c4 0c             	add    $0xc,%esp
c00242b9:	5b                   	pop    %ebx
c00242ba:	5e                   	pop    %esi
c00242bb:	5f                   	pop    %edi
c00242bc:	5d                   	pop    %ebp
c00242bd:	c3                   	ret    
    ASSERT(desc_cnt <= sizeof descs / sizeof *descs);
c00242be:	83 ec 0c             	sub    $0xc,%esp
c00242c1:	8d 83 70 3a ff ff    	lea    -0xc590(%ebx),%eax
c00242c7:	50                   	push   %eax
c00242c8:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00242ce:	50                   	push   %eax
c00242cf:	8d 83 20 1c ff ff    	lea    -0xe3e0(%ebx),%eax
c00242d5:	50                   	push   %eax
c00242d6:	6a 4e                	push   $0x4e
c00242d8:	8d 83 aa 39 ff ff    	lea    -0xc656(%ebx),%eax
c00242de:	50                   	push   %eax
c00242df:	e8 b1 55 00 00       	call   c0029895 <debug_panic>

c00242e4 <malloc>:
{
c00242e4:	55                   	push   %ebp
c00242e5:	57                   	push   %edi
c00242e6:	56                   	push   %esi
c00242e7:	53                   	push   %ebx
c00242e8:	83 ec 1c             	sub    $0x1c,%esp
c00242eb:	e8 f6 e1 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00242f0:	81 c3 4c c9 01 00    	add    $0x1c94c,%ebx
c00242f6:	8b 54 24 30          	mov    0x30(%esp),%edx
  if (size == 0)
c00242fa:	85 d2                	test   %edx,%edx
c00242fc:	0f 84 2e 01 00 00    	je     c0024430 <malloc+0x14c>
  for (d = descs; d < descs + desc_cnt; d++)
c0024302:	6b 83 84 16 00 00 4c 	imul   $0x4c,0x1684(%ebx),%eax
c0024309:	8d 8b a4 16 00 00    	lea    0x16a4(%ebx),%ecx
c002430f:	01 c8                	add    %ecx,%eax
c0024311:	39 c8                	cmp    %ecx,%eax
c0024313:	0f 86 c3 00 00 00    	jbe    c00243dc <malloc+0xf8>
    if (d->block_size >= size)
c0024319:	3b 93 a4 16 00 00    	cmp    0x16a4(%ebx),%edx
c002431f:	0f 86 19 01 00 00    	jbe    c002443e <malloc+0x15a>
  for (d = descs; d < descs + desc_cnt; d++)
c0024325:	89 ce                	mov    %ecx,%esi
c0024327:	83 c6 4c             	add    $0x4c,%esi
c002432a:	39 c6                	cmp    %eax,%esi
c002432c:	0f 83 b0 00 00 00    	jae    c00243e2 <malloc+0xfe>
    if (d->block_size >= size)
c0024332:	39 16                	cmp    %edx,(%esi)
c0024334:	72 f1                	jb     c0024327 <malloc+0x43>
  lock_acquire(&d->lock);
c0024336:	8d 46 18             	lea    0x18(%esi),%eax
c0024339:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002433d:	83 ec 0c             	sub    $0xc,%esp
c0024340:	50                   	push   %eax
c0024341:	e8 7c f2 ff ff       	call   c00235c2 <lock_acquire>
  if (list_empty(&d->free_list))
c0024346:	8d 6e 08             	lea    0x8(%esi),%ebp
c0024349:	89 2c 24             	mov    %ebp,(%esp)
c002434c:	e8 b6 5c 00 00       	call   c002a007 <list_empty>
c0024351:	83 c4 10             	add    $0x10,%esp
c0024354:	84 c0                	test   %al,%al
c0024356:	74 57                	je     c00243af <malloc+0xcb>
    a = palloc_get_page(0);
c0024358:	83 ec 0c             	sub    $0xc,%esp
c002435b:	6a 00                	push   $0x0
c002435d:	e8 6d fb ff ff       	call   c0023ecf <palloc_get_page>
c0024362:	89 44 24 18          	mov    %eax,0x18(%esp)
    if (a == NULL)
c0024366:	83 c4 10             	add    $0x10,%esp
c0024369:	85 c0                	test   %eax,%eax
c002436b:	0f 84 a9 00 00 00    	je     c002441a <malloc+0x136>
    a->magic = ARENA_MAGIC;
c0024371:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0024375:	c7 01 ed 8e 54 9a    	movl   $0x9a548eed,(%ecx)
    a->desc = d;
c002437b:	89 71 04             	mov    %esi,0x4(%ecx)
    a->free_cnt = d->blocks_per_arena;
c002437e:	8b 46 04             	mov    0x4(%esi),%eax
c0024381:	89 41 08             	mov    %eax,0x8(%ecx)
    for (i = 0; i < d->blocks_per_arena; i++)
c0024384:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0024388:	74 25                	je     c00243af <malloc+0xcb>
c002438a:	bf 00 00 00 00       	mov    $0x0,%edi
      struct block *b = arena_to_block(a, i);
c002438f:	89 fa                	mov    %edi,%edx
c0024391:	8b 44 24 08          	mov    0x8(%esp),%eax
c0024395:	e8 b5 fc ff ff       	call   c002404f <arena_to_block>
      list_push_back(&d->free_list, &b->free_elem);
c002439a:	83 ec 08             	sub    $0x8,%esp
c002439d:	50                   	push   %eax
c002439e:	55                   	push   %ebp
c002439f:	e8 a4 5b 00 00       	call   c0029f48 <list_push_back>
    for (i = 0; i < d->blocks_per_arena; i++)
c00243a4:	83 c7 01             	add    $0x1,%edi
c00243a7:	83 c4 10             	add    $0x10,%esp
c00243aa:	39 7e 04             	cmp    %edi,0x4(%esi)
c00243ad:	77 e0                	ja     c002438f <malloc+0xab>
  b = list_entry(list_pop_front(&d->free_list), struct block, free_elem);
c00243af:	83 ec 0c             	sub    $0xc,%esp
c00243b2:	55                   	push   %ebp
c00243b3:	e8 c6 5c 00 00       	call   c002a07e <list_pop_front>
c00243b8:	89 c6                	mov    %eax,%esi
  a = block_to_arena(b);
c00243ba:	e8 3a fd ff ff       	call   c00240f9 <block_to_arena>
  a->free_cnt--;
c00243bf:	83 68 08 01          	subl   $0x1,0x8(%eax)
  lock_release(&d->lock);
c00243c3:	83 c4 04             	add    $0x4,%esp
c00243c6:	ff 74 24 18          	pushl  0x18(%esp)
c00243ca:	e8 c7 f3 ff ff       	call   c0023796 <lock_release>
  return b;
c00243cf:	83 c4 10             	add    $0x10,%esp
}
c00243d2:	89 f0                	mov    %esi,%eax
c00243d4:	83 c4 1c             	add    $0x1c,%esp
c00243d7:	5b                   	pop    %ebx
c00243d8:	5e                   	pop    %esi
c00243d9:	5f                   	pop    %edi
c00243da:	5d                   	pop    %ebp
c00243db:	c3                   	ret    
  for (d = descs; d < descs + desc_cnt; d++)
c00243dc:	8d b3 a4 16 00 00    	lea    0x16a4(%ebx),%esi
  if (d == descs + desc_cnt)
c00243e2:	39 f0                	cmp    %esi,%eax
c00243e4:	0f 85 4c ff ff ff    	jne    c0024336 <malloc+0x52>
    size_t page_cnt = DIV_ROUND_UP(size + sizeof *a, PGSIZE);
c00243ea:	8d b2 0b 10 00 00    	lea    0x100b(%edx),%esi
c00243f0:	c1 ee 0c             	shr    $0xc,%esi
    a = palloc_get_multiple(0, page_cnt);
c00243f3:	83 ec 08             	sub    $0x8,%esp
c00243f6:	56                   	push   %esi
c00243f7:	6a 00                	push   $0x0
c00243f9:	e8 1c fa ff ff       	call   c0023e1a <palloc_get_multiple>
    if (a == NULL)
c00243fe:	83 c4 10             	add    $0x10,%esp
c0024401:	85 c0                	test   %eax,%eax
c0024403:	74 32                	je     c0024437 <malloc+0x153>
    a->magic = ARENA_MAGIC;
c0024405:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
    a->desc = NULL;
c002440b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    a->free_cnt = page_cnt;
c0024412:	89 70 08             	mov    %esi,0x8(%eax)
    return a + 1;
c0024415:	8d 70 0c             	lea    0xc(%eax),%esi
c0024418:	eb b8                	jmp    c00243d2 <malloc+0xee>
      lock_release(&d->lock);
c002441a:	83 ec 0c             	sub    $0xc,%esp
c002441d:	ff 74 24 18          	pushl  0x18(%esp)
c0024421:	e8 70 f3 ff ff       	call   c0023796 <lock_release>
      return NULL;
c0024426:	83 c4 10             	add    $0x10,%esp
c0024429:	be 00 00 00 00       	mov    $0x0,%esi
c002442e:	eb a2                	jmp    c00243d2 <malloc+0xee>
    return NULL;
c0024430:	be 00 00 00 00       	mov    $0x0,%esi
c0024435:	eb 9b                	jmp    c00243d2 <malloc+0xee>
      return NULL;
c0024437:	be 00 00 00 00       	mov    $0x0,%esi
c002443c:	eb 94                	jmp    c00243d2 <malloc+0xee>
  for (d = descs; d < descs + desc_cnt; d++)
c002443e:	8d b3 a4 16 00 00    	lea    0x16a4(%ebx),%esi
c0024444:	e9 ed fe ff ff       	jmp    c0024336 <malloc+0x52>

c0024449 <calloc>:
{
c0024449:	57                   	push   %edi
c002444a:	56                   	push   %esi
c002444b:	53                   	push   %ebx
c002444c:	e8 95 e0 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0024451:	81 c3 eb c7 01 00    	add    $0x1c7eb,%ebx
c0024457:	8b 44 24 10          	mov    0x10(%esp),%eax
c002445b:	8b 54 24 14          	mov    0x14(%esp),%edx
  size = a * b;
c002445f:	89 c6                	mov    %eax,%esi
c0024461:	0f af f2             	imul   %edx,%esi
  if (size < a || size < b)
c0024464:	39 f0                	cmp    %esi,%eax
c0024466:	77 2b                	ja     c0024493 <calloc+0x4a>
c0024468:	39 f2                	cmp    %esi,%edx
c002446a:	77 27                	ja     c0024493 <calloc+0x4a>
  p = malloc(size);
c002446c:	83 ec 0c             	sub    $0xc,%esp
c002446f:	56                   	push   %esi
c0024470:	e8 6f fe ff ff       	call   c00242e4 <malloc>
c0024475:	89 c7                	mov    %eax,%edi
  if (p != NULL)
c0024477:	83 c4 10             	add    $0x10,%esp
c002447a:	85 c0                	test   %eax,%eax
c002447c:	74 0f                	je     c002448d <calloc+0x44>
    memset(p, 0, size);
c002447e:	83 ec 04             	sub    $0x4,%esp
c0024481:	56                   	push   %esi
c0024482:	6a 00                	push   $0x0
c0024484:	50                   	push   %eax
c0024485:	e8 8a 49 00 00       	call   c0028e14 <memset>
c002448a:	83 c4 10             	add    $0x10,%esp
}
c002448d:	89 f8                	mov    %edi,%eax
c002448f:	5b                   	pop    %ebx
c0024490:	5e                   	pop    %esi
c0024491:	5f                   	pop    %edi
c0024492:	c3                   	ret    
    return NULL;
c0024493:	bf 00 00 00 00       	mov    $0x0,%edi
c0024498:	eb f3                	jmp    c002448d <calloc+0x44>

c002449a <free>:
{
c002449a:	55                   	push   %ebp
c002449b:	57                   	push   %edi
c002449c:	56                   	push   %esi
c002449d:	53                   	push   %ebx
c002449e:	83 ec 1c             	sub    $0x1c,%esp
c00244a1:	e8 40 e0 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00244a6:	81 c3 96 c7 01 00    	add    $0x1c796,%ebx
c00244ac:	8b 74 24 30          	mov    0x30(%esp),%esi
  if (p != NULL)
c00244b0:	85 f6                	test   %esi,%esi
c00244b2:	0f 84 98 00 00 00    	je     c0024550 <free+0xb6>
    struct arena *a = block_to_arena(b);
c00244b8:	89 f0                	mov    %esi,%eax
c00244ba:	e8 3a fc ff ff       	call   c00240f9 <block_to_arena>
c00244bf:	89 c5                	mov    %eax,%ebp
    struct desc *d = a->desc;
c00244c1:	8b 78 04             	mov    0x4(%eax),%edi
    if (d != NULL)
c00244c4:	85 ff                	test   %edi,%edi
c00244c6:	0f 84 b5 00 00 00    	je     c0024581 <free+0xe7>
      memset(b, 0xcc, d->block_size);
c00244cc:	83 ec 04             	sub    $0x4,%esp
c00244cf:	ff 37                	pushl  (%edi)
c00244d1:	68 cc 00 00 00       	push   $0xcc
c00244d6:	56                   	push   %esi
c00244d7:	e8 38 49 00 00       	call   c0028e14 <memset>
      lock_acquire(&d->lock);
c00244dc:	8d 47 18             	lea    0x18(%edi),%eax
c00244df:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c00244e3:	89 04 24             	mov    %eax,(%esp)
c00244e6:	e8 d7 f0 ff ff       	call   c00235c2 <lock_acquire>
      list_push_front(&d->free_list, &b->free_elem);
c00244eb:	83 c4 08             	add    $0x8,%esp
c00244ee:	56                   	push   %esi
c00244ef:	8d 47 08             	lea    0x8(%edi),%eax
c00244f2:	50                   	push   %eax
c00244f3:	e8 33 5a 00 00       	call   c0029f2b <list_push_front>
      if (++a->free_cnt >= d->blocks_per_arena)
c00244f8:	8b 45 08             	mov    0x8(%ebp),%eax
c00244fb:	83 c0 01             	add    $0x1,%eax
c00244fe:	89 45 08             	mov    %eax,0x8(%ebp)
c0024501:	8b 57 04             	mov    0x4(%edi),%edx
c0024504:	83 c4 10             	add    $0x10,%esp
c0024507:	39 d0                	cmp    %edx,%eax
c0024509:	72 36                	jb     c0024541 <free+0xa7>
        ASSERT(a->free_cnt == d->blocks_per_arena);
c002450b:	39 d0                	cmp    %edx,%eax
c002450d:	75 49                	jne    c0024558 <free+0xbe>
        for (i = 0; i < d->blocks_per_arena; i++)
c002450f:	be 00 00 00 00       	mov    $0x0,%esi
c0024514:	85 c0                	test   %eax,%eax
c0024516:	74 1d                	je     c0024535 <free+0x9b>
          struct block *b = arena_to_block(a, i);
c0024518:	89 f2                	mov    %esi,%edx
c002451a:	89 e8                	mov    %ebp,%eax
c002451c:	e8 2e fb ff ff       	call   c002404f <arena_to_block>
          list_remove(&b->free_elem);
c0024521:	83 ec 0c             	sub    $0xc,%esp
c0024524:	50                   	push   %eax
c0024525:	e8 3b 5a 00 00       	call   c0029f65 <list_remove>
        for (i = 0; i < d->blocks_per_arena; i++)
c002452a:	83 c6 01             	add    $0x1,%esi
c002452d:	83 c4 10             	add    $0x10,%esp
c0024530:	39 77 04             	cmp    %esi,0x4(%edi)
c0024533:	77 e3                	ja     c0024518 <free+0x7e>
        palloc_free_page(a);
c0024535:	83 ec 0c             	sub    $0xc,%esp
c0024538:	55                   	push   %ebp
c0024539:	e8 ff fa ff ff       	call   c002403d <palloc_free_page>
c002453e:	83 c4 10             	add    $0x10,%esp
      lock_release(&d->lock);
c0024541:	83 ec 0c             	sub    $0xc,%esp
c0024544:	ff 74 24 18          	pushl  0x18(%esp)
c0024548:	e8 49 f2 ff ff       	call   c0023796 <lock_release>
c002454d:	83 c4 10             	add    $0x10,%esp
}
c0024550:	83 c4 1c             	add    $0x1c,%esp
c0024553:	5b                   	pop    %ebx
c0024554:	5e                   	pop    %esi
c0024555:	5f                   	pop    %edi
c0024556:	5d                   	pop    %ebp
c0024557:	c3                   	ret    
        ASSERT(a->free_cnt == d->blocks_per_arena);
c0024558:	83 ec 0c             	sub    $0xc,%esp
c002455b:	8d 83 9c 3a ff ff    	lea    -0xc564(%ebx),%eax
c0024561:	50                   	push   %eax
c0024562:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0024568:	50                   	push   %eax
c0024569:	8d 83 f8 1b ff ff    	lea    -0xe408(%ebx),%eax
c002456f:	50                   	push   %eax
c0024570:	68 f4 00 00 00       	push   $0xf4
c0024575:	8d 83 aa 39 ff ff    	lea    -0xc656(%ebx),%eax
c002457b:	50                   	push   %eax
c002457c:	e8 14 53 00 00       	call   c0029895 <debug_panic>
      palloc_free_multiple(a, a->free_cnt);
c0024581:	83 ec 08             	sub    $0x8,%esp
c0024584:	ff 70 08             	pushl  0x8(%eax)
c0024587:	50                   	push   %eax
c0024588:	e8 54 f9 ff ff       	call   c0023ee1 <palloc_free_multiple>
      return;
c002458d:	83 c4 10             	add    $0x10,%esp
c0024590:	eb be                	jmp    c0024550 <free+0xb6>

c0024592 <realloc>:
{
c0024592:	55                   	push   %ebp
c0024593:	57                   	push   %edi
c0024594:	56                   	push   %esi
c0024595:	53                   	push   %ebx
c0024596:	83 ec 0c             	sub    $0xc,%esp
c0024599:	e8 48 df 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002459e:	81 c3 9e c6 01 00    	add    $0x1c69e,%ebx
c00245a4:	8b 7c 24 20          	mov    0x20(%esp),%edi
c00245a8:	8b 74 24 24          	mov    0x24(%esp),%esi
  if (new_size == 0)
c00245ac:	85 f6                	test   %esi,%esi
c00245ae:	74 4b                	je     c00245fb <realloc+0x69>
    void *new_block = malloc(new_size);
c00245b0:	83 ec 0c             	sub    $0xc,%esp
c00245b3:	56                   	push   %esi
c00245b4:	e8 2b fd ff ff       	call   c00242e4 <malloc>
c00245b9:	89 c5                	mov    %eax,%ebp
    if (old_block != NULL && new_block != NULL)
c00245bb:	83 c4 10             	add    $0x10,%esp
c00245be:	85 ff                	test   %edi,%edi
c00245c0:	74 2f                	je     c00245f1 <realloc+0x5f>
c00245c2:	85 c0                	test   %eax,%eax
c00245c4:	74 2b                	je     c00245f1 <realloc+0x5f>
  struct arena *a = block_to_arena(b);
c00245c6:	89 f8                	mov    %edi,%eax
c00245c8:	e8 2c fb ff ff       	call   c00240f9 <block_to_arena>
  struct desc *d = a->desc;
c00245cd:	8b 50 04             	mov    0x4(%eax),%edx
  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs(block);
c00245d0:	85 d2                	test   %edx,%edx
c00245d2:	74 3a                	je     c002460e <realloc+0x7c>
c00245d4:	8b 02                	mov    (%edx),%eax
      size_t min_size = new_size < old_size ? new_size : old_size;
c00245d6:	39 c6                	cmp    %eax,%esi
c00245d8:	0f 47 f0             	cmova  %eax,%esi
      memcpy(new_block, old_block, min_size);
c00245db:	83 ec 04             	sub    $0x4,%esp
c00245de:	56                   	push   %esi
c00245df:	57                   	push   %edi
c00245e0:	55                   	push   %ebp
c00245e1:	e8 ab 44 00 00       	call   c0028a91 <memcpy>
      free(old_block);
c00245e6:	89 3c 24             	mov    %edi,(%esp)
c00245e9:	e8 ac fe ff ff       	call   c002449a <free>
c00245ee:	83 c4 10             	add    $0x10,%esp
}
c00245f1:	89 e8                	mov    %ebp,%eax
c00245f3:	83 c4 0c             	add    $0xc,%esp
c00245f6:	5b                   	pop    %ebx
c00245f7:	5e                   	pop    %esi
c00245f8:	5f                   	pop    %edi
c00245f9:	5d                   	pop    %ebp
c00245fa:	c3                   	ret    
    free(old_block);
c00245fb:	83 ec 0c             	sub    $0xc,%esp
c00245fe:	57                   	push   %edi
c00245ff:	e8 96 fe ff ff       	call   c002449a <free>
    return NULL;
c0024604:	83 c4 10             	add    $0x10,%esp
c0024607:	bd 00 00 00 00       	mov    $0x0,%ebp
c002460c:	eb e3                	jmp    c00245f1 <realloc+0x5f>
  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs(block);
c002460e:	8b 40 08             	mov    0x8(%eax),%eax
c0024611:	c1 e0 0c             	shl    $0xc,%eax
c0024614:	89 fa                	mov    %edi,%edx
c0024616:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c002461c:	29 d0                	sub    %edx,%eax
c002461e:	eb b6                	jmp    c00245d6 <realloc+0x44>

c0024620 <float32_init>:
 */
const F = 1 << 14;

/* Transfer int32_t to float32 */
struct float32 float32_init(int32_t x)
{
c0024620:	8b 44 24 04          	mov    0x4(%esp),%eax
    struct float32 res = {x * F};
c0024624:	8b 54 24 08          	mov    0x8(%esp),%edx
c0024628:	c1 e2 0e             	shl    $0xe,%edx
c002462b:	89 10                	mov    %edx,(%eax)
    return res;
}
c002462d:	c2 04 00             	ret    $0x4

c0024630 <float32_trunc>:
}

/* floor and ceil */
int32_t float32_trunc(struct float32 a)
{
    return a.num >> 14;
c0024630:	8b 44 24 04          	mov    0x4(%esp),%eax
c0024634:	c1 f8 0e             	sar    $0xe,%eax
}
c0024637:	c3                   	ret    

c0024638 <float32_round>:

/* floor and ceil */
int32_t float32_round(struct float32 a)
{
c0024638:	8b 54 24 04          	mov    0x4(%esp),%edx
    return (a.num >= 0) ? (a.num + (F >> 1)) / F : (a.num - (F >> 1)) / F;
c002463c:	85 d2                	test   %edx,%edx
c002463e:	78 13                	js     c0024653 <float32_round+0x1b>
c0024640:	8d 82 ff 5f 00 00    	lea    0x5fff(%edx),%eax
c0024646:	81 c2 00 20 00 00    	add    $0x2000,%edx
c002464c:	0f 49 c2             	cmovns %edx,%eax
c002464f:	c1 f8 0e             	sar    $0xe,%eax
c0024652:	c3                   	ret    
c0024653:	8d 82 ff 1f 00 00    	lea    0x1fff(%edx),%eax
c0024659:	81 ea 00 20 00 00    	sub    $0x2000,%edx
c002465f:	0f 49 c2             	cmovns %edx,%eax
c0024662:	c1 f8 0e             	sar    $0xe,%eax
}
c0024665:	c3                   	ret    

c0024666 <float32_output>:
{
c0024666:	53                   	push   %ebx
c0024667:	83 ec 08             	sub    $0x8,%esp
c002466a:	e8 77 de 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002466f:	81 c3 cd c5 01 00    	add    $0x1c5cd,%ebx
    a.num = a.num * 1000;
c0024675:	69 44 24 10 e8 03 00 	imul   $0x3e8,0x10(%esp),%eax
c002467c:	00 
    int num = float32_round(a);
c002467d:	50                   	push   %eax
c002467e:	e8 b5 ff ff ff       	call   c0024638 <float32_round>
c0024683:	89 c1                	mov    %eax,%ecx
    printf("%d.%03d", num / 1000, num % 1000);
c0024685:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c002468a:	f7 ea                	imul   %edx
c002468c:	c1 fa 06             	sar    $0x6,%edx
c002468f:	89 c8                	mov    %ecx,%eax
c0024691:	c1 f8 1f             	sar    $0x1f,%eax
c0024694:	29 c2                	sub    %eax,%edx
c0024696:	69 c2 e8 03 00 00    	imul   $0x3e8,%edx,%eax
c002469c:	29 c1                	sub    %eax,%ecx
c002469e:	51                   	push   %ecx
c002469f:	52                   	push   %edx
c00246a0:	8d 83 bf 3a ff ff    	lea    -0xc541(%ebx),%eax
c00246a6:	50                   	push   %eax
c00246a7:	e8 52 34 00 00       	call   c0027afe <printf>
}
c00246ac:	83 c4 18             	add    $0x18,%esp
c00246af:	5b                   	pop    %ebx
c00246b0:	c3                   	ret    

c00246b1 <float32_add>:

struct float32 float32_add(struct float32 a, struct float32 b)
{
c00246b1:	8b 44 24 04          	mov    0x4(%esp),%eax
    struct float32 res = {a.num + b.num};
c00246b5:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00246b9:	03 54 24 08          	add    0x8(%esp),%edx
c00246bd:	89 10                	mov    %edx,(%eax)
    return res;
}
c00246bf:	c2 04 00             	ret    $0x4

c00246c2 <float32_add_int>:

struct float32 float32_add_int(struct float32 a, int32_t b)
{
c00246c2:	8b 44 24 04          	mov    0x4(%esp),%eax
    struct float32 res = {a.num + b * F};
c00246c6:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00246ca:	c1 e2 0e             	shl    $0xe,%edx
c00246cd:	03 54 24 08          	add    0x8(%esp),%edx
c00246d1:	89 10                	mov    %edx,(%eax)
    return res;
}
c00246d3:	c2 04 00             	ret    $0x4

c00246d6 <float32_sub>:

struct float32 float32_sub(struct float32 a, struct float32 b)
{
c00246d6:	8b 44 24 04          	mov    0x4(%esp),%eax
    struct float32 res = {a.num - b.num};
c00246da:	8b 54 24 08          	mov    0x8(%esp),%edx
c00246de:	2b 54 24 0c          	sub    0xc(%esp),%edx
c00246e2:	89 10                	mov    %edx,(%eax)
    return res;
}
c00246e4:	c2 04 00             	ret    $0x4

c00246e7 <float32_sub_int>:

struct float32 float32_sub_int(struct float32 a, int32_t b)
{
c00246e7:	8b 44 24 04          	mov    0x4(%esp),%eax
    struct float32 res = {a.num - b * F};
c00246eb:	8b 54 24 0c          	mov    0xc(%esp),%edx
c00246ef:	c1 e2 0e             	shl    $0xe,%edx
c00246f2:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c00246f6:	29 d1                	sub    %edx,%ecx
c00246f8:	89 08                	mov    %ecx,(%eax)
    return res;
}
c00246fa:	c2 04 00             	ret    $0x4

c00246fd <float32_mul>:

struct float32 float32_mul(struct float32 a, struct float32 b)
{
c00246fd:	55                   	push   %ebp
c00246fe:	57                   	push   %edi
c00246ff:	56                   	push   %esi
c0024700:	53                   	push   %ebx
c0024701:	8b 54 24 18          	mov    0x18(%esp),%edx
c0024705:	8b 44 24 1c          	mov    0x1c(%esp),%eax
    struct float32 res = {(int64_t)a.num * b.num / F};
c0024709:	89 d3                	mov    %edx,%ebx
c002470b:	c1 fb 1f             	sar    $0x1f,%ebx
c002470e:	89 c7                	mov    %eax,%edi
c0024710:	c1 ff 1f             	sar    $0x1f,%edi
c0024713:	89 dd                	mov    %ebx,%ebp
c0024715:	0f af e8             	imul   %eax,%ebp
c0024718:	89 fe                	mov    %edi,%esi
c002471a:	0f af f2             	imul   %edx,%esi
c002471d:	01 ee                	add    %ebp,%esi
c002471f:	f7 e2                	mul    %edx
c0024721:	01 f2                	add    %esi,%edx
c0024723:	89 d6                	mov    %edx,%esi
c0024725:	c1 fe 1f             	sar    $0x1f,%esi
c0024728:	81 e6 ff 3f 00 00    	and    $0x3fff,%esi
c002472e:	bb 00 00 00 00       	mov    $0x0,%ebx
c0024733:	01 f0                	add    %esi,%eax
c0024735:	11 da                	adc    %ebx,%edx
c0024737:	0f ac d0 0e          	shrd   $0xe,%edx,%eax
c002473b:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c002473f:	89 03                	mov    %eax,(%ebx)
    return res;
}
c0024741:	89 d8                	mov    %ebx,%eax
c0024743:	5b                   	pop    %ebx
c0024744:	5e                   	pop    %esi
c0024745:	5f                   	pop    %edi
c0024746:	5d                   	pop    %ebp
c0024747:	c2 04 00             	ret    $0x4

c002474a <float32_mul_int>:

struct float32 float32_mul_int(struct float32 a, int32_t b)
{
c002474a:	8b 44 24 04          	mov    0x4(%esp),%eax
    struct float32 res = {a.num * b};
c002474e:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0024752:	0f af 54 24 08       	imul   0x8(%esp),%edx
    return res;
c0024757:	89 10                	mov    %edx,(%eax)
}
c0024759:	c2 04 00             	ret    $0x4

c002475c <float32_div>:

struct float32 float32_div(struct float32 a, struct float32 b)
{
c002475c:	57                   	push   %edi
c002475d:	56                   	push   %esi
c002475e:	53                   	push   %ebx
c002475f:	e8 92 dd 00 00       	call   c00324f6 <__x86.get_pc_thunk.di>
c0024764:	81 c7 d8 c4 01 00    	add    $0x1c4d8,%edi
c002476a:	8b 74 24 10          	mov    0x10(%esp),%esi
    struct float32 res = {(int64_t)a.num * F / b.num};
c002476e:	8b 44 24 14          	mov    0x14(%esp),%eax
c0024772:	89 c3                	mov    %eax,%ebx
c0024774:	c1 fb 1f             	sar    $0x1f,%ebx
c0024777:	89 da                	mov    %ebx,%edx
c0024779:	0f a4 c2 0e          	shld   $0xe,%eax,%edx
c002477d:	c1 e0 0e             	shl    $0xe,%eax
c0024780:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c0024784:	89 cb                	mov    %ecx,%ebx
c0024786:	c1 fb 1f             	sar    $0x1f,%ebx
c0024789:	53                   	push   %ebx
c002478a:	51                   	push   %ecx
c002478b:	52                   	push   %edx
c002478c:	50                   	push   %eax
c002478d:	89 fb                	mov    %edi,%ebx
c002478f:	e8 c4 4a 00 00       	call   c0029258 <__divdi3>
c0024794:	83 c4 10             	add    $0x10,%esp
c0024797:	89 06                	mov    %eax,(%esi)
    return res;
}
c0024799:	89 f0                	mov    %esi,%eax
c002479b:	5b                   	pop    %ebx
c002479c:	5e                   	pop    %esi
c002479d:	5f                   	pop    %edi
c002479e:	c2 04 00             	ret    $0x4

c00247a1 <float32_div_int>:

struct float32 float32_div_int(struct float32 a, int32_t b)
{
c00247a1:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c00247a5:	8b 44 24 08          	mov    0x8(%esp),%eax
    struct float32 res = {a.num / b};
c00247a9:	99                   	cltd   
c00247aa:	f7 7c 24 0c          	idivl  0xc(%esp)
    return res;
c00247ae:	89 01                	mov    %eax,(%ecx)
}
c00247b0:	89 c8                	mov    %ecx,%eax
c00247b2:	c2 04 00             	ret    $0x4

c00247b5 <float32_div_int2>:

struct float32 float32_div_int2(int32_t a, int32_t b)
{
c00247b5:	8b 4c 24 04          	mov    0x4(%esp),%ecx
    struct float32 res = {a * F / b};
c00247b9:	8b 44 24 08          	mov    0x8(%esp),%eax
c00247bd:	c1 e0 0e             	shl    $0xe,%eax
c00247c0:	99                   	cltd   
c00247c1:	f7 7c 24 0c          	idivl  0xc(%esp)
    return res;
c00247c5:	89 01                	mov    %eax,(%ecx)
}
c00247c7:	89 c8                	mov    %ecx,%eax
c00247c9:	c2 04 00             	ret    $0x4

c00247cc <float32_less>:

/* Compare two float32, return true if the first argument less then second argument */
bool float32_less(struct float32 a, struct float32 b)
{
    return a.num < b.num;
c00247cc:	8b 44 24 08          	mov    0x8(%esp),%eax
c00247d0:	39 44 24 04          	cmp    %eax,0x4(%esp)
c00247d4:	0f 9c c0             	setl   %al
c00247d7:	c3                   	ret    

c00247d8 <pit_configure_channel>:

     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void pit_configure_channel(int channel, int mode, int frequency)
{
c00247d8:	55                   	push   %ebp
c00247d9:	57                   	push   %edi
c00247da:	56                   	push   %esi
c00247db:	53                   	push   %ebx
c00247dc:	83 ec 0c             	sub    $0xc,%esp
c00247df:	e8 02 dd 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00247e4:	81 c3 58 c4 01 00    	add    $0x1c458,%ebx
c00247ea:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c00247ee:	8b 7c 24 24          	mov    0x24(%esp),%edi
c00247f2:	8b 4c 24 28          	mov    0x28(%esp),%ecx
  uint16_t count;
  enum intr_level old_level;

  ASSERT(channel == 0 || channel == 2);
c00247f6:	f7 c5 fd ff ff ff    	test   $0xfffffffd,%ebp
c00247fc:	75 6a                	jne    c0024868 <pit_configure_channel+0x90>
  ASSERT(mode == 2 || mode == 3);
c00247fe:	8d 47 fe             	lea    -0x2(%edi),%eax
c0024801:	83 f8 01             	cmp    $0x1,%eax
c0024804:	0f 87 84 00 00 00    	ja     c002488e <pit_configure_channel+0xb6>
  {
    /* Frequency is too low: the quotient would overflow the
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
    count = 0;
c002480a:	be 00 00 00 00       	mov    $0x0,%esi
  if (frequency < 19)
c002480f:	83 f9 12             	cmp    $0x12,%ecx
c0024812:	7e 20                	jle    c0024834 <pit_configure_channel+0x5c>
    /* Frequency is too high: the quotient would underflow to
         0, which the PIT would interpret as 65536.  A count of 1
         is illegal in mode 2, so we force it to 2, which yields
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
    count = 2;
c0024814:	be 02 00 00 00       	mov    $0x2,%esi
  else if (frequency > PIT_HZ)
c0024819:	81 f9 dc 34 12 00    	cmp    $0x1234dc,%ecx
c002481f:	7f 13                	jg     c0024834 <pit_configure_channel+0x5c>
  }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c0024821:	89 c8                	mov    %ecx,%eax
c0024823:	c1 e8 1f             	shr    $0x1f,%eax
c0024826:	01 c8                	add    %ecx,%eax
c0024828:	d1 f8                	sar    %eax
c002482a:	05 dc 34 12 00       	add    $0x1234dc,%eax
c002482f:	99                   	cltd   
c0024830:	f7 f9                	idiv   %ecx
c0024832:	89 c6                	mov    %eax,%esi

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable();
c0024834:	e8 72 d7 ff ff       	call   c0021fab <intr_disable>
c0024839:	89 c1                	mov    %eax,%ecx
  outb(PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c002483b:	8d 04 3f             	lea    (%edi,%edi,1),%eax
c002483e:	83 c8 30             	or     $0x30,%eax
c0024841:	89 ef                	mov    %ebp,%edi
c0024843:	c1 e7 06             	shl    $0x6,%edi
c0024846:	09 f8                	or     %edi,%eax
c0024848:	e6 43                	out    %al,$0x43
  outb(PIT_PORT_COUNTER(channel), count);
c002484a:	8d 55 40             	lea    0x40(%ebp),%edx
c002484d:	89 f0                	mov    %esi,%eax
c002484f:	ee                   	out    %al,(%dx)
  outb(PIT_PORT_COUNTER(channel), count >> 8);
c0024850:	89 f0                	mov    %esi,%eax
c0024852:	66 c1 e8 08          	shr    $0x8,%ax
c0024856:	ee                   	out    %al,(%dx)
  intr_set_level(old_level);
c0024857:	83 ec 0c             	sub    $0xc,%esp
c002485a:	51                   	push   %ecx
c002485b:	e8 52 d7 ff ff       	call   c0021fb2 <intr_set_level>
}
c0024860:	83 c4 1c             	add    $0x1c,%esp
c0024863:	5b                   	pop    %ebx
c0024864:	5e                   	pop    %esi
c0024865:	5f                   	pop    %edi
c0024866:	5d                   	pop    %ebp
c0024867:	c3                   	ret    
  ASSERT(channel == 0 || channel == 2);
c0024868:	83 ec 0c             	sub    $0xc,%esp
c002486b:	8d 83 c7 3a ff ff    	lea    -0xc539(%ebx),%eax
c0024871:	50                   	push   %eax
c0024872:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0024878:	50                   	push   %eax
c0024879:	8d 83 30 1c ff ff    	lea    -0xe3d0(%ebx),%eax
c002487f:	50                   	push   %eax
c0024880:	6a 32                	push   $0x32
c0024882:	8d 83 e4 3a ff ff    	lea    -0xc51c(%ebx),%eax
c0024888:	50                   	push   %eax
c0024889:	e8 07 50 00 00       	call   c0029895 <debug_panic>
  ASSERT(mode == 2 || mode == 3);
c002488e:	83 ec 0c             	sub    $0xc,%esp
c0024891:	8d 83 f8 3a ff ff    	lea    -0xc508(%ebx),%eax
c0024897:	50                   	push   %eax
c0024898:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002489e:	50                   	push   %eax
c002489f:	8d 83 30 1c ff ff    	lea    -0xe3d0(%ebx),%eax
c00248a5:	50                   	push   %eax
c00248a6:	6a 33                	push   $0x33
c00248a8:	8d 83 e4 3a ff ff    	lea    -0xc51c(%ebx),%eax
c00248ae:	50                   	push   %eax
c00248af:	e8 e1 4f 00 00       	call   c0029895 <debug_panic>

c00248b4 <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait(int64_t loops)
{
c00248b4:	53                   	push   %ebx
  while (loops-- > 0)
c00248b5:	89 c1                	mov    %eax,%ecx
c00248b7:	89 d3                	mov    %edx,%ebx
c00248b9:	83 c1 ff             	add    $0xffffffff,%ecx
c00248bc:	83 d3 ff             	adc    $0xffffffff,%ebx
c00248bf:	85 d2                	test   %edx,%edx
c00248c1:	78 13                	js     c00248d6 <busy_wait+0x22>
c00248c3:	85 d2                	test   %edx,%edx
c00248c5:	7e 11                	jle    c00248d8 <busy_wait+0x24>
c00248c7:	83 c1 ff             	add    $0xffffffff,%ecx
c00248ca:	83 d3 ff             	adc    $0xffffffff,%ebx
c00248cd:	89 d8                	mov    %ebx,%eax
c00248cf:	21 c8                	and    %ecx,%eax
c00248d1:	83 f8 ff             	cmp    $0xffffffff,%eax
c00248d4:	75 f1                	jne    c00248c7 <busy_wait+0x13>
    barrier();
}
c00248d6:	5b                   	pop    %ebx
c00248d7:	c3                   	ret    
  while (loops-- > 0)
c00248d8:	83 f8 00             	cmp    $0x0,%eax
c00248db:	76 f9                	jbe    c00248d6 <busy_wait+0x22>
c00248dd:	eb e8                	jmp    c00248c7 <busy_wait+0x13>

c00248df <too_many_loops>:
{
c00248df:	55                   	push   %ebp
c00248e0:	57                   	push   %edi
c00248e1:	56                   	push   %esi
c00248e2:	53                   	push   %ebx
c00248e3:	83 ec 0c             	sub    $0xc,%esp
c00248e6:	e8 fb db 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00248eb:	81 c3 51 c3 01 00    	add    $0x1c351,%ebx
c00248f1:	89 44 24 04          	mov    %eax,0x4(%esp)
  int64_t start = ticks;
c00248f5:	8b ab a4 19 00 00    	mov    0x19a4(%ebx),%ebp
c00248fb:	8b 8b a8 19 00 00    	mov    0x19a8(%ebx),%ecx
  while (ticks == start)
c0024901:	8b bb a4 19 00 00    	mov    0x19a4(%ebx),%edi
c0024907:	8b b3 a8 19 00 00    	mov    0x19a8(%ebx),%esi
c002490d:	89 f8                	mov    %edi,%eax
c002490f:	31 e8                	xor    %ebp,%eax
c0024911:	89 f2                	mov    %esi,%edx
c0024913:	31 ca                	xor    %ecx,%edx
c0024915:	09 c2                	or     %eax,%edx
c0024917:	74 e8                	je     c0024901 <too_many_loops+0x22>
  busy_wait(loops);
c0024919:	8b 44 24 04          	mov    0x4(%esp),%eax
c002491d:	ba 00 00 00 00       	mov    $0x0,%edx
c0024922:	e8 8d ff ff ff       	call   c00248b4 <busy_wait>
  return start != ticks;
c0024927:	33 bb a4 19 00 00    	xor    0x19a4(%ebx),%edi
c002492d:	33 b3 a8 19 00 00    	xor    0x19a8(%ebx),%esi
c0024933:	09 f7                	or     %esi,%edi
c0024935:	0f 95 c0             	setne  %al
}
c0024938:	83 c4 0c             	add    $0xc,%esp
c002493b:	5b                   	pop    %ebx
c002493c:	5e                   	pop    %esi
c002493d:	5f                   	pop    %edi
c002493e:	5d                   	pop    %ebp
c002493f:	c3                   	ret    

c0024940 <real_time_delay>:
}

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay(int64_t num, int32_t denom)
{
c0024940:	55                   	push   %ebp
c0024941:	57                   	push   %edi
c0024942:	56                   	push   %esi
c0024943:	53                   	push   %ebx
c0024944:	83 ec 0c             	sub    $0xc,%esp
c0024947:	e8 aa db 00 00       	call   c00324f6 <__x86.get_pc_thunk.di>
c002494c:	81 c7 f0 c2 01 00    	add    $0x1c2f0,%edi
c0024952:	89 c5                	mov    %eax,%ebp
c0024954:	89 d3                	mov    %edx,%ebx
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT(denom % 1000 == 0);
c0024956:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c002495b:	89 c8                	mov    %ecx,%eax
c002495d:	f7 ea                	imul   %edx
c002495f:	c1 fa 06             	sar    $0x6,%edx
c0024962:	89 c8                	mov    %ecx,%eax
c0024964:	c1 f8 1f             	sar    $0x1f,%eax
c0024967:	29 c2                	sub    %eax,%edx
c0024969:	69 d2 e8 03 00 00    	imul   $0x3e8,%edx,%edx
c002496f:	39 d1                	cmp    %edx,%ecx
c0024971:	75 61                	jne    c00249d4 <real_time_delay+0x94>
c0024973:	89 ce                	mov    %ecx,%esi
  busy_wait(loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000));
c0024975:	8b 87 9c 19 00 00    	mov    0x199c(%edi),%eax
c002497b:	0f af d8             	imul   %eax,%ebx
c002497e:	f7 e5                	mul    %ebp
c0024980:	01 da                	add    %ebx,%edx
c0024982:	6a 00                	push   $0x0
c0024984:	68 e8 03 00 00       	push   $0x3e8
c0024989:	52                   	push   %edx
c002498a:	50                   	push   %eax
c002498b:	89 fb                	mov    %edi,%ebx
c002498d:	e8 c6 48 00 00       	call   c0029258 <__divdi3>
c0024992:	83 c4 10             	add    $0x10,%esp
c0024995:	6b ea 64             	imul   $0x64,%edx,%ebp
c0024998:	b9 64 00 00 00       	mov    $0x64,%ecx
c002499d:	f7 e1                	mul    %ecx
c002499f:	89 c1                	mov    %eax,%ecx
c00249a1:	89 d3                	mov    %edx,%ebx
c00249a3:	01 eb                	add    %ebp,%ebx
c00249a5:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c00249aa:	89 f0                	mov    %esi,%eax
c00249ac:	f7 ea                	imul   %edx
c00249ae:	c1 fa 06             	sar    $0x6,%edx
c00249b1:	c1 fe 1f             	sar    $0x1f,%esi
c00249b4:	29 f2                	sub    %esi,%edx
c00249b6:	89 d0                	mov    %edx,%eax
c00249b8:	99                   	cltd   
c00249b9:	52                   	push   %edx
c00249ba:	50                   	push   %eax
c00249bb:	53                   	push   %ebx
c00249bc:	51                   	push   %ecx
c00249bd:	89 fb                	mov    %edi,%ebx
c00249bf:	e8 94 48 00 00       	call   c0029258 <__divdi3>
c00249c4:	83 c4 10             	add    $0x10,%esp
c00249c7:	e8 e8 fe ff ff       	call   c00248b4 <busy_wait>
}
c00249cc:	83 c4 0c             	add    $0xc,%esp
c00249cf:	5b                   	pop    %ebx
c00249d0:	5e                   	pop    %esi
c00249d1:	5f                   	pop    %edi
c00249d2:	5d                   	pop    %ebp
c00249d3:	c3                   	ret    
  ASSERT(denom % 1000 == 0);
c00249d4:	83 ec 0c             	sub    $0xc,%esp
c00249d7:	8d 87 0f 3b ff ff    	lea    -0xc4f1(%edi),%eax
c00249dd:	50                   	push   %eax
c00249de:	8d 87 fc 2c ff ff    	lea    -0xd304(%edi),%eax
c00249e4:	50                   	push   %eax
c00249e5:	8d 87 48 1c ff ff    	lea    -0xe3b8(%edi),%eax
c00249eb:	50                   	push   %eax
c00249ec:	68 f1 00 00 00       	push   $0xf1
c00249f1:	8d 87 21 3b ff ff    	lea    -0xc4df(%edi),%eax
c00249f7:	50                   	push   %eax
c00249f8:	89 fb                	mov    %edi,%ebx
c00249fa:	e8 96 4e 00 00       	call   c0029895 <debug_panic>

c00249ff <timer_init>:
{
c00249ff:	53                   	push   %ebx
c0024a00:	83 ec 0c             	sub    $0xc,%esp
c0024a03:	e8 de da 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0024a08:	81 c3 34 c2 01 00    	add    $0x1c234,%ebx
  pit_configure_channel(0, 2, TIMER_FREQ);
c0024a0e:	6a 64                	push   $0x64
c0024a10:	6a 02                	push   $0x2
c0024a12:	6a 00                	push   $0x0
c0024a14:	e8 bf fd ff ff       	call   c00247d8 <pit_configure_channel>
  intr_register_ext(0x20, timer_interrupt, "8254 Timer");
c0024a19:	83 c4 0c             	add    $0xc,%esp
c0024a1c:	8d 83 37 3b ff ff    	lea    -0xc4c9(%ebx),%eax
c0024a22:	50                   	push   %eax
c0024a23:	8d 83 1b 3f fe ff    	lea    -0x1c0e5(%ebx),%eax
c0024a29:	50                   	push   %eax
c0024a2a:	6a 20                	push   $0x20
c0024a2c:	e8 54 d7 ff ff       	call   c0022185 <intr_register_ext>
}
c0024a31:	83 c4 18             	add    $0x18,%esp
c0024a34:	5b                   	pop    %ebx
c0024a35:	c3                   	ret    

c0024a36 <timer_calibrate>:
{
c0024a36:	55                   	push   %ebp
c0024a37:	57                   	push   %edi
c0024a38:	56                   	push   %esi
c0024a39:	53                   	push   %ebx
c0024a3a:	83 ec 0c             	sub    $0xc,%esp
c0024a3d:	e8 a4 da 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0024a42:	81 c3 fa c1 01 00    	add    $0x1c1fa,%ebx
  ASSERT(intr_get_level() == INTR_ON);
c0024a48:	e8 0c d5 ff ff       	call   c0021f59 <intr_get_level>
c0024a4d:	83 f8 01             	cmp    $0x1,%eax
c0024a50:	75 60                	jne    c0024ab2 <timer_calibrate+0x7c>
  printf("Calibrating timer...  ");
c0024a52:	83 ec 0c             	sub    $0xc,%esp
c0024a55:	8d 83 5e 3b ff ff    	lea    -0xc4a2(%ebx),%eax
c0024a5b:	50                   	push   %eax
c0024a5c:	e8 9d 30 00 00       	call   c0027afe <printf>
  loops_per_tick = 1u << 10;
c0024a61:	c7 83 9c 19 00 00 00 	movl   $0x400,0x199c(%ebx)
c0024a68:	04 00 00 
  while (!too_many_loops(loops_per_tick << 1))
c0024a6b:	83 c4 10             	add    $0x10,%esp
c0024a6e:	8b bb 9c 19 00 00    	mov    0x199c(%ebx),%edi
c0024a74:	8d 34 3f             	lea    (%edi,%edi,1),%esi
c0024a77:	89 f0                	mov    %esi,%eax
c0024a79:	e8 61 fe ff ff       	call   c00248df <too_many_loops>
c0024a7e:	84 c0                	test   %al,%al
c0024a80:	75 56                	jne    c0024ad8 <timer_calibrate+0xa2>
    loops_per_tick <<= 1;
c0024a82:	89 b3 9c 19 00 00    	mov    %esi,0x199c(%ebx)
    ASSERT(loops_per_tick != 0);
c0024a88:	85 f6                	test   %esi,%esi
c0024a8a:	75 e2                	jne    c0024a6e <timer_calibrate+0x38>
c0024a8c:	83 ec 0c             	sub    $0xc,%esp
c0024a8f:	8d 83 75 3b ff ff    	lea    -0xc48b(%ebx),%eax
c0024a95:	50                   	push   %eax
c0024a96:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0024a9c:	50                   	push   %eax
c0024a9d:	8d 83 74 1c ff ff    	lea    -0xe38c(%ebx),%eax
c0024aa3:	50                   	push   %eax
c0024aa4:	6a 37                	push   $0x37
c0024aa6:	8d 83 21 3b ff ff    	lea    -0xc4df(%ebx),%eax
c0024aac:	50                   	push   %eax
c0024aad:	e8 e3 4d 00 00       	call   c0029895 <debug_panic>
  ASSERT(intr_get_level() == INTR_ON);
c0024ab2:	83 ec 0c             	sub    $0xc,%esp
c0024ab5:	8d 83 42 3b ff ff    	lea    -0xc4be(%ebx),%eax
c0024abb:	50                   	push   %eax
c0024abc:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0024ac2:	50                   	push   %eax
c0024ac3:	8d 83 74 1c ff ff    	lea    -0xe38c(%ebx),%eax
c0024ac9:	50                   	push   %eax
c0024aca:	6a 2e                	push   $0x2e
c0024acc:	8d 83 21 3b ff ff    	lea    -0xc4df(%ebx),%eax
c0024ad2:	50                   	push   %eax
c0024ad3:	e8 bd 4d 00 00       	call   c0029895 <debug_panic>
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0024ad8:	89 fe                	mov    %edi,%esi
c0024ada:	d1 ee                	shr    %esi
c0024adc:	89 fd                	mov    %edi,%ebp
c0024ade:	c1 ed 0a             	shr    $0xa,%ebp
c0024ae1:	39 f5                	cmp    %esi,%ebp
c0024ae3:	75 2a                	jne    c0024b0f <timer_calibrate+0xd9>
  printf("%'" PRIu64 " loops/s.\n", (uint64_t)loops_per_tick * TIMER_FREQ);
c0024ae5:	83 ec 04             	sub    $0x4,%esp
c0024ae8:	b8 64 00 00 00       	mov    $0x64,%eax
c0024aed:	f7 a3 9c 19 00 00    	mull   0x199c(%ebx)
c0024af3:	52                   	push   %edx
c0024af4:	50                   	push   %eax
c0024af5:	8d 83 89 3b ff ff    	lea    -0xc477(%ebx),%eax
c0024afb:	50                   	push   %eax
c0024afc:	e8 fd 2f 00 00       	call   c0027afe <printf>
}
c0024b01:	83 c4 1c             	add    $0x1c,%esp
c0024b04:	5b                   	pop    %ebx
c0024b05:	5e                   	pop    %esi
c0024b06:	5f                   	pop    %edi
c0024b07:	5d                   	pop    %ebp
c0024b08:	c3                   	ret    
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c0024b09:	d1 ee                	shr    %esi
c0024b0b:	39 f5                	cmp    %esi,%ebp
c0024b0d:	74 d6                	je     c0024ae5 <timer_calibrate+0xaf>
    if (!too_many_loops(high_bit | test_bit))
c0024b0f:	89 f8                	mov    %edi,%eax
c0024b11:	09 f0                	or     %esi,%eax
c0024b13:	e8 c7 fd ff ff       	call   c00248df <too_many_loops>
c0024b18:	84 c0                	test   %al,%al
c0024b1a:	75 ed                	jne    c0024b09 <timer_calibrate+0xd3>
      loops_per_tick |= test_bit;
c0024b1c:	09 b3 9c 19 00 00    	or     %esi,0x199c(%ebx)
c0024b22:	eb e5                	jmp    c0024b09 <timer_calibrate+0xd3>

c0024b24 <timer_ticks>:
{
c0024b24:	57                   	push   %edi
c0024b25:	56                   	push   %esi
c0024b26:	53                   	push   %ebx
c0024b27:	e8 ba d9 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0024b2c:	81 c3 10 c1 01 00    	add    $0x1c110,%ebx
  enum intr_level old_level = intr_disable();
c0024b32:	e8 74 d4 ff ff       	call   c0021fab <intr_disable>
  int64_t t = ticks;
c0024b37:	8b b3 a4 19 00 00    	mov    0x19a4(%ebx),%esi
c0024b3d:	8b bb a8 19 00 00    	mov    0x19a8(%ebx),%edi
  intr_set_level(old_level);
c0024b43:	83 ec 0c             	sub    $0xc,%esp
c0024b46:	50                   	push   %eax
c0024b47:	e8 66 d4 ff ff       	call   c0021fb2 <intr_set_level>
  return t;
c0024b4c:	83 c4 10             	add    $0x10,%esp
}
c0024b4f:	89 f0                	mov    %esi,%eax
c0024b51:	89 fa                	mov    %edi,%edx
c0024b53:	5b                   	pop    %ebx
c0024b54:	5e                   	pop    %esi
c0024b55:	5f                   	pop    %edi
c0024b56:	c3                   	ret    

c0024b57 <timer_interrupt>:
{
c0024b57:	53                   	push   %ebx
c0024b58:	83 ec 08             	sub    $0x8,%esp
c0024b5b:	e8 86 d9 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0024b60:	81 c3 dc c0 01 00    	add    $0x1c0dc,%ebx
  ticks++;
c0024b66:	83 83 a4 19 00 00 01 	addl   $0x1,0x19a4(%ebx)
c0024b6d:	83 93 a8 19 00 00 00 	adcl   $0x0,0x19a8(%ebx)
  thread_tick();
c0024b74:	e8 4a c5 ff ff       	call   c00210c3 <thread_tick>
  thread_timer(timer_ticks() % TIMER_FREQ == 0);
c0024b79:	e8 a6 ff ff ff       	call   c0024b24 <timer_ticks>
c0024b7e:	83 ec 10             	sub    $0x10,%esp
c0024b81:	6a 00                	push   $0x0
c0024b83:	6a 64                	push   $0x64
c0024b85:	52                   	push   %edx
c0024b86:	50                   	push   %eax
c0024b87:	e8 e8 46 00 00       	call   c0029274 <__moddi3>
c0024b8c:	83 c4 14             	add    $0x14,%esp
c0024b8f:	09 d0                	or     %edx,%eax
c0024b91:	0f 94 c0             	sete   %al
c0024b94:	0f b6 c0             	movzbl %al,%eax
c0024b97:	50                   	push   %eax
c0024b98:	e8 53 cf ff ff       	call   c0021af0 <thread_timer>
}
c0024b9d:	83 c4 18             	add    $0x18,%esp
c0024ba0:	5b                   	pop    %ebx
c0024ba1:	c3                   	ret    

c0024ba2 <timer_elapsed>:
{
c0024ba2:	57                   	push   %edi
c0024ba3:	56                   	push   %esi
c0024ba4:	83 ec 04             	sub    $0x4,%esp
c0024ba7:	8b 74 24 10          	mov    0x10(%esp),%esi
c0024bab:	8b 7c 24 14          	mov    0x14(%esp),%edi
  return timer_ticks() - then;
c0024baf:	e8 70 ff ff ff       	call   c0024b24 <timer_ticks>
c0024bb4:	29 f0                	sub    %esi,%eax
c0024bb6:	19 fa                	sbb    %edi,%edx
}
c0024bb8:	83 c4 04             	add    $0x4,%esp
c0024bbb:	5e                   	pop    %esi
c0024bbc:	5f                   	pop    %edi
c0024bbd:	c3                   	ret    

c0024bbe <timer_sleep>:
{
c0024bbe:	57                   	push   %edi
c0024bbf:	56                   	push   %esi
c0024bc0:	53                   	push   %ebx
c0024bc1:	e8 20 d9 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0024bc6:	81 c3 76 c0 01 00    	add    $0x1c076,%ebx
c0024bcc:	8b 7c 24 10          	mov    0x10(%esp),%edi
c0024bd0:	8b 74 24 14          	mov    0x14(%esp),%esi
  if (ticks <= 0)
c0024bd4:	85 f6                	test   %esi,%esi
c0024bd6:	78 31                	js     c0024c09 <timer_sleep+0x4b>
c0024bd8:	85 f6                	test   %esi,%esi
c0024bda:	7e 31                	jle    c0024c0d <timer_sleep+0x4f>
  ASSERT(intr_get_level() == INTR_ON);
c0024bdc:	e8 78 d3 ff ff       	call   c0021f59 <intr_get_level>
c0024be1:	83 f8 01             	cmp    $0x1,%eax
c0024be4:	75 2e                	jne    c0024c14 <timer_sleep+0x56>
  struct thread *cur = thread_current();
c0024be6:	e8 5a c4 ff ff       	call   c0021045 <thread_current>
  cur->sleep_ticks = ticks;
c0024beb:	89 78 40             	mov    %edi,0x40(%eax)
c0024bee:	89 70 44             	mov    %esi,0x44(%eax)
  enum intr_level old_level = intr_disable(); // intr off to call thread_block().
c0024bf1:	e8 b5 d3 ff ff       	call   c0021fab <intr_disable>
c0024bf6:	89 c6                	mov    %eax,%esi
  thread_block();
c0024bf8:	e8 bd c9 ff ff       	call   c00215ba <thread_block>
  intr_set_level(old_level); // restore the original level.
c0024bfd:	83 ec 0c             	sub    $0xc,%esp
c0024c00:	56                   	push   %esi
c0024c01:	e8 ac d3 ff ff       	call   c0021fb2 <intr_set_level>
c0024c06:	83 c4 10             	add    $0x10,%esp
}
c0024c09:	5b                   	pop    %ebx
c0024c0a:	5e                   	pop    %esi
c0024c0b:	5f                   	pop    %edi
c0024c0c:	c3                   	ret    
  if (ticks <= 0)
c0024c0d:	83 ff 00             	cmp    $0x0,%edi
c0024c10:	76 f7                	jbe    c0024c09 <timer_sleep+0x4b>
c0024c12:	eb c8                	jmp    c0024bdc <timer_sleep+0x1e>
  ASSERT(intr_get_level() == INTR_ON);
c0024c14:	83 ec 0c             	sub    $0xc,%esp
c0024c17:	8d 83 42 3b ff ff    	lea    -0xc4be(%ebx),%eax
c0024c1d:	50                   	push   %eax
c0024c1e:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0024c24:	50                   	push   %eax
c0024c25:	8d 83 68 1c ff ff    	lea    -0xe398(%ebx),%eax
c0024c2b:	50                   	push   %eax
c0024c2c:	6a 5b                	push   $0x5b
c0024c2e:	8d 83 21 3b ff ff    	lea    -0xc4df(%ebx),%eax
c0024c34:	50                   	push   %eax
c0024c35:	e8 5b 4c 00 00       	call   c0029895 <debug_panic>

c0024c3a <real_time_sleep>:
{
c0024c3a:	55                   	push   %ebp
c0024c3b:	57                   	push   %edi
c0024c3c:	56                   	push   %esi
c0024c3d:	53                   	push   %ebx
c0024c3e:	83 ec 1c             	sub    $0x1c,%esp
c0024c41:	e8 a0 d8 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0024c46:	81 c3 f6 bf 01 00    	add    $0x1bff6,%ebx
c0024c4c:	89 c6                	mov    %eax,%esi
c0024c4e:	89 44 24 08          	mov    %eax,0x8(%esp)
c0024c52:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0024c56:	89 cd                	mov    %ecx,%ebp
  int64_t ticks = num * TIMER_FREQ / denom;
c0024c58:	6b ca 64             	imul   $0x64,%edx,%ecx
c0024c5b:	b8 64 00 00 00       	mov    $0x64,%eax
c0024c60:	f7 e6                	mul    %esi
c0024c62:	01 ca                	add    %ecx,%edx
c0024c64:	89 ef                	mov    %ebp,%edi
c0024c66:	c1 ff 1f             	sar    $0x1f,%edi
c0024c69:	57                   	push   %edi
c0024c6a:	55                   	push   %ebp
c0024c6b:	52                   	push   %edx
c0024c6c:	50                   	push   %eax
c0024c6d:	e8 e6 45 00 00       	call   c0029258 <__divdi3>
c0024c72:	83 c4 10             	add    $0x10,%esp
c0024c75:	89 c6                	mov    %eax,%esi
c0024c77:	89 d7                	mov    %edx,%edi
  ASSERT(intr_get_level() == INTR_ON);
c0024c79:	e8 db d2 ff ff       	call   c0021f59 <intr_get_level>
c0024c7e:	83 f8 01             	cmp    $0x1,%eax
c0024c81:	75 1d                	jne    c0024ca0 <real_time_sleep+0x66>
  if (ticks > 0)
c0024c83:	85 ff                	test   %edi,%edi
c0024c85:	78 47                	js     c0024cce <real_time_sleep+0x94>
c0024c87:	85 ff                	test   %edi,%edi
c0024c89:	7e 3e                	jle    c0024cc9 <real_time_sleep+0x8f>
    timer_sleep(ticks);
c0024c8b:	83 ec 08             	sub    $0x8,%esp
c0024c8e:	57                   	push   %edi
c0024c8f:	56                   	push   %esi
c0024c90:	e8 29 ff ff ff       	call   c0024bbe <timer_sleep>
c0024c95:	83 c4 10             	add    $0x10,%esp
}
c0024c98:	83 c4 1c             	add    $0x1c,%esp
c0024c9b:	5b                   	pop    %ebx
c0024c9c:	5e                   	pop    %esi
c0024c9d:	5f                   	pop    %edi
c0024c9e:	5d                   	pop    %ebp
c0024c9f:	c3                   	ret    
  ASSERT(intr_get_level() == INTR_ON);
c0024ca0:	83 ec 0c             	sub    $0xc,%esp
c0024ca3:	8d 83 42 3b ff ff    	lea    -0xc4be(%ebx),%eax
c0024ca9:	50                   	push   %eax
c0024caa:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0024cb0:	50                   	push   %eax
c0024cb1:	8d 83 58 1c ff ff    	lea    -0xe3a8(%ebx),%eax
c0024cb7:	50                   	push   %eax
c0024cb8:	68 db 00 00 00       	push   $0xdb
c0024cbd:	8d 83 21 3b ff ff    	lea    -0xc4df(%ebx),%eax
c0024cc3:	50                   	push   %eax
c0024cc4:	e8 cc 4b 00 00       	call   c0029895 <debug_panic>
  if (ticks > 0)
c0024cc9:	83 fe 00             	cmp    $0x0,%esi
c0024ccc:	77 bd                	ja     c0024c8b <real_time_sleep+0x51>
    real_time_delay(num, denom);
c0024cce:	89 e9                	mov    %ebp,%ecx
c0024cd0:	8b 44 24 08          	mov    0x8(%esp),%eax
c0024cd4:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0024cd8:	e8 63 fc ff ff       	call   c0024940 <real_time_delay>
}
c0024cdd:	eb b9                	jmp    c0024c98 <real_time_sleep+0x5e>

c0024cdf <timer_msleep>:
{
c0024cdf:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep(ms, 1000);
c0024ce2:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0024ce7:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024ceb:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024cef:	e8 46 ff ff ff       	call   c0024c3a <real_time_sleep>
}
c0024cf4:	83 c4 0c             	add    $0xc,%esp
c0024cf7:	c3                   	ret    

c0024cf8 <timer_usleep>:
{
c0024cf8:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep(us, 1000 * 1000);
c0024cfb:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c0024d00:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024d04:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024d08:	e8 2d ff ff ff       	call   c0024c3a <real_time_sleep>
}
c0024d0d:	83 c4 0c             	add    $0xc,%esp
c0024d10:	c3                   	ret    

c0024d11 <timer_nsleep>:
{
c0024d11:	83 ec 0c             	sub    $0xc,%esp
  real_time_sleep(ns, 1000 * 1000 * 1000);
c0024d14:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c0024d19:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024d1d:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024d21:	e8 14 ff ff ff       	call   c0024c3a <real_time_sleep>
}
c0024d26:	83 c4 0c             	add    $0xc,%esp
c0024d29:	c3                   	ret    

c0024d2a <timer_mdelay>:
{
c0024d2a:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay(ms, 1000);
c0024d2d:	b9 e8 03 00 00       	mov    $0x3e8,%ecx
c0024d32:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024d36:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024d3a:	e8 01 fc ff ff       	call   c0024940 <real_time_delay>
}
c0024d3f:	83 c4 0c             	add    $0xc,%esp
c0024d42:	c3                   	ret    

c0024d43 <timer_udelay>:
{
c0024d43:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay(us, 1000 * 1000);
c0024d46:	b9 40 42 0f 00       	mov    $0xf4240,%ecx
c0024d4b:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024d4f:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024d53:	e8 e8 fb ff ff       	call   c0024940 <real_time_delay>
}
c0024d58:	83 c4 0c             	add    $0xc,%esp
c0024d5b:	c3                   	ret    

c0024d5c <timer_ndelay>:
{
c0024d5c:	83 ec 0c             	sub    $0xc,%esp
  real_time_delay(ns, 1000 * 1000 * 1000);
c0024d5f:	b9 00 ca 9a 3b       	mov    $0x3b9aca00,%ecx
c0024d64:	8b 44 24 10          	mov    0x10(%esp),%eax
c0024d68:	8b 54 24 14          	mov    0x14(%esp),%edx
c0024d6c:	e8 cf fb ff ff       	call   c0024940 <real_time_delay>
}
c0024d71:	83 c4 0c             	add    $0xc,%esp
c0024d74:	c3                   	ret    

c0024d75 <timer_print_stats>:
{
c0024d75:	53                   	push   %ebx
c0024d76:	83 ec 08             	sub    $0x8,%esp
c0024d79:	e8 68 d7 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0024d7e:	81 c3 be be 01 00    	add    $0x1bebe,%ebx
  printf("Timer: %" PRId64 " ticks\n", timer_ticks());
c0024d84:	e8 9b fd ff ff       	call   c0024b24 <timer_ticks>
c0024d89:	83 ec 04             	sub    $0x4,%esp
c0024d8c:	52                   	push   %edx
c0024d8d:	50                   	push   %eax
c0024d8e:	8d 83 99 3b ff ff    	lea    -0xc467(%ebx),%eax
c0024d94:	50                   	push   %eax
c0024d95:	e8 64 2d 00 00       	call   c0027afe <printf>
}
c0024d9a:	83 c4 18             	add    $0x18,%esp
c0024d9d:	5b                   	pop    %ebx
c0024d9e:	c3                   	ret    

c0024d9f <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key(const struct keymap k[], unsigned scancode, uint8_t *c)
{
c0024d9f:	55                   	push   %ebp
c0024da0:	57                   	push   %edi
c0024da1:	56                   	push   %esi
c0024da2:	53                   	push   %ebx
c0024da3:	83 ec 04             	sub    $0x4,%esp
c0024da6:	89 0c 24             	mov    %ecx,(%esp)
  for (; k->first_scancode != 0; k++)
c0024da9:	0f b6 18             	movzbl (%eax),%ebx
c0024dac:	84 db                	test   %bl,%bl
c0024dae:	74 50                	je     c0024e00 <map_key+0x61>
c0024db0:	89 c6                	mov    %eax,%esi
    if (scancode >= k->first_scancode && scancode < k->first_scancode + strlen(k->chars))
c0024db2:	b8 00 00 00 00       	mov    $0x0,%eax
c0024db7:	eb 0a                	jmp    c0024dc3 <map_key+0x24>
  for (; k->first_scancode != 0; k++)
c0024db9:	83 c6 08             	add    $0x8,%esi
c0024dbc:	0f b6 1e             	movzbl (%esi),%ebx
c0024dbf:	84 db                	test   %bl,%bl
c0024dc1:	74 30                	je     c0024df3 <map_key+0x54>
    if (scancode >= k->first_scancode && scancode < k->first_scancode + strlen(k->chars))
c0024dc3:	0f b6 db             	movzbl %bl,%ebx
c0024dc6:	39 d3                	cmp    %edx,%ebx
c0024dc8:	77 ef                	ja     c0024db9 <map_key+0x1a>
c0024dca:	8b 6e 04             	mov    0x4(%esi),%ebp
c0024dcd:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0024dd2:	89 ef                	mov    %ebp,%edi
c0024dd4:	f2 ae                	repnz scas %es:(%edi),%al
c0024dd6:	f7 d1                	not    %ecx
c0024dd8:	8d 4c 0b ff          	lea    -0x1(%ebx,%ecx,1),%ecx
c0024ddc:	39 d1                	cmp    %edx,%ecx
c0024dde:	76 d9                	jbe    c0024db9 <map_key+0x1a>
    {
      *c = k->chars[scancode - k->first_scancode];
c0024de0:	29 da                	sub    %ebx,%edx
c0024de2:	0f b6 44 15 00       	movzbl 0x0(%ebp,%edx,1),%eax
c0024de7:	8b 3c 24             	mov    (%esp),%edi
c0024dea:	88 07                	mov    %al,(%edi)
      return true;
c0024dec:	b8 01 00 00 00       	mov    $0x1,%eax
c0024df1:	eb 05                	jmp    c0024df8 <map_key+0x59>
    }

  return false;
c0024df3:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0024df8:	83 c4 04             	add    $0x4,%esp
c0024dfb:	5b                   	pop    %ebx
c0024dfc:	5e                   	pop    %esi
c0024dfd:	5f                   	pop    %edi
c0024dfe:	5d                   	pop    %ebp
c0024dff:	c3                   	ret    
  return false;
c0024e00:	b8 00 00 00 00       	mov    $0x0,%eax
c0024e05:	eb f1                	jmp    c0024df8 <map_key+0x59>

c0024e07 <keyboard_interrupt>:
{
c0024e07:	55                   	push   %ebp
c0024e08:	57                   	push   %edi
c0024e09:	56                   	push   %esi
c0024e0a:	53                   	push   %ebx
c0024e0b:	83 ec 2c             	sub    $0x2c,%esp
c0024e0e:	e8 d3 d6 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0024e13:	81 c3 29 be 01 00    	add    $0x1be29,%ebx
  bool shift = left_shift || right_shift;
c0024e19:	ba 01 00 00 00       	mov    $0x1,%edx
c0024e1e:	80 bb ba 19 00 00 00 	cmpb   $0x0,0x19ba(%ebx)
c0024e25:	75 07                	jne    c0024e2e <keyboard_interrupt+0x27>
c0024e27:	0f b6 93 b9 19 00 00 	movzbl 0x19b9(%ebx),%edx
  bool alt = left_alt || right_alt;
c0024e2e:	bd 01 00 00 00       	mov    $0x1,%ebp
c0024e33:	80 bb b8 19 00 00 00 	cmpb   $0x0,0x19b8(%ebx)
c0024e3a:	75 07                	jne    c0024e43 <keyboard_interrupt+0x3c>
c0024e3c:	0f b6 ab b7 19 00 00 	movzbl 0x19b7(%ebx),%ebp
  bool ctrl = left_ctrl || right_ctrl;
c0024e43:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c0024e4a:	00 
c0024e4b:	80 bb b6 19 00 00 00 	cmpb   $0x0,0x19b6(%ebx)
c0024e52:	75 0b                	jne    c0024e5f <keyboard_interrupt+0x58>
c0024e54:	0f b6 83 b5 19 00 00 	movzbl 0x19b5(%ebx),%eax
c0024e5b:	89 44 24 08          	mov    %eax,0x8(%esp)
  asm volatile("inb %w1, %b0"
c0024e5f:	e4 60                	in     $0x60,%al
  code = inb(DATA_REG);
c0024e61:	0f b6 f0             	movzbl %al,%esi
  if (code == 0xe0)
c0024e64:	81 fe e0 00 00 00    	cmp    $0xe0,%esi
c0024e6a:	74 26                	je     c0024e92 <keyboard_interrupt+0x8b>
  release = (code & 0x80) != 0;
c0024e6c:	89 f7                	mov    %esi,%edi
c0024e6e:	81 e7 80 00 00 00    	and    $0x80,%edi
  code &= ~0x80u;
c0024e74:	81 e6 7f ff ff ff    	and    $0xffffff7f,%esi
  if (code == 0x3a)
c0024e7a:	83 fe 3a             	cmp    $0x3a,%esi
c0024e7d:	75 20                	jne    c0024e9f <keyboard_interrupt+0x98>
    if (!release)
c0024e7f:	85 ff                	test   %edi,%edi
c0024e81:	75 07                	jne    c0024e8a <keyboard_interrupt+0x83>
      caps_lock = !caps_lock;
c0024e83:	80 b3 b4 19 00 00 01 	xorb   $0x1,0x19b4(%ebx)
}
c0024e8a:	83 c4 2c             	add    $0x2c,%esp
c0024e8d:	5b                   	pop    %ebx
c0024e8e:	5e                   	pop    %esi
c0024e8f:	5f                   	pop    %edi
c0024e90:	5d                   	pop    %ebp
c0024e91:	c3                   	ret    
c0024e92:	e4 60                	in     $0x60,%al
    code = (code << 8) | inb(DATA_REG);
c0024e94:	0f b6 f0             	movzbl %al,%esi
c0024e97:	81 ce 00 e0 00 00    	or     $0xe000,%esi
c0024e9d:	eb cd                	jmp    c0024e6c <keyboard_interrupt+0x65>
  bool shift = left_shift || right_shift;
c0024e9f:	89 d0                	mov    %edx,%eax
c0024ea1:	83 e0 01             	and    $0x1,%eax
c0024ea4:	88 44 24 0f          	mov    %al,0xf(%esp)
  else if (map_key(invariant_keymap, code, &c) || (!shift && map_key(unshifted_keymap, code, &c)) || (shift && map_key(shifted_keymap, code, &c)))
c0024ea8:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c0024eac:	89 f2                	mov    %esi,%edx
c0024eae:	8d 83 04 59 ff ff    	lea    -0xa6fc(%ebx),%eax
c0024eb4:	e8 e6 fe ff ff       	call   c0024d9f <map_key>
c0024eb9:	84 c0                	test   %al,%al
c0024ebb:	75 57                	jne    c0024f14 <keyboard_interrupt+0x10d>
c0024ebd:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0024ec2:	74 3b                	je     c0024eff <keyboard_interrupt+0xf8>
c0024ec4:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c0024ec8:	89 f2                	mov    %esi,%edx
c0024eca:	8d 83 84 58 ff ff    	lea    -0xa77c(%ebx),%eax
c0024ed0:	e8 ca fe ff ff       	call   c0024d9f <map_key>
c0024ed5:	84 c0                	test   %al,%al
c0024ed7:	75 3b                	jne    c0024f14 <keyboard_interrupt+0x10d>
      if (key->scancode == code)
c0024ed9:	83 fe 2a             	cmp    $0x2a,%esi
c0024edc:	0f 84 da 00 00 00    	je     c0024fbc <keyboard_interrupt+0x1b5>
    for (key = shift_keys; key->scancode != 0; key++)
c0024ee2:	8d 83 44 58 ff ff    	lea    -0xa7bc(%ebx),%eax
c0024ee8:	83 c0 08             	add    $0x8,%eax
c0024eeb:	8b 10                	mov    (%eax),%edx
c0024eed:	85 d2                	test   %edx,%edx
c0024eef:	74 99                	je     c0024e8a <keyboard_interrupt+0x83>
      if (key->scancode == code)
c0024ef1:	39 f2                	cmp    %esi,%edx
c0024ef3:	75 f3                	jne    c0024ee8 <keyboard_interrupt+0xe1>
        *key->state_var = !release;
c0024ef5:	8b 40 04             	mov    0x4(%eax),%eax
c0024ef8:	85 ff                	test   %edi,%edi
c0024efa:	0f 94 00             	sete   (%eax)
        break;
c0024efd:	eb 8b                	jmp    c0024e8a <keyboard_interrupt+0x83>
  else if (map_key(invariant_keymap, code, &c) || (!shift && map_key(unshifted_keymap, code, &c)) || (shift && map_key(shifted_keymap, code, &c)))
c0024eff:	8d 4c 24 1f          	lea    0x1f(%esp),%ecx
c0024f03:	89 f2                	mov    %esi,%edx
c0024f05:	8d 83 c4 58 ff ff    	lea    -0xa73c(%ebx),%eax
c0024f0b:	e8 8f fe ff ff       	call   c0024d9f <map_key>
c0024f10:	84 c0                	test   %al,%al
c0024f12:	74 c5                	je     c0024ed9 <keyboard_interrupt+0xd2>
    if (!release)
c0024f14:	85 ff                	test   %edi,%edi
c0024f16:	0f 85 6e ff ff ff    	jne    c0024e8a <keyboard_interrupt+0x83>
      if (c == 0177 && ctrl && alt)
c0024f1c:	0f b6 44 24 1f       	movzbl 0x1f(%esp),%eax
c0024f21:	3c 7f                	cmp    $0x7f,%al
c0024f23:	74 5a                	je     c0024f7f <keyboard_interrupt+0x178>
      if (ctrl && c >= 0x40 && c < 0x60)
c0024f25:	8d 50 c0             	lea    -0x40(%eax),%edx
c0024f28:	80 fa 1f             	cmp    $0x1f,%dl
c0024f2b:	77 07                	ja     c0024f34 <keyboard_interrupt+0x12d>
c0024f2d:	f6 44 24 08 01       	testb  $0x1,0x8(%esp)
c0024f32:	75 6d                	jne    c0024fa1 <keyboard_interrupt+0x19a>
      else if (shift == caps_lock)
c0024f34:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
c0024f39:	38 8b b4 19 00 00    	cmp    %cl,0x19b4(%ebx)
c0024f3f:	74 66                	je     c0024fa7 <keyboard_interrupt+0x1a0>
      if (alt)
c0024f41:	f7 c5 01 00 00 00    	test   $0x1,%ebp
c0024f47:	74 05                	je     c0024f4e <keyboard_interrupt+0x147>
        c += 0x80;
c0024f49:	80 44 24 1f 80       	addb   $0x80,0x1f(%esp)
      if (!input_full())
c0024f4e:	e8 78 1d 00 00       	call   c0026ccb <input_full>
c0024f53:	84 c0                	test   %al,%al
c0024f55:	0f 85 2f ff ff ff    	jne    c0024e8a <keyboard_interrupt+0x83>
        key_cnt++;
c0024f5b:	83 83 ac 19 00 00 01 	addl   $0x1,0x19ac(%ebx)
c0024f62:	83 93 b0 19 00 00 00 	adcl   $0x0,0x19b0(%ebx)
        input_putc(c);
c0024f69:	83 ec 0c             	sub    $0xc,%esp
c0024f6c:	0f b6 44 24 2b       	movzbl 0x2b(%esp),%eax
c0024f71:	50                   	push   %eax
c0024f72:	e8 9f 1b 00 00       	call   c0026b16 <input_putc>
c0024f77:	83 c4 10             	add    $0x10,%esp
c0024f7a:	e9 0b ff ff ff       	jmp    c0024e8a <keyboard_interrupt+0x83>
      if (c == 0177 && ctrl && alt)
c0024f7f:	8b 54 24 08          	mov    0x8(%esp),%edx
c0024f83:	21 ea                	and    %ebp,%edx
c0024f85:	f6 c2 01             	test   $0x1,%dl
c0024f88:	75 12                	jne    c0024f9c <keyboard_interrupt+0x195>
      else if (shift == caps_lock)
c0024f8a:	0f b6 4c 24 0f       	movzbl 0xf(%esp),%ecx
c0024f8f:	3a 8b b4 19 00 00    	cmp    0x19b4(%ebx),%cl
c0024f95:	75 aa                	jne    c0024f41 <keyboard_interrupt+0x13a>
        c = tolower(c);
c0024f97:	0f b6 c0             	movzbl %al,%eax
c0024f9a:	eb 1a                	jmp    c0024fb6 <keyboard_interrupt+0x1af>
        shutdown_reboot();
c0024f9c:	e8 36 23 00 00       	call   c00272d7 <shutdown_reboot>
        c -= 0x40;
c0024fa1:	88 54 24 1f          	mov    %dl,0x1f(%esp)
c0024fa5:	eb 9a                	jmp    c0024f41 <keyboard_interrupt+0x13a>
        c = tolower(c);
c0024fa7:	0f b6 c0             	movzbl %al,%eax
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower(int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper(int c) { return c >= 'A' && c <= 'Z'; }
c0024faa:	8d 48 bf             	lea    -0x41(%eax),%ecx
static inline int ispunct(int c)
{
  return isprint(c) && !isalnum(c) && !isspace(c);
}

static inline int tolower(int c) { return isupper(c) ? c - 'A' + 'a' : c; }
c0024fad:	8d 50 20             	lea    0x20(%eax),%edx
c0024fb0:	83 f9 1a             	cmp    $0x1a,%ecx
c0024fb3:	0f 42 c2             	cmovb  %edx,%eax
c0024fb6:	88 44 24 1f          	mov    %al,0x1f(%esp)
c0024fba:	eb 85                	jmp    c0024f41 <keyboard_interrupt+0x13a>
    for (key = shift_keys; key->scancode != 0; key++)
c0024fbc:	8d 83 44 58 ff ff    	lea    -0xa7bc(%ebx),%eax
c0024fc2:	e9 2e ff ff ff       	jmp    c0024ef5 <keyboard_interrupt+0xee>

c0024fc7 <kbd_init>:
{
c0024fc7:	53                   	push   %ebx
c0024fc8:	83 ec 0c             	sub    $0xc,%esp
c0024fcb:	e8 16 d5 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0024fd0:	81 c3 6c bc 01 00    	add    $0x1bc6c,%ebx
  intr_register_ext(0x21, keyboard_interrupt, "8042 Keyboard");
c0024fd6:	8d 83 ac 3b ff ff    	lea    -0xc454(%ebx),%eax
c0024fdc:	50                   	push   %eax
c0024fdd:	8d 83 cb 41 fe ff    	lea    -0x1be35(%ebx),%eax
c0024fe3:	50                   	push   %eax
c0024fe4:	6a 21                	push   $0x21
c0024fe6:	e8 9a d1 ff ff       	call   c0022185 <intr_register_ext>
}
c0024feb:	83 c4 18             	add    $0x18,%esp
c0024fee:	5b                   	pop    %ebx
c0024fef:	c3                   	ret    

c0024ff0 <kbd_print_stats>:
{
c0024ff0:	53                   	push   %ebx
c0024ff1:	83 ec 0c             	sub    $0xc,%esp
c0024ff4:	e8 ed d4 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0024ff9:	81 c3 43 bc 01 00    	add    $0x1bc43,%ebx
  printf("Keyboard: %lld keys pressed\n", key_cnt);
c0024fff:	ff b3 b0 19 00 00    	pushl  0x19b0(%ebx)
c0025005:	ff b3 ac 19 00 00    	pushl  0x19ac(%ebx)
c002500b:	8d 83 ba 3b ff ff    	lea    -0xc446(%ebx),%eax
c0025011:	50                   	push   %eax
c0025012:	e8 e7 2a 00 00       	call   c0027afe <printf>
}
c0025017:	83 c4 18             	add    $0x18,%esp
c002501a:	5b                   	pop    %ebx
c002501b:	c3                   	ret    

c002501c <move_cursor>:
}

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor(void)
{
c002501c:	e8 c9 d4 00 00       	call   c00324ea <__x86.get_pc_thunk.ax>
c0025021:	05 1b bc 01 00       	add    $0x1bc1b,%eax
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c0025026:	8b 88 c4 19 00 00    	mov    0x19c4(%eax),%ecx
c002502c:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c002502f:	c1 e1 04             	shl    $0x4,%ecx
c0025032:	66 03 88 c8 19 00 00 	add    0x19c8(%eax),%cx
  outw(0x3d4, 0x0e | (cp & 0xff00));
c0025039:	89 c8                	mov    %ecx,%eax
c002503b:	b0 00                	mov    $0x0,%al
c002503d:	83 c8 0e             	or     $0xe,%eax
/* Writes the 16-bit DATA to PORT. */
static inline void
outw(uint16_t port, uint16_t data)
{
  /* See [IA32-v2b] "OUT". */
  asm volatile("outw %w0, %w1"
c0025040:	ba d4 03 00 00       	mov    $0x3d4,%edx
c0025045:	66 ef                	out    %ax,(%dx)
  outw(0x3d4, 0x0f | (cp << 8));
c0025047:	89 c8                	mov    %ecx,%eax
c0025049:	c1 e0 08             	shl    $0x8,%eax
c002504c:	83 c8 0f             	or     $0xf,%eax
c002504f:	66 ef                	out    %ax,(%dx)
}
c0025051:	c3                   	ret    

c0025052 <newline>:
{
c0025052:	56                   	push   %esi
c0025053:	53                   	push   %ebx
c0025054:	83 ec 04             	sub    $0x4,%esp
c0025057:	e8 8a d4 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002505c:	81 c3 e0 bb 01 00    	add    $0x1bbe0,%ebx
  cx = 0;
c0025062:	c7 83 c8 19 00 00 00 	movl   $0x0,0x19c8(%ebx)
c0025069:	00 00 00 
  cy++;
c002506c:	8b 83 c4 19 00 00    	mov    0x19c4(%ebx),%eax
c0025072:	83 c0 01             	add    $0x1,%eax
  if (cy >= ROW_CNT)
c0025075:	83 f8 18             	cmp    $0x18,%eax
c0025078:	77 0c                	ja     c0025086 <newline+0x34>
  cy++;
c002507a:	89 83 c4 19 00 00    	mov    %eax,0x19c4(%ebx)
}
c0025080:	83 c4 04             	add    $0x4,%esp
c0025083:	5b                   	pop    %ebx
c0025084:	5e                   	pop    %esi
c0025085:	c3                   	ret    
    cy = ROW_CNT - 1;
c0025086:	c7 83 c4 19 00 00 18 	movl   $0x18,0x19c4(%ebx)
c002508d:	00 00 00 
    memmove(&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c0025090:	8b b3 c0 19 00 00    	mov    0x19c0(%ebx),%esi
c0025096:	83 ec 04             	sub    $0x4,%esp
c0025099:	68 00 0f 00 00       	push   $0xf00
c002509e:	8d 86 a0 00 00 00    	lea    0xa0(%esi),%eax
c00250a4:	50                   	push   %eax
c00250a5:	56                   	push   %esi
c00250a6:	e8 0e 3a 00 00       	call   c0028ab9 <memmove>
c00250ab:	8d 86 00 0f 00 00    	lea    0xf00(%esi),%eax
c00250b1:	8d 96 a0 0f 00 00    	lea    0xfa0(%esi),%edx
c00250b7:	83 c4 10             	add    $0x10,%esp
    fb[y][x][0] = ' ';
c00250ba:	c6 00 20             	movb   $0x20,(%eax)
    fb[y][x][1] = GRAY_ON_BLACK;
c00250bd:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c00250c1:	83 c0 02             	add    $0x2,%eax
  for (x = 0; x < COL_CNT; x++)
c00250c4:	39 d0                	cmp    %edx,%eax
c00250c6:	75 f2                	jne    c00250ba <newline+0x68>
c00250c8:	eb b6                	jmp    c0025080 <newline+0x2e>

c00250ca <vga_putc>:
{
c00250ca:	55                   	push   %ebp
c00250cb:	57                   	push   %edi
c00250cc:	56                   	push   %esi
c00250cd:	53                   	push   %ebx
c00250ce:	83 ec 0c             	sub    $0xc,%esp
c00250d1:	e8 10 d4 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00250d6:	81 c3 66 bb 01 00    	add    $0x1bb66,%ebx
  enum intr_level old_level = intr_disable();
c00250dc:	e8 ca ce ff ff       	call   c0021fab <intr_disable>
c00250e1:	89 c6                	mov    %eax,%esi
  if (!inited)
c00250e3:	80 bb bc 19 00 00 00 	cmpb   $0x0,0x19bc(%ebx)
c00250ea:	74 1b                	je     c0025107 <vga_putc+0x3d>
  switch (c)
c00250ec:	8b 44 24 20          	mov    0x20(%esp),%eax
c00250f0:	83 e8 07             	sub    $0x7,%eax
c00250f3:	83 f8 06             	cmp    $0x6,%eax
c00250f6:	0f 87 1f 01 00 00    	ja     c002521b <.L11>
c00250fc:	89 df                	mov    %ebx,%edi
c00250fe:	03 bc 83 84 1c ff ff 	add    -0xe37c(%ebx,%eax,4),%edi
c0025105:	ff e7                	jmp    *%edi
    fb = ptov(0xb8000);
c0025107:	c7 83 c0 19 00 00 00 	movl   $0xc00b8000,0x19c0(%ebx)
c002510e:	80 0b c0 
  asm volatile("outb %b0, %w1"
c0025111:	bf d4 03 00 00       	mov    $0x3d4,%edi
c0025116:	b8 0e 00 00 00       	mov    $0xe,%eax
c002511b:	89 fa                	mov    %edi,%edx
c002511d:	ee                   	out    %al,(%dx)
  asm volatile("inb %w1, %b0"
c002511e:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
c0025123:	89 ca                	mov    %ecx,%edx
c0025125:	ec                   	in     (%dx),%al
{
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb(0x3d4, 0x0e);
  cp = inb(0x3d5) << 8;
c0025126:	89 c5                	mov    %eax,%ebp
c0025128:	c1 e5 08             	shl    $0x8,%ebp
  asm volatile("outb %b0, %w1"
c002512b:	b8 0f 00 00 00       	mov    $0xf,%eax
c0025130:	89 fa                	mov    %edi,%edx
c0025132:	ee                   	out    %al,(%dx)
  asm volatile("inb %w1, %b0"
c0025133:	89 ca                	mov    %ecx,%edx
c0025135:	ec                   	in     (%dx),%al

  outb(0x3d4, 0x0f);
  cp |= inb(0x3d5);
c0025136:	0f b6 c0             	movzbl %al,%eax
c0025139:	09 e8                	or     %ebp,%eax

  *x = cp % COL_CNT;
c002513b:	0f b7 d0             	movzwl %ax,%edx
c002513e:	69 d2 cd cc 00 00    	imul   $0xcccd,%edx,%edx
c0025144:	c1 ea 16             	shr    $0x16,%edx
c0025147:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c002514a:	c1 e1 04             	shl    $0x4,%ecx
c002514d:	29 c8                	sub    %ecx,%eax
c002514f:	0f b7 c0             	movzwl %ax,%eax
c0025152:	89 83 c8 19 00 00    	mov    %eax,0x19c8(%ebx)
  *y = cp / COL_CNT;
c0025158:	0f b7 d2             	movzwl %dx,%edx
c002515b:	89 93 c4 19 00 00    	mov    %edx,0x19c4(%ebx)
    inited = true;
c0025161:	c6 83 bc 19 00 00 01 	movb   $0x1,0x19bc(%ebx)
c0025168:	eb 82                	jmp    c00250ec <vga_putc+0x22>

c002516a <.L17>:
c002516a:	8b 83 c0 19 00 00    	mov    0x19c0(%ebx),%eax
c0025170:	8d 88 a0 0f 00 00    	lea    0xfa0(%eax),%ecx
c0025176:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
    fb[y][x][0] = ' ';
c002517c:	c6 00 20             	movb   $0x20,(%eax)
    fb[y][x][1] = GRAY_ON_BLACK;
c002517f:	c6 40 01 07          	movb   $0x7,0x1(%eax)
c0025183:	83 c0 02             	add    $0x2,%eax
  for (x = 0; x < COL_CNT; x++)
c0025186:	39 c2                	cmp    %eax,%edx
c0025188:	75 f2                	jne    c002517c <.L17+0x12>
  for (y = 0; y < ROW_CNT; y++)
c002518a:	39 c8                	cmp    %ecx,%eax
c002518c:	75 e8                	jne    c0025176 <.L17+0xc>
  cx = cy = 0;
c002518e:	c7 83 c4 19 00 00 00 	movl   $0x0,0x19c4(%ebx)
c0025195:	00 00 00 
c0025198:	c7 83 c8 19 00 00 00 	movl   $0x0,0x19c8(%ebx)
c002519f:	00 00 00 
  move_cursor();
c00251a2:	e8 75 fe ff ff       	call   c002501c <move_cursor>
c00251a7:	eb 05                	jmp    c00251ae <.L16+0x5>

c00251a9 <.L16>:
    newline();
c00251a9:	e8 a4 fe ff ff       	call   c0025052 <newline>
  move_cursor();
c00251ae:	e8 69 fe ff ff       	call   c002501c <move_cursor>
  intr_set_level(old_level);
c00251b3:	83 ec 0c             	sub    $0xc,%esp
c00251b6:	56                   	push   %esi
c00251b7:	e8 f6 cd ff ff       	call   c0021fb2 <intr_set_level>
}
c00251bc:	83 c4 1c             	add    $0x1c,%esp
c00251bf:	5b                   	pop    %ebx
c00251c0:	5e                   	pop    %esi
c00251c1:	5f                   	pop    %edi
c00251c2:	5d                   	pop    %ebp
c00251c3:	c3                   	ret    

c00251c4 <.L14>:
    if (cx > 0)
c00251c4:	8b 83 c8 19 00 00    	mov    0x19c8(%ebx),%eax
c00251ca:	85 c0                	test   %eax,%eax
c00251cc:	74 e0                	je     c00251ae <.L16+0x5>
      cx--;
c00251ce:	83 e8 01             	sub    $0x1,%eax
c00251d1:	89 83 c8 19 00 00    	mov    %eax,0x19c8(%ebx)
c00251d7:	eb d5                	jmp    c00251ae <.L16+0x5>

c00251d9 <.L18>:
    cx = 0;
c00251d9:	c7 83 c8 19 00 00 00 	movl   $0x0,0x19c8(%ebx)
c00251e0:	00 00 00 
    break;
c00251e3:	eb c9                	jmp    c00251ae <.L16+0x5>

c00251e5 <.L15>:
    cx = ROUND_UP(cx + 1, 8);
c00251e5:	8b 83 c8 19 00 00    	mov    0x19c8(%ebx),%eax
c00251eb:	83 c0 08             	add    $0x8,%eax
c00251ee:	83 e0 f8             	and    $0xfffffff8,%eax
c00251f1:	89 83 c8 19 00 00    	mov    %eax,0x19c8(%ebx)
    if (cx >= COL_CNT)
c00251f7:	83 f8 4f             	cmp    $0x4f,%eax
c00251fa:	76 b2                	jbe    c00251ae <.L16+0x5>
      newline();
c00251fc:	e8 51 fe ff ff       	call   c0025052 <newline>
c0025201:	eb ab                	jmp    c00251ae <.L16+0x5>

c0025203 <.L12>:
    intr_set_level(old_level);
c0025203:	83 ec 0c             	sub    $0xc,%esp
c0025206:	56                   	push   %esi
c0025207:	e8 a6 cd ff ff       	call   c0021fb2 <intr_set_level>
    speaker_beep();
c002520c:	e8 8d 22 00 00       	call   c002749e <speaker_beep>
    intr_disable();
c0025211:	e8 95 cd ff ff       	call   c0021fab <intr_disable>
    break;
c0025216:	83 c4 10             	add    $0x10,%esp
c0025219:	eb 93                	jmp    c00251ae <.L16+0x5>

c002521b <.L11>:
    fb[cy][cx][0] = c;
c002521b:	8b bb c0 19 00 00    	mov    0x19c0(%ebx),%edi
c0025221:	8b 83 c4 19 00 00    	mov    0x19c4(%ebx),%eax
c0025227:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002522a:	c1 e0 05             	shl    $0x5,%eax
c002522d:	01 f8                	add    %edi,%eax
c002522f:	8b 8b c8 19 00 00    	mov    0x19c8(%ebx),%ecx
c0025235:	0f b6 54 24 20       	movzbl 0x20(%esp),%edx
c002523a:	88 14 48             	mov    %dl,(%eax,%ecx,2)
    fb[cy][cx][1] = GRAY_ON_BLACK;
c002523d:	8b 83 c4 19 00 00    	mov    0x19c4(%ebx),%eax
c0025243:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0025246:	c1 e0 05             	shl    $0x5,%eax
c0025249:	8d 14 07             	lea    (%edi,%eax,1),%edx
c002524c:	8b 83 c8 19 00 00    	mov    0x19c8(%ebx),%eax
c0025252:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
    if (++cx >= COL_CNT)
c0025257:	8b 83 c8 19 00 00    	mov    0x19c8(%ebx),%eax
c002525d:	83 c0 01             	add    $0x1,%eax
c0025260:	89 83 c8 19 00 00    	mov    %eax,0x19c8(%ebx)
c0025266:	83 f8 4f             	cmp    $0x4f,%eax
c0025269:	0f 86 3f ff ff ff    	jbe    c00251ae <.L16+0x5>
      newline();
c002526f:	e8 de fd ff ff       	call   c0025052 <newline>
c0025274:	e9 35 ff ff ff       	jmp    c00251ae <.L16+0x5>

c0025279 <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll(void)
{
c0025279:	57                   	push   %edi
c002527a:	56                   	push   %esi
c002527b:	53                   	push   %ebx
c002527c:	e8 65 d2 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0025281:	81 c3 bb b9 01 00    	add    $0x1b9bb,%ebx
  ASSERT(mode == UNINIT);
c0025287:	83 bb 68 1a 00 00 00 	cmpl   $0x0,0x1a68(%ebx)
c002528e:	75 65                	jne    c00252f5 <init_poll+0x7c>
  asm volatile("outb %b0, %w1"
c0025290:	b9 00 00 00 00       	mov    $0x0,%ecx
c0025295:	bf f9 03 00 00       	mov    $0x3f9,%edi
c002529a:	89 c8                	mov    %ecx,%eax
c002529c:	89 fa                	mov    %edi,%edx
c002529e:	ee                   	out    %al,(%dx)
c002529f:	ba fa 03 00 00       	mov    $0x3fa,%edx
c00252a4:	ee                   	out    %al,(%dx)
c00252a5:	be fb 03 00 00       	mov    $0x3fb,%esi
c00252aa:	b8 83 ff ff ff       	mov    $0xffffff83,%eax
c00252af:	89 f2                	mov    %esi,%edx
c00252b1:	ee                   	out    %al,(%dx)
c00252b2:	b8 0c 00 00 00       	mov    $0xc,%eax
c00252b7:	ba f8 03 00 00       	mov    $0x3f8,%edx
c00252bc:	ee                   	out    %al,(%dx)
c00252bd:	89 c8                	mov    %ecx,%eax
c00252bf:	89 fa                	mov    %edi,%edx
c00252c1:	ee                   	out    %al,(%dx)
c00252c2:	b8 03 00 00 00       	mov    $0x3,%eax
c00252c7:	89 f2                	mov    %esi,%edx
c00252c9:	ee                   	out    %al,(%dx)
c00252ca:	b8 08 00 00 00       	mov    $0x8,%eax
c00252cf:	ba fc 03 00 00       	mov    $0x3fc,%edx
c00252d4:	ee                   	out    %al,(%dx)
  outb(IER_REG, 0);        /* Turn off all interrupts. */
  outb(FCR_REG, 0);        /* Disable FIFO. */
  set_serial(9600);        /* 9.6 kbps, N-8-1. */
  outb(MCR_REG, MCR_OUT2); /* Required to enable interrupts. */
  intq_init(&txq);
c00252d5:	83 ec 0c             	sub    $0xc,%esp
c00252d8:	8d 83 e4 19 00 00    	lea    0x19e4(%ebx),%eax
c00252de:	50                   	push   %eax
c00252df:	e8 39 1a 00 00       	call   c0026d1d <intq_init>
  mode = POLL;
c00252e4:	c7 83 68 1a 00 00 01 	movl   $0x1,0x1a68(%ebx)
c00252eb:	00 00 00 
}
c00252ee:	83 c4 10             	add    $0x10,%esp
c00252f1:	5b                   	pop    %ebx
c00252f2:	5e                   	pop    %esi
c00252f3:	5f                   	pop    %edi
c00252f4:	c3                   	ret    
  ASSERT(mode == UNINIT);
c00252f5:	83 ec 0c             	sub    $0xc,%esp
c00252f8:	8d 83 2f 3c ff ff    	lea    -0xc3d1(%ebx),%eax
c00252fe:	50                   	push   %eax
c00252ff:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0025305:	50                   	push   %eax
c0025306:	8d 83 c8 1c ff ff    	lea    -0xe338(%ebx),%eax
c002530c:	50                   	push   %eax
c002530d:	6a 47                	push   $0x47
c002530f:	8d 83 3e 3c ff ff    	lea    -0xc3c2(%ebx),%eax
c0025315:	50                   	push   %eax
c0025316:	e8 7a 45 00 00       	call   c0029895 <debug_panic>

c002531b <write_ier>:
}

/* Update interrupt enable register. */
static void
write_ier(void)
{
c002531b:	56                   	push   %esi
c002531c:	53                   	push   %ebx
c002531d:	83 ec 04             	sub    $0x4,%esp
c0025320:	e8 c1 d1 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0025325:	81 c3 17 b9 01 00    	add    $0x1b917,%ebx
  uint8_t ier = 0;

  ASSERT(intr_get_level() == INTR_OFF);
c002532b:	e8 29 cc ff ff       	call   c0021f59 <intr_get_level>
c0025330:	85 c0                	test   %eax,%eax
c0025332:	75 37                	jne    c002536b <write_ier+0x50>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty(&txq))
c0025334:	83 ec 0c             	sub    $0xc,%esp
c0025337:	8d 83 e4 19 00 00    	lea    0x19e4(%ebx),%eax
c002533d:	50                   	push   %eax
c002533e:	e8 19 1a 00 00       	call   c0026d5c <intq_empty>
c0025343:	83 c4 10             	add    $0x10,%esp
    ier |= IER_XMIT;
c0025346:	84 c0                	test   %al,%al
c0025348:	0f 94 c0             	sete   %al
c002534b:	8d 34 00             	lea    (%eax,%eax,1),%esi

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full())
c002534e:	e8 78 19 00 00       	call   c0026ccb <input_full>
    ier |= IER_RECV;
c0025353:	89 f2                	mov    %esi,%edx
c0025355:	83 ca 01             	or     $0x1,%edx
c0025358:	84 c0                	test   %al,%al
c002535a:	0f 44 f2             	cmove  %edx,%esi
c002535d:	ba f9 03 00 00       	mov    $0x3f9,%edx
c0025362:	89 f0                	mov    %esi,%eax
c0025364:	ee                   	out    %al,(%dx)

  outb(IER_REG, ier);
}
c0025365:	83 c4 04             	add    $0x4,%esp
c0025368:	5b                   	pop    %ebx
c0025369:	5e                   	pop    %esi
c002536a:	c3                   	ret    
  ASSERT(intr_get_level() == INTR_OFF);
c002536b:	83 ec 0c             	sub    $0xc,%esp
c002536e:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c0025374:	50                   	push   %eax
c0025375:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002537b:	50                   	push   %eax
c002537c:	8d 83 bc 1c ff ff    	lea    -0xe344(%ebx),%eax
c0025382:	50                   	push   %eax
c0025383:	68 b3 00 00 00       	push   $0xb3
c0025388:	8d 83 3e 3c ff ff    	lea    -0xc3c2(%ebx),%eax
c002538e:	50                   	push   %eax
c002538f:	e8 01 45 00 00       	call   c0029895 <debug_panic>

c0025394 <serial_interrupt>:
}

/* Serial interrupt handler. */
static void
serial_interrupt(struct intr_frame *f UNUSED)
{
c0025394:	57                   	push   %edi
c0025395:	56                   	push   %esi
c0025396:	53                   	push   %ebx
c0025397:	e8 4a d1 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002539c:	81 c3 a0 b8 01 00    	add    $0x1b8a0,%ebx
  asm volatile("inb %w1, %b0"
c00253a2:	ba fa 03 00 00       	mov    $0x3fa,%edx
c00253a7:	ec                   	in     (%dx),%al
c00253a8:	be fd 03 00 00       	mov    $0x3fd,%esi
c00253ad:	bf f8 03 00 00       	mov    $0x3f8,%edi
c00253b2:	eb 12                	jmp    c00253c6 <serial_interrupt+0x32>
c00253b4:	89 fa                	mov    %edi,%edx
c00253b6:	ec                   	in     (%dx),%al
  inb(IIR_REG);

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full() && (inb(LSR_REG) & LSR_DR) != 0)
    input_putc(inb(RBR_REG));
c00253b7:	83 ec 0c             	sub    $0xc,%esp
c00253ba:	0f b6 c0             	movzbl %al,%eax
c00253bd:	50                   	push   %eax
c00253be:	e8 53 17 00 00       	call   c0026b16 <input_putc>
c00253c3:	83 c4 10             	add    $0x10,%esp
  while (!input_full() && (inb(LSR_REG) & LSR_DR) != 0)
c00253c6:	e8 00 19 00 00       	call   c0026ccb <input_full>
c00253cb:	84 c0                	test   %al,%al
c00253cd:	75 07                	jne    c00253d6 <serial_interrupt+0x42>
c00253cf:	89 f2                	mov    %esi,%edx
c00253d1:	ec                   	in     (%dx),%al
c00253d2:	a8 01                	test   $0x1,%al
c00253d4:	75 de                	jne    c00253b4 <serial_interrupt+0x20>

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty(&txq) && (inb(LSR_REG) & LSR_THRE) != 0)
c00253d6:	8d b3 e4 19 00 00    	lea    0x19e4(%ebx),%esi
c00253dc:	bf fd 03 00 00       	mov    $0x3fd,%edi
c00253e1:	eb 12                	jmp    c00253f5 <serial_interrupt+0x61>
    outb(THR_REG, intq_getc(&txq));
c00253e3:	83 ec 0c             	sub    $0xc,%esp
c00253e6:	56                   	push   %esi
c00253e7:	e8 b9 1b 00 00       	call   c0026fa5 <intq_getc>
  asm volatile("outb %b0, %w1"
c00253ec:	ba f8 03 00 00       	mov    $0x3f8,%edx
c00253f1:	ee                   	out    %al,(%dx)
c00253f2:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty(&txq) && (inb(LSR_REG) & LSR_THRE) != 0)
c00253f5:	83 ec 0c             	sub    $0xc,%esp
c00253f8:	56                   	push   %esi
c00253f9:	e8 5e 19 00 00       	call   c0026d5c <intq_empty>
c00253fe:	83 c4 10             	add    $0x10,%esp
c0025401:	84 c0                	test   %al,%al
c0025403:	75 07                	jne    c002540c <serial_interrupt+0x78>
  asm volatile("inb %w1, %b0"
c0025405:	89 fa                	mov    %edi,%edx
c0025407:	ec                   	in     (%dx),%al
c0025408:	a8 20                	test   $0x20,%al
c002540a:	75 d7                	jne    c00253e3 <serial_interrupt+0x4f>

  /* Update interrupt enable register based on queue status. */
  write_ier();
c002540c:	e8 0a ff ff ff       	call   c002531b <write_ier>
}
c0025411:	5b                   	pop    %ebx
c0025412:	5e                   	pop    %esi
c0025413:	5f                   	pop    %edi
c0025414:	c3                   	ret    

c0025415 <putc_poll>:
{
c0025415:	56                   	push   %esi
c0025416:	53                   	push   %ebx
c0025417:	83 ec 04             	sub    $0x4,%esp
c002541a:	e8 c7 d0 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002541f:	81 c3 1d b8 01 00    	add    $0x1b81d,%ebx
c0025425:	89 c6                	mov    %eax,%esi
  ASSERT(intr_get_level() == INTR_OFF);
c0025427:	e8 2d cb ff ff       	call   c0021f59 <intr_get_level>
c002542c:	85 c0                	test   %eax,%eax
c002542e:	75 18                	jne    c0025448 <putc_poll+0x33>
c0025430:	ba fd 03 00 00       	mov    $0x3fd,%edx
c0025435:	ec                   	in     (%dx),%al
  while ((inb(LSR_REG) & LSR_THRE) == 0)
c0025436:	a8 20                	test   $0x20,%al
c0025438:	74 fb                	je     c0025435 <putc_poll+0x20>
  asm volatile("outb %b0, %w1"
c002543a:	ba f8 03 00 00       	mov    $0x3f8,%edx
c002543f:	89 f0                	mov    %esi,%eax
c0025441:	ee                   	out    %al,(%dx)
}
c0025442:	83 c4 04             	add    $0x4,%esp
c0025445:	5b                   	pop    %ebx
c0025446:	5e                   	pop    %esi
c0025447:	c3                   	ret    
  ASSERT(intr_get_level() == INTR_OFF);
c0025448:	83 ec 0c             	sub    $0xc,%esp
c002544b:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c0025451:	50                   	push   %eax
c0025452:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0025458:	50                   	push   %eax
c0025459:	8d 83 b0 1c ff ff    	lea    -0xe350(%ebx),%eax
c002545f:	50                   	push   %eax
c0025460:	68 c7 00 00 00       	push   $0xc7
c0025465:	8d 83 3e 3c ff ff    	lea    -0xc3c2(%ebx),%eax
c002546b:	50                   	push   %eax
c002546c:	e8 24 44 00 00       	call   c0029895 <debug_panic>

c0025471 <serial_init_queue>:
{
c0025471:	56                   	push   %esi
c0025472:	53                   	push   %ebx
c0025473:	83 ec 04             	sub    $0x4,%esp
c0025476:	e8 6b d0 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002547b:	81 c3 c1 b7 01 00    	add    $0x1b7c1,%ebx
  if (mode == UNINIT)
c0025481:	83 bb 68 1a 00 00 00 	cmpl   $0x0,0x1a68(%ebx)
c0025488:	74 45                	je     c00254cf <serial_init_queue+0x5e>
  ASSERT(mode == POLL);
c002548a:	83 bb 68 1a 00 00 01 	cmpl   $0x1,0x1a68(%ebx)
c0025491:	75 43                	jne    c00254d6 <serial_init_queue+0x65>
  intr_register_ext(0x20 + 4, serial_interrupt, "serial");
c0025493:	83 ec 04             	sub    $0x4,%esp
c0025496:	8d 83 62 3c ff ff    	lea    -0xc39e(%ebx),%eax
c002549c:	50                   	push   %eax
c002549d:	8d 83 58 47 fe ff    	lea    -0x1b8a8(%ebx),%eax
c00254a3:	50                   	push   %eax
c00254a4:	6a 24                	push   $0x24
c00254a6:	e8 da cc ff ff       	call   c0022185 <intr_register_ext>
  mode = QUEUE;
c00254ab:	c7 83 68 1a 00 00 02 	movl   $0x2,0x1a68(%ebx)
c00254b2:	00 00 00 
  old_level = intr_disable();
c00254b5:	e8 f1 ca ff ff       	call   c0021fab <intr_disable>
c00254ba:	89 c6                	mov    %eax,%esi
  write_ier();
c00254bc:	e8 5a fe ff ff       	call   c002531b <write_ier>
  intr_set_level(old_level);
c00254c1:	89 34 24             	mov    %esi,(%esp)
c00254c4:	e8 e9 ca ff ff       	call   c0021fb2 <intr_set_level>
}
c00254c9:	83 c4 14             	add    $0x14,%esp
c00254cc:	5b                   	pop    %ebx
c00254cd:	5e                   	pop    %esi
c00254ce:	c3                   	ret    
    init_poll();
c00254cf:	e8 a5 fd ff ff       	call   c0025279 <init_poll>
c00254d4:	eb b4                	jmp    c002548a <serial_init_queue+0x19>
  ASSERT(mode == POLL);
c00254d6:	83 ec 0c             	sub    $0xc,%esp
c00254d9:	8d 83 55 3c ff ff    	lea    -0xc3ab(%ebx),%eax
c00254df:	50                   	push   %eax
c00254e0:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00254e6:	50                   	push   %eax
c00254e7:	8d 83 d4 1c ff ff    	lea    -0xe32c(%ebx),%eax
c00254ed:	50                   	push   %eax
c00254ee:	6a 59                	push   $0x59
c00254f0:	8d 83 3e 3c ff ff    	lea    -0xc3c2(%ebx),%eax
c00254f6:	50                   	push   %eax
c00254f7:	e8 99 43 00 00       	call   c0029895 <debug_panic>

c00254fc <serial_putc>:
{
c00254fc:	57                   	push   %edi
c00254fd:	56                   	push   %esi
c00254fe:	53                   	push   %ebx
c00254ff:	e8 e2 cf 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0025504:	81 c3 38 b7 01 00    	add    $0x1b738,%ebx
c002550a:	8b 74 24 10          	mov    0x10(%esp),%esi
  enum intr_level old_level = intr_disable();
c002550e:	e8 98 ca ff ff       	call   c0021fab <intr_disable>
c0025513:	89 c7                	mov    %eax,%edi
  if (mode != QUEUE)
c0025515:	8b 83 68 1a 00 00    	mov    0x1a68(%ebx),%eax
c002551b:	83 f8 02             	cmp    $0x2,%eax
c002551e:	74 25                	je     c0025545 <serial_putc+0x49>
    if (mode == UNINIT)
c0025520:	85 c0                	test   %eax,%eax
c0025522:	74 1a                	je     c002553e <serial_putc+0x42>
    putc_poll(byte);
c0025524:	89 f0                	mov    %esi,%eax
c0025526:	0f b6 c0             	movzbl %al,%eax
c0025529:	e8 e7 fe ff ff       	call   c0025415 <putc_poll>
  intr_set_level(old_level);
c002552e:	83 ec 0c             	sub    $0xc,%esp
c0025531:	57                   	push   %edi
c0025532:	e8 7b ca ff ff       	call   c0021fb2 <intr_set_level>
}
c0025537:	83 c4 10             	add    $0x10,%esp
c002553a:	5b                   	pop    %ebx
c002553b:	5e                   	pop    %esi
c002553c:	5f                   	pop    %edi
c002553d:	c3                   	ret    
      init_poll();
c002553e:	e8 36 fd ff ff       	call   c0025279 <init_poll>
c0025543:	eb df                	jmp    c0025524 <serial_putc+0x28>
    if (old_level == INTR_OFF && intq_full(&txq))
c0025545:	85 ff                	test   %edi,%edi
c0025547:	74 1f                	je     c0025568 <serial_putc+0x6c>
    intq_putc(&txq, byte);
c0025549:	83 ec 08             	sub    $0x8,%esp
c002554c:	89 f0                	mov    %esi,%eax
c002554e:	0f b6 f0             	movzbl %al,%esi
c0025551:	56                   	push   %esi
c0025552:	8d 83 e4 19 00 00    	lea    0x19e4(%ebx),%eax
c0025558:	50                   	push   %eax
c0025559:	e8 18 1b 00 00       	call   c0027076 <intq_putc>
    write_ier();
c002555e:	e8 b8 fd ff ff       	call   c002531b <write_ier>
c0025563:	83 c4 10             	add    $0x10,%esp
c0025566:	eb c6                	jmp    c002552e <serial_putc+0x32>
    if (old_level == INTR_OFF && intq_full(&txq))
c0025568:	83 ec 0c             	sub    $0xc,%esp
c002556b:	8d 83 e4 19 00 00    	lea    0x19e4(%ebx),%eax
c0025571:	50                   	push   %eax
c0025572:	e8 3a 18 00 00       	call   c0026db1 <intq_full>
c0025577:	83 c4 10             	add    $0x10,%esp
c002557a:	84 c0                	test   %al,%al
c002557c:	74 cb                	je     c0025549 <serial_putc+0x4d>
      putc_poll(intq_getc(&txq));
c002557e:	83 ec 0c             	sub    $0xc,%esp
c0025581:	8d 83 e4 19 00 00    	lea    0x19e4(%ebx),%eax
c0025587:	50                   	push   %eax
c0025588:	e8 18 1a 00 00       	call   c0026fa5 <intq_getc>
c002558d:	0f b6 c0             	movzbl %al,%eax
c0025590:	e8 80 fe ff ff       	call   c0025415 <putc_poll>
c0025595:	83 c4 10             	add    $0x10,%esp
c0025598:	eb af                	jmp    c0025549 <serial_putc+0x4d>

c002559a <serial_flush>:
{
c002559a:	57                   	push   %edi
c002559b:	56                   	push   %esi
c002559c:	53                   	push   %ebx
c002559d:	e8 44 cf 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00255a2:	81 c3 9a b6 01 00    	add    $0x1b69a,%ebx
  enum intr_level old_level = intr_disable();
c00255a8:	e8 fe c9 ff ff       	call   c0021fab <intr_disable>
c00255ad:	89 c7                	mov    %eax,%edi
  while (!intq_empty(&txq))
c00255af:	8d b3 e4 19 00 00    	lea    0x19e4(%ebx),%esi
c00255b5:	eb 14                	jmp    c00255cb <serial_flush+0x31>
    putc_poll(intq_getc(&txq));
c00255b7:	83 ec 0c             	sub    $0xc,%esp
c00255ba:	56                   	push   %esi
c00255bb:	e8 e5 19 00 00       	call   c0026fa5 <intq_getc>
c00255c0:	0f b6 c0             	movzbl %al,%eax
c00255c3:	e8 4d fe ff ff       	call   c0025415 <putc_poll>
c00255c8:	83 c4 10             	add    $0x10,%esp
  while (!intq_empty(&txq))
c00255cb:	83 ec 0c             	sub    $0xc,%esp
c00255ce:	56                   	push   %esi
c00255cf:	e8 88 17 00 00       	call   c0026d5c <intq_empty>
c00255d4:	83 c4 10             	add    $0x10,%esp
c00255d7:	84 c0                	test   %al,%al
c00255d9:	74 dc                	je     c00255b7 <serial_flush+0x1d>
  intr_set_level(old_level);
c00255db:	83 ec 0c             	sub    $0xc,%esp
c00255de:	57                   	push   %edi
c00255df:	e8 ce c9 ff ff       	call   c0021fb2 <intr_set_level>
}
c00255e4:	83 c4 10             	add    $0x10,%esp
c00255e7:	5b                   	pop    %ebx
c00255e8:	5e                   	pop    %esi
c00255e9:	5f                   	pop    %edi
c00255ea:	c3                   	ret    

c00255eb <serial_notify>:
{
c00255eb:	53                   	push   %ebx
c00255ec:	83 ec 08             	sub    $0x8,%esp
c00255ef:	e8 f2 ce 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00255f4:	81 c3 48 b6 01 00    	add    $0x1b648,%ebx
  ASSERT(intr_get_level() == INTR_OFF);
c00255fa:	e8 5a c9 ff ff       	call   c0021f59 <intr_get_level>
c00255ff:	85 c0                	test   %eax,%eax
c0025601:	75 0e                	jne    c0025611 <serial_notify+0x26>
  if (mode == QUEUE)
c0025603:	83 bb 68 1a 00 00 02 	cmpl   $0x2,0x1a68(%ebx)
c002560a:	74 2e                	je     c002563a <serial_notify+0x4f>
}
c002560c:	83 c4 08             	add    $0x8,%esp
c002560f:	5b                   	pop    %ebx
c0025610:	c3                   	ret    
  ASSERT(intr_get_level() == INTR_OFF);
c0025611:	83 ec 0c             	sub    $0xc,%esp
c0025614:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c002561a:	50                   	push   %eax
c002561b:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0025621:	50                   	push   %eax
c0025622:	8d 83 a0 1c ff ff    	lea    -0xe360(%ebx),%eax
c0025628:	50                   	push   %eax
c0025629:	68 94 00 00 00       	push   $0x94
c002562e:	8d 83 3e 3c ff ff    	lea    -0xc3c2(%ebx),%eax
c0025634:	50                   	push   %eax
c0025635:	e8 5b 42 00 00       	call   c0029895 <debug_panic>
    write_ier();
c002563a:	e8 dc fc ff ff       	call   c002531b <write_ier>
}
c002563f:	eb cb                	jmp    c002560c <serial_notify+0x21>

c0025641 <check_sector>:

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector(struct block *block, block_sector_t sector)
{
c0025641:	53                   	push   %ebx
c0025642:	83 ec 08             	sub    $0x8,%esp
c0025645:	e8 b0 ce 00 00       	call   c00324fa <__x86.get_pc_thunk.cx>
c002564a:	81 c1 f2 b5 01 00    	add    $0x1b5f2,%ecx
  if (sector >= block->size)
c0025650:	8b 58 1c             	mov    0x1c(%eax),%ebx
c0025653:	39 d3                	cmp    %edx,%ebx
c0025655:	76 05                	jbe    c002565c <check_sector+0x1b>
         regardless of whether NDEBUG is defined. */
    PANIC("Access past end of device %s (sector=%" PRDSNu ", "
          "size=%" PRDSNu ")\n",
          block_name(block), sector, block->size);
  }
}
c0025657:	83 c4 08             	add    $0x8,%esp
c002565a:	5b                   	pop    %ebx
c002565b:	c3                   	ret    
    PANIC("Access past end of device %s (sector=%" PRDSNu ", "
c002565c:	83 ec 04             	sub    $0x4,%esp
c002565f:	53                   	push   %ebx
c0025660:	52                   	push   %edx

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name(struct block *block)
{
  return block->name;
c0025661:	83 c0 08             	add    $0x8,%eax
    PANIC("Access past end of device %s (sector=%" PRDSNu ", "
c0025664:	50                   	push   %eax
c0025665:	8d 81 6c 3c ff ff    	lea    -0xc394(%ecx),%eax
c002566b:	50                   	push   %eax
c002566c:	8d 81 04 1d ff ff    	lea    -0xe2fc(%ecx),%eax
c0025672:	50                   	push   %eax
c0025673:	6a 70                	push   $0x70
c0025675:	8d 81 fa 3c ff ff    	lea    -0xc306(%ecx),%eax
c002567b:	50                   	push   %eax
c002567c:	89 cb                	mov    %ecx,%ebx
c002567e:	e8 12 42 00 00       	call   c0029895 <debug_panic>

c0025683 <block_type_name>:
{
c0025683:	53                   	push   %ebx
c0025684:	83 ec 08             	sub    $0x8,%esp
c0025687:	e8 5a ce 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002568c:	81 c3 b0 b5 01 00    	add    $0x1b5b0,%ebx
c0025692:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(type < BLOCK_CNT);
c0025696:	83 f8 05             	cmp    $0x5,%eax
c0025699:	77 0c                	ja     c00256a7 <block_type_name+0x24>
  return block_type_names[type];
c002569b:	8b 84 83 54 59 ff ff 	mov    -0xa6ac(%ebx,%eax,4),%eax
}
c00256a2:	83 c4 08             	add    $0x8,%esp
c00256a5:	5b                   	pop    %ebx
c00256a6:	c3                   	ret    
  ASSERT(type < BLOCK_CNT);
c00256a7:	83 ec 0c             	sub    $0xc,%esp
c00256aa:	8d 83 10 3d ff ff    	lea    -0xc2f0(%ebx),%eax
c00256b0:	50                   	push   %eax
c00256b1:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00256b7:	50                   	push   %eax
c00256b8:	8d 83 34 1d ff ff    	lea    -0xe2cc(%ebx),%eax
c00256be:	50                   	push   %eax
c00256bf:	6a 2f                	push   $0x2f
c00256c1:	8d 83 fa 3c ff ff    	lea    -0xc306(%ebx),%eax
c00256c7:	50                   	push   %eax
c00256c8:	e8 c8 41 00 00       	call   c0029895 <debug_panic>

c00256cd <block_get_role>:
{
c00256cd:	53                   	push   %ebx
c00256ce:	83 ec 08             	sub    $0x8,%esp
c00256d1:	e8 10 ce 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00256d6:	81 c3 66 b5 01 00    	add    $0x1b566,%ebx
c00256dc:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(role < BLOCK_ROLE_CNT);
c00256e0:	83 f8 03             	cmp    $0x3,%eax
c00256e3:	77 0c                	ja     c00256f1 <block_get_role+0x24>
  return block_by_role[role];
c00256e5:	8b 84 83 6c 1a 00 00 	mov    0x1a6c(%ebx,%eax,4),%eax
}
c00256ec:	83 c4 08             	add    $0x8,%esp
c00256ef:	5b                   	pop    %ebx
c00256f0:	c3                   	ret    
  ASSERT(role < BLOCK_ROLE_CNT);
c00256f1:	83 ec 0c             	sub    $0xc,%esp
c00256f4:	8d 83 21 3d ff ff    	lea    -0xc2df(%ebx),%eax
c00256fa:	50                   	push   %eax
c00256fb:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0025701:	50                   	push   %eax
c0025702:	8d 83 24 1d ff ff    	lea    -0xe2dc(%ebx),%eax
c0025708:	50                   	push   %eax
c0025709:	6a 38                	push   $0x38
c002570b:	8d 83 fa 3c ff ff    	lea    -0xc306(%ebx),%eax
c0025711:	50                   	push   %eax
c0025712:	e8 7e 41 00 00       	call   c0029895 <debug_panic>

c0025717 <block_set_role>:
{
c0025717:	53                   	push   %ebx
c0025718:	83 ec 08             	sub    $0x8,%esp
c002571b:	e8 c6 cd 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0025720:	81 c3 1c b5 01 00    	add    $0x1b51c,%ebx
c0025726:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(role < BLOCK_ROLE_CNT);
c002572a:	83 f8 03             	cmp    $0x3,%eax
c002572d:	77 10                	ja     c002573f <block_set_role+0x28>
  block_by_role[role] = block;
c002572f:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0025733:	89 8c 83 6c 1a 00 00 	mov    %ecx,0x1a6c(%ebx,%eax,4)
}
c002573a:	83 c4 08             	add    $0x8,%esp
c002573d:	5b                   	pop    %ebx
c002573e:	c3                   	ret    
  ASSERT(role < BLOCK_ROLE_CNT);
c002573f:	83 ec 0c             	sub    $0xc,%esp
c0025742:	8d 83 21 3d ff ff    	lea    -0xc2df(%ebx),%eax
c0025748:	50                   	push   %eax
c0025749:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002574f:	50                   	push   %eax
c0025750:	8d 83 14 1d ff ff    	lea    -0xe2ec(%ebx),%eax
c0025756:	50                   	push   %eax
c0025757:	6a 3f                	push   $0x3f
c0025759:	8d 83 fa 3c ff ff    	lea    -0xc306(%ebx),%eax
c002575f:	50                   	push   %eax
c0025760:	e8 30 41 00 00       	call   c0029895 <debug_panic>

c0025765 <block_first>:
{
c0025765:	57                   	push   %edi
c0025766:	56                   	push   %esi
c0025767:	53                   	push   %ebx
c0025768:	e8 79 cd 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002576d:	81 c3 cf b4 01 00    	add    $0x1b4cf,%ebx
  return list_elem_to_block(list_begin(&all_blocks));
c0025773:	83 ec 0c             	sub    $0xc,%esp
c0025776:	8d bb c4 ff ff ff    	lea    -0x3c(%ebx),%edi
c002577c:	57                   	push   %edi
c002577d:	e8 38 42 00 00       	call   c00299ba <list_begin>
c0025782:	89 c6                	mov    %eax,%esi
/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block(struct list_elem *list_elem)
{
  return (list_elem != list_end(&all_blocks)
c0025784:	89 3c 24             	mov    %edi,(%esp)
c0025787:	e8 d0 42 00 00       	call   c0029a5c <list_end>
              ? list_entry(list_elem, struct block, list_elem)
              : NULL);
c002578c:	83 c4 10             	add    $0x10,%esp
c002578f:	39 c6                	cmp    %eax,%esi
c0025791:	b8 00 00 00 00       	mov    $0x0,%eax
c0025796:	0f 44 f0             	cmove  %eax,%esi
}
c0025799:	89 f0                	mov    %esi,%eax
c002579b:	5b                   	pop    %ebx
c002579c:	5e                   	pop    %esi
c002579d:	5f                   	pop    %edi
c002579e:	c3                   	ret    

c002579f <block_next>:
{
c002579f:	56                   	push   %esi
c00257a0:	53                   	push   %ebx
c00257a1:	83 ec 10             	sub    $0x10,%esp
c00257a4:	e8 3d cd 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00257a9:	81 c3 93 b4 01 00    	add    $0x1b493,%ebx
  return list_elem_to_block(list_next(&block->list_elem));
c00257af:	ff 74 24 1c          	pushl  0x1c(%esp)
c00257b3:	e8 47 42 00 00       	call   c00299ff <list_next>
c00257b8:	89 c6                	mov    %eax,%esi
  return (list_elem != list_end(&all_blocks)
c00257ba:	8d 83 c4 ff ff ff    	lea    -0x3c(%ebx),%eax
c00257c0:	89 04 24             	mov    %eax,(%esp)
c00257c3:	e8 94 42 00 00       	call   c0029a5c <list_end>
              : NULL);
c00257c8:	39 c6                	cmp    %eax,%esi
c00257ca:	b8 00 00 00 00       	mov    $0x0,%eax
c00257cf:	0f 44 f0             	cmove  %eax,%esi
}
c00257d2:	89 f0                	mov    %esi,%eax
c00257d4:	83 c4 14             	add    $0x14,%esp
c00257d7:	5b                   	pop    %ebx
c00257d8:	5e                   	pop    %esi
c00257d9:	c3                   	ret    

c00257da <block_get_by_name>:
{
c00257da:	55                   	push   %ebp
c00257db:	57                   	push   %edi
c00257dc:	56                   	push   %esi
c00257dd:	53                   	push   %ebx
c00257de:	83 ec 18             	sub    $0x18,%esp
c00257e1:	e8 00 cd 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00257e6:	81 c3 56 b4 01 00    	add    $0x1b456,%ebx
c00257ec:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
  for (e = list_begin(&all_blocks); e != list_end(&all_blocks);
c00257f0:	8d 83 c4 ff ff ff    	lea    -0x3c(%ebx),%eax
c00257f6:	50                   	push   %eax
c00257f7:	e8 be 41 00 00       	call   c00299ba <list_begin>
c00257fc:	89 c6                	mov    %eax,%esi
c00257fe:	83 c4 10             	add    $0x10,%esp
c0025801:	8d bb c4 ff ff ff    	lea    -0x3c(%ebx),%edi
c0025807:	83 ec 0c             	sub    $0xc,%esp
c002580a:	57                   	push   %edi
c002580b:	e8 4c 42 00 00       	call   c0029a5c <list_end>
c0025810:	83 c4 10             	add    $0x10,%esp
c0025813:	39 f0                	cmp    %esi,%eax
c0025815:	74 24                	je     c002583b <block_get_by_name+0x61>
    if (!strcmp(name, block->name))
c0025817:	8d 46 08             	lea    0x8(%esi),%eax
c002581a:	83 ec 08             	sub    $0x8,%esp
c002581d:	50                   	push   %eax
c002581e:	55                   	push   %ebp
c002581f:	e8 36 33 00 00       	call   c0028b5a <strcmp>
c0025824:	83 c4 10             	add    $0x10,%esp
c0025827:	85 c0                	test   %eax,%eax
c0025829:	74 15                	je     c0025840 <block_get_by_name+0x66>
       e = list_next(e))
c002582b:	83 ec 0c             	sub    $0xc,%esp
c002582e:	56                   	push   %esi
c002582f:	e8 cb 41 00 00       	call   c00299ff <list_next>
c0025834:	89 c6                	mov    %eax,%esi
c0025836:	83 c4 10             	add    $0x10,%esp
c0025839:	eb cc                	jmp    c0025807 <block_get_by_name+0x2d>
  return NULL;
c002583b:	be 00 00 00 00       	mov    $0x0,%esi
}
c0025840:	89 f0                	mov    %esi,%eax
c0025842:	83 c4 0c             	add    $0xc,%esp
c0025845:	5b                   	pop    %ebx
c0025846:	5e                   	pop    %esi
c0025847:	5f                   	pop    %edi
c0025848:	5d                   	pop    %ebp
c0025849:	c3                   	ret    

c002584a <block_read>:
{
c002584a:	56                   	push   %esi
c002584b:	53                   	push   %ebx
c002584c:	83 ec 04             	sub    $0x4,%esp
c002584f:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0025853:	8b 74 24 14          	mov    0x14(%esp),%esi
  check_sector(block, sector);
c0025857:	89 f2                	mov    %esi,%edx
c0025859:	89 d8                	mov    %ebx,%eax
c002585b:	e8 e1 fd ff ff       	call   c0025641 <check_sector>
  block->ops->read(block->aux, sector, buffer);
c0025860:	83 ec 04             	sub    $0x4,%esp
c0025863:	8b 43 20             	mov    0x20(%ebx),%eax
c0025866:	ff 74 24 1c          	pushl  0x1c(%esp)
c002586a:	56                   	push   %esi
c002586b:	ff 73 24             	pushl  0x24(%ebx)
c002586e:	ff 10                	call   *(%eax)
  block->read_cnt++;
c0025870:	83 43 28 01          	addl   $0x1,0x28(%ebx)
c0025874:	83 53 2c 00          	adcl   $0x0,0x2c(%ebx)
}
c0025878:	83 c4 14             	add    $0x14,%esp
c002587b:	5b                   	pop    %ebx
c002587c:	5e                   	pop    %esi
c002587d:	c3                   	ret    

c002587e <block_write>:
{
c002587e:	57                   	push   %edi
c002587f:	56                   	push   %esi
c0025880:	53                   	push   %ebx
c0025881:	e8 60 cc 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0025886:	81 c3 b6 b3 01 00    	add    $0x1b3b6,%ebx
c002588c:	8b 74 24 10          	mov    0x10(%esp),%esi
c0025890:	8b 7c 24 14          	mov    0x14(%esp),%edi
  check_sector(block, sector);
c0025894:	89 fa                	mov    %edi,%edx
c0025896:	89 f0                	mov    %esi,%eax
c0025898:	e8 a4 fd ff ff       	call   c0025641 <check_sector>
  ASSERT(block->type != BLOCK_FOREIGN);
c002589d:	83 7e 18 05          	cmpl   $0x5,0x18(%esi)
c00258a1:	74 20                	je     c00258c3 <block_write+0x45>
  block->ops->write(block->aux, sector, buffer);
c00258a3:	83 ec 04             	sub    $0x4,%esp
c00258a6:	8b 46 20             	mov    0x20(%esi),%eax
c00258a9:	ff 74 24 1c          	pushl  0x1c(%esp)
c00258ad:	57                   	push   %edi
c00258ae:	ff 76 24             	pushl  0x24(%esi)
c00258b1:	ff 50 04             	call   *0x4(%eax)
  block->write_cnt++;
c00258b4:	83 46 30 01          	addl   $0x1,0x30(%esi)
c00258b8:	83 56 34 00          	adcl   $0x0,0x34(%esi)
}
c00258bc:	83 c4 10             	add    $0x10,%esp
c00258bf:	5b                   	pop    %ebx
c00258c0:	5e                   	pop    %esi
c00258c1:	5f                   	pop    %edi
c00258c2:	c3                   	ret    
  ASSERT(block->type != BLOCK_FOREIGN);
c00258c3:	83 ec 0c             	sub    $0xc,%esp
c00258c6:	8d 83 37 3d ff ff    	lea    -0xc2c9(%ebx),%eax
c00258cc:	50                   	push   %eax
c00258cd:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00258d3:	50                   	push   %eax
c00258d4:	8d 83 f8 1c ff ff    	lea    -0xe308(%ebx),%eax
c00258da:	50                   	push   %eax
c00258db:	68 87 00 00 00       	push   $0x87
c00258e0:	8d 83 fa 3c ff ff    	lea    -0xc306(%ebx),%eax
c00258e6:	50                   	push   %eax
c00258e7:	e8 a9 3f 00 00       	call   c0029895 <debug_panic>

c00258ec <block_size>:
  return block->size;
c00258ec:	8b 44 24 04          	mov    0x4(%esp),%eax
c00258f0:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c00258f3:	c3                   	ret    

c00258f4 <block_name>:
  return block->name;
c00258f4:	8b 44 24 04          	mov    0x4(%esp),%eax
c00258f8:	83 c0 08             	add    $0x8,%eax
}
c00258fb:	c3                   	ret    

c00258fc <block_type>:
  return block->type;
c00258fc:	8b 44 24 04          	mov    0x4(%esp),%eax
c0025900:	8b 40 18             	mov    0x18(%eax),%eax
}
c0025903:	c3                   	ret    

c0025904 <block_print_stats>:
{
c0025904:	55                   	push   %ebp
c0025905:	57                   	push   %edi
c0025906:	56                   	push   %esi
c0025907:	53                   	push   %ebx
c0025908:	83 ec 1c             	sub    $0x1c,%esp
c002590b:	e8 d6 cb 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0025910:	81 c3 2c b3 01 00    	add    $0x1b32c,%ebx
c0025916:	8d bb 6c 1a 00 00    	lea    0x1a6c(%ebx),%edi
c002591c:	8d 6f 10             	lea    0x10(%edi),%ebp
      printf("%s (%s): %llu reads, %llu writes\n",
c002591f:	8d 83 a0 3c ff ff    	lea    -0xc360(%ebx),%eax
c0025925:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0025929:	eb 07                	jmp    c0025932 <block_print_stats+0x2e>
c002592b:	83 c7 04             	add    $0x4,%edi
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c002592e:	39 ef                	cmp    %ebp,%edi
c0025930:	74 33                	je     c0025965 <block_print_stats+0x61>
    struct block *block = block_by_role[i];
c0025932:	8b 37                	mov    (%edi),%esi
    if (block != NULL)
c0025934:	85 f6                	test   %esi,%esi
c0025936:	74 f3                	je     c002592b <block_print_stats+0x27>
      printf("%s (%s): %llu reads, %llu writes\n",
c0025938:	83 ec 0c             	sub    $0xc,%esp
c002593b:	ff 76 18             	pushl  0x18(%esi)
c002593e:	e8 40 fd ff ff       	call   c0025683 <block_type_name>
c0025943:	83 c4 0c             	add    $0xc,%esp
c0025946:	ff 76 34             	pushl  0x34(%esi)
c0025949:	ff 76 30             	pushl  0x30(%esi)
c002594c:	ff 76 2c             	pushl  0x2c(%esi)
c002594f:	ff 76 28             	pushl  0x28(%esi)
c0025952:	50                   	push   %eax
c0025953:	83 c6 08             	add    $0x8,%esi
c0025956:	56                   	push   %esi
c0025957:	ff 74 24 28          	pushl  0x28(%esp)
c002595b:	e8 9e 21 00 00       	call   c0027afe <printf>
c0025960:	83 c4 20             	add    $0x20,%esp
c0025963:	eb c6                	jmp    c002592b <block_print_stats+0x27>
}
c0025965:	83 c4 1c             	add    $0x1c,%esp
c0025968:	5b                   	pop    %ebx
c0025969:	5e                   	pop    %esi
c002596a:	5f                   	pop    %edi
c002596b:	5d                   	pop    %ebp
c002596c:	c3                   	ret    

c002596d <block_register>:
{
c002596d:	55                   	push   %ebp
c002596e:	57                   	push   %edi
c002596f:	56                   	push   %esi
c0025970:	53                   	push   %ebx
c0025971:	83 ec 18             	sub    $0x18,%esp
c0025974:	e8 6d cb 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0025979:	81 c3 c3 b2 01 00    	add    $0x1b2c3,%ebx
c002597f:	8b 7c 24 38          	mov    0x38(%esp),%edi
  struct block *block = malloc(sizeof *block);
c0025983:	6a 38                	push   $0x38
c0025985:	e8 5a e9 ff ff       	call   c00242e4 <malloc>
  if (block == NULL)
c002598a:	83 c4 10             	add    $0x10,%esp
c002598d:	85 c0                	test   %eax,%eax
c002598f:	0f 84 c6 00 00 00    	je     c0025a5b <block_register+0xee>
c0025995:	89 c6                	mov    %eax,%esi
  list_push_back(&all_blocks, &block->list_elem);
c0025997:	83 ec 08             	sub    $0x8,%esp
c002599a:	50                   	push   %eax
c002599b:	8d 83 c4 ff ff ff    	lea    -0x3c(%ebx),%eax
c00259a1:	50                   	push   %eax
c00259a2:	e8 a1 45 00 00       	call   c0029f48 <list_push_back>
  strlcpy(block->name, name, sizeof block->name);
c00259a7:	8d 6e 08             	lea    0x8(%esi),%ebp
c00259aa:	83 c4 0c             	add    $0xc,%esp
c00259ad:	6a 10                	push   $0x10
c00259af:	ff 74 24 28          	pushl  0x28(%esp)
c00259b3:	55                   	push   %ebp
c00259b4:	e8 31 35 00 00       	call   c0028eea <strlcpy>
  block->type = type;
c00259b9:	8b 44 24 34          	mov    0x34(%esp),%eax
c00259bd:	89 46 18             	mov    %eax,0x18(%esi)
  block->size = size;
c00259c0:	89 7e 1c             	mov    %edi,0x1c(%esi)
  block->ops = ops;
c00259c3:	8b 44 24 40          	mov    0x40(%esp),%eax
c00259c7:	89 46 20             	mov    %eax,0x20(%esi)
  block->aux = aux;
c00259ca:	8b 44 24 44          	mov    0x44(%esp),%eax
c00259ce:	89 46 24             	mov    %eax,0x24(%esi)
  block->read_cnt = 0;
c00259d1:	c7 46 28 00 00 00 00 	movl   $0x0,0x28(%esi)
c00259d8:	c7 46 2c 00 00 00 00 	movl   $0x0,0x2c(%esi)
  block->write_cnt = 0;
c00259df:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
c00259e6:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  printf("%s: %'" PRDSNu " sectors (", block->name, block->size);
c00259ed:	83 c4 0c             	add    $0xc,%esp
c00259f0:	57                   	push   %edi
c00259f1:	55                   	push   %ebp
c00259f2:	8d 83 54 3d ff ff    	lea    -0xc2ac(%ebx),%eax
c00259f8:	50                   	push   %eax
c00259f9:	e8 00 21 00 00       	call   c0027afe <printf>
  print_human_readable_size((uint64_t)block->size * BLOCK_SECTOR_SIZE);
c00259fe:	83 c4 08             	add    $0x8,%esp
c0025a01:	8b 7e 1c             	mov    0x1c(%esi),%edi
c0025a04:	bd 00 00 00 00       	mov    $0x0,%ebp
c0025a09:	89 f8                	mov    %edi,%eax
c0025a0b:	89 ea                	mov    %ebp,%edx
c0025a0d:	0f a4 fa 09          	shld   $0x9,%edi,%edx
c0025a11:	c1 e0 09             	shl    $0x9,%eax
c0025a14:	52                   	push   %edx
c0025a15:	50                   	push   %eax
c0025a16:	e8 15 2c 00 00       	call   c0028630 <print_human_readable_size>
  printf(")");
c0025a1b:	c7 04 24 29 00 00 00 	movl   $0x29,(%esp)
c0025a22:	e8 b9 5e 00 00       	call   c002b8e0 <putchar>
  if (extra_info != NULL)
c0025a27:	83 c4 10             	add    $0x10,%esp
c0025a2a:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0025a2f:	74 16                	je     c0025a47 <block_register+0xda>
    printf(", %s", extra_info);
c0025a31:	83 ec 08             	sub    $0x8,%esp
c0025a34:	ff 74 24 30          	pushl  0x30(%esp)
c0025a38:	8d 83 66 3d ff ff    	lea    -0xc29a(%ebx),%eax
c0025a3e:	50                   	push   %eax
c0025a3f:	e8 ba 20 00 00       	call   c0027afe <printf>
c0025a44:	83 c4 10             	add    $0x10,%esp
  printf("\n");
c0025a47:	83 ec 0c             	sub    $0xc,%esp
c0025a4a:	6a 0a                	push   $0xa
c0025a4c:	e8 8f 5e 00 00       	call   c002b8e0 <putchar>
}
c0025a51:	89 f0                	mov    %esi,%eax
c0025a53:	83 c4 1c             	add    $0x1c,%esp
c0025a56:	5b                   	pop    %ebx
c0025a57:	5e                   	pop    %esi
c0025a58:	5f                   	pop    %edi
c0025a59:	5d                   	pop    %ebp
c0025a5a:	c3                   	ret    
    PANIC("Failed to allocate memory for block device descriptor");
c0025a5b:	8d 83 c4 3c ff ff    	lea    -0xc33c(%ebx),%eax
c0025a61:	50                   	push   %eax
c0025a62:	8d 83 e8 1c ff ff    	lea    -0xe318(%ebx),%eax
c0025a68:	50                   	push   %eax
c0025a69:	68 be 00 00 00       	push   $0xbe
c0025a6e:	8d 83 fa 3c ff ff    	lea    -0xc306(%ebx),%eax
c0025a74:	50                   	push   %eax
c0025a75:	e8 1b 3e 00 00       	call   c0029895 <debug_panic>

c0025a7a <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read(void *p_, block_sector_t sector, void *buffer)
{
c0025a7a:	53                   	push   %ebx
c0025a7b:	83 ec 0c             	sub    $0xc,%esp
c0025a7e:	e8 63 ca 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0025a83:	81 c3 b9 b1 01 00    	add    $0x1b1b9,%ebx
c0025a89:	8b 54 24 14          	mov    0x14(%esp),%edx
  struct partition *p = p_;
  block_read(p->block, p->start + sector, buffer);
c0025a8d:	ff 74 24 1c          	pushl  0x1c(%esp)
c0025a91:	8b 42 04             	mov    0x4(%edx),%eax
c0025a94:	03 44 24 1c          	add    0x1c(%esp),%eax
c0025a98:	50                   	push   %eax
c0025a99:	ff 32                	pushl  (%edx)
c0025a9b:	e8 aa fd ff ff       	call   c002584a <block_read>
}
c0025aa0:	83 c4 18             	add    $0x18,%esp
c0025aa3:	5b                   	pop    %ebx
c0025aa4:	c3                   	ret    

c0025aa5 <read_partition_table>:
{
c0025aa5:	55                   	push   %ebp
c0025aa6:	57                   	push   %edi
c0025aa7:	56                   	push   %esi
c0025aa8:	53                   	push   %ebx
c0025aa9:	81 ec d8 00 00 00    	sub    $0xd8,%esp
c0025aaf:	e8 32 ca 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0025ab4:	81 c3 88 b1 01 00    	add    $0x1b188,%ebx
c0025aba:	89 c6                	mov    %eax,%esi
c0025abc:	89 d7                	mov    %edx,%edi
c0025abe:	89 54 24 14          	mov    %edx,0x14(%esp)
c0025ac2:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  if (sector >= block_size(block))
c0025ac6:	50                   	push   %eax
c0025ac7:	e8 20 fe ff ff       	call   c00258ec <block_size>
c0025acc:	83 c4 10             	add    $0x10,%esp
c0025acf:	39 f8                	cmp    %edi,%eax
c0025ad1:	76 65                	jbe    c0025b38 <read_partition_table+0x93>
  pt = malloc(sizeof *pt);
c0025ad3:	83 ec 0c             	sub    $0xc,%esp
c0025ad6:	68 00 02 00 00       	push   $0x200
c0025adb:	e8 04 e8 ff ff       	call   c00242e4 <malloc>
c0025ae0:	89 c5                	mov    %eax,%ebp
  if (pt == NULL)
c0025ae2:	83 c4 10             	add    $0x10,%esp
c0025ae5:	85 c0                	test   %eax,%eax
c0025ae7:	74 77                	je     c0025b60 <read_partition_table+0xbb>
  block_read(block, 0, pt);
c0025ae9:	83 ec 04             	sub    $0x4,%esp
c0025aec:	50                   	push   %eax
c0025aed:	6a 00                	push   $0x0
c0025aef:	56                   	push   %esi
c0025af0:	e8 55 fd ff ff       	call   c002584a <block_read>
  if (pt->signature != 0xaa55)
c0025af5:	83 c4 10             	add    $0x10,%esp
c0025af8:	66 81 bd fe 01 00 00 	cmpw   $0xaa55,0x1fe(%ebp)
c0025aff:	55 aa 
c0025b01:	0f 84 97 00 00 00    	je     c0025b9e <read_partition_table+0xf9>
    if (primary_extended_sector == 0)
c0025b07:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0025b0c:	75 6e                	jne    c0025b7c <read_partition_table+0xd7>
      printf("%s: Invalid partition table signature\n", block_name(block));
c0025b0e:	83 ec 0c             	sub    $0xc,%esp
c0025b11:	56                   	push   %esi
c0025b12:	e8 dd fd ff ff       	call   c00258f4 <block_name>
c0025b17:	83 c4 08             	add    $0x8,%esp
c0025b1a:	50                   	push   %eax
c0025b1b:	8d 83 78 42 ff ff    	lea    -0xbd88(%ebx),%eax
c0025b21:	50                   	push   %eax
c0025b22:	e8 d7 1f 00 00       	call   c0027afe <printf>
c0025b27:	83 c4 10             	add    $0x10,%esp
    free(pt);
c0025b2a:	83 ec 0c             	sub    $0xc,%esp
c0025b2d:	55                   	push   %ebp
c0025b2e:	e8 67 e9 ff ff       	call   c002449a <free>
    return;
c0025b33:	83 c4 10             	add    $0x10,%esp
c0025b36:	eb 1d                	jmp    c0025b55 <read_partition_table+0xb0>
    printf("%s: Partition table at sector %" PRDSNu " past end of device.\n",
c0025b38:	83 ec 0c             	sub    $0xc,%esp
c0025b3b:	56                   	push   %esi
c0025b3c:	e8 b3 fd ff ff       	call   c00258f4 <block_name>
c0025b41:	83 c4 0c             	add    $0xc,%esp
c0025b44:	57                   	push   %edi
c0025b45:	50                   	push   %eax
c0025b46:	8d 83 10 42 ff ff    	lea    -0xbdf0(%ebx),%eax
c0025b4c:	50                   	push   %eax
c0025b4d:	e8 ac 1f 00 00       	call   c0027afe <printf>
    return;
c0025b52:	83 c4 10             	add    $0x10,%esp
}
c0025b55:	81 c4 cc 00 00 00    	add    $0xcc,%esp
c0025b5b:	5b                   	pop    %ebx
c0025b5c:	5e                   	pop    %esi
c0025b5d:	5f                   	pop    %edi
c0025b5e:	5d                   	pop    %ebp
c0025b5f:	c3                   	ret    
    PANIC("Failed to allocate memory for partition table.");
c0025b60:	8d 83 48 42 ff ff    	lea    -0xbdb8(%ebx),%eax
c0025b66:	50                   	push   %eax
c0025b67:	8d 83 54 1d ff ff    	lea    -0xe2ac(%ebx),%eax
c0025b6d:	50                   	push   %eax
c0025b6e:	6a 57                	push   $0x57
c0025b70:	8d 83 7f 3d ff ff    	lea    -0xc281(%ebx),%eax
c0025b76:	50                   	push   %eax
c0025b77:	e8 19 3d 00 00       	call   c0029895 <debug_panic>
      printf("%s: Invalid extended partition table in sector %" PRDSNu "\n",
c0025b7c:	83 ec 0c             	sub    $0xc,%esp
c0025b7f:	56                   	push   %esi
c0025b80:	e8 6f fd ff ff       	call   c00258f4 <block_name>
c0025b85:	83 c4 0c             	add    $0xc,%esp
c0025b88:	ff 74 24 0c          	pushl  0xc(%esp)
c0025b8c:	50                   	push   %eax
c0025b8d:	8d 83 a0 42 ff ff    	lea    -0xbd60(%ebx),%eax
c0025b93:	50                   	push   %eax
c0025b94:	e8 65 1f 00 00       	call   c0027afe <printf>
c0025b99:	83 c4 10             	add    $0x10,%esp
c0025b9c:	eb 8c                	jmp    c0025b2a <read_partition_table+0x85>
c0025b9e:	8d bd c2 01 00 00    	lea    0x1c2(%ebp),%edi
c0025ba4:	8d 85 02 02 00 00    	lea    0x202(%ebp),%eax
c0025baa:	89 44 24 0c          	mov    %eax,0xc(%esp)
      printf("%s: Extended partition in sector %" PRDSNu "\n",
c0025bae:	8d 83 d4 42 ff ff    	lea    -0xbd2c(%ebx),%eax
c0025bb4:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    printf("%s%d: Partition end (%" PRDSNu ") past end of device (%" PRDSNu ")\n",
c0025bb8:	8d 83 34 43 ff ff    	lea    -0xbccc(%ebx),%eax
c0025bbe:	89 44 24 20          	mov    %eax,0x20(%esp)
c0025bc2:	89 6c 24 18          	mov    %ebp,0x18(%esp)
c0025bc6:	89 74 24 14          	mov    %esi,0x14(%esp)
c0025bca:	eb 30                	jmp    c0025bfc <read_partition_table+0x157>
        read_partition_table(block, e->offset + primary_extended_sector,
c0025bcc:	8b 44 24 10          	mov    0x10(%esp),%eax
c0025bd0:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0025bd4:	89 ca                	mov    %ecx,%edx
c0025bd6:	03 50 04             	add    0x4(%eax),%edx
c0025bd9:	83 ec 0c             	sub    $0xc,%esp
c0025bdc:	ff b4 24 ec 00 00 00 	pushl  0xec(%esp)
c0025be3:	8b 44 24 24          	mov    0x24(%esp),%eax
c0025be7:	e8 b9 fe ff ff       	call   c0025aa5 <read_partition_table>
c0025bec:	83 c4 10             	add    $0x10,%esp
c0025bef:	83 c7 10             	add    $0x10,%edi
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0025bf2:	3b 7c 24 0c          	cmp    0xc(%esp),%edi
c0025bf6:	0f 84 04 02 00 00    	je     c0025e00 <read_partition_table+0x35b>
c0025bfc:	89 7c 24 10          	mov    %edi,0x10(%esp)
    if (e->size == 0 || e->type == 0)
c0025c00:	8b 77 08             	mov    0x8(%edi),%esi
c0025c03:	85 f6                	test   %esi,%esi
c0025c05:	74 e8                	je     c0025bef <read_partition_table+0x14a>
c0025c07:	0f b6 2f             	movzbl (%edi),%ebp
c0025c0a:	89 e8                	mov    %ebp,%eax
c0025c0c:	84 c0                	test   %al,%al
c0025c0e:	74 df                	je     c0025bef <read_partition_table+0x14a>
             || e->type == 0x0f  /* Windows 98 extended partition. */
c0025c10:	3c 0f                	cmp    $0xf,%al
c0025c12:	0f 94 c2             	sete   %dl
             || e->type == 0xc5) /* DR-DOS extended partition. */
c0025c15:	3c c5                	cmp    $0xc5,%al
c0025c17:	0f 94 c0             	sete   %al
c0025c1a:	08 c2                	or     %al,%dl
c0025c1c:	75 09                	jne    c0025c27 <read_partition_table+0x182>
             || e->type == 0x0f  /* Windows 98 extended partition. */
c0025c1e:	89 e8                	mov    %ebp,%eax
c0025c20:	83 e0 7f             	and    $0x7f,%eax
             || e->type == 0xc5) /* DR-DOS extended partition. */
c0025c23:	3c 05                	cmp    $0x5,%al
c0025c25:	75 4c                	jne    c0025c73 <read_partition_table+0x1ce>
      printf("%s: Extended partition in sector %" PRDSNu "\n",
c0025c27:	83 ec 0c             	sub    $0xc,%esp
c0025c2a:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0025c2e:	55                   	push   %ebp
c0025c2f:	e8 c0 fc ff ff       	call   c00258f4 <block_name>
c0025c34:	83 c4 0c             	add    $0xc,%esp
c0025c37:	8b 74 24 0c          	mov    0xc(%esp),%esi
c0025c3b:	56                   	push   %esi
c0025c3c:	50                   	push   %eax
c0025c3d:	ff 74 24 28          	pushl  0x28(%esp)
c0025c41:	e8 b8 1e 00 00       	call   c0027afe <printf>
      if (sector == 0)
c0025c46:	83 c4 10             	add    $0x10,%esp
c0025c49:	85 f6                	test   %esi,%esi
c0025c4b:	0f 85 7b ff ff ff    	jne    c0025bcc <read_partition_table+0x127>
        read_partition_table(block, e->offset, e->offset, part_nr);
c0025c51:	8b 44 24 10          	mov    0x10(%esp),%eax
c0025c55:	8b 50 04             	mov    0x4(%eax),%edx
c0025c58:	83 ec 0c             	sub    $0xc,%esp
c0025c5b:	ff b4 24 ec 00 00 00 	pushl  0xec(%esp)
c0025c62:	89 d1                	mov    %edx,%ecx
c0025c64:	89 e8                	mov    %ebp,%eax
c0025c66:	e8 3a fe ff ff       	call   c0025aa5 <read_partition_table>
c0025c6b:	83 c4 10             	add    $0x10,%esp
c0025c6e:	e9 7c ff ff ff       	jmp    c0025bef <read_partition_table+0x14a>
      ++*part_nr;
c0025c73:	8b 84 24 e0 00 00 00 	mov    0xe0(%esp),%eax
c0025c7a:	8b 00                	mov    (%eax),%eax
c0025c7c:	83 c0 01             	add    $0x1,%eax
c0025c7f:	89 44 24 24          	mov    %eax,0x24(%esp)
c0025c83:	8b 8c 24 e0 00 00 00 	mov    0xe0(%esp),%ecx
c0025c8a:	89 01                	mov    %eax,(%ecx)
      found_partition(block, e->type, e->offset + sector,
c0025c8c:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0025c90:	8b 44 24 08          	mov    0x8(%esp),%eax
c0025c94:	03 41 04             	add    0x4(%ecx),%eax
c0025c97:	89 44 24 10          	mov    %eax,0x10(%esp)
  if (start >= block_size(block))
c0025c9b:	83 ec 0c             	sub    $0xc,%esp
c0025c9e:	ff 74 24 20          	pushl  0x20(%esp)
c0025ca2:	e8 45 fc ff ff       	call   c00258ec <block_size>
c0025ca7:	83 c4 10             	add    $0x10,%esp
c0025caa:	39 44 24 10          	cmp    %eax,0x10(%esp)
c0025cae:	0f 83 c6 00 00 00    	jae    c0025d7a <read_partition_table+0x2d5>
  else if (start + size < start || start + size > block_size(block))
c0025cb4:	8b 44 24 10          	mov    0x10(%esp),%eax
c0025cb8:	01 f0                	add    %esi,%eax
c0025cba:	89 44 24 28          	mov    %eax,0x28(%esp)
c0025cbe:	0f 82 df 00 00 00    	jb     c0025da3 <read_partition_table+0x2fe>
c0025cc4:	83 ec 0c             	sub    $0xc,%esp
c0025cc7:	ff 74 24 20          	pushl  0x20(%esp)
c0025ccb:	e8 1c fc ff ff       	call   c00258ec <block_size>
c0025cd0:	83 c4 10             	add    $0x10,%esp
c0025cd3:	39 44 24 28          	cmp    %eax,0x28(%esp)
c0025cd7:	0f 87 c6 00 00 00    	ja     c0025da3 <read_partition_table+0x2fe>
      found_partition(block, e->type, e->offset + sector,
c0025cdd:	89 e8                	mov    %ebp,%eax
c0025cdf:	0f b6 c0             	movzbl %al,%eax
c0025ce2:	89 44 24 28          	mov    %eax,0x28(%esp)
                                              : part_type == 0x21 ? BLOCK_FILESYS
c0025ce6:	89 e8                	mov    %ebp,%eax
c0025ce8:	3c 20                	cmp    $0x20,%al
c0025cea:	0f 84 25 01 00 00    	je     c0025e15 <read_partition_table+0x370>
c0025cf0:	3c 21                	cmp    $0x21,%al
c0025cf2:	0f 84 c0 01 00 00    	je     c0025eb8 <read_partition_table+0x413>
c0025cf8:	3c 22                	cmp    $0x22,%al
c0025cfa:	0f 84 c5 01 00 00    	je     c0025ec5 <read_partition_table+0x420>
c0025d00:	3c 23                	cmp    $0x23,%al
c0025d02:	0f 84 ca 01 00 00    	je     c0025ed2 <read_partition_table+0x42d>
    p = malloc(sizeof *p);
c0025d08:	83 ec 0c             	sub    $0xc,%esp
c0025d0b:	6a 08                	push   $0x8
c0025d0d:	e8 d2 e5 ff ff       	call   c00242e4 <malloc>
c0025d12:	89 c5                	mov    %eax,%ebp
    if (p == NULL)
c0025d14:	83 c4 10             	add    $0x10,%esp
c0025d17:	85 c0                	test   %eax,%eax
c0025d19:	0f 84 b8 00 00 00    	je     c0025dd7 <read_partition_table+0x332>
    p->block = block;
c0025d1f:	8b 44 24 14          	mov    0x14(%esp),%eax
c0025d23:	89 45 00             	mov    %eax,0x0(%ebp)
    p->start = start;
c0025d26:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0025d2a:	89 4d 04             	mov    %ecx,0x4(%ebp)
    snprintf(name, sizeof name, "%s%d", block_name(block), part_nr);
c0025d2d:	83 ec 0c             	sub    $0xc,%esp
c0025d30:	50                   	push   %eax
c0025d31:	e8 be fb ff ff       	call   c00258f4 <block_name>
c0025d36:	83 c4 04             	add    $0x4,%esp
c0025d39:	ff 74 24 30          	pushl  0x30(%esp)
c0025d3d:	50                   	push   %eax
c0025d3e:	8d 83 99 3d ff ff    	lea    -0xc267(%ebx),%eax
c0025d44:	50                   	push   %eax
c0025d45:	6a 10                	push   $0x10
c0025d47:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c0025d4b:	50                   	push   %eax
c0025d4c:	e8 ce 26 00 00       	call   c002841f <snprintf>
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025d51:	8b 44 24 48          	mov    0x48(%esp),%eax
c0025d55:	8b 84 83 84 59 ff ff 	mov    -0xa67c(%ebx,%eax,4),%eax
c0025d5c:	83 c4 20             	add    $0x20,%esp
c0025d5f:	85 c0                	test   %eax,%eax
c0025d61:	0f 85 8f 00 00 00    	jne    c0025df6 <read_partition_table+0x351>
                                              : part_type == 0x21 ? BLOCK_FILESYS
c0025d67:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c0025d6e:	00 
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025d6f:	8d 83 77 3d ff ff    	lea    -0xc289(%ebx),%eax
c0025d75:	e9 f6 00 00 00       	jmp    c0025e70 <read_partition_table+0x3cb>
    printf("%s%d: Partition starts past end of device (sector %" PRDSNu ")\n",
c0025d7a:	83 ec 0c             	sub    $0xc,%esp
c0025d7d:	ff 74 24 20          	pushl  0x20(%esp)
c0025d81:	e8 6e fb ff ff       	call   c00258f4 <block_name>
c0025d86:	ff 74 24 20          	pushl  0x20(%esp)
c0025d8a:	ff 74 24 38          	pushl  0x38(%esp)
c0025d8e:	50                   	push   %eax
c0025d8f:	8d 83 fc 42 ff ff    	lea    -0xbd04(%ebx),%eax
c0025d95:	50                   	push   %eax
c0025d96:	e8 63 1d 00 00       	call   c0027afe <printf>
c0025d9b:	83 c4 20             	add    $0x20,%esp
c0025d9e:	e9 4c fe ff ff       	jmp    c0025bef <read_partition_table+0x14a>
    printf("%s%d: Partition end (%" PRDSNu ") past end of device (%" PRDSNu ")\n",
c0025da3:	83 ec 0c             	sub    $0xc,%esp
c0025da6:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0025daa:	55                   	push   %ebp
c0025dab:	e8 3c fb ff ff       	call   c00258ec <block_size>
c0025db0:	89 c6                	mov    %eax,%esi
c0025db2:	89 2c 24             	mov    %ebp,(%esp)
c0025db5:	e8 3a fb ff ff       	call   c00258f4 <block_name>
c0025dba:	89 34 24             	mov    %esi,(%esp)
c0025dbd:	ff 74 24 38          	pushl  0x38(%esp)
c0025dc1:	ff 74 24 38          	pushl  0x38(%esp)
c0025dc5:	50                   	push   %eax
c0025dc6:	ff 74 24 3c          	pushl  0x3c(%esp)
c0025dca:	e8 2f 1d 00 00       	call   c0027afe <printf>
c0025dcf:	83 c4 20             	add    $0x20,%esp
c0025dd2:	e9 18 fe ff ff       	jmp    c0025bef <read_partition_table+0x14a>
      PANIC("Failed to allocate memory for partition descriptor");
c0025dd7:	8d 83 68 43 ff ff    	lea    -0xbc98(%ebx),%eax
c0025ddd:	50                   	push   %eax
c0025dde:	8d 83 44 1d ff ff    	lea    -0xe2bc(%ebx),%eax
c0025de4:	50                   	push   %eax
c0025de5:	68 ae 00 00 00       	push   $0xae
c0025dea:	8d 83 7f 3d ff ff    	lea    -0xc281(%ebx),%eax
c0025df0:	50                   	push   %eax
c0025df1:	e8 9f 3a 00 00       	call   c0029895 <debug_panic>
                                              : part_type == 0x21 ? BLOCK_FILESYS
c0025df6:	c7 44 24 2c 05 00 00 	movl   $0x5,0x2c(%esp)
c0025dfd:	00 
c0025dfe:	eb 70                	jmp    c0025e70 <read_partition_table+0x3cb>
c0025e00:	8b 6c 24 18          	mov    0x18(%esp),%ebp
  free(pt);
c0025e04:	83 ec 0c             	sub    $0xc,%esp
c0025e07:	55                   	push   %ebp
c0025e08:	e8 8d e6 ff ff       	call   c002449a <free>
c0025e0d:	83 c4 10             	add    $0x10,%esp
c0025e10:	e9 40 fd ff ff       	jmp    c0025b55 <read_partition_table+0xb0>
                                              : part_type == 0x21 ? BLOCK_FILESYS
c0025e15:	c7 44 24 2c 00 00 00 	movl   $0x0,0x2c(%esp)
c0025e1c:	00 
    p = malloc(sizeof *p);
c0025e1d:	83 ec 0c             	sub    $0xc,%esp
c0025e20:	6a 08                	push   $0x8
c0025e22:	e8 bd e4 ff ff       	call   c00242e4 <malloc>
c0025e27:	89 c5                	mov    %eax,%ebp
    if (p == NULL)
c0025e29:	83 c4 10             	add    $0x10,%esp
c0025e2c:	85 c0                	test   %eax,%eax
c0025e2e:	74 a7                	je     c0025dd7 <read_partition_table+0x332>
    p->block = block;
c0025e30:	8b 44 24 14          	mov    0x14(%esp),%eax
c0025e34:	89 45 00             	mov    %eax,0x0(%ebp)
    p->start = start;
c0025e37:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0025e3b:	89 4d 04             	mov    %ecx,0x4(%ebp)
    snprintf(name, sizeof name, "%s%d", block_name(block), part_nr);
c0025e3e:	83 ec 0c             	sub    $0xc,%esp
c0025e41:	50                   	push   %eax
c0025e42:	e8 ad fa ff ff       	call   c00258f4 <block_name>
c0025e47:	83 c4 04             	add    $0x4,%esp
c0025e4a:	ff 74 24 30          	pushl  0x30(%esp)
c0025e4e:	50                   	push   %eax
c0025e4f:	8d 83 99 3d ff ff    	lea    -0xc267(%ebx),%eax
c0025e55:	50                   	push   %eax
c0025e56:	6a 10                	push   $0x10
c0025e58:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c0025e5c:	50                   	push   %eax
c0025e5d:	e8 bd 25 00 00       	call   c002841f <snprintf>
  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025e62:	8b 44 24 48          	mov    0x48(%esp),%eax
c0025e66:	8b 84 83 84 59 ff ff 	mov    -0xa67c(%ebx,%eax,4),%eax
c0025e6d:	83 c4 20             	add    $0x20,%esp
    snprintf(extra_info, sizeof extra_info, "%s (%02x)",
c0025e70:	83 ec 0c             	sub    $0xc,%esp
c0025e73:	ff 74 24 34          	pushl  0x34(%esp)
c0025e77:	50                   	push   %eax
c0025e78:	8d 83 9e 3d ff ff    	lea    -0xc262(%ebx),%eax
c0025e7e:	50                   	push   %eax
c0025e7f:	68 80 00 00 00       	push   $0x80
c0025e84:	8d 44 24 5c          	lea    0x5c(%esp),%eax
c0025e88:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0025e8c:	50                   	push   %eax
c0025e8d:	e8 8d 25 00 00       	call   c002841f <snprintf>
    block_register(name, type, extra_info, size, &partition_operations, p);
c0025e92:	83 c4 18             	add    $0x18,%esp
c0025e95:	55                   	push   %ebp
c0025e96:	8d 83 d4 ff ff ff    	lea    -0x2c(%ebx),%eax
c0025e9c:	50                   	push   %eax
c0025e9d:	56                   	push   %esi
c0025e9e:	ff 74 24 24          	pushl  0x24(%esp)
c0025ea2:	ff 74 24 44          	pushl  0x44(%esp)
c0025ea6:	8d 44 24 4c          	lea    0x4c(%esp),%eax
c0025eaa:	50                   	push   %eax
c0025eab:	e8 bd fa ff ff       	call   c002596d <block_register>
c0025eb0:	83 c4 20             	add    $0x20,%esp
c0025eb3:	e9 37 fd ff ff       	jmp    c0025bef <read_partition_table+0x14a>
                                              : part_type == 0x21 ? BLOCK_FILESYS
c0025eb8:	c7 44 24 2c 01 00 00 	movl   $0x1,0x2c(%esp)
c0025ebf:	00 
c0025ec0:	e9 58 ff ff ff       	jmp    c0025e1d <read_partition_table+0x378>
c0025ec5:	c7 44 24 2c 02 00 00 	movl   $0x2,0x2c(%esp)
c0025ecc:	00 
c0025ecd:	e9 4b ff ff ff       	jmp    c0025e1d <read_partition_table+0x378>
c0025ed2:	c7 44 24 2c 03 00 00 	movl   $0x3,0x2c(%esp)
c0025ed9:	00 
c0025eda:	e9 3e ff ff ff       	jmp    c0025e1d <read_partition_table+0x378>

c0025edf <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write(void *p_, block_sector_t sector, const void *buffer)
{
c0025edf:	53                   	push   %ebx
c0025ee0:	83 ec 0c             	sub    $0xc,%esp
c0025ee3:	e8 fe c5 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0025ee8:	81 c3 54 ad 01 00    	add    $0x1ad54,%ebx
c0025eee:	8b 54 24 14          	mov    0x14(%esp),%edx
  struct partition *p = p_;
  block_write(p->block, p->start + sector, buffer);
c0025ef2:	ff 74 24 1c          	pushl  0x1c(%esp)
c0025ef6:	8b 42 04             	mov    0x4(%edx),%eax
c0025ef9:	03 44 24 1c          	add    0x1c(%esp),%eax
c0025efd:	50                   	push   %eax
c0025efe:	ff 32                	pushl  (%edx)
c0025f00:	e8 79 f9 ff ff       	call   c002587e <block_write>
}
c0025f05:	83 c4 18             	add    $0x18,%esp
c0025f08:	5b                   	pop    %ebx
c0025f09:	c3                   	ret    

c0025f0a <partition_scan>:
{
c0025f0a:	56                   	push   %esi
c0025f0b:	53                   	push   %ebx
c0025f0c:	83 ec 20             	sub    $0x20,%esp
c0025f0f:	e8 d2 c5 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0025f14:	81 c3 28 ad 01 00    	add    $0x1ad28,%ebx
c0025f1a:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  int part_nr = 0;
c0025f1e:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0025f25:	00 
  read_partition_table(block, 0, 0, &part_nr);
c0025f26:	8d 44 24 18          	lea    0x18(%esp),%eax
c0025f2a:	50                   	push   %eax
c0025f2b:	b9 00 00 00 00       	mov    $0x0,%ecx
c0025f30:	ba 00 00 00 00       	mov    $0x0,%edx
c0025f35:	89 f0                	mov    %esi,%eax
c0025f37:	e8 69 fb ff ff       	call   c0025aa5 <read_partition_table>
  if (part_nr == 0)
c0025f3c:	83 c4 10             	add    $0x10,%esp
c0025f3f:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0025f44:	74 06                	je     c0025f4c <partition_scan+0x42>
}
c0025f46:	83 c4 14             	add    $0x14,%esp
c0025f49:	5b                   	pop    %ebx
c0025f4a:	5e                   	pop    %esi
c0025f4b:	c3                   	ret    
    printf("%s: Device contains no partitions\n", block_name(block));
c0025f4c:	83 ec 0c             	sub    $0xc,%esp
c0025f4f:	56                   	push   %esi
c0025f50:	e8 9f f9 ff ff       	call   c00258f4 <block_name>
c0025f55:	83 c4 08             	add    $0x8,%esp
c0025f58:	50                   	push   %eax
c0025f59:	8d 83 9c 43 ff ff    	lea    -0xbc64(%ebx),%eax
c0025f5f:	50                   	push   %eax
c0025f60:	e8 99 1b 00 00       	call   c0027afe <printf>
c0025f65:	83 c4 10             	add    $0x10,%esp
}
c0025f68:	eb dc                	jmp    c0025f46 <partition_scan+0x3c>

c0025f6a <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string(char *string, int size)
{
c0025f6a:	57                   	push   %edi
c0025f6b:	56                   	push   %esi
c0025f6c:	53                   	push   %ebx
c0025f6d:	89 d7                	mov    %edx,%edi
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0025f6f:	83 fa 01             	cmp    $0x1,%edx
c0025f72:	7e 1f                	jle    c0025f93 <descramble_ata_string+0x29>
c0025f74:	89 c1                	mov    %eax,%ecx
c0025f76:	8d 5a fe             	lea    -0x2(%edx),%ebx
c0025f79:	83 e3 fe             	and    $0xfffffffe,%ebx
c0025f7c:	8d 74 18 02          	lea    0x2(%eax,%ebx,1),%esi
  {
    char tmp = string[i];
c0025f80:	0f b6 19             	movzbl (%ecx),%ebx
    string[i] = string[i + 1];
c0025f83:	0f b6 51 01          	movzbl 0x1(%ecx),%edx
c0025f87:	88 11                	mov    %dl,(%ecx)
    string[i + 1] = tmp;
c0025f89:	88 59 01             	mov    %bl,0x1(%ecx)
c0025f8c:	83 c1 02             	add    $0x2,%ecx
  for (i = 0; i + 1 < size; i += 2)
c0025f8f:	39 f1                	cmp    %esi,%ecx
c0025f91:	75 ed                	jne    c0025f80 <descramble_ata_string+0x16>
  }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0025f93:	8d 57 ff             	lea    -0x1(%edi),%edx
c0025f96:	85 d2                	test   %edx,%edx
c0025f98:	7f 07                	jg     c0025fa1 <descramble_ata_string+0x37>
c0025f9a:	eb 17                	jmp    c0025fb3 <descramble_ata_string+0x49>
c0025f9c:	83 ea 01             	sub    $0x1,%edx
c0025f9f:	74 12                	je     c0025fb3 <descramble_ata_string+0x49>
  {
    int c = string[size - 1];
c0025fa1:	0f b6 4c 10 ff       	movzbl -0x1(%eax,%edx,1),%ecx
    if (c != '\0' && !isspace(c))
c0025fa6:	f6 c1 df             	test   $0xdf,%cl
c0025fa9:	74 f1                	je     c0025f9c <descramble_ata_string+0x32>
  return (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v');
c0025fab:	83 e9 09             	sub    $0x9,%ecx
c0025fae:	80 f9 04             	cmp    $0x4,%cl
c0025fb1:	76 e9                	jbe    c0025f9c <descramble_ata_string+0x32>
      break;
  }
  string[size] = '\0';
c0025fb3:	c6 04 10 00          	movb   $0x0,(%eax,%edx,1)

  return string;
}
c0025fb7:	5b                   	pop    %ebx
c0025fb8:	5e                   	pop    %esi
c0025fb9:	5f                   	pop    %edi
c0025fba:	c3                   	ret    

c0025fbb <interrupt_handler>:
}

/* ATA interrupt handler. */
static void
interrupt_handler(struct intr_frame *f)
{
c0025fbb:	53                   	push   %ebx
c0025fbc:	83 ec 08             	sub    $0x8,%esp
c0025fbf:	e8 22 c5 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0025fc4:	81 c3 78 ac 01 00    	add    $0x1ac78,%ebx
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
    if (f->vec_no == c->irq)
c0025fca:	8b 44 24 10          	mov    0x10(%esp),%eax
c0025fce:	8b 40 30             	mov    0x30(%eax),%eax
c0025fd1:	0f b6 93 8e 1a 00 00 	movzbl 0x1a8e(%ebx),%edx
c0025fd8:	39 d0                	cmp    %edx,%eax
c0025fda:	74 30                	je     c002600c <interrupt_handler+0x51>
c0025fdc:	0f b6 93 0e 1b 00 00 	movzbl 0x1b0e(%ebx),%edx
c0025fe3:	8d 8b 04 1b 00 00    	lea    0x1b04(%ebx),%ecx
c0025fe9:	39 c2                	cmp    %eax,%edx
c0025feb:	74 25                	je     c0026012 <interrupt_handler+0x57>
      else
        printf("%s: unexpected interrupt\n", c->name);
      return;
    }

  NOT_REACHED();
c0025fed:	8d 83 60 34 ff ff    	lea    -0xcba0(%ebx),%eax
c0025ff3:	50                   	push   %eax
c0025ff4:	8d 83 bc 1d ff ff    	lea    -0xe244(%ebx),%eax
c0025ffa:	50                   	push   %eax
c0025ffb:	68 07 02 00 00       	push   $0x207
c0026000:	8d 83 d9 43 ff ff    	lea    -0xbc27(%ebx),%eax
c0026006:	50                   	push   %eax
c0026007:	e8 89 38 00 00       	call   c0029895 <debug_panic>
  for (c = channels; c < channels + CHANNEL_CNT; c++)
c002600c:	8d 8b 84 1a 00 00    	lea    0x1a84(%ebx),%ecx
      if (c->expecting_interrupt)
c0026012:	80 79 40 00          	cmpb   $0x0,0x40(%ecx)
c0026016:	74 1c                	je     c0026034 <interrupt_handler+0x79>
        inb(reg_status(c));           /* Acknowledge interrupt. */
c0026018:	0f b7 41 08          	movzwl 0x8(%ecx),%eax
c002601c:	8d 50 07             	lea    0x7(%eax),%edx
  asm volatile("inb %w1, %b0"
c002601f:	ec                   	in     (%dx),%al
        sema_up(&c->completion_wait); /* Wake up waiter. */
c0026020:	83 ec 0c             	sub    $0xc,%esp
c0026023:	83 c1 44             	add    $0x44,%ecx
c0026026:	51                   	push   %ecx
c0026027:	e8 05 d3 ff ff       	call   c0023331 <sema_up>
c002602c:	83 c4 10             	add    $0x10,%esp
}
c002602f:	83 c4 08             	add    $0x8,%esp
c0026032:	5b                   	pop    %ebx
c0026033:	c3                   	ret    
        printf("%s: unexpected interrupt\n", c->name);
c0026034:	83 ec 08             	sub    $0x8,%esp
c0026037:	51                   	push   %ecx
c0026038:	8d 83 bf 43 ff ff    	lea    -0xbc41(%ebx),%eax
c002603e:	50                   	push   %eax
c002603f:	e8 ba 1a 00 00       	call   c0027afe <printf>
c0026044:	83 c4 10             	add    $0x10,%esp
c0026047:	eb e6                	jmp    c002602f <interrupt_handler+0x74>

c0026049 <wait_until_idle>:
{
c0026049:	57                   	push   %edi
c002604a:	56                   	push   %esi
c002604b:	53                   	push   %ebx
c002604c:	e8 95 c4 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0026051:	81 c3 eb ab 01 00    	add    $0x1abeb,%ebx
c0026057:	89 c7                	mov    %eax,%edi
    if ((inb(reg_status(d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0026059:	8b 40 08             	mov    0x8(%eax),%eax
c002605c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026060:	8d 50 07             	lea    0x7(%eax),%edx
c0026063:	ec                   	in     (%dx),%al
c0026064:	a8 88                	test   $0x88,%al
c0026066:	74 4a                	je     c00260b2 <wait_until_idle+0x69>
    timer_usleep(10);
c0026068:	83 ec 08             	sub    $0x8,%esp
c002606b:	6a 00                	push   $0x0
c002606d:	6a 0a                	push   $0xa
c002606f:	e8 84 ec ff ff       	call   c0024cf8 <timer_usleep>
c0026074:	83 c4 10             	add    $0x10,%esp
c0026077:	be e7 03 00 00       	mov    $0x3e7,%esi
    if ((inb(reg_status(d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c002607c:	8b 47 08             	mov    0x8(%edi),%eax
c002607f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026083:	8d 50 07             	lea    0x7(%eax),%edx
c0026086:	ec                   	in     (%dx),%al
c0026087:	a8 88                	test   $0x88,%al
c0026089:	74 27                	je     c00260b2 <wait_until_idle+0x69>
    timer_usleep(10);
c002608b:	83 ec 08             	sub    $0x8,%esp
c002608e:	6a 00                	push   $0x0
c0026090:	6a 0a                	push   $0xa
c0026092:	e8 61 ec ff ff       	call   c0024cf8 <timer_usleep>
  for (i = 0; i < 1000; i++)
c0026097:	83 c4 10             	add    $0x10,%esp
c002609a:	83 ee 01             	sub    $0x1,%esi
c002609d:	75 dd                	jne    c002607c <wait_until_idle+0x33>
  printf("%s: idle timeout\n", d->name);
c002609f:	83 ec 08             	sub    $0x8,%esp
c00260a2:	57                   	push   %edi
c00260a3:	8d 83 ed 43 ff ff    	lea    -0xbc13(%ebx),%eax
c00260a9:	50                   	push   %eax
c00260aa:	e8 4f 1a 00 00       	call   c0027afe <printf>
c00260af:	83 c4 10             	add    $0x10,%esp
}
c00260b2:	5b                   	pop    %ebx
c00260b3:	5e                   	pop    %esi
c00260b4:	5f                   	pop    %edi
c00260b5:	c3                   	ret    

c00260b6 <select_device>:
{
c00260b6:	53                   	push   %ebx
c00260b7:	83 ec 10             	sub    $0x10,%esp
c00260ba:	e8 27 c4 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00260bf:	81 c3 7d ab 01 00    	add    $0x1ab7d,%ebx
  struct channel *c = d->channel;
c00260c5:	8b 50 08             	mov    0x8(%eax),%edx
  if (d->dev_no == 1)
c00260c8:	83 78 0c 01          	cmpl   $0x1,0xc(%eax)
    dev |= DEV_DEV;
c00260cc:	b8 a0 ff ff ff       	mov    $0xffffffa0,%eax
c00260d1:	b9 b0 ff ff ff       	mov    $0xffffffb0,%ecx
c00260d6:	0f 44 c1             	cmove  %ecx,%eax
  outb(reg_device(c), dev);
c00260d9:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx
c00260dd:	8d 51 06             	lea    0x6(%ecx),%edx
  asm volatile("outb %b0, %w1"
c00260e0:	ee                   	out    %al,(%dx)
  inb(reg_alt_status(c));
c00260e1:	8d 91 06 02 00 00    	lea    0x206(%ecx),%edx
  asm volatile("inb %w1, %b0"
c00260e7:	ec                   	in     (%dx),%al
  timer_nsleep(400);
c00260e8:	6a 00                	push   $0x0
c00260ea:	68 90 01 00 00       	push   $0x190
c00260ef:	e8 1d ec ff ff       	call   c0024d11 <timer_nsleep>
}
c00260f4:	83 c4 18             	add    $0x18,%esp
c00260f7:	5b                   	pop    %ebx
c00260f8:	c3                   	ret    

c00260f9 <check_device_type>:
{
c00260f9:	55                   	push   %ebp
c00260fa:	57                   	push   %edi
c00260fb:	56                   	push   %esi
c00260fc:	53                   	push   %ebx
c00260fd:	83 ec 0c             	sub    $0xc,%esp
c0026100:	89 c6                	mov    %eax,%esi
  struct channel *c = d->channel;
c0026102:	8b 58 08             	mov    0x8(%eax),%ebx
  select_device(d);
c0026105:	e8 ac ff ff ff       	call   c00260b6 <select_device>
  error = inb(reg_error(c));
c002610a:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
c002610e:	8d 51 01             	lea    0x1(%ecx),%edx
c0026111:	ec                   	in     (%dx),%al
c0026112:	89 c3                	mov    %eax,%ebx
  lbam = inb(reg_lbam(c));
c0026114:	8d 51 04             	lea    0x4(%ecx),%edx
c0026117:	ec                   	in     (%dx),%al
c0026118:	89 c5                	mov    %eax,%ebp
  lbah = inb(reg_lbah(c));
c002611a:	8d 51 05             	lea    0x5(%ecx),%edx
c002611d:	ec                   	in     (%dx),%al
c002611e:	89 c7                	mov    %eax,%edi
  status = inb(reg_status(c));
c0026120:	8d 51 07             	lea    0x7(%ecx),%edx
c0026123:	ec                   	in     (%dx),%al
  if ((error != 1 && (error != 0x81 || d->dev_no == 1)) || (status & STA_DRDY) == 0 || (status & STA_BSY) != 0)
c0026124:	80 fb 01             	cmp    $0x1,%bl
c0026127:	74 1d                	je     c0026146 <check_device_type+0x4d>
c0026129:	80 fb 81             	cmp    $0x81,%bl
c002612c:	74 12                	je     c0026140 <check_device_type+0x47>
    d->is_ata = false;
c002612e:	c6 46 10 00          	movb   $0x0,0x10(%esi)
    return error != 0x81;
c0026132:	80 fb 81             	cmp    $0x81,%bl
c0026135:	0f 95 c0             	setne  %al
}
c0026138:	83 c4 0c             	add    $0xc,%esp
c002613b:	5b                   	pop    %ebx
c002613c:	5e                   	pop    %esi
c002613d:	5f                   	pop    %edi
c002613e:	5d                   	pop    %ebp
c002613f:	c3                   	ret    
  if ((error != 1 && (error != 0x81 || d->dev_no == 1)) || (status & STA_DRDY) == 0 || (status & STA_BSY) != 0)
c0026140:	83 7e 0c 01          	cmpl   $0x1,0xc(%esi)
c0026144:	74 e8                	je     c002612e <check_device_type+0x35>
c0026146:	a8 40                	test   $0x40,%al
c0026148:	74 e4                	je     c002612e <check_device_type+0x35>
c002614a:	84 c0                	test   %al,%al
c002614c:	78 e0                	js     c002612e <check_device_type+0x35>
    d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c002614e:	b8 01 00 00 00       	mov    $0x1,%eax
c0026153:	89 f9                	mov    %edi,%ecx
c0026155:	89 eb                	mov    %ebp,%ebx
c0026157:	08 d9                	or     %bl,%cl
c0026159:	74 12                	je     c002616d <check_device_type+0x74>
c002615b:	80 fb 3c             	cmp    $0x3c,%bl
c002615e:	0f 94 c2             	sete   %dl
c0026161:	89 f8                	mov    %edi,%eax
c0026163:	3c c3                	cmp    $0xc3,%al
c0026165:	0f 94 c0             	sete   %al
c0026168:	0f b6 c0             	movzbl %al,%eax
c002616b:	21 d0                	and    %edx,%eax
c002616d:	88 46 10             	mov    %al,0x10(%esi)
c0026170:	80 66 10 01          	andb   $0x1,0x10(%esi)
    return true;
c0026174:	b8 01 00 00 00       	mov    $0x1,%eax
c0026179:	eb bd                	jmp    c0026138 <check_device_type+0x3f>

c002617b <select_sector>:
{
c002617b:	55                   	push   %ebp
c002617c:	57                   	push   %edi
c002617d:	56                   	push   %esi
c002617e:	53                   	push   %ebx
c002617f:	83 ec 0c             	sub    $0xc,%esp
c0026182:	e8 5f c3 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0026187:	81 c3 b5 aa 01 00    	add    $0x1aab5,%ebx
  struct channel *c = d->channel;
c002618d:	8b 68 08             	mov    0x8(%eax),%ebp
  ASSERT(sec_no < (1UL << 28));
c0026190:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c0026196:	77 5e                	ja     c00261f6 <select_sector+0x7b>
c0026198:	89 c7                	mov    %eax,%edi
c002619a:	89 d6                	mov    %edx,%esi
  wait_until_idle(d);
c002619c:	e8 a8 fe ff ff       	call   c0026049 <wait_until_idle>
  select_device(d);
c00261a1:	89 f8                	mov    %edi,%eax
c00261a3:	e8 0e ff ff ff       	call   c00260b6 <select_device>
  wait_until_idle(d);
c00261a8:	89 f8                	mov    %edi,%eax
c00261aa:	e8 9a fe ff ff       	call   c0026049 <wait_until_idle>
  outb(reg_nsect(c), 1);
c00261af:	0f b7 4d 08          	movzwl 0x8(%ebp),%ecx
c00261b3:	8d 51 02             	lea    0x2(%ecx),%edx
  asm volatile("outb %b0, %w1"
c00261b6:	b8 01 00 00 00       	mov    $0x1,%eax
c00261bb:	ee                   	out    %al,(%dx)
  outb(reg_lbal(c), sec_no);
c00261bc:	8d 51 03             	lea    0x3(%ecx),%edx
c00261bf:	89 f0                	mov    %esi,%eax
c00261c1:	ee                   	out    %al,(%dx)
  outb(reg_lbam(c), sec_no >> 8);
c00261c2:	89 f0                	mov    %esi,%eax
c00261c4:	c1 e8 08             	shr    $0x8,%eax
c00261c7:	8d 51 04             	lea    0x4(%ecx),%edx
c00261ca:	ee                   	out    %al,(%dx)
  outb(reg_lbah(c), (sec_no >> 16));
c00261cb:	89 f0                	mov    %esi,%eax
c00261cd:	c1 e8 10             	shr    $0x10,%eax
c00261d0:	8d 51 05             	lea    0x5(%ecx),%edx
c00261d3:	ee                   	out    %al,(%dx)
       DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c00261d4:	83 7f 0c 01          	cmpl   $0x1,0xc(%edi)
c00261d8:	b8 f0 ff ff ff       	mov    $0xfffffff0,%eax
c00261dd:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
c00261e2:	0f 45 c2             	cmovne %edx,%eax
c00261e5:	c1 ee 18             	shr    $0x18,%esi
c00261e8:	09 f0                	or     %esi,%eax
  outb(reg_device(c),
c00261ea:	8d 51 06             	lea    0x6(%ecx),%edx
c00261ed:	ee                   	out    %al,(%dx)
}
c00261ee:	83 c4 0c             	add    $0xc,%esp
c00261f1:	5b                   	pop    %ebx
c00261f2:	5e                   	pop    %esi
c00261f3:	5f                   	pop    %edi
c00261f4:	5d                   	pop    %ebp
c00261f5:	c3                   	ret    
  ASSERT(sec_no < (1UL << 28));
c00261f6:	83 ec 0c             	sub    $0xc,%esp
c00261f9:	8d 83 ff 43 ff ff    	lea    -0xbc01(%ebx),%eax
c00261ff:	50                   	push   %eax
c0026200:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0026206:	50                   	push   %eax
c0026207:	8d 83 8c 1d ff ff    	lea    -0xe274(%ebx),%eax
c002620d:	50                   	push   %eax
c002620e:	68 84 01 00 00       	push   $0x184
c0026213:	8d 83 d9 43 ff ff    	lea    -0xbc27(%ebx),%eax
c0026219:	50                   	push   %eax
c002621a:	e8 76 36 00 00       	call   c0029895 <debug_panic>

c002621f <wait_while_busy>:
{
c002621f:	55                   	push   %ebp
c0026220:	57                   	push   %edi
c0026221:	56                   	push   %esi
c0026222:	53                   	push   %ebx
c0026223:	83 ec 1c             	sub    $0x1c,%esp
c0026226:	e8 bb c2 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002622b:	81 c3 11 aa 01 00    	add    $0x1aa11,%ebx
c0026231:	89 c5                	mov    %eax,%ebp
  struct channel *c = d->channel;
c0026233:	8b 78 08             	mov    0x8(%eax),%edi
  for (i = 0; i < 3000; i++)
c0026236:	be 00 00 00 00       	mov    $0x0,%esi
      printf("%s: busy, waiting...", d->name);
c002623b:	8d 83 14 44 ff ff    	lea    -0xbbec(%ebx),%eax
c0026241:	89 44 24 0c          	mov    %eax,0xc(%esp)
    if (!(inb(reg_alt_status(c)) & STA_BSY))
c0026245:	0f b7 47 08          	movzwl 0x8(%edi),%eax
c0026249:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
  asm volatile("inb %w1, %b0"
c002624f:	ec                   	in     (%dx),%al
c0026250:	84 c0                	test   %al,%al
c0026252:	79 34                	jns    c0026288 <wait_while_busy+0x69>
    timer_msleep(10);
c0026254:	83 ec 08             	sub    $0x8,%esp
c0026257:	6a 00                	push   $0x0
c0026259:	6a 0a                	push   $0xa
c002625b:	e8 7f ea ff ff       	call   c0024cdf <timer_msleep>
  for (i = 0; i < 3000; i++)
c0026260:	83 c6 01             	add    $0x1,%esi
c0026263:	83 c4 10             	add    $0x10,%esp
c0026266:	81 fe b8 0b 00 00    	cmp    $0xbb8,%esi
c002626c:	74 4f                	je     c00262bd <wait_while_busy+0x9e>
    if (i == 700)
c002626e:	81 fe bc 02 00 00    	cmp    $0x2bc,%esi
c0026274:	75 cf                	jne    c0026245 <wait_while_busy+0x26>
      printf("%s: busy, waiting...", d->name);
c0026276:	83 ec 08             	sub    $0x8,%esp
c0026279:	55                   	push   %ebp
c002627a:	ff 74 24 18          	pushl  0x18(%esp)
c002627e:	e8 7b 18 00 00       	call   c0027afe <printf>
c0026283:	83 c4 10             	add    $0x10,%esp
c0026286:	eb bd                	jmp    c0026245 <wait_while_busy+0x26>
      if (i >= 700)
c0026288:	81 fe bb 02 00 00    	cmp    $0x2bb,%esi
c002628e:	7f 19                	jg     c00262a9 <wait_while_busy+0x8a>
      return (inb(reg_alt_status(c)) & STA_DRQ) != 0;
c0026290:	0f b7 47 08          	movzwl 0x8(%edi),%eax
c0026294:	8d 90 06 02 00 00    	lea    0x206(%eax),%edx
c002629a:	ec                   	in     (%dx),%al
c002629b:	c0 e8 03             	shr    $0x3,%al
c002629e:	83 e0 01             	and    $0x1,%eax
}
c00262a1:	83 c4 1c             	add    $0x1c,%esp
c00262a4:	5b                   	pop    %ebx
c00262a5:	5e                   	pop    %esi
c00262a6:	5f                   	pop    %edi
c00262a7:	5d                   	pop    %ebp
c00262a8:	c3                   	ret    
        printf("ok\n");
c00262a9:	83 ec 0c             	sub    $0xc,%esp
c00262ac:	8d 83 29 44 ff ff    	lea    -0xbbd7(%ebx),%eax
c00262b2:	50                   	push   %eax
c00262b3:	e8 b6 55 00 00       	call   c002b86e <puts>
c00262b8:	83 c4 10             	add    $0x10,%esp
c00262bb:	eb d3                	jmp    c0026290 <wait_while_busy+0x71>
  printf("failed\n");
c00262bd:	83 ec 0c             	sub    $0xc,%esp
c00262c0:	8d 83 c8 53 ff ff    	lea    -0xac38(%ebx),%eax
c00262c6:	50                   	push   %eax
c00262c7:	e8 a2 55 00 00       	call   c002b86e <puts>
  return false;
c00262cc:	83 c4 10             	add    $0x10,%esp
c00262cf:	b8 00 00 00 00       	mov    $0x0,%eax
c00262d4:	eb cb                	jmp    c00262a1 <wait_while_busy+0x82>

c00262d6 <issue_pio_command>:
{
c00262d6:	57                   	push   %edi
c00262d7:	56                   	push   %esi
c00262d8:	53                   	push   %ebx
c00262d9:	e8 08 c2 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00262de:	81 c3 5e a9 01 00    	add    $0x1a95e,%ebx
c00262e4:	89 c7                	mov    %eax,%edi
c00262e6:	89 d6                	mov    %edx,%esi
  ASSERT(intr_get_level() == INTR_ON);
c00262e8:	e8 6c bc ff ff       	call   c0021f59 <intr_get_level>
c00262ed:	83 f8 01             	cmp    $0x1,%eax
c00262f0:	75 12                	jne    c0026304 <issue_pio_command+0x2e>
  c->expecting_interrupt = true;
c00262f2:	c6 47 40 01          	movb   $0x1,0x40(%edi)
  outb(reg_command(c), command);
c00262f6:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c00262fa:	83 c2 07             	add    $0x7,%edx
  asm volatile("outb %b0, %w1"
c00262fd:	89 f0                	mov    %esi,%eax
c00262ff:	ee                   	out    %al,(%dx)
}
c0026300:	5b                   	pop    %ebx
c0026301:	5e                   	pop    %esi
c0026302:	5f                   	pop    %edi
c0026303:	c3                   	ret    
  ASSERT(intr_get_level() == INTR_ON);
c0026304:	83 ec 0c             	sub    $0xc,%esp
c0026307:	8d 83 42 3b ff ff    	lea    -0xc4be(%ebx),%eax
c002630d:	50                   	push   %eax
c002630e:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0026314:	50                   	push   %eax
c0026315:	8d 83 6c 1d ff ff    	lea    -0xe294(%ebx),%eax
c002631b:	50                   	push   %eax
c002631c:	68 96 01 00 00       	push   $0x196
c0026321:	8d 83 d9 43 ff ff    	lea    -0xbc27(%ebx),%eax
c0026327:	50                   	push   %eax
c0026328:	e8 68 35 00 00       	call   c0029895 <debug_panic>

c002632d <ide_write>:
{
c002632d:	55                   	push   %ebp
c002632e:	57                   	push   %edi
c002632f:	56                   	push   %esi
c0026330:	53                   	push   %ebx
c0026331:	83 ec 18             	sub    $0x18,%esp
c0026334:	e8 ad c1 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0026339:	81 c3 03 a9 01 00    	add    $0x1a903,%ebx
c002633f:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  struct channel *c = d->channel;
c0026343:	8b 7e 08             	mov    0x8(%esi),%edi
  lock_acquire(&c->lock);
c0026346:	8d 6f 0c             	lea    0xc(%edi),%ebp
c0026349:	55                   	push   %ebp
c002634a:	e8 73 d2 ff ff       	call   c00235c2 <lock_acquire>
  select_sector(d, sec_no);
c002634f:	8b 54 24 34          	mov    0x34(%esp),%edx
c0026353:	89 f0                	mov    %esi,%eax
c0026355:	e8 21 fe ff ff       	call   c002617b <select_sector>
  issue_pio_command(c, CMD_WRITE_SECTOR_RETRY);
c002635a:	ba 30 00 00 00       	mov    $0x30,%edx
c002635f:	89 f8                	mov    %edi,%eax
c0026361:	e8 70 ff ff ff       	call   c00262d6 <issue_pio_command>
  if (!wait_while_busy(d))
c0026366:	89 f0                	mov    %esi,%eax
c0026368:	e8 b2 fe ff ff       	call   c002621f <wait_while_busy>
c002636d:	83 c4 10             	add    $0x10,%esp
c0026370:	84 c0                	test   %al,%al
c0026372:	74 2c                	je     c00263a0 <ide_write+0x73>
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw(uint16_t port, const void *addr, size_t cnt)
{
  /* See [IA32-v2b] "OUTS". */
  asm volatile("rep outsw"
c0026374:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c0026378:	8b 74 24 28          	mov    0x28(%esp),%esi
c002637c:	b9 00 01 00 00       	mov    $0x100,%ecx
c0026381:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
  sema_down(&c->completion_wait);
c0026384:	83 ec 0c             	sub    $0xc,%esp
c0026387:	83 c7 44             	add    $0x44,%edi
c002638a:	57                   	push   %edi
c002638b:	e8 84 ce ff ff       	call   c0023214 <sema_down>
  lock_release(&c->lock);
c0026390:	89 2c 24             	mov    %ebp,(%esp)
c0026393:	e8 fe d3 ff ff       	call   c0023796 <lock_release>
}
c0026398:	83 c4 1c             	add    $0x1c,%esp
c002639b:	5b                   	pop    %ebx
c002639c:	5e                   	pop    %esi
c002639d:	5f                   	pop    %edi
c002639e:	5d                   	pop    %ebp
c002639f:	c3                   	ret    
    PANIC("%s: disk write failed, sector=%" PRDSNu, d->name, sec_no);
c00263a0:	83 ec 08             	sub    $0x8,%esp
c00263a3:	ff 74 24 2c          	pushl  0x2c(%esp)
c00263a7:	56                   	push   %esi
c00263a8:	8d 83 78 44 ff ff    	lea    -0xbb88(%ebx),%eax
c00263ae:	50                   	push   %eax
c00263af:	8d 83 9c 1d ff ff    	lea    -0xe264(%ebx),%eax
c00263b5:	50                   	push   %eax
c00263b6:	68 71 01 00 00       	push   $0x171
c00263bb:	8d 83 d9 43 ff ff    	lea    -0xbc27(%ebx),%eax
c00263c1:	50                   	push   %eax
c00263c2:	e8 ce 34 00 00       	call   c0029895 <debug_panic>

c00263c7 <identify_ata_device>:
{
c00263c7:	55                   	push   %ebp
c00263c8:	57                   	push   %edi
c00263c9:	56                   	push   %esi
c00263ca:	53                   	push   %ebx
c00263cb:	81 ec 8c 02 00 00    	sub    $0x28c,%esp
c00263d1:	e8 10 c1 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00263d6:	81 c3 66 a8 01 00    	add    $0x1a866,%ebx
  struct channel *c = d->channel;
c00263dc:	8b 78 08             	mov    0x8(%eax),%edi
  ASSERT(d->is_ata);
c00263df:	80 78 10 00          	cmpb   $0x0,0x10(%eax)
c00263e3:	74 4a                	je     c002642f <identify_ata_device+0x68>
c00263e5:	89 c6                	mov    %eax,%esi
  wait_until_idle(d);
c00263e7:	e8 5d fc ff ff       	call   c0026049 <wait_until_idle>
  select_device(d);
c00263ec:	89 f0                	mov    %esi,%eax
c00263ee:	e8 c3 fc ff ff       	call   c00260b6 <select_device>
  wait_until_idle(d);
c00263f3:	89 f0                	mov    %esi,%eax
c00263f5:	e8 4f fc ff ff       	call   c0026049 <wait_until_idle>
  issue_pio_command(c, CMD_IDENTIFY_DEVICE);
c00263fa:	ba ec 00 00 00       	mov    $0xec,%edx
c00263ff:	89 f8                	mov    %edi,%eax
c0026401:	e8 d0 fe ff ff       	call   c00262d6 <issue_pio_command>
  sema_down(&c->completion_wait);
c0026406:	83 ec 0c             	sub    $0xc,%esp
c0026409:	8d 47 44             	lea    0x44(%edi),%eax
c002640c:	50                   	push   %eax
c002640d:	e8 02 ce ff ff       	call   c0023214 <sema_down>
  if (!wait_while_busy(d))
c0026412:	89 f0                	mov    %esi,%eax
c0026414:	e8 06 fe ff ff       	call   c002621f <wait_while_busy>
c0026419:	83 c4 10             	add    $0x10,%esp
c002641c:	84 c0                	test   %al,%al
c002641e:	75 38                	jne    c0026458 <identify_ata_device+0x91>
    d->is_ata = false;
c0026420:	c6 46 10 00          	movb   $0x0,0x10(%esi)
}
c0026424:	81 c4 8c 02 00 00    	add    $0x28c,%esp
c002642a:	5b                   	pop    %ebx
c002642b:	5e                   	pop    %esi
c002642c:	5f                   	pop    %edi
c002642d:	5d                   	pop    %ebp
c002642e:	c3                   	ret    
  ASSERT(d->is_ata);
c002642f:	83 ec 0c             	sub    $0xc,%esp
c0026432:	8d 83 2c 44 ff ff    	lea    -0xbbd4(%ebx),%eax
c0026438:	50                   	push   %eax
c0026439:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002643f:	50                   	push   %eax
c0026440:	8d 83 a8 1d ff ff    	lea    -0xe258(%ebx),%eax
c0026446:	50                   	push   %eax
c0026447:	68 09 01 00 00       	push   $0x109
c002644c:	8d 83 d9 43 ff ff    	lea    -0xbc27(%ebx),%eax
c0026452:	50                   	push   %eax
c0026453:	e8 3d 34 00 00       	call   c0029895 <debug_panic>
  asm volatile("rep insw"
c0026458:	0f b7 57 08          	movzwl 0x8(%edi),%edx
c002645c:	8d bc 24 80 00 00 00 	lea    0x80(%esp),%edi
c0026463:	b9 00 01 00 00       	mov    $0x100,%ecx
c0026468:	66 f3 6d             	rep insw (%dx),%es:(%edi)
  capacity = *(uint32_t *)&id[60 * 2];
c002646b:	8b bc 24 f8 00 00 00 	mov    0xf8(%esp),%edi
  model = descramble_ata_string(&id[10 * 2], 20);
c0026472:	8d 84 24 94 00 00 00 	lea    0x94(%esp),%eax
c0026479:	ba 14 00 00 00       	mov    $0x14,%edx
c002647e:	e8 e7 fa ff ff       	call   c0025f6a <descramble_ata_string>
c0026483:	89 c5                	mov    %eax,%ebp
  serial = descramble_ata_string(&id[27 * 2], 40);
c0026485:	8d 84 24 b6 00 00 00 	lea    0xb6(%esp),%eax
c002648c:	ba 28 00 00 00       	mov    $0x28,%edx
c0026491:	e8 d4 fa ff ff       	call   c0025f6a <descramble_ata_string>
  snprintf(extra_info, sizeof extra_info,
c0026496:	83 ec 0c             	sub    $0xc,%esp
c0026499:	50                   	push   %eax
c002649a:	55                   	push   %ebp
c002649b:	8d 83 36 44 ff ff    	lea    -0xbbca(%ebx),%eax
c00264a1:	50                   	push   %eax
c00264a2:	68 80 00 00 00       	push   $0x80
c00264a7:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c00264ab:	50                   	push   %eax
c00264ac:	e8 6e 1f 00 00       	call   c002841f <snprintf>
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c00264b1:	83 c4 20             	add    $0x20,%esp
c00264b4:	81 ff ff ff 1f 00    	cmp    $0x1fffff,%edi
c00264ba:	76 3c                	jbe    c00264f8 <identify_ata_device+0x131>
    printf("%s: ignoring ", d->name);
c00264bc:	83 ec 08             	sub    $0x8,%esp
c00264bf:	56                   	push   %esi
c00264c0:	8d 83 4e 44 ff ff    	lea    -0xbbb2(%ebx),%eax
c00264c6:	50                   	push   %eax
c00264c7:	e8 32 16 00 00       	call   c0027afe <printf>
    print_human_readable_size(capacity * 512);
c00264cc:	83 c4 08             	add    $0x8,%esp
c00264cf:	c1 e7 09             	shl    $0x9,%edi
c00264d2:	ba 00 00 00 00       	mov    $0x0,%edx
c00264d7:	52                   	push   %edx
c00264d8:	57                   	push   %edi
c00264d9:	e8 52 21 00 00       	call   c0028630 <print_human_readable_size>
    printf("disk for safety\n");
c00264de:	8d 83 5c 44 ff ff    	lea    -0xbba4(%ebx),%eax
c00264e4:	89 04 24             	mov    %eax,(%esp)
c00264e7:	e8 82 53 00 00       	call   c002b86e <puts>
    d->is_ata = false;
c00264ec:	c6 46 10 00          	movb   $0x0,0x10(%esi)
    return;
c00264f0:	83 c4 10             	add    $0x10,%esp
c00264f3:	e9 2c ff ff ff       	jmp    c0026424 <identify_ata_device+0x5d>
  block = block_register(d->name, BLOCK_RAW, extra_info, capacity,
c00264f8:	83 ec 08             	sub    $0x8,%esp
c00264fb:	56                   	push   %esi
c00264fc:	8d 83 dc ff ff ff    	lea    -0x24(%ebx),%eax
c0026502:	50                   	push   %eax
c0026503:	57                   	push   %edi
c0026504:	8d 44 24 14          	lea    0x14(%esp),%eax
c0026508:	50                   	push   %eax
c0026509:	6a 04                	push   $0x4
c002650b:	56                   	push   %esi
c002650c:	e8 5c f4 ff ff       	call   c002596d <block_register>
  partition_scan(block);
c0026511:	83 c4 14             	add    $0x14,%esp
c0026514:	50                   	push   %eax
c0026515:	e8 f0 f9 ff ff       	call   c0025f0a <partition_scan>
c002651a:	83 c4 10             	add    $0x10,%esp
c002651d:	e9 02 ff ff ff       	jmp    c0026424 <identify_ata_device+0x5d>

c0026522 <ide_read>:
{
c0026522:	55                   	push   %ebp
c0026523:	57                   	push   %edi
c0026524:	56                   	push   %esi
c0026525:	53                   	push   %ebx
c0026526:	83 ec 18             	sub    $0x18,%esp
c0026529:	e8 b8 bf 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002652e:	81 c3 0e a7 01 00    	add    $0x1a70e,%ebx
c0026534:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  struct channel *c = d->channel;
c0026538:	8b 77 08             	mov    0x8(%edi),%esi
  lock_acquire(&c->lock);
c002653b:	8d 6e 0c             	lea    0xc(%esi),%ebp
c002653e:	55                   	push   %ebp
c002653f:	e8 7e d0 ff ff       	call   c00235c2 <lock_acquire>
  select_sector(d, sec_no);
c0026544:	8b 54 24 34          	mov    0x34(%esp),%edx
c0026548:	89 f8                	mov    %edi,%eax
c002654a:	e8 2c fc ff ff       	call   c002617b <select_sector>
  issue_pio_command(c, CMD_READ_SECTOR_RETRY);
c002654f:	ba 20 00 00 00       	mov    $0x20,%edx
c0026554:	89 f0                	mov    %esi,%eax
c0026556:	e8 7b fd ff ff       	call   c00262d6 <issue_pio_command>
  sema_down(&c->completion_wait);
c002655b:	8d 46 44             	lea    0x44(%esi),%eax
c002655e:	89 04 24             	mov    %eax,(%esp)
c0026561:	e8 ae cc ff ff       	call   c0023214 <sema_down>
  if (!wait_while_busy(d))
c0026566:	89 f8                	mov    %edi,%eax
c0026568:	e8 b2 fc ff ff       	call   c002621f <wait_while_busy>
c002656d:	83 c4 10             	add    $0x10,%esp
c0026570:	84 c0                	test   %al,%al
c0026572:	74 21                	je     c0026595 <ide_read+0x73>
c0026574:	0f b7 56 08          	movzwl 0x8(%esi),%edx
c0026578:	8b 7c 24 28          	mov    0x28(%esp),%edi
c002657c:	b9 00 01 00 00       	mov    $0x100,%ecx
c0026581:	66 f3 6d             	rep insw (%dx),%es:(%edi)
  lock_release(&c->lock);
c0026584:	83 ec 0c             	sub    $0xc,%esp
c0026587:	55                   	push   %ebp
c0026588:	e8 09 d2 ff ff       	call   c0023796 <lock_release>
}
c002658d:	83 c4 1c             	add    $0x1c,%esp
c0026590:	5b                   	pop    %ebx
c0026591:	5e                   	pop    %esi
c0026592:	5f                   	pop    %edi
c0026593:	5d                   	pop    %ebp
c0026594:	c3                   	ret    
    PANIC("%s: disk read failed, sector=%" PRDSNu, d->name, sec_no);
c0026595:	83 ec 08             	sub    $0x8,%esp
c0026598:	ff 74 24 2c          	pushl  0x2c(%esp)
c002659c:	57                   	push   %edi
c002659d:	8d 83 9c 44 ff ff    	lea    -0xbb64(%ebx),%eax
c00265a3:	50                   	push   %eax
c00265a4:	8d 83 80 1d ff ff    	lea    -0xe280(%ebx),%eax
c00265aa:	50                   	push   %eax
c00265ab:	68 5e 01 00 00       	push   $0x15e
c00265b0:	8d 83 d9 43 ff ff    	lea    -0xbc27(%ebx),%eax
c00265b6:	50                   	push   %eax
c00265b7:	e8 d9 32 00 00       	call   c0029895 <debug_panic>

c00265bc <ide_init>:
{
c00265bc:	55                   	push   %ebp
c00265bd:	57                   	push   %edi
c00265be:	56                   	push   %esi
c00265bf:	53                   	push   %ebx
c00265c0:	83 ec 2c             	sub    $0x2c,%esp
c00265c3:	e8 1e bf 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00265c8:	81 c3 74 a6 01 00    	add    $0x1a674,%ebx
    snprintf(c->name, sizeof c->name, "ide%zu", chan_no);
c00265ce:	6a 00                	push   $0x0
c00265d0:	8d 83 6c 44 ff ff    	lea    -0xbb94(%ebx),%eax
c00265d6:	50                   	push   %eax
c00265d7:	6a 08                	push   $0x8
c00265d9:	8d b3 84 1a 00 00    	lea    0x1a84(%ebx),%esi
c00265df:	56                   	push   %esi
c00265e0:	e8 3a 1e 00 00       	call   c002841f <snprintf>
      c->reg_base = 0x1f0;
c00265e5:	66 c7 83 8c 1a 00 00 	movw   $0x1f0,0x1a8c(%ebx)
c00265ec:	f0 01 
      c->irq = 14 + 0x20;
c00265ee:	c6 83 8e 1a 00 00 2e 	movb   $0x2e,0x1a8e(%ebx)
    lock_init(&c->lock);
c00265f5:	8d 83 90 1a 00 00    	lea    0x1a90(%ebx),%eax
c00265fb:	89 04 24             	mov    %eax,(%esp)
c00265fe:	e8 ff ce ff ff       	call   c0023502 <lock_init>
    c->expecting_interrupt = false;
c0026603:	c6 83 c4 1a 00 00 00 	movb   $0x0,0x1ac4(%ebx)
    sema_init(&c->completion_wait, 0);
c002660a:	83 c4 08             	add    $0x8,%esp
c002660d:	6a 00                	push   $0x0
c002660f:	8d 83 c8 1a 00 00    	lea    0x1ac8(%ebx),%eax
c0026615:	50                   	push   %eax
c0026616:	e8 a5 cb ff ff       	call   c00231c0 <sema_init>
      snprintf(d->name, sizeof d->name,
c002661b:	6a 61                	push   $0x61
c002661d:	8d bb 73 44 ff ff    	lea    -0xbb8d(%ebx),%edi
c0026623:	57                   	push   %edi
c0026624:	6a 08                	push   $0x8
c0026626:	8d ab dc 1a 00 00    	lea    0x1adc(%ebx),%ebp
c002662c:	55                   	push   %ebp
c002662d:	e8 ed 1d 00 00       	call   c002841f <snprintf>
      d->channel = c;
c0026632:	89 b3 e4 1a 00 00    	mov    %esi,0x1ae4(%ebx)
      d->dev_no = dev_no;
c0026638:	c7 83 e8 1a 00 00 00 	movl   $0x0,0x1ae8(%ebx)
c002663f:	00 00 00 
      d->is_ata = false;
c0026642:	c6 83 ec 1a 00 00 00 	movb   $0x0,0x1aec(%ebx)
      snprintf(d->name, sizeof d->name,
c0026649:	83 c4 20             	add    $0x20,%esp
c002664c:	6a 62                	push   $0x62
c002664e:	57                   	push   %edi
c002664f:	6a 08                	push   $0x8
c0026651:	8d 83 f0 1a 00 00    	lea    0x1af0(%ebx),%eax
c0026657:	50                   	push   %eax
c0026658:	e8 c2 1d 00 00       	call   c002841f <snprintf>
      d->channel = c;
c002665d:	89 b3 f8 1a 00 00    	mov    %esi,0x1af8(%ebx)
      d->dev_no = dev_no;
c0026663:	c7 83 fc 1a 00 00 01 	movl   $0x1,0x1afc(%ebx)
c002666a:	00 00 00 
      d->is_ata = false;
c002666d:	c6 83 00 1b 00 00 00 	movb   $0x0,0x1b00(%ebx)
    intr_register_ext(c->irq, interrupt_handler, c->name);
c0026674:	83 c4 0c             	add    $0xc,%esp
c0026677:	56                   	push   %esi
c0026678:	8d 83 7f 53 fe ff    	lea    -0x1ac81(%ebx),%eax
c002667e:	50                   	push   %eax
c002667f:	0f b6 83 8e 1a 00 00 	movzbl 0x1a8e(%ebx),%eax
c0026686:	50                   	push   %eax
c0026687:	e8 f9 ba ff ff       	call   c0022185 <intr_register_ext>
    select_device(d);
c002668c:	89 e8                	mov    %ebp,%eax
c002668e:	e8 23 fa ff ff       	call   c00260b6 <select_device>
    outb(reg_nsect(c), 0x55);
c0026693:	0f b7 8b 8c 1a 00 00 	movzwl 0x1a8c(%ebx),%ecx
c002669a:	8d 71 02             	lea    0x2(%ecx),%esi
  asm volatile("outb %b0, %w1"
c002669d:	bd 55 00 00 00       	mov    $0x55,%ebp
c00266a2:	89 e8                	mov    %ebp,%eax
c00266a4:	89 f2                	mov    %esi,%edx
c00266a6:	ee                   	out    %al,(%dx)
    outb(reg_lbal(c), 0xaa);
c00266a7:	83 c1 03             	add    $0x3,%ecx
c00266aa:	bf aa ff ff ff       	mov    $0xffffffaa,%edi
c00266af:	89 f8                	mov    %edi,%eax
c00266b1:	89 ca                	mov    %ecx,%edx
c00266b3:	ee                   	out    %al,(%dx)
c00266b4:	89 f2                	mov    %esi,%edx
c00266b6:	ee                   	out    %al,(%dx)
c00266b7:	89 e8                	mov    %ebp,%eax
c00266b9:	89 ca                	mov    %ecx,%edx
c00266bb:	ee                   	out    %al,(%dx)
c00266bc:	89 f2                	mov    %esi,%edx
c00266be:	ee                   	out    %al,(%dx)
c00266bf:	89 f8                	mov    %edi,%eax
c00266c1:	89 ca                	mov    %ecx,%edx
c00266c3:	ee                   	out    %al,(%dx)
  asm volatile("inb %w1, %b0"
c00266c4:	89 f2                	mov    %esi,%edx
c00266c6:	ec                   	in     (%dx),%al
    present[dev_no] = (inb(reg_nsect(c)) == 0x55 && inb(reg_lbal(c)) == 0xaa);
c00266c7:	83 c4 10             	add    $0x10,%esp
c00266ca:	ba 00 00 00 00       	mov    $0x0,%edx
c00266cf:	3c 55                	cmp    $0x55,%al
c00266d1:	0f 84 cf 01 00 00    	je     c00268a6 <ide_init+0x2ea>
c00266d7:	89 d0                	mov    %edx,%eax
c00266d9:	83 e0 01             	and    $0x1,%eax
c00266dc:	88 44 24 0c          	mov    %al,0xc(%esp)
c00266e0:	88 44 24 1e          	mov    %al,0x1e(%esp)
    select_device(d);
c00266e4:	8d 83 f0 1a 00 00    	lea    0x1af0(%ebx),%eax
c00266ea:	e8 c7 f9 ff ff       	call   c00260b6 <select_device>
    outb(reg_nsect(c), 0x55);
c00266ef:	0f b7 ab 8c 1a 00 00 	movzwl 0x1a8c(%ebx),%ebp
c00266f6:	8d 4d 02             	lea    0x2(%ebp),%ecx
  asm volatile("outb %b0, %w1"
c00266f9:	b8 55 00 00 00       	mov    $0x55,%eax
c00266fe:	89 ca                	mov    %ecx,%edx
c0026700:	ee                   	out    %al,(%dx)
    outb(reg_lbal(c), 0xaa);
c0026701:	8d 75 03             	lea    0x3(%ebp),%esi
c0026704:	bf aa ff ff ff       	mov    $0xffffffaa,%edi
c0026709:	89 f8                	mov    %edi,%eax
c002670b:	89 f2                	mov    %esi,%edx
c002670d:	ee                   	out    %al,(%dx)
c002670e:	89 ca                	mov    %ecx,%edx
c0026710:	ee                   	out    %al,(%dx)
c0026711:	b8 55 00 00 00       	mov    $0x55,%eax
c0026716:	89 f2                	mov    %esi,%edx
c0026718:	ee                   	out    %al,(%dx)
c0026719:	89 ca                	mov    %ecx,%edx
c002671b:	ee                   	out    %al,(%dx)
c002671c:	89 f8                	mov    %edi,%eax
c002671e:	89 f2                	mov    %esi,%edx
c0026720:	ee                   	out    %al,(%dx)
  asm volatile("inb %w1, %b0"
c0026721:	89 ca                	mov    %ecx,%edx
c0026723:	ec                   	in     (%dx),%al
    present[dev_no] = (inb(reg_nsect(c)) == 0x55 && inb(reg_lbal(c)) == 0xaa);
c0026724:	ba 00 00 00 00       	mov    $0x0,%edx
c0026729:	3c 55                	cmp    $0x55,%al
c002672b:	0f 84 85 01 00 00    	je     c00268b6 <ide_init+0x2fa>
c0026731:	89 d6                	mov    %edx,%esi
c0026733:	83 e6 01             	and    $0x1,%esi
c0026736:	89 f0                	mov    %esi,%eax
c0026738:	88 44 24 1f          	mov    %al,0x1f(%esp)
  asm volatile("outb %b0, %w1"
c002673c:	bf 00 00 00 00       	mov    $0x0,%edi
  outb(reg_ctl(c), 0);
c0026741:	8d 95 06 02 00 00    	lea    0x206(%ebp),%edx
c0026747:	89 f8                	mov    %edi,%eax
c0026749:	ee                   	out    %al,(%dx)
  timer_usleep(10);
c002674a:	83 ec 08             	sub    $0x8,%esp
c002674d:	6a 00                	push   $0x0
c002674f:	6a 0a                	push   $0xa
c0026751:	e8 a2 e5 ff ff       	call   c0024cf8 <timer_usleep>
  outb(reg_ctl(c), CTL_SRST);
c0026756:	0f b7 93 8c 1a 00 00 	movzwl 0x1a8c(%ebx),%edx
c002675d:	66 81 c2 06 02       	add    $0x206,%dx
c0026762:	b8 04 00 00 00       	mov    $0x4,%eax
c0026767:	ee                   	out    %al,(%dx)
  timer_usleep(10);
c0026768:	83 c4 08             	add    $0x8,%esp
c002676b:	6a 00                	push   $0x0
c002676d:	6a 0a                	push   $0xa
c002676f:	e8 84 e5 ff ff       	call   c0024cf8 <timer_usleep>
  outb(reg_ctl(c), 0);
c0026774:	0f b7 93 8c 1a 00 00 	movzwl 0x1a8c(%ebx),%edx
c002677b:	66 81 c2 06 02       	add    $0x206,%dx
c0026780:	89 f8                	mov    %edi,%eax
c0026782:	ee                   	out    %al,(%dx)
  timer_msleep(150);
c0026783:	83 c4 08             	add    $0x8,%esp
c0026786:	6a 00                	push   $0x0
c0026788:	68 96 00 00 00       	push   $0x96
c002678d:	e8 4d e5 ff ff       	call   c0024cdf <timer_msleep>
  if (present[0])
c0026792:	83 c4 10             	add    $0x10,%esp
c0026795:	80 7c 24 0c 00       	cmpb   $0x0,0xc(%esp)
c002679a:	0f 85 26 01 00 00    	jne    c00268c6 <ide_init+0x30a>
  if (present[1])
c00267a0:	89 f0                	mov    %esi,%eax
c00267a2:	84 c0                	test   %al,%al
c00267a4:	0f 85 37 01 00 00    	jne    c00268e1 <ide_init+0x325>
    if (check_device_type(&c->devices[0]))
c00267aa:	8d 83 dc 1a 00 00    	lea    0x1adc(%ebx),%eax
c00267b0:	e8 44 f9 ff ff       	call   c00260f9 <check_device_type>
c00267b5:	84 c0                	test   %al,%al
c00267b7:	0f 85 71 01 00 00    	jne    c002692e <ide_init+0x372>
      if (c->devices[dev_no].is_ata)
c00267bd:	80 bb ec 1a 00 00 00 	cmpb   $0x0,0x1aec(%ebx)
c00267c4:	0f 85 74 01 00 00    	jne    c002693e <ide_init+0x382>
c00267ca:	80 bb 00 1b 00 00 00 	cmpb   $0x0,0x1b00(%ebx)
c00267d1:	0f 85 77 01 00 00    	jne    c002694e <ide_init+0x392>
    snprintf(c->name, sizeof c->name, "ide%zu", chan_no);
c00267d7:	6a 01                	push   $0x1
c00267d9:	8d 83 6c 44 ff ff    	lea    -0xbb94(%ebx),%eax
c00267df:	50                   	push   %eax
c00267e0:	6a 08                	push   $0x8
c00267e2:	8d b3 04 1b 00 00    	lea    0x1b04(%ebx),%esi
c00267e8:	56                   	push   %esi
c00267e9:	e8 31 1c 00 00       	call   c002841f <snprintf>
      c->reg_base = 0x170;
c00267ee:	66 c7 83 0c 1b 00 00 	movw   $0x170,0x1b0c(%ebx)
c00267f5:	70 01 
      c->irq = 15 + 0x20;
c00267f7:	c6 83 0e 1b 00 00 2f 	movb   $0x2f,0x1b0e(%ebx)
    lock_init(&c->lock);
c00267fe:	8d 83 10 1b 00 00    	lea    0x1b10(%ebx),%eax
c0026804:	89 04 24             	mov    %eax,(%esp)
c0026807:	e8 f6 cc ff ff       	call   c0023502 <lock_init>
    c->expecting_interrupt = false;
c002680c:	c6 83 44 1b 00 00 00 	movb   $0x0,0x1b44(%ebx)
    sema_init(&c->completion_wait, 0);
c0026813:	83 c4 08             	add    $0x8,%esp
c0026816:	6a 00                	push   $0x0
c0026818:	8d 83 48 1b 00 00    	lea    0x1b48(%ebx),%eax
c002681e:	50                   	push   %eax
c002681f:	e8 9c c9 ff ff       	call   c00231c0 <sema_init>
      snprintf(d->name, sizeof d->name,
c0026824:	6a 63                	push   $0x63
c0026826:	8d bb 73 44 ff ff    	lea    -0xbb8d(%ebx),%edi
c002682c:	57                   	push   %edi
c002682d:	6a 08                	push   $0x8
c002682f:	8d ab 5c 1b 00 00    	lea    0x1b5c(%ebx),%ebp
c0026835:	55                   	push   %ebp
c0026836:	e8 e4 1b 00 00       	call   c002841f <snprintf>
      d->channel = c;
c002683b:	89 b3 64 1b 00 00    	mov    %esi,0x1b64(%ebx)
      d->dev_no = dev_no;
c0026841:	c7 83 68 1b 00 00 00 	movl   $0x0,0x1b68(%ebx)
c0026848:	00 00 00 
      d->is_ata = false;
c002684b:	c6 83 6c 1b 00 00 00 	movb   $0x0,0x1b6c(%ebx)
      snprintf(d->name, sizeof d->name,
c0026852:	83 c4 20             	add    $0x20,%esp
c0026855:	6a 64                	push   $0x64
c0026857:	57                   	push   %edi
c0026858:	6a 08                	push   $0x8
c002685a:	8d 83 70 1b 00 00    	lea    0x1b70(%ebx),%eax
c0026860:	50                   	push   %eax
c0026861:	e8 b9 1b 00 00       	call   c002841f <snprintf>
      d->channel = c;
c0026866:	89 b3 78 1b 00 00    	mov    %esi,0x1b78(%ebx)
      d->dev_no = dev_no;
c002686c:	c7 83 7c 1b 00 00 01 	movl   $0x1,0x1b7c(%ebx)
c0026873:	00 00 00 
      d->is_ata = false;
c0026876:	c6 83 80 1b 00 00 00 	movb   $0x0,0x1b80(%ebx)
    intr_register_ext(c->irq, interrupt_handler, c->name);
c002687d:	83 c4 0c             	add    $0xc,%esp
c0026880:	56                   	push   %esi
c0026881:	8d 83 7f 53 fe ff    	lea    -0x1ac81(%ebx),%eax
c0026887:	50                   	push   %eax
c0026888:	0f b6 83 0e 1b 00 00 	movzbl 0x1b0e(%ebx),%eax
c002688f:	50                   	push   %eax
c0026890:	e8 f0 b8 ff ff       	call   c0022185 <intr_register_ext>
c0026895:	89 6c 24 1c          	mov    %ebp,0x1c(%esp)
c0026899:	83 c4 10             	add    $0x10,%esp
  for (dev_no = 0; dev_no < 2; dev_no++)
c002689c:	be 00 00 00 00       	mov    $0x0,%esi
c00268a1:	e9 ce 00 00 00       	jmp    c0026974 <ide_init+0x3b8>
  asm volatile("inb %w1, %b0"
c00268a6:	89 ca                	mov    %ecx,%edx
c00268a8:	ec                   	in     (%dx),%al
    present[dev_no] = (inb(reg_nsect(c)) == 0x55 && inb(reg_lbal(c)) == 0xaa);
c00268a9:	3c aa                	cmp    $0xaa,%al
c00268ab:	0f 94 c2             	sete   %dl
c00268ae:	0f b6 d2             	movzbl %dl,%edx
c00268b1:	e9 21 fe ff ff       	jmp    c00266d7 <ide_init+0x11b>
c00268b6:	89 f2                	mov    %esi,%edx
c00268b8:	ec                   	in     (%dx),%al
c00268b9:	3c aa                	cmp    $0xaa,%al
c00268bb:	0f 94 c2             	sete   %dl
c00268be:	0f b6 d2             	movzbl %dl,%edx
c00268c1:	e9 6b fe ff ff       	jmp    c0026731 <ide_init+0x175>
    select_device(&c->devices[0]);
c00268c6:	8d 83 dc 1a 00 00    	lea    0x1adc(%ebx),%eax
c00268cc:	e8 e5 f7 ff ff       	call   c00260b6 <select_device>
    wait_while_busy(&c->devices[0]);
c00268d1:	8d 83 dc 1a 00 00    	lea    0x1adc(%ebx),%eax
c00268d7:	e8 43 f9 ff ff       	call   c002621f <wait_while_busy>
c00268dc:	e9 bf fe ff ff       	jmp    c00267a0 <ide_init+0x1e4>
    select_device(&c->devices[1]);
c00268e1:	8d 83 f0 1a 00 00    	lea    0x1af0(%ebx),%eax
c00268e7:	e8 ca f7 ff ff       	call   c00260b6 <select_device>
c00268ec:	be b8 0b 00 00       	mov    $0xbb8,%esi
c00268f1:	eb 14                	jmp    c0026907 <ide_init+0x34b>
      timer_msleep(10);
c00268f3:	83 ec 08             	sub    $0x8,%esp
c00268f6:	6a 00                	push   $0x0
c00268f8:	6a 0a                	push   $0xa
c00268fa:	e8 e0 e3 ff ff       	call   c0024cdf <timer_msleep>
    for (i = 0; i < 3000; i++)
c00268ff:	83 c4 10             	add    $0x10,%esp
c0026902:	83 ee 01             	sub    $0x1,%esi
c0026905:	74 17                	je     c002691e <ide_init+0x362>
      if (inb(reg_nsect(c)) == 1 && inb(reg_lbal(c)) == 1)
c0026907:	0f b7 8b 8c 1a 00 00 	movzwl 0x1a8c(%ebx),%ecx
c002690e:	8d 51 02             	lea    0x2(%ecx),%edx
c0026911:	ec                   	in     (%dx),%al
c0026912:	3c 01                	cmp    $0x1,%al
c0026914:	75 dd                	jne    c00268f3 <ide_init+0x337>
c0026916:	8d 51 03             	lea    0x3(%ecx),%edx
c0026919:	ec                   	in     (%dx),%al
c002691a:	3c 01                	cmp    $0x1,%al
c002691c:	75 d5                	jne    c00268f3 <ide_init+0x337>
    wait_while_busy(&c->devices[1]);
c002691e:	8d 83 f0 1a 00 00    	lea    0x1af0(%ebx),%eax
c0026924:	e8 f6 f8 ff ff       	call   c002621f <wait_while_busy>
c0026929:	e9 7c fe ff ff       	jmp    c00267aa <ide_init+0x1ee>
      check_device_type(&c->devices[1]);
c002692e:	8d 83 f0 1a 00 00    	lea    0x1af0(%ebx),%eax
c0026934:	e8 c0 f7 ff ff       	call   c00260f9 <check_device_type>
c0026939:	e9 7f fe ff ff       	jmp    c00267bd <ide_init+0x201>
        identify_ata_device(&c->devices[dev_no]);
c002693e:	8d 83 dc 1a 00 00    	lea    0x1adc(%ebx),%eax
c0026944:	e8 7e fa ff ff       	call   c00263c7 <identify_ata_device>
c0026949:	e9 7c fe ff ff       	jmp    c00267ca <ide_init+0x20e>
c002694e:	8d 83 f0 1a 00 00    	lea    0x1af0(%ebx),%eax
c0026954:	e8 6e fa ff ff       	call   c00263c7 <identify_ata_device>
c0026959:	e9 79 fe ff ff       	jmp    c00267d7 <ide_init+0x21b>
    present[dev_no] = (inb(reg_nsect(c)) == 0x55 && inb(reg_lbal(c)) == 0xaa);
c002695e:	88 54 34 1e          	mov    %dl,0x1e(%esp,%esi,1)
c0026962:	80 64 34 1e 01       	andb   $0x1,0x1e(%esp,%esi,1)
  for (dev_no = 0; dev_no < 2; dev_no++)
c0026967:	83 c6 01             	add    $0x1,%esi
c002696a:	83 44 24 0c 14       	addl   $0x14,0xc(%esp)
c002696f:	83 fe 02             	cmp    $0x2,%esi
c0026972:	74 55                	je     c00269c9 <ide_init+0x40d>
    select_device(d);
c0026974:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0026978:	e8 39 f7 ff ff       	call   c00260b6 <select_device>
    outb(reg_nsect(c), 0x55);
c002697d:	0f b7 ab 0c 1b 00 00 	movzwl 0x1b0c(%ebx),%ebp
c0026984:	8d 4d 02             	lea    0x2(%ebp),%ecx
  asm volatile("outb %b0, %w1"
c0026987:	b8 55 00 00 00       	mov    $0x55,%eax
c002698c:	89 ca                	mov    %ecx,%edx
c002698e:	ee                   	out    %al,(%dx)
    outb(reg_lbal(c), 0xaa);
c002698f:	8d 7d 03             	lea    0x3(%ebp),%edi
c0026992:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c0026997:	89 fa                	mov    %edi,%edx
c0026999:	ee                   	out    %al,(%dx)
c002699a:	89 ca                	mov    %ecx,%edx
c002699c:	ee                   	out    %al,(%dx)
c002699d:	b8 55 00 00 00       	mov    $0x55,%eax
c00269a2:	89 fa                	mov    %edi,%edx
c00269a4:	ee                   	out    %al,(%dx)
c00269a5:	89 ca                	mov    %ecx,%edx
c00269a7:	ee                   	out    %al,(%dx)
c00269a8:	b8 aa ff ff ff       	mov    $0xffffffaa,%eax
c00269ad:	89 fa                	mov    %edi,%edx
c00269af:	ee                   	out    %al,(%dx)
  asm volatile("inb %w1, %b0"
c00269b0:	89 ca                	mov    %ecx,%edx
c00269b2:	ec                   	in     (%dx),%al
    present[dev_no] = (inb(reg_nsect(c)) == 0x55 && inb(reg_lbal(c)) == 0xaa);
c00269b3:	ba 00 00 00 00       	mov    $0x0,%edx
c00269b8:	3c 55                	cmp    $0x55,%al
c00269ba:	75 a2                	jne    c002695e <ide_init+0x3a2>
c00269bc:	89 fa                	mov    %edi,%edx
c00269be:	ec                   	in     (%dx),%al
c00269bf:	3c aa                	cmp    $0xaa,%al
c00269c1:	0f 94 c2             	sete   %dl
c00269c4:	0f b6 d2             	movzbl %dl,%edx
c00269c7:	eb 95                	jmp    c002695e <ide_init+0x3a2>
  asm volatile("outb %b0, %w1"
c00269c9:	be 00 00 00 00       	mov    $0x0,%esi
  outb(reg_ctl(c), 0);
c00269ce:	8d 95 06 02 00 00    	lea    0x206(%ebp),%edx
c00269d4:	89 f0                	mov    %esi,%eax
c00269d6:	ee                   	out    %al,(%dx)
  timer_usleep(10);
c00269d7:	83 ec 08             	sub    $0x8,%esp
c00269da:	6a 00                	push   $0x0
c00269dc:	6a 0a                	push   $0xa
c00269de:	e8 15 e3 ff ff       	call   c0024cf8 <timer_usleep>
  outb(reg_ctl(c), CTL_SRST);
c00269e3:	0f b7 93 0c 1b 00 00 	movzwl 0x1b0c(%ebx),%edx
c00269ea:	66 81 c2 06 02       	add    $0x206,%dx
c00269ef:	b8 04 00 00 00       	mov    $0x4,%eax
c00269f4:	ee                   	out    %al,(%dx)
  timer_usleep(10);
c00269f5:	83 c4 08             	add    $0x8,%esp
c00269f8:	6a 00                	push   $0x0
c00269fa:	6a 0a                	push   $0xa
c00269fc:	e8 f7 e2 ff ff       	call   c0024cf8 <timer_usleep>
  outb(reg_ctl(c), 0);
c0026a01:	0f b7 93 0c 1b 00 00 	movzwl 0x1b0c(%ebx),%edx
c0026a08:	66 81 c2 06 02       	add    $0x206,%dx
c0026a0d:	89 f0                	mov    %esi,%eax
c0026a0f:	ee                   	out    %al,(%dx)
  timer_msleep(150);
c0026a10:	83 c4 08             	add    $0x8,%esp
c0026a13:	6a 00                	push   $0x0
c0026a15:	68 96 00 00 00       	push   $0x96
c0026a1a:	e8 c0 e2 ff ff       	call   c0024cdf <timer_msleep>
  if (present[0])
c0026a1f:	83 c4 10             	add    $0x10,%esp
c0026a22:	80 7c 24 1e 00       	cmpb   $0x0,0x1e(%esp)
c0026a27:	75 38                	jne    c0026a61 <ide_init+0x4a5>
  if (present[1])
c0026a29:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c0026a2e:	75 49                	jne    c0026a79 <ide_init+0x4bd>
    if (check_device_type(&c->devices[0]))
c0026a30:	8d 83 5c 1b 00 00    	lea    0x1b5c(%ebx),%eax
c0026a36:	e8 be f6 ff ff       	call   c00260f9 <check_device_type>
c0026a3b:	84 c0                	test   %al,%al
c0026a3d:	0f 85 83 00 00 00    	jne    c0026ac6 <ide_init+0x50a>
      if (c->devices[dev_no].is_ata)
c0026a43:	80 bb 6c 1b 00 00 00 	cmpb   $0x0,0x1b6c(%ebx)
c0026a4a:	0f 85 96 00 00 00    	jne    c0026ae6 <ide_init+0x52a>
c0026a50:	80 bb 80 1b 00 00 00 	cmpb   $0x0,0x1b80(%ebx)
c0026a57:	75 7d                	jne    c0026ad6 <ide_init+0x51a>
}
c0026a59:	83 c4 2c             	add    $0x2c,%esp
c0026a5c:	5b                   	pop    %ebx
c0026a5d:	5e                   	pop    %esi
c0026a5e:	5f                   	pop    %edi
c0026a5f:	5d                   	pop    %ebp
c0026a60:	c3                   	ret    
    select_device(&c->devices[0]);
c0026a61:	8d 83 5c 1b 00 00    	lea    0x1b5c(%ebx),%eax
c0026a67:	e8 4a f6 ff ff       	call   c00260b6 <select_device>
    wait_while_busy(&c->devices[0]);
c0026a6c:	8d 83 5c 1b 00 00    	lea    0x1b5c(%ebx),%eax
c0026a72:	e8 a8 f7 ff ff       	call   c002621f <wait_while_busy>
c0026a77:	eb b0                	jmp    c0026a29 <ide_init+0x46d>
    select_device(&c->devices[1]);
c0026a79:	8d 83 70 1b 00 00    	lea    0x1b70(%ebx),%eax
c0026a7f:	e8 32 f6 ff ff       	call   c00260b6 <select_device>
c0026a84:	be b8 0b 00 00       	mov    $0xbb8,%esi
c0026a89:	eb 14                	jmp    c0026a9f <ide_init+0x4e3>
      timer_msleep(10);
c0026a8b:	83 ec 08             	sub    $0x8,%esp
c0026a8e:	6a 00                	push   $0x0
c0026a90:	6a 0a                	push   $0xa
c0026a92:	e8 48 e2 ff ff       	call   c0024cdf <timer_msleep>
    for (i = 0; i < 3000; i++)
c0026a97:	83 c4 10             	add    $0x10,%esp
c0026a9a:	83 ee 01             	sub    $0x1,%esi
c0026a9d:	74 17                	je     c0026ab6 <ide_init+0x4fa>
      if (inb(reg_nsect(c)) == 1 && inb(reg_lbal(c)) == 1)
c0026a9f:	0f b7 8b 0c 1b 00 00 	movzwl 0x1b0c(%ebx),%ecx
c0026aa6:	8d 51 02             	lea    0x2(%ecx),%edx
  asm volatile("inb %w1, %b0"
c0026aa9:	ec                   	in     (%dx),%al
c0026aaa:	3c 01                	cmp    $0x1,%al
c0026aac:	75 dd                	jne    c0026a8b <ide_init+0x4cf>
c0026aae:	8d 51 03             	lea    0x3(%ecx),%edx
c0026ab1:	ec                   	in     (%dx),%al
c0026ab2:	3c 01                	cmp    $0x1,%al
c0026ab4:	75 d5                	jne    c0026a8b <ide_init+0x4cf>
    wait_while_busy(&c->devices[1]);
c0026ab6:	8d 83 70 1b 00 00    	lea    0x1b70(%ebx),%eax
c0026abc:	e8 5e f7 ff ff       	call   c002621f <wait_while_busy>
c0026ac1:	e9 6a ff ff ff       	jmp    c0026a30 <ide_init+0x474>
      check_device_type(&c->devices[1]);
c0026ac6:	8d 83 70 1b 00 00    	lea    0x1b70(%ebx),%eax
c0026acc:	e8 28 f6 ff ff       	call   c00260f9 <check_device_type>
c0026ad1:	e9 6d ff ff ff       	jmp    c0026a43 <ide_init+0x487>
        identify_ata_device(&c->devices[dev_no]);
c0026ad6:	8d 83 70 1b 00 00    	lea    0x1b70(%ebx),%eax
c0026adc:	e8 e6 f8 ff ff       	call   c00263c7 <identify_ata_device>
}
c0026ae1:	e9 73 ff ff ff       	jmp    c0026a59 <ide_init+0x49d>
        identify_ata_device(&c->devices[dev_no]);
c0026ae6:	8d 83 5c 1b 00 00    	lea    0x1b5c(%ebx),%eax
c0026aec:	e8 d6 f8 ff ff       	call   c00263c7 <identify_ata_device>
c0026af1:	e9 5a ff ff ff       	jmp    c0026a50 <ide_init+0x494>

c0026af6 <input_init>:
    str[len] = '\0';
}

/* Initializes the input buffer. */
void input_init(void)
{
c0026af6:	53                   	push   %ebx
c0026af7:	83 ec 14             	sub    $0x14,%esp
c0026afa:	e8 e7 b9 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0026aff:	81 c3 3d a1 01 00    	add    $0x1a13d,%ebx
  intq_init(&buffer);
c0026b05:	8d 83 84 1b 00 00    	lea    0x1b84(%ebx),%eax
c0026b0b:	50                   	push   %eax
c0026b0c:	e8 0c 02 00 00       	call   c0026d1d <intq_init>
}
c0026b11:	83 c4 18             	add    $0x18,%esp
c0026b14:	5b                   	pop    %ebx
c0026b15:	c3                   	ret    

c0026b16 <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void input_putc(uint8_t key)
{
c0026b16:	56                   	push   %esi
c0026b17:	53                   	push   %ebx
c0026b18:	83 ec 04             	sub    $0x4,%esp
c0026b1b:	e8 c6 b9 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0026b20:	81 c3 1c a1 01 00    	add    $0x1a11c,%ebx
c0026b26:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT(intr_get_level() == INTR_OFF);
c0026b2a:	e8 2a b4 ff ff       	call   c0021f59 <intr_get_level>
c0026b2f:	85 c0                	test   %eax,%eax
c0026b31:	75 36                	jne    c0026b69 <input_putc+0x53>
  ASSERT(!intq_full(&buffer));
c0026b33:	83 ec 0c             	sub    $0xc,%esp
c0026b36:	8d 83 84 1b 00 00    	lea    0x1b84(%ebx),%eax
c0026b3c:	50                   	push   %eax
c0026b3d:	e8 6f 02 00 00       	call   c0026db1 <intq_full>
c0026b42:	83 c4 10             	add    $0x10,%esp
c0026b45:	84 c0                	test   %al,%al
c0026b47:	75 46                	jne    c0026b8f <input_putc+0x79>

  intq_putc(&buffer, key);
c0026b49:	83 ec 08             	sub    $0x8,%esp
c0026b4c:	89 f0                	mov    %esi,%eax
c0026b4e:	0f b6 f0             	movzbl %al,%esi
c0026b51:	56                   	push   %esi
c0026b52:	8d 83 84 1b 00 00    	lea    0x1b84(%ebx),%eax
c0026b58:	50                   	push   %eax
c0026b59:	e8 18 05 00 00       	call   c0027076 <intq_putc>
  serial_notify();
c0026b5e:	e8 88 ea ff ff       	call   c00255eb <serial_notify>
}
c0026b63:	83 c4 14             	add    $0x14,%esp
c0026b66:	5b                   	pop    %ebx
c0026b67:	5e                   	pop    %esi
c0026b68:	c3                   	ret    
  ASSERT(intr_get_level() == INTR_OFF);
c0026b69:	83 ec 0c             	sub    $0xc,%esp
c0026b6c:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c0026b72:	50                   	push   %eax
c0026b73:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0026b79:	50                   	push   %eax
c0026b7a:	8d 83 54 1e ff ff    	lea    -0xe1ac(%ebx),%eax
c0026b80:	50                   	push   %eax
c0026b81:	6a 48                	push   $0x48
c0026b83:	8d 83 bc 44 ff ff    	lea    -0xbb44(%ebx),%eax
c0026b89:	50                   	push   %eax
c0026b8a:	e8 06 2d 00 00       	call   c0029895 <debug_panic>
  ASSERT(!intq_full(&buffer));
c0026b8f:	83 ec 0c             	sub    $0xc,%esp
c0026b92:	8d 83 d2 44 ff ff    	lea    -0xbb2e(%ebx),%eax
c0026b98:	50                   	push   %eax
c0026b99:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0026b9f:	50                   	push   %eax
c0026ba0:	8d 83 54 1e ff ff    	lea    -0xe1ac(%ebx),%eax
c0026ba6:	50                   	push   %eax
c0026ba7:	6a 49                	push   $0x49
c0026ba9:	8d 83 bc 44 ff ff    	lea    -0xbb44(%ebx),%eax
c0026baf:	50                   	push   %eax
c0026bb0:	e8 e0 2c 00 00       	call   c0029895 <debug_panic>

c0026bb5 <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc(void)
{
c0026bb5:	57                   	push   %edi
c0026bb6:	56                   	push   %esi
c0026bb7:	53                   	push   %ebx
c0026bb8:	e8 29 b9 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0026bbd:	81 c3 7f a0 01 00    	add    $0x1a07f,%ebx
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable();
c0026bc3:	e8 e3 b3 ff ff       	call   c0021fab <intr_disable>
c0026bc8:	89 c7                	mov    %eax,%edi
  key = intq_getc(&buffer);
c0026bca:	83 ec 0c             	sub    $0xc,%esp
c0026bcd:	8d 83 84 1b 00 00    	lea    0x1b84(%ebx),%eax
c0026bd3:	50                   	push   %eax
c0026bd4:	e8 cc 03 00 00       	call   c0026fa5 <intq_getc>
c0026bd9:	89 c6                	mov    %eax,%esi
  serial_notify();
c0026bdb:	e8 0b ea ff ff       	call   c00255eb <serial_notify>
  intr_set_level(old_level);
c0026be0:	89 3c 24             	mov    %edi,(%esp)
c0026be3:	e8 ca b3 ff ff       	call   c0021fb2 <intr_set_level>

  return key;
c0026be8:	83 c4 10             	add    $0x10,%esp
}
c0026beb:	89 f0                	mov    %esi,%eax
c0026bed:	5b                   	pop    %ebx
c0026bee:	5e                   	pop    %esi
c0026bef:	5f                   	pop    %edi
c0026bf0:	c3                   	ret    

c0026bf1 <readline>:
{
c0026bf1:	55                   	push   %ebp
c0026bf2:	57                   	push   %edi
c0026bf3:	56                   	push   %esi
c0026bf4:	53                   	push   %ebx
c0026bf5:	83 ec 0c             	sub    $0xc,%esp
c0026bf8:	e8 e9 b8 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0026bfd:	81 c3 3f a0 01 00    	add    $0x1a03f,%ebx
  int len = 0;
c0026c03:	bf 00 00 00 00       	mov    $0x0,%edi
    bool isEnd = false;
c0026c08:	bd 00 00 00 00       	mov    $0x0,%ebp
c0026c0d:	eb 7a                	jmp    c0026c89 <.L20+0xf>

c0026c0f <.L16>:
      putchar(ch);
c0026c0f:	83 ec 0c             	sub    $0xc,%esp
c0026c12:	52                   	push   %edx
c0026c13:	e8 c8 4c 00 00       	call   c002b8e0 <putchar>
      str[len++] = ch;
c0026c18:	8b 54 24 30          	mov    0x30(%esp),%edx
c0026c1c:	89 f0                	mov    %esi,%eax
c0026c1e:	88 04 3a             	mov    %al,(%edx,%edi,1)
      break;
c0026c21:	83 c4 10             	add    $0x10,%esp
      str[len++] = ch;
c0026c24:	8d 7f 01             	lea    0x1(%edi),%edi
    bool isEnd = false;
c0026c27:	89 e8                	mov    %ebp,%eax
      break;
c0026c29:	eb 54                	jmp    c0026c7f <.L20+0x5>

c0026c2b <.L15>:
    bool isEnd = false;
c0026c2b:	89 e8                	mov    %ebp,%eax
      if (len > 0)
c0026c2d:	85 ff                	test   %edi,%edi
c0026c2f:	7e 4e                	jle    c0026c7f <.L20+0x5>
        putbuf("\b \b", 3);
c0026c31:	83 ec 08             	sub    $0x8,%esp
c0026c34:	6a 03                	push   $0x3
c0026c36:	8d 83 e6 44 ff ff    	lea    -0xbb1a(%ebx),%eax
c0026c3c:	50                   	push   %eax
c0026c3d:	e8 6b 4c 00 00       	call   c002b8ad <putbuf>
        str[--len] = '\0';
c0026c42:	83 ef 01             	sub    $0x1,%edi
c0026c45:	8b 44 24 30          	mov    0x30(%esp),%eax
c0026c49:	c6 04 38 00          	movb   $0x0,(%eax,%edi,1)
        break;
c0026c4d:	83 c4 10             	add    $0x10,%esp
    bool isEnd = false;
c0026c50:	89 e8                	mov    %ebp,%eax
        break;
c0026c52:	eb 2b                	jmp    c0026c7f <.L20+0x5>

c0026c54 <.L12>:
      if (ch >= 0x21 && ch <= 0x7E)
c0026c54:	8d 4e df             	lea    -0x21(%esi),%ecx
    bool isEnd = false;
c0026c57:	89 e8                	mov    %ebp,%eax
      if (ch >= 0x21 && ch <= 0x7E)
c0026c59:	80 f9 5d             	cmp    $0x5d,%cl
c0026c5c:	77 21                	ja     c0026c7f <.L20+0x5>
        putchar(ch);
c0026c5e:	83 ec 0c             	sub    $0xc,%esp
c0026c61:	52                   	push   %edx
c0026c62:	e8 79 4c 00 00       	call   c002b8e0 <putchar>
        str[len++] = ch;
c0026c67:	8b 54 24 30          	mov    0x30(%esp),%edx
c0026c6b:	89 f0                	mov    %esi,%eax
c0026c6d:	88 04 3a             	mov    %al,(%edx,%edi,1)
c0026c70:	83 c4 10             	add    $0x10,%esp
c0026c73:	8d 7f 01             	lea    0x1(%edi),%edi
    bool isEnd = false;
c0026c76:	89 e8                	mov    %ebp,%eax
c0026c78:	eb 05                	jmp    c0026c7f <.L20+0x5>

c0026c7a <.L20>:
      isEnd = true;
c0026c7a:	b8 01 00 00 00       	mov    $0x1,%eax
    if (isEnd || len == max_len)
c0026c7f:	3b 7c 24 24          	cmp    0x24(%esp),%edi
c0026c83:	74 23                	je     c0026ca8 <.L20+0x2e>
c0026c85:	84 c0                	test   %al,%al
c0026c87:	75 1f                	jne    c0026ca8 <.L20+0x2e>
    char ch = input_getc();
c0026c89:	e8 27 ff ff ff       	call   c0026bb5 <input_getc>
c0026c8e:	89 c6                	mov    %eax,%esi
    switch (ch)
c0026c90:	0f be d0             	movsbl %al,%edx
c0026c93:	8d 46 fd             	lea    -0x3(%esi),%eax
c0026c96:	3c 1d                	cmp    $0x1d,%al
c0026c98:	77 ba                	ja     c0026c54 <.L12>
c0026c9a:	0f b6 c0             	movzbl %al,%eax
c0026c9d:	89 d9                	mov    %ebx,%ecx
c0026c9f:	03 8c 83 d0 1d ff ff 	add    -0xe230(%ebx,%eax,4),%ecx
c0026ca6:	ff e1                	jmp    *%ecx
      putchar('\n');
c0026ca8:	83 ec 0c             	sub    $0xc,%esp
c0026cab:	6a 0a                	push   $0xa
c0026cad:	e8 2e 4c 00 00       	call   c002b8e0 <putchar>
  if (len < max_len)
c0026cb2:	83 c4 10             	add    $0x10,%esp
c0026cb5:	3b 7c 24 24          	cmp    0x24(%esp),%edi
c0026cb9:	7d 08                	jge    c0026cc3 <.L20+0x49>
    str[len] = '\0';
c0026cbb:	8b 44 24 20          	mov    0x20(%esp),%eax
c0026cbf:	c6 04 38 00          	movb   $0x0,(%eax,%edi,1)
}
c0026cc3:	83 c4 0c             	add    $0xc,%esp
c0026cc6:	5b                   	pop    %ebx
c0026cc7:	5e                   	pop    %esi
c0026cc8:	5f                   	pop    %edi
c0026cc9:	5d                   	pop    %ebp
c0026cca:	c3                   	ret    

c0026ccb <input_full>:

/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool input_full(void)
{
c0026ccb:	53                   	push   %ebx
c0026ccc:	83 ec 08             	sub    $0x8,%esp
c0026ccf:	e8 12 b8 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0026cd4:	81 c3 68 9f 01 00    	add    $0x19f68,%ebx
  ASSERT(intr_get_level() == INTR_OFF);
c0026cda:	e8 7a b2 ff ff       	call   c0021f59 <intr_get_level>
c0026cdf:	85 c0                	test   %eax,%eax
c0026ce1:	75 14                	jne    c0026cf7 <input_full+0x2c>
  return intq_full(&buffer);
c0026ce3:	83 ec 0c             	sub    $0xc,%esp
c0026ce6:	8d 83 84 1b 00 00    	lea    0x1b84(%ebx),%eax
c0026cec:	50                   	push   %eax
c0026ced:	e8 bf 00 00 00       	call   c0026db1 <intq_full>
}
c0026cf2:	83 c4 18             	add    $0x18,%esp
c0026cf5:	5b                   	pop    %ebx
c0026cf6:	c3                   	ret    
  ASSERT(intr_get_level() == INTR_OFF);
c0026cf7:	83 ec 0c             	sub    $0xc,%esp
c0026cfa:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c0026d00:	50                   	push   %eax
c0026d01:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0026d07:	50                   	push   %eax
c0026d08:	8d 83 48 1e ff ff    	lea    -0xe1b8(%ebx),%eax
c0026d0e:	50                   	push   %eax
c0026d0f:	6a 64                	push   $0x64
c0026d11:	8d 83 bc 44 ff ff    	lea    -0xbb44(%ebx),%eax
c0026d17:	50                   	push   %eax
c0026d18:	e8 78 2b 00 00       	call   c0029895 <debug_panic>

c0026d1d <intq_init>:
static void wait(struct intq *q, struct thread **waiter);
static void signal(struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void intq_init(struct intq *q)
{
c0026d1d:	56                   	push   %esi
c0026d1e:	53                   	push   %ebx
c0026d1f:	83 ec 10             	sub    $0x10,%esp
c0026d22:	e8 bf b7 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0026d27:	81 c3 15 9f 01 00    	add    $0x19f15,%ebx
c0026d2d:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  lock_init(&q->lock);
c0026d31:	56                   	push   %esi
c0026d32:	e8 cb c7 ff ff       	call   c0023502 <lock_init>
  q->not_full = q->not_empty = NULL;
c0026d37:	c7 46 38 00 00 00 00 	movl   $0x0,0x38(%esi)
c0026d3e:	c7 46 34 00 00 00 00 	movl   $0x0,0x34(%esi)
  q->head = q->tail = 0;
c0026d45:	c7 86 80 00 00 00 00 	movl   $0x0,0x80(%esi)
c0026d4c:	00 00 00 
c0026d4f:	c7 46 7c 00 00 00 00 	movl   $0x0,0x7c(%esi)
}
c0026d56:	83 c4 14             	add    $0x14,%esp
c0026d59:	5b                   	pop    %ebx
c0026d5a:	5e                   	pop    %esi
c0026d5b:	c3                   	ret    

c0026d5c <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool intq_empty(const struct intq *q)
{
c0026d5c:	56                   	push   %esi
c0026d5d:	53                   	push   %ebx
c0026d5e:	83 ec 04             	sub    $0x4,%esp
c0026d61:	e8 80 b7 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0026d66:	81 c3 d6 9e 01 00    	add    $0x19ed6,%ebx
c0026d6c:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT(intr_get_level() == INTR_OFF);
c0026d70:	e8 e4 b1 ff ff       	call   c0021f59 <intr_get_level>
c0026d75:	85 c0                	test   %eax,%eax
c0026d77:	75 12                	jne    c0026d8b <intq_empty+0x2f>
  return q->head == q->tail;
c0026d79:	8b 86 80 00 00 00    	mov    0x80(%esi),%eax
c0026d7f:	39 46 7c             	cmp    %eax,0x7c(%esi)
c0026d82:	0f 94 c0             	sete   %al
}
c0026d85:	83 c4 04             	add    $0x4,%esp
c0026d88:	5b                   	pop    %ebx
c0026d89:	5e                   	pop    %esi
c0026d8a:	c3                   	ret    
  ASSERT(intr_get_level() == INTR_OFF);
c0026d8b:	83 ec 0c             	sub    $0xc,%esp
c0026d8e:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c0026d94:	50                   	push   %eax
c0026d95:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0026d9b:	50                   	push   %eax
c0026d9c:	8d 83 94 1e ff ff    	lea    -0xe16c(%ebx),%eax
c0026da2:	50                   	push   %eax
c0026da3:	6a 14                	push   $0x14
c0026da5:	8d 83 ea 44 ff ff    	lea    -0xbb16(%ebx),%eax
c0026dab:	50                   	push   %eax
c0026dac:	e8 e4 2a 00 00       	call   c0029895 <debug_panic>

c0026db1 <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool intq_full(const struct intq *q)
{
c0026db1:	56                   	push   %esi
c0026db2:	53                   	push   %ebx
c0026db3:	83 ec 04             	sub    $0x4,%esp
c0026db6:	e8 2b b7 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0026dbb:	81 c3 81 9e 01 00    	add    $0x19e81,%ebx
c0026dc1:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT(intr_get_level() == INTR_OFF);
c0026dc5:	e8 8f b1 ff ff       	call   c0021f59 <intr_get_level>
c0026dca:	85 c0                	test   %eax,%eax
c0026dcc:	75 20                	jne    c0026dee <intq_full+0x3d>

/* Returns the position after POS within an intq. */
static int
next(int pos)
{
  return (pos + 1) % INTQ_BUFSIZE;
c0026dce:	8b 46 7c             	mov    0x7c(%esi),%eax
c0026dd1:	83 c0 01             	add    $0x1,%eax
c0026dd4:	99                   	cltd   
c0026dd5:	c1 ea 1a             	shr    $0x1a,%edx
c0026dd8:	01 d0                	add    %edx,%eax
c0026dda:	83 e0 3f             	and    $0x3f,%eax
c0026ddd:	29 d0                	sub    %edx,%eax
  return next(q->head) == q->tail;
c0026ddf:	3b 86 80 00 00 00    	cmp    0x80(%esi),%eax
c0026de5:	0f 94 c0             	sete   %al
}
c0026de8:	83 c4 04             	add    $0x4,%esp
c0026deb:	5b                   	pop    %ebx
c0026dec:	5e                   	pop    %esi
c0026ded:	c3                   	ret    
  ASSERT(intr_get_level() == INTR_OFF);
c0026dee:	83 ec 0c             	sub    $0xc,%esp
c0026df1:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c0026df7:	50                   	push   %eax
c0026df8:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0026dfe:	50                   	push   %eax
c0026dff:	8d 83 88 1e ff ff    	lea    -0xe178(%ebx),%eax
c0026e05:	50                   	push   %eax
c0026e06:	6a 1b                	push   $0x1b
c0026e08:	8d 83 ea 44 ff ff    	lea    -0xbb16(%ebx),%eax
c0026e0e:	50                   	push   %eax
c0026e0f:	e8 81 2a 00 00       	call   c0029895 <debug_panic>

c0026e14 <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait(struct intq *q UNUSED, struct thread **waiter)
{
c0026e14:	57                   	push   %edi
c0026e15:	56                   	push   %esi
c0026e16:	53                   	push   %ebx
c0026e17:	e8 ca b6 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0026e1c:	81 c3 20 9e 01 00    	add    $0x19e20,%ebx
c0026e22:	89 c6                	mov    %eax,%esi
c0026e24:	89 d7                	mov    %edx,%edi
  ASSERT(!intr_context());
c0026e26:	e8 24 b4 ff ff       	call   c002224f <intr_context>
c0026e2b:	84 c0                	test   %al,%al
c0026e2d:	75 3b                	jne    c0026e6a <wait+0x56>
  ASSERT(intr_get_level() == INTR_OFF);
c0026e2f:	e8 25 b1 ff ff       	call   c0021f59 <intr_get_level>
c0026e34:	85 c0                	test   %eax,%eax
c0026e36:	75 58                	jne    c0026e90 <wait+0x7c>
  ASSERT((waiter == &q->not_empty && intq_empty(q)) || (waiter == &q->not_full && intq_full(q)));
c0026e38:	8d 46 38             	lea    0x38(%esi),%eax
c0026e3b:	39 c7                	cmp    %eax,%edi
c0026e3d:	74 77                	je     c0026eb6 <wait+0xa2>
c0026e3f:	8d 46 34             	lea    0x34(%esi),%eax
c0026e42:	39 c7                	cmp    %eax,%edi
c0026e44:	0f 85 82 00 00 00    	jne    c0026ecc <wait+0xb8>
c0026e4a:	83 ec 0c             	sub    $0xc,%esp
c0026e4d:	56                   	push   %esi
c0026e4e:	e8 5e ff ff ff       	call   c0026db1 <intq_full>
c0026e53:	83 c4 10             	add    $0x10,%esp
c0026e56:	84 c0                	test   %al,%al
c0026e58:	74 72                	je     c0026ecc <wait+0xb8>

  *waiter = thread_current();
c0026e5a:	e8 e6 a1 ff ff       	call   c0021045 <thread_current>
c0026e5f:	89 07                	mov    %eax,(%edi)
  thread_block();
c0026e61:	e8 54 a7 ff ff       	call   c00215ba <thread_block>
}
c0026e66:	5b                   	pop    %ebx
c0026e67:	5e                   	pop    %esi
c0026e68:	5f                   	pop    %edi
c0026e69:	c3                   	ret    
  ASSERT(!intr_context());
c0026e6a:	83 ec 0c             	sub    $0xc,%esp
c0026e6d:	8d 83 ce 33 ff ff    	lea    -0xcc32(%ebx),%eax
c0026e73:	50                   	push   %eax
c0026e74:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0026e7a:	50                   	push   %eax
c0026e7b:	8d 83 74 1e ff ff    	lea    -0xe18c(%ebx),%eax
c0026e81:	50                   	push   %eax
c0026e82:	6a 55                	push   $0x55
c0026e84:	8d 83 ea 44 ff ff    	lea    -0xbb16(%ebx),%eax
c0026e8a:	50                   	push   %eax
c0026e8b:	e8 05 2a 00 00       	call   c0029895 <debug_panic>
  ASSERT(intr_get_level() == INTR_OFF);
c0026e90:	83 ec 0c             	sub    $0xc,%esp
c0026e93:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c0026e99:	50                   	push   %eax
c0026e9a:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0026ea0:	50                   	push   %eax
c0026ea1:	8d 83 74 1e ff ff    	lea    -0xe18c(%ebx),%eax
c0026ea7:	50                   	push   %eax
c0026ea8:	6a 56                	push   $0x56
c0026eaa:	8d 83 ea 44 ff ff    	lea    -0xbb16(%ebx),%eax
c0026eb0:	50                   	push   %eax
c0026eb1:	e8 df 29 00 00       	call   c0029895 <debug_panic>
  ASSERT((waiter == &q->not_empty && intq_empty(q)) || (waiter == &q->not_full && intq_full(q)));
c0026eb6:	83 ec 0c             	sub    $0xc,%esp
c0026eb9:	56                   	push   %esi
c0026eba:	e8 9d fe ff ff       	call   c0026d5c <intq_empty>
c0026ebf:	83 c4 10             	add    $0x10,%esp
c0026ec2:	84 c0                	test   %al,%al
c0026ec4:	0f 84 75 ff ff ff    	je     c0026e3f <wait+0x2b>
c0026eca:	eb 8e                	jmp    c0026e5a <wait+0x46>
c0026ecc:	83 ec 0c             	sub    $0xc,%esp
c0026ecf:	8d 83 00 45 ff ff    	lea    -0xbb00(%ebx),%eax
c0026ed5:	50                   	push   %eax
c0026ed6:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0026edc:	50                   	push   %eax
c0026edd:	8d 83 74 1e ff ff    	lea    -0xe18c(%ebx),%eax
c0026ee3:	50                   	push   %eax
c0026ee4:	6a 57                	push   $0x57
c0026ee6:	8d 83 ea 44 ff ff    	lea    -0xbb16(%ebx),%eax
c0026eec:	50                   	push   %eax
c0026eed:	e8 a3 29 00 00       	call   c0029895 <debug_panic>

c0026ef2 <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal(struct intq *q UNUSED, struct thread **waiter)
{
c0026ef2:	57                   	push   %edi
c0026ef3:	56                   	push   %esi
c0026ef4:	53                   	push   %ebx
c0026ef5:	e8 ec b5 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0026efa:	81 c3 42 9d 01 00    	add    $0x19d42,%ebx
c0026f00:	89 c7                	mov    %eax,%edi
c0026f02:	89 d6                	mov    %edx,%esi
  ASSERT(intr_get_level() == INTR_OFF);
c0026f04:	e8 50 b0 ff ff       	call   c0021f59 <intr_get_level>
c0026f09:	85 c0                	test   %eax,%eax
c0026f0b:	75 3a                	jne    c0026f47 <signal+0x55>
  ASSERT((waiter == &q->not_empty && !intq_empty(q)) || (waiter == &q->not_full && !intq_full(q)));
c0026f0d:	8d 47 38             	lea    0x38(%edi),%eax
c0026f10:	39 c6                	cmp    %eax,%esi
c0026f12:	74 59                	je     c0026f6d <signal+0x7b>
c0026f14:	8d 47 34             	lea    0x34(%edi),%eax
c0026f17:	39 c6                	cmp    %eax,%esi
c0026f19:	75 64                	jne    c0026f7f <signal+0x8d>
c0026f1b:	83 ec 0c             	sub    $0xc,%esp
c0026f1e:	57                   	push   %edi
c0026f1f:	e8 8d fe ff ff       	call   c0026db1 <intq_full>
c0026f24:	83 c4 10             	add    $0x10,%esp
c0026f27:	84 c0                	test   %al,%al
c0026f29:	75 54                	jne    c0026f7f <signal+0x8d>

  if (*waiter != NULL)
c0026f2b:	8b 06                	mov    (%esi),%eax
c0026f2d:	85 c0                	test   %eax,%eax
c0026f2f:	74 12                	je     c0026f43 <signal+0x51>
  {
    thread_unblock(*waiter);
c0026f31:	83 ec 0c             	sub    $0xc,%esp
c0026f34:	50                   	push   %eax
c0026f35:	e8 2c a0 ff ff       	call   c0020f66 <thread_unblock>
    *waiter = NULL;
c0026f3a:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
c0026f40:	83 c4 10             	add    $0x10,%esp
  }
}
c0026f43:	5b                   	pop    %ebx
c0026f44:	5e                   	pop    %esi
c0026f45:	5f                   	pop    %edi
c0026f46:	c3                   	ret    
  ASSERT(intr_get_level() == INTR_OFF);
c0026f47:	83 ec 0c             	sub    $0xc,%esp
c0026f4a:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c0026f50:	50                   	push   %eax
c0026f51:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0026f57:	50                   	push   %eax
c0026f58:	8d 83 6c 1e ff ff    	lea    -0xe194(%ebx),%eax
c0026f5e:	50                   	push   %eax
c0026f5f:	6a 64                	push   $0x64
c0026f61:	8d 83 ea 44 ff ff    	lea    -0xbb16(%ebx),%eax
c0026f67:	50                   	push   %eax
c0026f68:	e8 28 29 00 00       	call   c0029895 <debug_panic>
  ASSERT((waiter == &q->not_empty && !intq_empty(q)) || (waiter == &q->not_full && !intq_full(q)));
c0026f6d:	83 ec 0c             	sub    $0xc,%esp
c0026f70:	57                   	push   %edi
c0026f71:	e8 e6 fd ff ff       	call   c0026d5c <intq_empty>
c0026f76:	83 c4 10             	add    $0x10,%esp
c0026f79:	84 c0                	test   %al,%al
c0026f7b:	74 ae                	je     c0026f2b <signal+0x39>
c0026f7d:	eb 95                	jmp    c0026f14 <signal+0x22>
c0026f7f:	83 ec 0c             	sub    $0xc,%esp
c0026f82:	8d 83 58 45 ff ff    	lea    -0xbaa8(%ebx),%eax
c0026f88:	50                   	push   %eax
c0026f89:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0026f8f:	50                   	push   %eax
c0026f90:	8d 83 6c 1e ff ff    	lea    -0xe194(%ebx),%eax
c0026f96:	50                   	push   %eax
c0026f97:	6a 65                	push   $0x65
c0026f99:	8d 83 ea 44 ff ff    	lea    -0xbb16(%ebx),%eax
c0026f9f:	50                   	push   %eax
c0026fa0:	e8 f0 28 00 00       	call   c0029895 <debug_panic>

c0026fa5 <intq_getc>:
{
c0026fa5:	57                   	push   %edi
c0026fa6:	56                   	push   %esi
c0026fa7:	53                   	push   %ebx
c0026fa8:	e8 39 b5 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0026fad:	81 c3 8f 9c 01 00    	add    $0x19c8f,%ebx
c0026fb3:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT(intr_get_level() == INTR_OFF);
c0026fb7:	e8 9d af ff ff       	call   c0021f59 <intr_get_level>
c0026fbc:	85 c0                	test   %eax,%eax
c0026fbe:	75 3b                	jne    c0026ffb <intq_getc+0x56>
    wait(q, &q->not_empty);
c0026fc0:	8d 7e 38             	lea    0x38(%esi),%edi
  while (intq_empty(q))
c0026fc3:	83 ec 0c             	sub    $0xc,%esp
c0026fc6:	56                   	push   %esi
c0026fc7:	e8 90 fd ff ff       	call   c0026d5c <intq_empty>
c0026fcc:	83 c4 10             	add    $0x10,%esp
c0026fcf:	84 c0                	test   %al,%al
c0026fd1:	74 74                	je     c0027047 <intq_getc+0xa2>
    ASSERT(!intr_context());
c0026fd3:	e8 77 b2 ff ff       	call   c002224f <intr_context>
c0026fd8:	84 c0                	test   %al,%al
c0026fda:	75 45                	jne    c0027021 <intq_getc+0x7c>
    lock_acquire(&q->lock);
c0026fdc:	83 ec 0c             	sub    $0xc,%esp
c0026fdf:	56                   	push   %esi
c0026fe0:	e8 dd c5 ff ff       	call   c00235c2 <lock_acquire>
    wait(q, &q->not_empty);
c0026fe5:	89 fa                	mov    %edi,%edx
c0026fe7:	89 f0                	mov    %esi,%eax
c0026fe9:	e8 26 fe ff ff       	call   c0026e14 <wait>
    lock_release(&q->lock);
c0026fee:	89 34 24             	mov    %esi,(%esp)
c0026ff1:	e8 a0 c7 ff ff       	call   c0023796 <lock_release>
c0026ff6:	83 c4 10             	add    $0x10,%esp
c0026ff9:	eb c8                	jmp    c0026fc3 <intq_getc+0x1e>
  ASSERT(intr_get_level() == INTR_OFF);
c0026ffb:	83 ec 0c             	sub    $0xc,%esp
c0026ffe:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c0027004:	50                   	push   %eax
c0027005:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002700b:	50                   	push   %eax
c002700c:	8d 83 7c 1e ff ff    	lea    -0xe184(%ebx),%eax
c0027012:	50                   	push   %eax
c0027013:	6a 27                	push   $0x27
c0027015:	8d 83 ea 44 ff ff    	lea    -0xbb16(%ebx),%eax
c002701b:	50                   	push   %eax
c002701c:	e8 74 28 00 00       	call   c0029895 <debug_panic>
    ASSERT(!intr_context());
c0027021:	83 ec 0c             	sub    $0xc,%esp
c0027024:	8d 83 ce 33 ff ff    	lea    -0xcc32(%ebx),%eax
c002702a:	50                   	push   %eax
c002702b:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0027031:	50                   	push   %eax
c0027032:	8d 83 7c 1e ff ff    	lea    -0xe184(%ebx),%eax
c0027038:	50                   	push   %eax
c0027039:	6a 2a                	push   $0x2a
c002703b:	8d 83 ea 44 ff ff    	lea    -0xbb16(%ebx),%eax
c0027041:	50                   	push   %eax
c0027042:	e8 4e 28 00 00       	call   c0029895 <debug_panic>
  byte = q->buf[q->tail];
c0027047:	8b 86 80 00 00 00    	mov    0x80(%esi),%eax
c002704d:	0f b6 5c 06 3c       	movzbl 0x3c(%esi,%eax,1),%ebx
  return (pos + 1) % INTQ_BUFSIZE;
c0027052:	83 c0 01             	add    $0x1,%eax
c0027055:	99                   	cltd   
c0027056:	c1 ea 1a             	shr    $0x1a,%edx
c0027059:	01 d0                	add    %edx,%eax
c002705b:	83 e0 3f             	and    $0x3f,%eax
c002705e:	29 d0                	sub    %edx,%eax
  q->tail = next(q->tail);
c0027060:	89 86 80 00 00 00    	mov    %eax,0x80(%esi)
  signal(q, &q->not_full);
c0027066:	8d 56 34             	lea    0x34(%esi),%edx
c0027069:	89 f0                	mov    %esi,%eax
c002706b:	e8 82 fe ff ff       	call   c0026ef2 <signal>
}
c0027070:	89 d8                	mov    %ebx,%eax
c0027072:	5b                   	pop    %ebx
c0027073:	5e                   	pop    %esi
c0027074:	5f                   	pop    %edi
c0027075:	c3                   	ret    

c0027076 <intq_putc>:
{
c0027076:	55                   	push   %ebp
c0027077:	57                   	push   %edi
c0027078:	56                   	push   %esi
c0027079:	53                   	push   %ebx
c002707a:	83 ec 0c             	sub    $0xc,%esp
c002707d:	e8 64 b4 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0027082:	81 c3 ba 9b 01 00    	add    $0x19bba,%ebx
c0027088:	8b 74 24 20          	mov    0x20(%esp),%esi
c002708c:	8b 6c 24 24          	mov    0x24(%esp),%ebp
  ASSERT(intr_get_level() == INTR_OFF);
c0027090:	e8 c4 ae ff ff       	call   c0021f59 <intr_get_level>
c0027095:	85 c0                	test   %eax,%eax
c0027097:	75 3b                	jne    c00270d4 <intq_putc+0x5e>
    wait(q, &q->not_full);
c0027099:	8d 7e 34             	lea    0x34(%esi),%edi
  while (intq_full(q))
c002709c:	83 ec 0c             	sub    $0xc,%esp
c002709f:	56                   	push   %esi
c00270a0:	e8 0c fd ff ff       	call   c0026db1 <intq_full>
c00270a5:	83 c4 10             	add    $0x10,%esp
c00270a8:	84 c0                	test   %al,%al
c00270aa:	74 74                	je     c0027120 <intq_putc+0xaa>
    ASSERT(!intr_context());
c00270ac:	e8 9e b1 ff ff       	call   c002224f <intr_context>
c00270b1:	84 c0                	test   %al,%al
c00270b3:	75 45                	jne    c00270fa <intq_putc+0x84>
    lock_acquire(&q->lock);
c00270b5:	83 ec 0c             	sub    $0xc,%esp
c00270b8:	56                   	push   %esi
c00270b9:	e8 04 c5 ff ff       	call   c00235c2 <lock_acquire>
    wait(q, &q->not_full);
c00270be:	89 fa                	mov    %edi,%edx
c00270c0:	89 f0                	mov    %esi,%eax
c00270c2:	e8 4d fd ff ff       	call   c0026e14 <wait>
    lock_release(&q->lock);
c00270c7:	89 34 24             	mov    %esi,(%esp)
c00270ca:	e8 c7 c6 ff ff       	call   c0023796 <lock_release>
c00270cf:	83 c4 10             	add    $0x10,%esp
c00270d2:	eb c8                	jmp    c002709c <intq_putc+0x26>
  ASSERT(intr_get_level() == INTR_OFF);
c00270d4:	83 ec 0c             	sub    $0xc,%esp
c00270d7:	8d 83 2d 33 ff ff    	lea    -0xccd3(%ebx),%eax
c00270dd:	50                   	push   %eax
c00270de:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00270e4:	50                   	push   %eax
c00270e5:	8d 83 60 1e ff ff    	lea    -0xe1a0(%ebx),%eax
c00270eb:	50                   	push   %eax
c00270ec:	6a 3b                	push   $0x3b
c00270ee:	8d 83 ea 44 ff ff    	lea    -0xbb16(%ebx),%eax
c00270f4:	50                   	push   %eax
c00270f5:	e8 9b 27 00 00       	call   c0029895 <debug_panic>
    ASSERT(!intr_context());
c00270fa:	83 ec 0c             	sub    $0xc,%esp
c00270fd:	8d 83 ce 33 ff ff    	lea    -0xcc32(%ebx),%eax
c0027103:	50                   	push   %eax
c0027104:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002710a:	50                   	push   %eax
c002710b:	8d 83 60 1e ff ff    	lea    -0xe1a0(%ebx),%eax
c0027111:	50                   	push   %eax
c0027112:	6a 3e                	push   $0x3e
c0027114:	8d 83 ea 44 ff ff    	lea    -0xbb16(%ebx),%eax
c002711a:	50                   	push   %eax
c002711b:	e8 75 27 00 00       	call   c0029895 <debug_panic>
  q->buf[q->head] = byte;
c0027120:	8b 46 7c             	mov    0x7c(%esi),%eax
c0027123:	89 e9                	mov    %ebp,%ecx
c0027125:	88 4c 06 3c          	mov    %cl,0x3c(%esi,%eax,1)
  return (pos + 1) % INTQ_BUFSIZE;
c0027129:	83 c0 01             	add    $0x1,%eax
c002712c:	99                   	cltd   
c002712d:	c1 ea 1a             	shr    $0x1a,%edx
c0027130:	01 d0                	add    %edx,%eax
c0027132:	83 e0 3f             	and    $0x3f,%eax
c0027135:	29 d0                	sub    %edx,%eax
  q->head = next(q->head);
c0027137:	89 46 7c             	mov    %eax,0x7c(%esi)
  signal(q, &q->not_empty);
c002713a:	8d 56 38             	lea    0x38(%esi),%edx
c002713d:	89 f0                	mov    %esi,%eax
c002713f:	e8 ae fd ff ff       	call   c0026ef2 <signal>
}
c0027144:	83 c4 0c             	add    $0xc,%esp
c0027147:	5b                   	pop    %ebx
c0027148:	5e                   	pop    %esi
c0027149:	5f                   	pop    %edi
c002714a:	5d                   	pop    %ebp
c002714b:	c3                   	ret    

c002714c <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time(void)
{
c002714c:	55                   	push   %ebp
c002714d:	57                   	push   %edi
c002714e:	56                   	push   %esi
c002714f:	53                   	push   %ebx
c0027150:	83 ec 0c             	sub    $0xc,%esp
c0027153:	e8 92 b3 00 00       	call   c00324ea <__x86.get_pc_thunk.ax>
c0027158:	05 e4 9a 01 00       	add    $0x19ae4,%eax
c002715d:	89 44 24 08          	mov    %eax,0x8(%esp)
  asm volatile("outb %b0, %w1"
c0027161:	bf 00 00 00 00       	mov    $0x0,%edi
c0027166:	bd 02 00 00 00       	mov    $0x2,%ebp
c002716b:	89 f8                	mov    %edi,%eax
c002716d:	e6 70                	out    %al,$0x70
  asm volatile("inb %w1, %b0"
c002716f:	e4 71                	in     $0x71,%al
c0027171:	89 c2                	mov    %eax,%edx
  asm volatile("outb %b0, %w1"
c0027173:	89 e8                	mov    %ebp,%eax
c0027175:	e6 70                	out    %al,$0x70
  asm volatile("inb %w1, %b0"
c0027177:	e4 71                	in     $0x71,%al
c0027179:	88 04 24             	mov    %al,(%esp)
  asm volatile("outb %b0, %w1"
c002717c:	b8 04 00 00 00       	mov    $0x4,%eax
c0027181:	e6 70                	out    %al,$0x70
  asm volatile("inb %w1, %b0"
c0027183:	e4 71                	in     $0x71,%al
c0027185:	88 44 24 07          	mov    %al,0x7(%esp)
  asm volatile("outb %b0, %w1"
c0027189:	b8 07 00 00 00       	mov    $0x7,%eax
c002718e:	e6 70                	out    %al,$0x70
  asm volatile("inb %w1, %b0"
c0027190:	e4 71                	in     $0x71,%al
c0027192:	88 44 24 06          	mov    %al,0x6(%esp)
  asm volatile("outb %b0, %w1"
c0027196:	b8 08 00 00 00       	mov    $0x8,%eax
c002719b:	e6 70                	out    %al,$0x70
  asm volatile("inb %w1, %b0"
c002719d:	e4 71                	in     $0x71,%al
c002719f:	88 44 24 05          	mov    %al,0x5(%esp)
  asm volatile("outb %b0, %w1"
c00271a3:	b8 09 00 00 00       	mov    $0x9,%eax
c00271a8:	e6 70                	out    %al,$0x70
  asm volatile("inb %w1, %b0"
c00271aa:	e4 71                	in     $0x71,%al
c00271ac:	89 c3                	mov    %eax,%ebx
  asm volatile("outb %b0, %w1"
c00271ae:	89 f8                	mov    %edi,%eax
c00271b0:	e6 70                	out    %al,$0x70
  asm volatile("inb %w1, %b0"
c00271b2:	e4 71                	in     $0x71,%al

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin(uint8_t x)
{
  return (x & 0x0f) + ((x >> 4) * 10);
c00271b4:	89 c1                	mov    %eax,%ecx
c00271b6:	c0 e9 04             	shr    $0x4,%cl
c00271b9:	0f b6 c9             	movzbl %cl,%ecx
c00271bc:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
c00271bf:	83 e0 0f             	and    $0xf,%eax
c00271c2:	8d 34 48             	lea    (%eax,%ecx,2),%esi
c00271c5:	89 d1                	mov    %edx,%ecx
c00271c7:	c0 e9 04             	shr    $0x4,%cl
c00271ca:	0f b6 c9             	movzbl %cl,%ecx
c00271cd:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
c00271d0:	83 e2 0f             	and    $0xf,%edx
c00271d3:	8d 04 42             	lea    (%edx,%eax,2),%eax
  } while (sec != bcd_to_bin(cmos_read(RTC_REG_SEC)));
c00271d6:	39 c6                	cmp    %eax,%esi
c00271d8:	75 91                	jne    c002716b <rtc_get_time+0x1f>
  return (x & 0x0f) + ((x >> 4) * 10);
c00271da:	89 d8                	mov    %ebx,%eax
c00271dc:	c0 e8 04             	shr    $0x4,%al
c00271df:	0f b6 c0             	movzbl %al,%eax
c00271e2:	8d 04 80             	lea    (%eax,%eax,4),%eax
c00271e5:	83 e3 0f             	and    $0xf,%ebx
c00271e8:	8d 04 43             	lea    (%ebx,%eax,2),%eax
    year += 100;
c00271eb:	8d 50 64             	lea    0x64(%eax),%edx
c00271ee:	83 f8 46             	cmp    $0x46,%eax
c00271f1:	0f 4c c2             	cmovl  %edx,%eax
  return (x & 0x0f) + ((x >> 4) * 10);
c00271f4:	0f b6 5c 24 05       	movzbl 0x5(%esp),%ebx
c00271f9:	89 da                	mov    %ebx,%edx
c00271fb:	c0 ea 04             	shr    $0x4,%dl
c00271fe:	0f b6 d2             	movzbl %dl,%edx
c0027201:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0027204:	89 d9                	mov    %ebx,%ecx
c0027206:	83 e1 0f             	and    $0xf,%ecx
c0027209:	8d 2c 51             	lea    (%ecx,%edx,2),%ebp
  year -= 70;
c002720c:	8d 78 ba             	lea    -0x46(%eax),%edi
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c002720f:	8d 50 bc             	lea    -0x44(%eax),%edx
c0027212:	83 e8 47             	sub    $0x47,%eax
c0027215:	0f 48 c2             	cmovs  %edx,%eax
c0027218:	c1 f8 02             	sar    $0x2,%eax
c002721b:	69 d7 6d 01 00 00    	imul   $0x16d,%edi,%edx
c0027221:	01 d0                	add    %edx,%eax
c0027223:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
  for (i = 1; i <= mon; i++)
c0027229:	85 ed                	test   %ebp,%ebp
c002722b:	7e 1c                	jle    c0027249 <rtc_get_time+0xfd>
c002722d:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c0027231:	8d 93 a4 1e ff ff    	lea    -0xe15c(%ebx),%edx
c0027237:	8d 1c aa             	lea    (%edx,%ebp,4),%ebx
    time += days_per_month[i - 1] * 24 * 60 * 60;
c002723a:	69 0a 80 51 01 00    	imul   $0x15180,(%edx),%ecx
c0027240:	01 c8                	add    %ecx,%eax
c0027242:	83 c2 04             	add    $0x4,%edx
  for (i = 1; i <= mon; i++)
c0027245:	39 da                	cmp    %ebx,%edx
c0027247:	75 f1                	jne    c002723a <rtc_get_time+0xee>
  if (mon > 2 && year % 4 == 0)
c0027249:	83 fd 02             	cmp    $0x2,%ebp
c002724c:	7e 0e                	jle    c002725c <rtc_get_time+0x110>
c002724e:	83 e7 03             	and    $0x3,%edi
    time += 24 * 60 * 60;
c0027251:	8d 90 80 51 01 00    	lea    0x15180(%eax),%edx
c0027257:	85 ff                	test   %edi,%edi
c0027259:	0f 44 c2             	cmove  %edx,%eax
  return (x & 0x0f) + ((x >> 4) * 10);
c002725c:	0f b6 5c 24 07       	movzbl 0x7(%esp),%ebx
c0027261:	89 da                	mov    %ebx,%edx
c0027263:	c0 ea 04             	shr    $0x4,%dl
c0027266:	0f b6 d2             	movzbl %dl,%edx
c0027269:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c002726c:	89 da                	mov    %ebx,%edx
c002726e:	83 e2 0f             	and    $0xf,%edx
c0027271:	8d 0c 4a             	lea    (%edx,%ecx,2),%ecx
  time += hour * 60 * 60;
c0027274:	69 c9 10 0e 00 00    	imul   $0xe10,%ecx,%ecx
  return (x & 0x0f) + ((x >> 4) * 10);
c002727a:	0f b6 14 24          	movzbl (%esp),%edx
c002727e:	c0 ea 04             	shr    $0x4,%dl
c0027281:	0f b6 d2             	movzbl %dl,%edx
c0027284:	8d 1c 92             	lea    (%edx,%edx,4),%ebx
c0027287:	8b 14 24             	mov    (%esp),%edx
c002728a:	83 e2 0f             	and    $0xf,%edx
c002728d:	8d 14 5a             	lea    (%edx,%ebx,2),%edx
  time += min * 60;
c0027290:	6b d2 3c             	imul   $0x3c,%edx,%edx
  time += sec;
c0027293:	01 d1                	add    %edx,%ecx
c0027295:	01 ce                	add    %ecx,%esi
  return (x & 0x0f) + ((x >> 4) * 10);
c0027297:	0f b6 5c 24 06       	movzbl 0x6(%esp),%ebx
c002729c:	89 da                	mov    %ebx,%edx
c002729e:	c0 ea 04             	shr    $0x4,%dl
c00272a1:	0f b6 d2             	movzbl %dl,%edx
c00272a4:	8d 0c 92             	lea    (%edx,%edx,4),%ecx
c00272a7:	89 da                	mov    %ebx,%edx
c00272a9:	83 e2 0f             	and    $0xf,%edx
  time += (mday - 1) * 24 * 60 * 60;
c00272ac:	8d 54 4a ff          	lea    -0x1(%edx,%ecx,2),%edx
c00272b0:	69 d2 80 51 01 00    	imul   $0x15180,%edx,%edx
  time += sec;
c00272b6:	01 d6                	add    %edx,%esi
c00272b8:	01 f0                	add    %esi,%eax
}
c00272ba:	83 c4 0c             	add    $0xc,%esp
c00272bd:	5b                   	pop    %ebx
c00272be:	5e                   	pop    %esi
c00272bf:	5f                   	pop    %edi
c00272c0:	5d                   	pop    %ebp
c00272c1:	c3                   	ret    

c00272c2 <shutdown_configure>:
}

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void shutdown_configure(enum shutdown_type type)
{
c00272c2:	e8 23 b2 00 00       	call   c00324ea <__x86.get_pc_thunk.ax>
c00272c7:	05 75 99 01 00       	add    $0x19975,%eax
  how = type;
c00272cc:	8b 54 24 04          	mov    0x4(%esp),%edx
c00272d0:	89 90 08 1c 00 00    	mov    %edx,0x1c08(%eax)
}
c00272d6:	c3                   	ret    

c00272d7 <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void shutdown_reboot(void)
{
c00272d7:	57                   	push   %edi
c00272d8:	56                   	push   %esi
c00272d9:	53                   	push   %ebx
c00272da:	e8 07 b2 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00272df:	81 c3 5d 99 01 00    	add    $0x1995d,%ebx
  printf("Rebooting...\n");
c00272e5:	83 ec 0c             	sub    $0xc,%esp
c00272e8:	8d 83 b1 45 ff ff    	lea    -0xba4f(%ebx),%eax
c00272ee:	50                   	push   %eax
c00272ef:	e8 7a 45 00 00       	call   c002b86e <puts>
c00272f4:	83 c4 10             	add    $0x10,%esp
  asm volatile("outb %b0, %w1"
c00272f7:	bf fe ff ff ff       	mov    $0xfffffffe,%edi
c00272fc:	eb 1f                	jmp    c002731d <shutdown_reboot+0x46>
      if ((inb(CONTROL_REG) & 0x02) == 0)
        break;
      timer_udelay(2);
    }

    timer_udelay(50);
c00272fe:	83 ec 08             	sub    $0x8,%esp
c0027301:	6a 00                	push   $0x0
c0027303:	6a 32                	push   $0x32
c0027305:	e8 39 da ff ff       	call   c0024d43 <timer_udelay>
c002730a:	89 f8                	mov    %edi,%eax
c002730c:	e6 64                	out    %al,$0x64

    /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
    outb(CONTROL_REG, 0xfe);
    timer_udelay(50);
c002730e:	83 c4 08             	add    $0x8,%esp
c0027311:	6a 00                	push   $0x0
c0027313:	6a 32                	push   $0x32
c0027315:	e8 29 da ff ff       	call   c0024d43 <timer_udelay>
  {
c002731a:	83 c4 10             	add    $0x10,%esp
  asm volatile("inb %w1, %b0"
c002731d:	e4 64                	in     $0x64,%al
      if ((inb(CONTROL_REG) & 0x02) == 0)
c002731f:	a8 02                	test   $0x2,%al
c0027321:	74 db                	je     c00272fe <shutdown_reboot+0x27>
      timer_udelay(2);
c0027323:	83 ec 08             	sub    $0x8,%esp
c0027326:	6a 00                	push   $0x0
c0027328:	6a 02                	push   $0x2
c002732a:	e8 14 da ff ff       	call   c0024d43 <timer_udelay>
c002732f:	83 c4 10             	add    $0x10,%esp
c0027332:	be ff ff 00 00       	mov    $0xffff,%esi
c0027337:	e4 64                	in     $0x64,%al
      if ((inb(CONTROL_REG) & 0x02) == 0)
c0027339:	a8 02                	test   $0x2,%al
c002733b:	74 c1                	je     c00272fe <shutdown_reboot+0x27>
      timer_udelay(2);
c002733d:	83 ec 08             	sub    $0x8,%esp
c0027340:	6a 00                	push   $0x0
c0027342:	6a 02                	push   $0x2
c0027344:	e8 fa d9 ff ff       	call   c0024d43 <timer_udelay>
    for (i = 0; i < 0x10000; i++)
c0027349:	83 c4 10             	add    $0x10,%esp
c002734c:	83 ee 01             	sub    $0x1,%esi
c002734f:	75 e6                	jne    c0027337 <shutdown_reboot+0x60>
c0027351:	eb ab                	jmp    c00272fe <shutdown_reboot+0x27>

c0027353 <shutdown_power_off>:
}

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void shutdown_power_off(void)
{
c0027353:	53                   	push   %ebx
c0027354:	83 ec 18             	sub    $0x18,%esp
c0027357:	e8 8a b1 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002735c:	81 c3 e0 98 01 00    	add    $0x198e0,%ebx
  const char s[] = "Shutdown";
c0027362:	c7 44 24 07 53 68 75 	movl   $0x74756853,0x7(%esp)
c0027369:	74 
c002736a:	c7 44 24 0b 64 6f 77 	movl   $0x6e776f64,0xb(%esp)
c0027371:	6e 
c0027372:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
  const char *p;

#ifdef FILESYS
  filesys_done();
c0027377:	e8 df 71 00 00       	call   c002e55b <filesys_done>

/* Print statistics about Pintos execution. */
static void
print_stats(void)
{
  timer_print_stats();
c002737c:	e8 f4 d9 ff ff       	call   c0024d75 <timer_print_stats>
  thread_print_stats();
c0027381:	e8 9c 9b ff ff       	call   c0020f22 <thread_print_stats>
#ifdef FILESYS
  block_print_stats();
c0027386:	e8 79 e5 ff ff       	call   c0025904 <block_print_stats>
#endif
  console_print_stats();
c002738b:	e8 6f 44 00 00       	call   c002b7ff <console_print_stats>
  kbd_print_stats();
c0027390:	e8 5b dc ff ff       	call   c0024ff0 <kbd_print_stats>
#ifdef USERPROG
  exception_print_stats();
c0027395:	e8 d0 59 00 00       	call   c002cd6a <exception_print_stats>
  printf("Powering off...\n");
c002739a:	83 ec 0c             	sub    $0xc,%esp
c002739d:	8d 83 be 45 ff ff    	lea    -0xba42(%ebx),%eax
c00273a3:	50                   	push   %eax
c00273a4:	e8 c5 44 00 00       	call   c002b86e <puts>
  serial_flush();
c00273a9:	e8 ec e1 ff ff       	call   c002559a <serial_flush>
  asm volatile("outw %w0, %w1"
c00273ae:	b8 00 20 00 00       	mov    $0x2000,%eax
c00273b3:	ba 04 b0 ff ff       	mov    $0xffffb004,%edx
c00273b8:	66 ef                	out    %ax,(%dx)
  for (p = s; *p != '\0'; p++)
c00273ba:	0f b6 44 24 17       	movzbl 0x17(%esp),%eax
c00273bf:	83 c4 10             	add    $0x10,%esp
c00273c2:	84 c0                	test   %al,%al
c00273c4:	74 14                	je     c00273da <shutdown_power_off+0x87>
c00273c6:	8d 4c 24 07          	lea    0x7(%esp),%ecx
  asm volatile("outb %b0, %w1"
c00273ca:	ba 00 89 ff ff       	mov    $0xffff8900,%edx
c00273cf:	ee                   	out    %al,(%dx)
c00273d0:	83 c1 01             	add    $0x1,%ecx
c00273d3:	0f b6 01             	movzbl (%ecx),%eax
c00273d6:	84 c0                	test   %al,%al
c00273d8:	75 f5                	jne    c00273cf <shutdown_power_off+0x7c>
c00273da:	b8 31 00 00 00       	mov    $0x31,%eax
c00273df:	ba 01 05 00 00       	mov    $0x501,%edx
c00273e4:	ee                   	out    %al,(%dx)
  asm volatile("cli; hlt"
c00273e5:	fa                   	cli    
c00273e6:	f4                   	hlt    
  printf("still running...\n");
c00273e7:	83 ec 0c             	sub    $0xc,%esp
c00273ea:	8d 83 ce 45 ff ff    	lea    -0xba32(%ebx),%eax
c00273f0:	50                   	push   %eax
c00273f1:	e8 78 44 00 00       	call   c002b86e <puts>
c00273f6:	83 c4 10             	add    $0x10,%esp
c00273f9:	eb fe                	jmp    c00273f9 <shutdown_power_off+0xa6>

c00273fb <shutdown>:
{
c00273fb:	83 ec 0c             	sub    $0xc,%esp
c00273fe:	e8 e7 b0 00 00       	call   c00324ea <__x86.get_pc_thunk.ax>
c0027403:	05 39 98 01 00       	add    $0x19839,%eax
  switch (how)
c0027408:	8b 80 08 1c 00 00    	mov    0x1c08(%eax),%eax
c002740e:	83 f8 01             	cmp    $0x1,%eax
c0027411:	74 09                	je     c002741c <shutdown+0x21>
c0027413:	83 f8 02             	cmp    $0x2,%eax
c0027416:	74 09                	je     c0027421 <shutdown+0x26>
}
c0027418:	83 c4 0c             	add    $0xc,%esp
c002741b:	c3                   	ret    
    shutdown_power_off();
c002741c:	e8 32 ff ff ff       	call   c0027353 <shutdown_power_off>
    shutdown_reboot();
c0027421:	e8 b1 fe ff ff       	call   c00272d7 <shutdown_reboot>

c0027426 <speaker_off>:
}

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void speaker_off(void)
{
c0027426:	53                   	push   %ebx
c0027427:	83 ec 08             	sub    $0x8,%esp
c002742a:	e8 b7 b0 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002742f:	81 c3 0d 98 01 00    	add    $0x1980d,%ebx
  enum intr_level old_level = intr_disable();
c0027435:	e8 71 ab ff ff       	call   c0021fab <intr_disable>
c002743a:	89 c2                	mov    %eax,%edx
  asm volatile("inb %w1, %b0"
c002743c:	e4 61                	in     $0x61,%al
  asm volatile("outb %b0, %w1"
c002743e:	83 e0 fc             	and    $0xfffffffc,%eax
c0027441:	e6 61                	out    %al,$0x61
  outb(SPEAKER_PORT_GATE, inb(SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
  intr_set_level(old_level);
c0027443:	83 ec 0c             	sub    $0xc,%esp
c0027446:	52                   	push   %edx
c0027447:	e8 66 ab ff ff       	call   c0021fb2 <intr_set_level>
}
c002744c:	83 c4 18             	add    $0x18,%esp
c002744f:	5b                   	pop    %ebx
c0027450:	c3                   	ret    

c0027451 <speaker_on>:
{
c0027451:	57                   	push   %edi
c0027452:	56                   	push   %esi
c0027453:	53                   	push   %ebx
c0027454:	e8 8d b0 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0027459:	81 c3 e3 97 01 00    	add    $0x197e3,%ebx
c002745f:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (frequency >= 20 && frequency <= 20000)
c0027463:	8d 46 ec             	lea    -0x14(%esi),%eax
c0027466:	3d 0c 4e 00 00       	cmp    $0x4e0c,%eax
c002746b:	76 09                	jbe    c0027476 <speaker_on+0x25>
    speaker_off();
c002746d:	e8 b4 ff ff ff       	call   c0027426 <speaker_off>
}
c0027472:	5b                   	pop    %ebx
c0027473:	5e                   	pop    %esi
c0027474:	5f                   	pop    %edi
c0027475:	c3                   	ret    
    enum intr_level old_level = intr_disable();
c0027476:	e8 30 ab ff ff       	call   c0021fab <intr_disable>
c002747b:	89 c7                	mov    %eax,%edi
    pit_configure_channel(2, 3, frequency);
c002747d:	83 ec 04             	sub    $0x4,%esp
c0027480:	56                   	push   %esi
c0027481:	6a 03                	push   $0x3
c0027483:	6a 02                	push   $0x2
c0027485:	e8 4e d3 ff ff       	call   c00247d8 <pit_configure_channel>
  asm volatile("inb %w1, %b0"
c002748a:	e4 61                	in     $0x61,%al
    outb(SPEAKER_PORT_GATE, inb(SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c002748c:	83 c8 03             	or     $0x3,%eax
  asm volatile("outb %b0, %w1"
c002748f:	e6 61                	out    %al,$0x61
    intr_set_level(old_level);
c0027491:	89 3c 24             	mov    %edi,(%esp)
c0027494:	e8 19 ab ff ff       	call   c0021fb2 <intr_set_level>
c0027499:	83 c4 10             	add    $0x10,%esp
c002749c:	eb d4                	jmp    c0027472 <speaker_on+0x21>

c002749e <speaker_beep>:

/* Briefly beep the PC speaker. */
void speaker_beep(void)
{
c002749e:	53                   	push   %ebx
c002749f:	83 ec 08             	sub    $0x8,%esp
c00274a2:	e8 3f b0 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00274a7:	81 c3 95 97 01 00    	add    $0x19795,%ebx

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level() == INTR_ON)
c00274ad:	e8 a7 aa ff ff       	call   c0021f59 <intr_get_level>
c00274b2:	83 f8 01             	cmp    $0x1,%eax
c00274b5:	74 05                	je     c00274bc <speaker_beep+0x1e>
  {
    speaker_on(440);
    timer_msleep(250);
    speaker_off();
  }
}
c00274b7:	83 c4 08             	add    $0x8,%esp
c00274ba:	5b                   	pop    %ebx
c00274bb:	c3                   	ret    
    speaker_on(440);
c00274bc:	83 ec 0c             	sub    $0xc,%esp
c00274bf:	68 b8 01 00 00       	push   $0x1b8
c00274c4:	e8 88 ff ff ff       	call   c0027451 <speaker_on>
    timer_msleep(250);
c00274c9:	83 c4 08             	add    $0x8,%esp
c00274cc:	6a 00                	push   $0x0
c00274ce:	68 fa 00 00 00       	push   $0xfa
c00274d3:	e8 07 d8 ff ff       	call   c0024cdf <timer_msleep>
    speaker_off();
c00274d8:	e8 49 ff ff ff       	call   c0027426 <speaker_off>
c00274dd:	83 c4 10             	add    $0x10,%esp
}
c00274e0:	eb d5                	jmp    c00274b7 <speaker_beep+0x19>

c00274e2 <debug_backtrace>:
/* Prints the call stack, that is, a list of addresses, one in
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void debug_backtrace(void)
{
c00274e2:	55                   	push   %ebp
c00274e3:	89 e5                	mov    %esp,%ebp
c00274e5:	57                   	push   %edi
c00274e6:	56                   	push   %esi
c00274e7:	53                   	push   %ebx
c00274e8:	83 ec 14             	sub    $0x14,%esp
c00274eb:	e8 f6 af 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00274f0:	81 c3 4c 97 01 00    	add    $0x1974c,%ebx
  static bool explained;
  void **frame;

  printf("Call stack: %p", __builtin_return_address(0));
c00274f6:	ff 75 04             	pushl  0x4(%ebp)
c00274f9:	8d 83 df 45 ff ff    	lea    -0xba21(%ebx),%eax
c00274ff:	50                   	push   %eax
c0027500:	e8 f9 05 00 00       	call   c0027afe <printf>
  for (frame = __builtin_frame_address(1);
c0027505:	8b 75 00             	mov    0x0(%ebp),%esi
c0027508:	83 c4 10             	add    $0x10,%esp
c002750b:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0027511:	76 29                	jbe    c002753c <debug_backtrace+0x5a>
       (uintptr_t)frame >= 0x1000 && frame[0] != NULL;
c0027513:	83 3e 00             	cmpl   $0x0,(%esi)
c0027516:	74 24                	je     c002753c <debug_backtrace+0x5a>
       frame = frame[0])
    printf(" %p", frame[1]);
c0027518:	8d bb ea 45 ff ff    	lea    -0xba16(%ebx),%edi
c002751e:	83 ec 08             	sub    $0x8,%esp
c0027521:	ff 76 04             	pushl  0x4(%esi)
c0027524:	57                   	push   %edi
c0027525:	e8 d4 05 00 00       	call   c0027afe <printf>
       frame = frame[0])
c002752a:	8b 36                	mov    (%esi),%esi
  for (frame = __builtin_frame_address(1);
c002752c:	83 c4 10             	add    $0x10,%esp
c002752f:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0027535:	76 05                	jbe    c002753c <debug_backtrace+0x5a>
       (uintptr_t)frame >= 0x1000 && frame[0] != NULL;
c0027537:	83 3e 00             	cmpl   $0x0,(%esi)
c002753a:	75 e2                	jne    c002751e <debug_backtrace+0x3c>
  printf(".\n");
c002753c:	83 ec 0c             	sub    $0xc,%esp
c002753f:	8d 83 83 41 ff ff    	lea    -0xbe7d(%ebx),%eax
c0027545:	50                   	push   %eax
c0027546:	e8 23 43 00 00       	call   c002b86e <puts>

  if (!explained)
c002754b:	83 c4 10             	add    $0x10,%esp
c002754e:	80 bb 0c 1c 00 00 00 	cmpb   $0x0,0x1c0c(%ebx)
c0027555:	74 08                	je     c002755f <debug_backtrace+0x7d>
    explained = true;
    printf("The `backtrace' program can make call stacks useful.\n"
           "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
           "of the Pintos documentation for more information.\n");
  }
}
c0027557:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002755a:	5b                   	pop    %ebx
c002755b:	5e                   	pop    %esi
c002755c:	5f                   	pop    %edi
c002755d:	5d                   	pop    %ebp
c002755e:	c3                   	ret    
    explained = true;
c002755f:	c6 83 0c 1c 00 00 01 	movb   $0x1,0x1c0c(%ebx)
    printf("The `backtrace' program can make call stacks useful.\n"
c0027566:	83 ec 0c             	sub    $0xc,%esp
c0027569:	8d 83 f0 45 ff ff    	lea    -0xba10(%ebx),%eax
c002756f:	50                   	push   %eax
c0027570:	e8 f9 42 00 00       	call   c002b86e <puts>
c0027575:	83 c4 10             	add    $0x10,%esp
}
c0027578:	eb dd                	jmp    c0027557 <debug_backtrace+0x75>

c002757a <random_init>:
  *b = t;
}

/* Initializes or reinitializes the PRNG with the given SEED. */
void random_init(unsigned seed)
{
c002757a:	55                   	push   %ebp
c002757b:	57                   	push   %edi
c002757c:	56                   	push   %esi
c002757d:	53                   	push   %ebx
c002757e:	e8 77 af 00 00       	call   c00324fa <__x86.get_pc_thunk.cx>
c0027583:	81 c1 b9 96 01 00    	add    $0x196b9,%ecx
  uint8_t *seedp = (uint8_t *)&seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++)
c0027589:	b8 00 00 00 00       	mov    $0x0,%eax
    s[i] = i;
c002758e:	88 84 08 44 1c 00 00 	mov    %al,0x1c44(%eax,%ecx,1)
  for (i = 0; i < 256; i++)
c0027595:	83 c0 01             	add    $0x1,%eax
c0027598:	3d 00 01 00 00       	cmp    $0x100,%eax
c002759d:	75 ef                	jne    c002758e <random_init+0x14>
  for (i = j = 0; i < 256; i++)
c002759f:	bd 00 00 00 00       	mov    $0x0,%ebp
c00275a4:	b8 00 00 00 00       	mov    $0x0,%eax
  {
    j += s[i] + seedp[i % sizeof seed];
    swap_byte(s + i, s + j);
c00275a9:	8d b9 44 1c 00 00    	lea    0x1c44(%ecx),%edi
    j += s[i] + seedp[i % sizeof seed];
c00275af:	89 c2                	mov    %eax,%edx
c00275b1:	83 e2 03             	and    $0x3,%edx
c00275b4:	0f b6 b4 08 44 1c 00 	movzbl 0x1c44(%eax,%ecx,1),%esi
c00275bb:	00 
c00275bc:	89 f3                	mov    %esi,%ebx
c00275be:	02 5c 14 14          	add    0x14(%esp,%edx,1),%bl
c00275c2:	89 da                	mov    %ebx,%edx
c00275c4:	01 d5                	add    %edx,%ebp
    swap_byte(s + i, s + j);
c00275c6:	89 eb                	mov    %ebp,%ebx
c00275c8:	0f b6 d3             	movzbl %bl,%edx
c00275cb:	01 fa                	add    %edi,%edx
  *a = *b;
c00275cd:	0f b6 1a             	movzbl (%edx),%ebx
c00275d0:	88 9c 08 44 1c 00 00 	mov    %bl,0x1c44(%eax,%ecx,1)
  *b = t;
c00275d7:	89 f3                	mov    %esi,%ebx
c00275d9:	88 1a                	mov    %bl,(%edx)
  for (i = j = 0; i < 256; i++)
c00275db:	83 c0 01             	add    $0x1,%eax
c00275de:	3d 00 01 00 00       	cmp    $0x100,%eax
c00275e3:	75 ca                	jne    c00275af <random_init+0x35>
  }

  s_i = s_j = 0;
c00275e5:	c6 81 25 1c 00 00 00 	movb   $0x0,0x1c25(%ecx)
c00275ec:	c6 81 26 1c 00 00 00 	movb   $0x0,0x1c26(%ecx)
  inited = true;
c00275f3:	c6 81 24 1c 00 00 01 	movb   $0x1,0x1c24(%ecx)
}
c00275fa:	5b                   	pop    %ebx
c00275fb:	5e                   	pop    %esi
c00275fc:	5f                   	pop    %edi
c00275fd:	5d                   	pop    %ebp
c00275fe:	c3                   	ret    

c00275ff <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void random_bytes(void *buf_, size_t size)
{
c00275ff:	55                   	push   %ebp
c0027600:	57                   	push   %edi
c0027601:	56                   	push   %esi
c0027602:	53                   	push   %ebx
c0027603:	83 ec 10             	sub    $0x10,%esp
c0027606:	e8 df ae 00 00       	call   c00324ea <__x86.get_pc_thunk.ax>
c002760b:	05 31 96 01 00       	add    $0x19631,%eax
c0027610:	89 44 24 0c          	mov    %eax,0xc(%esp)
  uint8_t *buf;

  if (!inited)
c0027614:	80 b8 24 1c 00 00 00 	cmpb   $0x0,0x1c24(%eax)
c002761b:	74 31                	je     c002764e <random_bytes+0x4f>
    random_init(0);

  for (buf = buf_; size-- > 0; buf++)
c002761d:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0027622:	0f 84 95 00 00 00    	je     c00276bd <random_bytes+0xbe>
c0027628:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002762c:	0f b6 87 25 1c 00 00 	movzbl 0x1c25(%edi),%eax
c0027633:	88 44 24 03          	mov    %al,0x3(%esp)
c0027637:	bb 00 00 00 00       	mov    $0x0,%ebx
c002763c:	0f b6 87 26 1c 00 00 	movzbl 0x1c26(%edi),%eax
c0027643:	8d 68 01             	lea    0x1(%eax),%ebp
  {
    uint8_t s_k;

    s_i++;
    s_j += s[s_i];
c0027646:	8d 87 44 1c 00 00    	lea    0x1c44(%edi),%eax
c002764c:	eb 0e                	jmp    c002765c <random_bytes+0x5d>
    random_init(0);
c002764e:	6a 00                	push   $0x0
c0027650:	e8 25 ff ff ff       	call   c002757a <random_init>
c0027655:	83 c4 04             	add    $0x4,%esp
c0027658:	eb c3                	jmp    c002761d <random_bytes+0x1e>
c002765a:	89 d3                	mov    %edx,%ebx
c002765c:	8d 54 1d 00          	lea    0x0(%ebp,%ebx,1),%edx
    s_j += s[s_i];
c0027660:	0f b6 fa             	movzbl %dl,%edi
c0027663:	0f b6 4c 24 03       	movzbl 0x3(%esp),%ecx
c0027668:	02 0c 38             	add    (%eax,%edi,1),%cl
c002766b:	88 4c 24 03          	mov    %cl,0x3(%esp)
    swap_byte(s + s_i, s + s_j);
c002766f:	0f b6 f1             	movzbl %cl,%esi
c0027672:	89 74 24 08          	mov    %esi,0x8(%esp)
c0027676:	01 c6                	add    %eax,%esi
c0027678:	89 7c 24 04          	mov    %edi,0x4(%esp)
c002767c:	01 c7                	add    %eax,%edi
  uint8_t t = *a;
c002767e:	0f b6 0f             	movzbl (%edi),%ecx
  *a = *b;
c0027681:	0f b6 16             	movzbl (%esi),%edx
c0027684:	88 17                	mov    %dl,(%edi)
  *b = t;
c0027686:	88 0e                	mov    %cl,(%esi)

    s_k = s[s_i] + s[s_j];
c0027688:	8b 7c 24 04          	mov    0x4(%esp),%edi
c002768c:	02 0c 38             	add    (%eax,%edi,1),%cl
    *buf = s[s_k];
c002768f:	0f b6 c9             	movzbl %cl,%ecx
c0027692:	0f b6 14 08          	movzbl (%eax,%ecx,1),%edx
c0027696:	8b 74 24 24          	mov    0x24(%esp),%esi
c002769a:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
c002769d:	8d 53 01             	lea    0x1(%ebx),%edx
  for (buf = buf_; size-- > 0; buf++)
c00276a0:	3b 54 24 28          	cmp    0x28(%esp),%edx
c00276a4:	75 b4                	jne    c002765a <random_bytes+0x5b>
c00276a6:	01 eb                	add    %ebp,%ebx
c00276a8:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c00276ac:	88 9f 26 1c 00 00    	mov    %bl,0x1c26(%edi)
c00276b2:	0f b6 44 24 03       	movzbl 0x3(%esp),%eax
c00276b7:	88 87 25 1c 00 00    	mov    %al,0x1c25(%edi)
  }
}
c00276bd:	83 c4 10             	add    $0x10,%esp
c00276c0:	5b                   	pop    %ebx
c00276c1:	5e                   	pop    %esi
c00276c2:	5f                   	pop    %edi
c00276c3:	5d                   	pop    %ebp
c00276c4:	c3                   	ret    

c00276c5 <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong(void)
{
c00276c5:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes(&ul, sizeof ul);
c00276c8:	6a 04                	push   $0x4
c00276ca:	8d 44 24 10          	lea    0x10(%esp),%eax
c00276ce:	50                   	push   %eax
c00276cf:	e8 2b ff ff ff       	call   c00275ff <random_bytes>
  return ul;
}
c00276d4:	8b 44 24 14          	mov    0x14(%esp),%eax
c00276d8:	83 c4 18             	add    $0x18,%esp
c00276db:	c3                   	ret    

c00276dc <vsnprintf_helper>:
}

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper(char ch, void *aux_)
{
c00276dc:	53                   	push   %ebx
c00276dd:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c00276e1:	8b 44 24 0c          	mov    0xc(%esp),%eax
  struct vsnprintf_aux *aux = aux_;

  if (aux->length++ < aux->max_length)
c00276e5:	8b 50 04             	mov    0x4(%eax),%edx
c00276e8:	8d 4a 01             	lea    0x1(%edx),%ecx
c00276eb:	89 48 04             	mov    %ecx,0x4(%eax)
c00276ee:	3b 50 08             	cmp    0x8(%eax),%edx
c00276f1:	7d 09                	jge    c00276fc <vsnprintf_helper+0x20>
    *aux->p++ = ch;
c00276f3:	8b 10                	mov    (%eax),%edx
c00276f5:	8d 4a 01             	lea    0x1(%edx),%ecx
c00276f8:	89 08                	mov    %ecx,(%eax)
c00276fa:	88 1a                	mov    %bl,(%edx)
}
c00276fc:	5b                   	pop    %ebx
c00276fd:	c3                   	ret    

c00276fe <output_dup>:
}

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup(char ch, size_t cnt, void (*output)(char, void *), void *aux)
{
c00276fe:	55                   	push   %ebp
c00276ff:	57                   	push   %edi
c0027700:	56                   	push   %esi
c0027701:	53                   	push   %ebx
c0027702:	83 ec 0c             	sub    $0xc,%esp
c0027705:	8b 7c 24 20          	mov    0x20(%esp),%edi
  while (cnt-- > 0)
c0027709:	85 d2                	test   %edx,%edx
c002770b:	74 1a                	je     c0027727 <output_dup+0x29>
c002770d:	8d 5a ff             	lea    -0x1(%edx),%ebx
c0027710:	89 cd                	mov    %ecx,%ebp
    output(ch, aux);
c0027712:	0f be f0             	movsbl %al,%esi
c0027715:	83 ec 08             	sub    $0x8,%esp
c0027718:	57                   	push   %edi
c0027719:	56                   	push   %esi
c002771a:	ff d5                	call   *%ebp
  while (cnt-- > 0)
c002771c:	83 eb 01             	sub    $0x1,%ebx
c002771f:	83 c4 10             	add    $0x10,%esp
c0027722:	83 fb ff             	cmp    $0xffffffff,%ebx
c0027725:	75 ee                	jne    c0027715 <output_dup+0x17>
}
c0027727:	83 c4 0c             	add    $0xc,%esp
c002772a:	5b                   	pop    %ebx
c002772b:	5e                   	pop    %esi
c002772c:	5f                   	pop    %edi
c002772d:	5d                   	pop    %ebp
c002772e:	c3                   	ret    

c002772f <format_integer>:
{
c002772f:	55                   	push   %ebp
c0027730:	57                   	push   %edi
c0027731:	56                   	push   %esi
c0027732:	53                   	push   %ebx
c0027733:	83 ec 7c             	sub    $0x7c,%esp
c0027736:	e8 ab ad 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002773b:	81 c3 01 95 01 00    	add    $0x19501,%ebx
c0027741:	89 c6                	mov    %eax,%esi
c0027743:	89 d7                	mov    %edx,%edi
c0027745:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
  sign = 0;
c002774c:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c0027753:	00 
  if (is_signed)
c0027754:	84 c9                	test   %cl,%cl
c0027756:	74 1c                	je     c0027774 <format_integer+0x45>
    if (c->flags & PLUS)
c0027758:	8b 8c 24 98 00 00 00 	mov    0x98(%esp),%ecx
c002775f:	8b 11                	mov    (%ecx),%edx
c0027761:	f6 c2 02             	test   $0x2,%dl
c0027764:	74 7e                	je     c00277e4 <format_integer+0xb5>
      sign = negative ? '-' : '+';
c0027766:	3c 01                	cmp    $0x1,%al
c0027768:	19 c0                	sbb    %eax,%eax
c002776a:	83 e0 fe             	and    $0xfffffffe,%eax
c002776d:	83 c0 2d             	add    $0x2d,%eax
c0027770:	89 44 24 20          	mov    %eax,0x20(%esp)
  x = (c->flags & POUND) && value ? b->x : 0;
c0027774:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c002777b:	8b 00                	mov    (%eax),%eax
c002777d:	89 44 24 28          	mov    %eax,0x28(%esp)
c0027781:	83 e0 08             	and    $0x8,%eax
c0027784:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0027788:	89 f1                	mov    %esi,%ecx
c002778a:	09 f9                	or     %edi,%ecx
c002778c:	74 04                	je     c0027792 <format_integer+0x63>
c002778e:	85 c0                	test   %eax,%eax
c0027790:	75 7c                	jne    c002780e <format_integer+0xdf>
c0027792:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0027799:	00 
  while (value > 0)
c002779a:	89 fa                	mov    %edi,%edx
c002779c:	09 f2                	or     %esi,%edx
c002779e:	0f 84 32 02 00 00    	je     c00279d6 <format_integer+0x2a7>
    *cp++ = b->digits[value % b->base];
c00277a4:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c00277ab:	8b 40 04             	mov    0x4(%eax),%eax
c00277ae:	89 44 24 18          	mov    %eax,0x18(%esp)
c00277b2:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c00277b9:	8b 00                	mov    (%eax),%eax
c00277bb:	89 44 24 08          	mov    %eax,0x8(%esp)
c00277bf:	89 c1                	mov    %eax,%ecx
c00277c1:	c1 f9 1f             	sar    $0x1f,%ecx
c00277c4:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  digit_cnt = 0;
c00277c8:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c00277cf:	00 
  cp = buf;
c00277d0:	8d 6c 24 30          	lea    0x30(%esp),%ebp
    if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c00277d4:	8b 44 24 28          	mov    0x28(%esp),%eax
c00277d8:	c1 e8 05             	shr    $0x5,%eax
c00277db:	83 e0 01             	and    $0x1,%eax
c00277de:	88 44 24 1f          	mov    %al,0x1f(%esp)
c00277e2:	eb 41                	jmp    c0027825 <format_integer+0xf6>
    else if (c->flags & SPACE)
c00277e4:	f6 c2 04             	test   $0x4,%dl
c00277e7:	74 13                	je     c00277fc <format_integer+0xcd>
      sign = negative ? '-' : ' ';
c00277e9:	3c 01                	cmp    $0x1,%al
c00277eb:	19 c0                	sbb    %eax,%eax
c00277ed:	83 e0 f3             	and    $0xfffffff3,%eax
c00277f0:	83 c0 2d             	add    $0x2d,%eax
c00277f3:	89 44 24 20          	mov    %eax,0x20(%esp)
c00277f7:	e9 78 ff ff ff       	jmp    c0027774 <format_integer+0x45>
      sign = '-';
c00277fc:	3c 01                	cmp    $0x1,%al
c00277fe:	19 c0                	sbb    %eax,%eax
c0027800:	f7 d0                	not    %eax
c0027802:	83 e0 2d             	and    $0x2d,%eax
c0027805:	89 44 24 20          	mov    %eax,0x20(%esp)
c0027809:	e9 66 ff ff ff       	jmp    c0027774 <format_integer+0x45>
  x = (c->flags & POUND) && value ? b->x : 0;
c002780e:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0027815:	8b 40 08             	mov    0x8(%eax),%eax
c0027818:	89 44 24 24          	mov    %eax,0x24(%esp)
c002781c:	e9 79 ff ff ff       	jmp    c002779a <format_integer+0x6b>
c0027821:	8b 6c 24 10          	mov    0x10(%esp),%ebp
    *cp++ = b->digits[value % b->base];
c0027825:	8d 45 01             	lea    0x1(%ebp),%eax
c0027828:	89 44 24 10          	mov    %eax,0x10(%esp)
c002782c:	ff 74 24 0c          	pushl  0xc(%esp)
c0027830:	ff 74 24 0c          	pushl  0xc(%esp)
c0027834:	57                   	push   %edi
c0027835:	56                   	push   %esi
c0027836:	e8 80 1a 00 00       	call   c00292bb <__umoddi3>
c002783b:	83 c4 10             	add    $0x10,%esp
c002783e:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c0027842:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
c0027846:	88 45 00             	mov    %al,0x0(%ebp)
    value /= b->base;
c0027849:	ff 74 24 0c          	pushl  0xc(%esp)
c002784d:	ff 74 24 0c          	pushl  0xc(%esp)
c0027851:	57                   	push   %edi
c0027852:	56                   	push   %esi
c0027853:	e8 47 1a 00 00       	call   c002929f <__udivdi3>
c0027858:	83 c4 10             	add    $0x10,%esp
c002785b:	89 c6                	mov    %eax,%esi
c002785d:	89 d7                	mov    %edx,%edi
    digit_cnt++;
c002785f:	83 44 24 14 01       	addl   $0x1,0x14(%esp)
  while (value > 0)
c0027864:	09 c2                	or     %eax,%edx
c0027866:	74 2b                	je     c0027893 <format_integer+0x164>
    if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c0027868:	80 7c 24 1f 00       	cmpb   $0x0,0x1f(%esp)
c002786d:	74 b2                	je     c0027821 <format_integer+0xf2>
c002786f:	8b 44 24 14          	mov    0x14(%esp),%eax
c0027873:	85 c0                	test   %eax,%eax
c0027875:	7e aa                	jle    c0027821 <format_integer+0xf2>
c0027877:	8b 8c 24 94 00 00 00 	mov    0x94(%esp),%ecx
c002787e:	99                   	cltd   
c002787f:	f7 79 0c             	idivl  0xc(%ecx)
c0027882:	85 d2                	test   %edx,%edx
c0027884:	75 9b                	jne    c0027821 <format_integer+0xf2>
      *cp++ = ',';
c0027886:	8d 45 02             	lea    0x2(%ebp),%eax
c0027889:	89 44 24 10          	mov    %eax,0x10(%esp)
c002788d:	c6 45 01 2c          	movb   $0x2c,0x1(%ebp)
c0027891:	eb 8e                	jmp    c0027821 <format_integer+0xf2>
c0027893:	8b 6c 24 10          	mov    0x10(%esp),%ebp
  precision = c->precision < 0 ? 1 : c->precision;
c0027897:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c002789e:	8b 48 08             	mov    0x8(%eax),%ecx
c00278a1:	85 c9                	test   %ecx,%ecx
c00278a3:	b8 01 00 00 00       	mov    $0x1,%eax
c00278a8:	0f 48 c8             	cmovs  %eax,%ecx
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c00278ab:	8d 44 24 30          	lea    0x30(%esp),%eax
c00278af:	89 ea                	mov    %ebp,%edx
c00278b1:	29 c2                	sub    %eax,%edx
c00278b3:	39 d1                	cmp    %edx,%ecx
c00278b5:	7e 1f                	jle    c00278d6 <format_integer+0x1a7>
c00278b7:	8d 54 24 6f          	lea    0x6f(%esp),%edx
c00278bb:	39 d5                	cmp    %edx,%ebp
c00278bd:	73 17                	jae    c00278d6 <format_integer+0x1a7>
c00278bf:	89 c6                	mov    %eax,%esi
c00278c1:	89 d7                	mov    %edx,%edi
    *cp++ = '0';
c00278c3:	83 c5 01             	add    $0x1,%ebp
c00278c6:	c6 45 ff 30          	movb   $0x30,-0x1(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c00278ca:	89 ea                	mov    %ebp,%edx
c00278cc:	29 f2                	sub    %esi,%edx
c00278ce:	39 d1                	cmp    %edx,%ecx
c00278d0:	7e 04                	jle    c00278d6 <format_integer+0x1a7>
c00278d2:	39 fd                	cmp    %edi,%ebp
c00278d4:	72 ed                	jb     c00278c3 <format_integer+0x194>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c00278d6:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c00278db:	74 10                	je     c00278ed <format_integer+0x1be>
c00278dd:	8b 9c 24 94 00 00 00 	mov    0x94(%esp),%ebx
c00278e4:	83 3b 08             	cmpl   $0x8,(%ebx)
c00278e7:	0f 84 f2 00 00 00    	je     c00279df <format_integer+0x2b0>
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c00278ed:	29 e8                	sub    %ebp,%eax
c00278ef:	8b bc 24 98 00 00 00 	mov    0x98(%esp),%edi
c00278f6:	03 47 04             	add    0x4(%edi),%eax
c00278f9:	89 c6                	mov    %eax,%esi
c00278fb:	8b 7c 24 24          	mov    0x24(%esp),%edi
c00278ff:	85 ff                	test   %edi,%edi
c0027901:	b8 02 00 00 00       	mov    $0x2,%eax
c0027906:	0f 44 c7             	cmove  %edi,%eax
c0027909:	29 c6                	sub    %eax,%esi
c002790b:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0027910:	0f 95 c0             	setne  %al
c0027913:	0f b6 c0             	movzbl %al,%eax
c0027916:	29 c6                	sub    %eax,%esi
c0027918:	b8 00 00 00 00       	mov    $0x0,%eax
c002791d:	0f 48 f0             	cmovs  %eax,%esi
  if ((c->flags & (MINUS | ZERO)) == 0)
c0027920:	f6 44 24 28 11       	testb  $0x11,0x28(%esp)
c0027925:	0f 84 d2 00 00 00    	je     c00279fd <format_integer+0x2ce>
  if (sign)
c002792b:	8b 44 24 20          	mov    0x20(%esp),%eax
c002792f:	85 c0                	test   %eax,%eax
c0027931:	74 15                	je     c0027948 <format_integer+0x219>
    output(sign, aux);
c0027933:	83 ec 08             	sub    $0x8,%esp
c0027936:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c002793d:	50                   	push   %eax
c002793e:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c0027945:	83 c4 10             	add    $0x10,%esp
  if (x)
c0027948:	8b 7c 24 24          	mov    0x24(%esp),%edi
c002794c:	85 ff                	test   %edi,%edi
c002794e:	74 2d                	je     c002797d <format_integer+0x24e>
    output('0', aux);
c0027950:	83 ec 08             	sub    $0x8,%esp
c0027953:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c002795a:	6a 30                	push   $0x30
c002795c:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
    output(x, aux);
c0027963:	83 c4 08             	add    $0x8,%esp
c0027966:	ff b4 24 a8 00 00 00 	pushl  0xa8(%esp)
c002796d:	89 f8                	mov    %edi,%eax
c002796f:	0f be c0             	movsbl %al,%eax
c0027972:	50                   	push   %eax
c0027973:	ff 94 24 ac 00 00 00 	call   *0xac(%esp)
c002797a:	83 c4 10             	add    $0x10,%esp
  if (c->flags & ZERO)
c002797d:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c0027984:	f6 00 10             	testb  $0x10,(%eax)
c0027987:	0f 85 95 00 00 00    	jne    c0027a22 <format_integer+0x2f3>
  while (cp > buf)
c002798d:	8d 44 24 30          	lea    0x30(%esp),%eax
c0027991:	89 c7                	mov    %eax,%edi
c0027993:	39 c5                	cmp    %eax,%ebp
c0027995:	76 2b                	jbe    c00279c2 <format_integer+0x293>
c0027997:	89 74 24 10          	mov    %esi,0x10(%esp)
c002799b:	8b 9c 24 9c 00 00 00 	mov    0x9c(%esp),%ebx
c00279a2:	8b b4 24 a0 00 00 00 	mov    0xa0(%esp),%esi
    output(*--cp, aux);
c00279a9:	83 ed 01             	sub    $0x1,%ebp
c00279ac:	83 ec 08             	sub    $0x8,%esp
c00279af:	56                   	push   %esi
c00279b0:	0f be 45 00          	movsbl 0x0(%ebp),%eax
c00279b4:	50                   	push   %eax
c00279b5:	ff d3                	call   *%ebx
  while (cp > buf)
c00279b7:	83 c4 10             	add    $0x10,%esp
c00279ba:	39 fd                	cmp    %edi,%ebp
c00279bc:	75 eb                	jne    c00279a9 <format_integer+0x27a>
c00279be:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (c->flags & MINUS)
c00279c2:	8b 84 24 98 00 00 00 	mov    0x98(%esp),%eax
c00279c9:	f6 00 01             	testb  $0x1,(%eax)
c00279cc:	75 79                	jne    c0027a47 <format_integer+0x318>
}
c00279ce:	83 c4 7c             	add    $0x7c,%esp
c00279d1:	5b                   	pop    %ebx
c00279d2:	5e                   	pop    %esi
c00279d3:	5f                   	pop    %edi
c00279d4:	5d                   	pop    %ebp
c00279d5:	c3                   	ret    
  cp = buf;
c00279d6:	8d 6c 24 30          	lea    0x30(%esp),%ebp
c00279da:	e9 b8 fe ff ff       	jmp    c0027897 <format_integer+0x168>
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c00279df:	8d 54 24 30          	lea    0x30(%esp),%edx
c00279e3:	39 d5                	cmp    %edx,%ebp
c00279e5:	74 0a                	je     c00279f1 <format_integer+0x2c2>
c00279e7:	80 7d ff 30          	cmpb   $0x30,-0x1(%ebp)
c00279eb:	0f 84 fc fe ff ff    	je     c00278ed <format_integer+0x1be>
    *cp++ = '0';
c00279f1:	c6 45 00 30          	movb   $0x30,0x0(%ebp)
c00279f5:	8d 6d 01             	lea    0x1(%ebp),%ebp
c00279f8:	e9 f0 fe ff ff       	jmp    c00278ed <format_integer+0x1be>
    output_dup(' ', pad_cnt, output, aux);
c00279fd:	83 ec 0c             	sub    $0xc,%esp
c0027a00:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0027a07:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0027a0e:	89 f2                	mov    %esi,%edx
c0027a10:	b8 20 00 00 00       	mov    $0x20,%eax
c0027a15:	e8 e4 fc ff ff       	call   c00276fe <output_dup>
c0027a1a:	83 c4 10             	add    $0x10,%esp
c0027a1d:	e9 09 ff ff ff       	jmp    c002792b <format_integer+0x1fc>
    output_dup('0', pad_cnt, output, aux);
c0027a22:	83 ec 0c             	sub    $0xc,%esp
c0027a25:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0027a2c:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0027a33:	89 f2                	mov    %esi,%edx
c0027a35:	b8 30 00 00 00       	mov    $0x30,%eax
c0027a3a:	e8 bf fc ff ff       	call   c00276fe <output_dup>
c0027a3f:	83 c4 10             	add    $0x10,%esp
c0027a42:	e9 46 ff ff ff       	jmp    c002798d <format_integer+0x25e>
    output_dup(' ', pad_cnt, output, aux);
c0027a47:	83 ec 0c             	sub    $0xc,%esp
c0027a4a:	ff b4 24 ac 00 00 00 	pushl  0xac(%esp)
c0027a51:	8b 8c 24 ac 00 00 00 	mov    0xac(%esp),%ecx
c0027a58:	89 f2                	mov    %esi,%edx
c0027a5a:	b8 20 00 00 00       	mov    $0x20,%eax
c0027a5f:	e8 9a fc ff ff       	call   c00276fe <output_dup>
c0027a64:	83 c4 10             	add    $0x10,%esp
}
c0027a67:	e9 62 ff ff ff       	jmp    c00279ce <format_integer+0x29f>

c0027a6c <format_string>:
   auxiliary data AUX. */
static void
format_string(const char *string, int length,
              struct printf_conversion *c,
              void (*output)(char, void *), void *aux)
{
c0027a6c:	55                   	push   %ebp
c0027a6d:	57                   	push   %edi
c0027a6e:	56                   	push   %esi
c0027a6f:	53                   	push   %ebx
c0027a70:	83 ec 1c             	sub    $0x1c,%esp
c0027a73:	89 c5                	mov    %eax,%ebp
c0027a75:	89 d6                	mov    %edx,%esi
c0027a77:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
c0027a7b:	8b 7c 24 34          	mov    0x34(%esp),%edi
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0027a7f:	8b 51 04             	mov    0x4(%ecx),%edx
c0027a82:	39 f2                	cmp    %esi,%edx
c0027a84:	7e 3f                	jle    c0027ac5 <format_string+0x59>
c0027a86:	f6 01 01             	testb  $0x1,(%ecx)
c0027a89:	74 1d                	je     c0027aa8 <format_string+0x3c>
    output_dup(' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
c0027a8b:	85 f6                	test   %esi,%esi
c0027a8d:	7f 3a                	jg     c0027ac9 <format_string+0x5d>
    output(string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
    output_dup(' ', c->width - length, output, aux);
c0027a8f:	29 f2                	sub    %esi,%edx
c0027a91:	83 ec 0c             	sub    $0xc,%esp
c0027a94:	57                   	push   %edi
c0027a95:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c0027a99:	b8 20 00 00 00       	mov    $0x20,%eax
c0027a9e:	e8 5b fc ff ff       	call   c00276fe <output_dup>
c0027aa3:	83 c4 10             	add    $0x10,%esp
}
c0027aa6:	eb 4e                	jmp    c0027af6 <format_string+0x8a>
    output_dup(' ', c->width - length, output, aux);
c0027aa8:	29 f2                	sub    %esi,%edx
c0027aaa:	83 ec 0c             	sub    $0xc,%esp
c0027aad:	57                   	push   %edi
c0027aae:	8b 4c 24 40          	mov    0x40(%esp),%ecx
c0027ab2:	b8 20 00 00 00       	mov    $0x20,%eax
c0027ab7:	e8 42 fc ff ff       	call   c00276fe <output_dup>
  for (i = 0; i < length; i++)
c0027abc:	83 c4 10             	add    $0x10,%esp
c0027abf:	85 f6                	test   %esi,%esi
c0027ac1:	7f 06                	jg     c0027ac9 <format_string+0x5d>
c0027ac3:	eb 21                	jmp    c0027ae6 <format_string+0x7a>
c0027ac5:	85 f6                	test   %esi,%esi
c0027ac7:	7e 2d                	jle    c0027af6 <format_string+0x8a>
{
c0027ac9:	bb 00 00 00 00       	mov    $0x0,%ebx
    output(string[i], aux);
c0027ace:	83 ec 08             	sub    $0x8,%esp
c0027ad1:	57                   	push   %edi
c0027ad2:	0f be 44 1d 00       	movsbl 0x0(%ebp,%ebx,1),%eax
c0027ad7:	50                   	push   %eax
c0027ad8:	ff 54 24 40          	call   *0x40(%esp)
  for (i = 0; i < length; i++)
c0027adc:	83 c3 01             	add    $0x1,%ebx
c0027adf:	83 c4 10             	add    $0x10,%esp
c0027ae2:	39 de                	cmp    %ebx,%esi
c0027ae4:	7f e8                	jg     c0027ace <format_string+0x62>
  if (c->width > length && (c->flags & MINUS) != 0)
c0027ae6:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0027aea:	8b 50 04             	mov    0x4(%eax),%edx
c0027aed:	39 f2                	cmp    %esi,%edx
c0027aef:	7e 05                	jle    c0027af6 <format_string+0x8a>
c0027af1:	f6 00 01             	testb  $0x1,(%eax)
c0027af4:	75 99                	jne    c0027a8f <format_string+0x23>
}
c0027af6:	83 c4 1c             	add    $0x1c,%esp
c0027af9:	5b                   	pop    %ebx
c0027afa:	5e                   	pop    %esi
c0027afb:	5f                   	pop    %edi
c0027afc:	5d                   	pop    %ebp
c0027afd:	c3                   	ret    

c0027afe <printf>:
{
c0027afe:	53                   	push   %ebx
c0027aff:	83 ec 08             	sub    $0x8,%esp
c0027b02:	e8 df a9 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0027b07:	81 c3 35 91 01 00    	add    $0x19135,%ebx
  va_start(args, format);
c0027b0d:	8d 44 24 14          	lea    0x14(%esp),%eax
  retval = vprintf(format, args);
c0027b11:	83 ec 08             	sub    $0x8,%esp
c0027b14:	50                   	push   %eax
c0027b15:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027b19:	e8 0d 3d 00 00       	call   c002b82b <vprintf>
}
c0027b1e:	83 c4 18             	add    $0x18,%esp
c0027b21:	5b                   	pop    %ebx
c0027b22:	c3                   	ret    

c0027b23 <__printf>:

/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void __printf(const char *format,
              void (*output)(char, void *), void *aux, ...)
{
c0027b23:	83 ec 0c             	sub    $0xc,%esp
  va_list args;

  va_start(args, aux);
c0027b26:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  __vprintf(format, args, output, aux);
c0027b2a:	ff 74 24 18          	pushl  0x18(%esp)
c0027b2e:	ff 74 24 18          	pushl  0x18(%esp)
c0027b32:	50                   	push   %eax
c0027b33:	ff 74 24 1c          	pushl  0x1c(%esp)
c0027b37:	e8 04 00 00 00       	call   c0027b40 <__vprintf>
  va_end(args);
}
c0027b3c:	83 c4 1c             	add    $0x1c,%esp
c0027b3f:	c3                   	ret    

c0027b40 <__vprintf>:
{
c0027b40:	55                   	push   %ebp
c0027b41:	57                   	push   %edi
c0027b42:	56                   	push   %esi
c0027b43:	53                   	push   %ebx
c0027b44:	83 ec 5c             	sub    $0x5c,%esp
c0027b47:	e8 9e a9 00 00       	call   c00324ea <__x86.get_pc_thunk.ax>
c0027b4c:	05 f0 90 01 00       	add    $0x190f0,%eax
c0027b51:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0027b55:	8b 74 24 70          	mov    0x70(%esp),%esi
c0027b59:	8b 7c 24 78          	mov    0x78(%esp),%edi
c0027b5d:	8b 6c 24 7c          	mov    0x7c(%esp),%ebp
  for (; *format != '\0'; format++)
c0027b61:	0f b6 06             	movzbl (%esi),%eax
c0027b64:	84 c0                	test   %al,%al
c0027b66:	75 27                	jne    c0027b8f <__vprintf+0x4f>
}
c0027b68:	83 c4 5c             	add    $0x5c,%esp
c0027b6b:	5b                   	pop    %ebx
c0027b6c:	5e                   	pop    %esi
c0027b6d:	5f                   	pop    %edi
c0027b6e:	5d                   	pop    %ebp
c0027b6f:	c3                   	ret    
    format++;
c0027b70:	8d 5e 01             	lea    0x1(%esi),%ebx
    if (*format == '%')
c0027b73:	80 7e 01 25          	cmpb   $0x25,0x1(%esi)
c0027b77:	75 2b                	jne    c0027ba4 <__vprintf+0x64>
      output('%', aux);
c0027b79:	83 ec 08             	sub    $0x8,%esp
c0027b7c:	55                   	push   %ebp
c0027b7d:	6a 25                	push   $0x25
c0027b7f:	ff d7                	call   *%edi
      continue;
c0027b81:	83 c4 10             	add    $0x10,%esp
  for (; *format != '\0'; format++)
c0027b84:	8d 73 01             	lea    0x1(%ebx),%esi
c0027b87:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027b8b:	84 c0                	test   %al,%al
c0027b8d:	74 d9                	je     c0027b68 <__vprintf+0x28>
    if (*format != '%')
c0027b8f:	3c 25                	cmp    $0x25,%al
c0027b91:	74 dd                	je     c0027b70 <__vprintf+0x30>
      output(*format, aux);
c0027b93:	83 ec 08             	sub    $0x8,%esp
c0027b96:	55                   	push   %ebp
c0027b97:	0f be c0             	movsbl %al,%eax
c0027b9a:	50                   	push   %eax
c0027b9b:	ff d7                	call   *%edi
      continue;
c0027b9d:	83 c4 10             	add    $0x10,%esp
c0027ba0:	89 f3                	mov    %esi,%ebx
c0027ba2:	eb e0                	jmp    c0027b84 <__vprintf+0x44>
  c->flags = 0;
c0027ba4:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
c0027bab:	00 
c0027bac:	c6 44 24 18 00       	movb   $0x0,0x18(%esp)
c0027bb1:	be 00 00 00 00       	mov    $0x0,%esi
c0027bb6:	89 7c 24 78          	mov    %edi,0x78(%esp)
c0027bba:	89 6c 24 7c          	mov    %ebp,0x7c(%esp)
c0027bbe:	eb 0a                	jmp    c0027bca <.L79+0xa>

c0027bc0 <.L79>:
      c->flags |= MINUS;
c0027bc0:	83 ce 01             	or     $0x1,%esi
c0027bc3:	c6 44 24 18 01       	movb   $0x1,0x18(%esp)
    switch (*format++)
c0027bc8:	89 cb                	mov    %ecx,%ebx
c0027bca:	8d 4b 01             	lea    0x1(%ebx),%ecx
c0027bcd:	0f b6 51 ff          	movzbl -0x1(%ecx),%edx
c0027bd1:	8d 42 e0             	lea    -0x20(%edx),%eax
c0027bd4:	3c 10                	cmp    $0x10,%al
c0027bd6:	77 2b                	ja     c0027c03 <.L73>
c0027bd8:	0f b6 c0             	movzbl %al,%eax
c0027bdb:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c0027bdf:	89 fd                	mov    %edi,%ebp
c0027be1:	03 ac 87 d4 1e ff ff 	add    -0xe12c(%edi,%eax,4),%ebp
c0027be8:	ff e5                	jmp    *%ebp

c0027bea <.L78>:
      c->flags |= PLUS;
c0027bea:	83 ce 02             	or     $0x2,%esi
c0027bed:	eb d4                	jmp    c0027bc3 <.L79+0x3>

c0027bef <.L74>:
      c->flags |= SPACE;
c0027bef:	83 ce 04             	or     $0x4,%esi
c0027bf2:	eb cf                	jmp    c0027bc3 <.L79+0x3>

c0027bf4 <.L76>:
      c->flags |= POUND;
c0027bf4:	83 ce 08             	or     $0x8,%esi
c0027bf7:	eb ca                	jmp    c0027bc3 <.L79+0x3>

c0027bf9 <.L80>:
      c->flags |= ZERO;
c0027bf9:	83 ce 10             	or     $0x10,%esi
c0027bfc:	eb c5                	jmp    c0027bc3 <.L79+0x3>

c0027bfe <.L77>:
      c->flags |= GROUP;
c0027bfe:	83 ce 20             	or     $0x20,%esi
c0027c01:	eb c0                	jmp    c0027bc3 <.L79+0x3>

c0027c03 <.L73>:
c0027c03:	8b 7c 24 78          	mov    0x78(%esp),%edi
c0027c07:	8b 6c 24 7c          	mov    0x7c(%esp),%ebp
c0027c0b:	80 7c 24 18 00       	cmpb   $0x0,0x18(%esp)
c0027c10:	0f 85 9e 00 00 00    	jne    c0027cb4 <.L73+0xb1>
  if (c->flags & PLUS)
c0027c16:	8b 44 24 40          	mov    0x40(%esp),%eax
c0027c1a:	a8 02                	test   $0x2,%al
c0027c1c:	74 07                	je     c0027c25 <.L73+0x22>
    c->flags &= ~SPACE;
c0027c1e:	83 e0 fb             	and    $0xfffffffb,%eax
c0027c21:	89 44 24 40          	mov    %eax,0x40(%esp)
  c->width = 0;
c0027c25:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%esp)
c0027c2c:	00 
  if (*format == '*')
c0027c2d:	80 fa 2a             	cmp    $0x2a,%dl
c0027c30:	0f 84 9a 00 00 00    	je     c0027cd0 <.L73+0xcd>
    for (; isdigit(*format); format++)
c0027c36:	0f be d2             	movsbl %dl,%edx
static inline int isdigit(int c) { return c >= '0' && c <= '9'; }
c0027c39:	8d 4a d0             	lea    -0x30(%edx),%ecx
c0027c3c:	b8 00 00 00 00       	mov    $0x0,%eax
c0027c41:	83 f9 09             	cmp    $0x9,%ecx
c0027c44:	77 25                	ja     c0027c6b <.L73+0x68>
      c->width = c->width * 10 + *format - '0';
c0027c46:	8d 04 80             	lea    (%eax,%eax,4),%eax
c0027c49:	8d 44 42 d0          	lea    -0x30(%edx,%eax,2),%eax
    for (; isdigit(*format); format++)
c0027c4d:	83 c3 01             	add    $0x1,%ebx
c0027c50:	0f be 13             	movsbl (%ebx),%edx
c0027c53:	8d 4a d0             	lea    -0x30(%edx),%ecx
c0027c56:	83 f9 09             	cmp    $0x9,%ecx
c0027c59:	76 eb                	jbe    c0027c46 <.L73+0x43>
c0027c5b:	89 44 24 44          	mov    %eax,0x44(%esp)
  if (c->width < 0)
c0027c5f:	8b 44 24 44          	mov    0x44(%esp),%eax
c0027c63:	85 c0                	test   %eax,%eax
c0027c65:	0f 88 81 00 00 00    	js     c0027cec <.L73+0xe9>
  c->precision = -1;
c0027c6b:	c7 44 24 48 ff ff ff 	movl   $0xffffffff,0x48(%esp)
c0027c72:	ff 
  if (*format == '.')
c0027c73:	80 3b 2e             	cmpb   $0x2e,(%ebx)
c0027c76:	0f 84 80 00 00 00    	je     c0027cfc <.L73+0xf9>
  if (c->precision >= 0)
c0027c7c:	8b 44 24 48          	mov    0x48(%esp),%eax
c0027c80:	89 44 24 10          	mov    %eax,0x10(%esp)
  c->type = INT;
c0027c84:	c7 44 24 4c 03 00 00 	movl   $0x3,0x4c(%esp)
c0027c8b:	00 
  switch (*format++)
c0027c8c:	8d 43 01             	lea    0x1(%ebx),%eax
c0027c8f:	89 44 24 18          	mov    %eax,0x18(%esp)
c0027c93:	0f b6 03             	movzbl (%ebx),%eax
c0027c96:	8d 50 98             	lea    -0x68(%eax),%edx
c0027c99:	80 fa 12             	cmp    $0x12,%dl
c0027c9c:	0f 87 44 02 00 00    	ja     c0027ee6 <.L93>
c0027ca2:	0f b6 d2             	movzbl %dl,%edx
c0027ca5:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c0027ca9:	89 ce                	mov    %ecx,%esi
c0027cab:	03 b4 91 18 1f ff ff 	add    -0xe0e8(%ecx,%edx,4),%esi
c0027cb2:	ff e6                	jmp    *%esi
c0027cb4:	89 74 24 40          	mov    %esi,0x40(%esp)
  if (c->flags & MINUS)
c0027cb8:	f7 c6 01 00 00 00    	test   $0x1,%esi
c0027cbe:	0f 84 52 ff ff ff    	je     c0027c16 <.L73+0x13>
    c->flags &= ~ZERO;
c0027cc4:	83 e6 ef             	and    $0xffffffef,%esi
c0027cc7:	89 74 24 40          	mov    %esi,0x40(%esp)
c0027ccb:	e9 46 ff ff ff       	jmp    c0027c16 <.L73+0x13>
    c->width = va_arg(*args, int);
c0027cd0:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027cd4:	8b 00                	mov    (%eax),%eax
c0027cd6:	89 44 24 44          	mov    %eax,0x44(%esp)
c0027cda:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027cde:	8d 40 04             	lea    0x4(%eax),%eax
c0027ce1:	89 44 24 74          	mov    %eax,0x74(%esp)
    switch (*format++)
c0027ce5:	89 cb                	mov    %ecx,%ebx
c0027ce7:	e9 73 ff ff ff       	jmp    c0027c5f <.L73+0x5c>
    c->width = -c->width;
c0027cec:	f7 d8                	neg    %eax
c0027cee:	89 44 24 44          	mov    %eax,0x44(%esp)
    c->flags |= MINUS;
c0027cf2:	83 4c 24 40 01       	orl    $0x1,0x40(%esp)
c0027cf7:	e9 6f ff ff ff       	jmp    c0027c6b <.L73+0x68>
    if (*format == '*')
c0027cfc:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027d00:	3c 2a                	cmp    $0x2a,%al
c0027d02:	74 4a                	je     c0027d4e <.L73+0x14b>
    format++;
c0027d04:	83 c3 01             	add    $0x1,%ebx
      c->precision = 0;
c0027d07:	c7 44 24 48 00 00 00 	movl   $0x0,0x48(%esp)
c0027d0e:	00 
      for (; isdigit(*format); format++)
c0027d0f:	0f be c0             	movsbl %al,%eax
c0027d12:	8d 50 d0             	lea    -0x30(%eax),%edx
c0027d15:	83 fa 09             	cmp    $0x9,%edx
c0027d18:	77 5b                	ja     c0027d75 <.L73+0x172>
c0027d1a:	ba 00 00 00 00       	mov    $0x0,%edx
        c->precision = c->precision * 10 + *format - '0';
c0027d1f:	8d 14 92             	lea    (%edx,%edx,4),%edx
c0027d22:	8d 54 50 d0          	lea    -0x30(%eax,%edx,2),%edx
      for (; isdigit(*format); format++)
c0027d26:	83 c3 01             	add    $0x1,%ebx
c0027d29:	0f be 03             	movsbl (%ebx),%eax
c0027d2c:	8d 48 d0             	lea    -0x30(%eax),%ecx
c0027d2f:	83 f9 09             	cmp    $0x9,%ecx
c0027d32:	76 eb                	jbe    c0027d1f <.L73+0x11c>
c0027d34:	89 54 24 48          	mov    %edx,0x48(%esp)
    if (c->precision < 0)
c0027d38:	8b 44 24 48          	mov    0x48(%esp),%eax
c0027d3c:	89 44 24 10          	mov    %eax,0x10(%esp)
c0027d40:	85 c0                	test   %eax,%eax
c0027d42:	78 24                	js     c0027d68 <.L73+0x165>
    c->flags &= ~ZERO;
c0027d44:	83 64 24 40 ef       	andl   $0xffffffef,0x40(%esp)
c0027d49:	e9 36 ff ff ff       	jmp    c0027c84 <.L73+0x81>
      format++;
c0027d4e:	83 c3 02             	add    $0x2,%ebx
      c->precision = va_arg(*args, int);
c0027d51:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027d55:	8b 00                	mov    (%eax),%eax
c0027d57:	89 44 24 48          	mov    %eax,0x48(%esp)
c0027d5b:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027d5f:	8d 40 04             	lea    0x4(%eax),%eax
c0027d62:	89 44 24 74          	mov    %eax,0x74(%esp)
c0027d66:	eb d0                	jmp    c0027d38 <.L73+0x135>
      c->precision = -1;
c0027d68:	c7 44 24 48 ff ff ff 	movl   $0xffffffff,0x48(%esp)
c0027d6f:	ff 
c0027d70:	e9 07 ff ff ff       	jmp    c0027c7c <.L73+0x79>
  if (c->precision >= 0)
c0027d75:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0027d7c:	00 
c0027d7d:	eb c5                	jmp    c0027d44 <.L73+0x141>

c0027d7f <.L94>:
    if (*format == 'h')
c0027d7f:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027d83:	3c 68                	cmp    $0x68,%al
c0027d85:	74 2d                	je     c0027db4 <.L94+0x35>
      c->type = SHORT;
c0027d87:	c7 44 24 4c 02 00 00 	movl   $0x2,0x4c(%esp)
c0027d8e:	00 
    switch (*format)
c0027d8f:	0f be d0             	movsbl %al,%edx
c0027d92:	89 54 24 1c          	mov    %edx,0x1c(%esp)
c0027d96:	8d 48 bb             	lea    -0x45(%eax),%ecx
c0027d99:	80 f9 33             	cmp    $0x33,%cl
c0027d9c:	0f 87 dd 05 00 00    	ja     c002837f <.L101>
c0027da2:	0f b6 c9             	movzbl %cl,%ecx
c0027da5:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0027da9:	89 d6                	mov    %edx,%esi
c0027dab:	03 b4 8a 64 1f ff ff 	add    -0xe09c(%edx,%ecx,4),%esi
c0027db2:	ff e6                	jmp    *%esi
      format++;
c0027db4:	8d 43 02             	lea    0x2(%ebx),%eax
c0027db7:	89 44 24 18          	mov    %eax,0x18(%esp)
      c->type = CHAR;
c0027dbb:	c7 44 24 4c 01 00 00 	movl   $0x1,0x4c(%esp)
c0027dc2:	00 
    switch (*format)
c0027dc3:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
c0027dc7:	0f be d0             	movsbl %al,%edx
c0027dca:	89 54 24 1c          	mov    %edx,0x1c(%esp)
c0027dce:	8d 48 bb             	lea    -0x45(%eax),%ecx
c0027dd1:	80 f9 33             	cmp    $0x33,%cl
c0027dd4:	0f 87 a5 05 00 00    	ja     c002837f <.L101>
c0027dda:	0f b6 c9             	movzbl %cl,%ecx
c0027ddd:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0027de1:	89 d6                	mov    %edx,%esi
c0027de3:	03 b4 8a 34 20 ff ff 	add    -0xdfcc(%edx,%ecx,4),%esi
c0027dea:	ff e6                	jmp    *%esi

c0027dec <.L96>:
    c->type = INTMAX;
c0027dec:	c7 44 24 4c 04 00 00 	movl   $0x4,0x4c(%esp)
c0027df3:	00 
    switch (*format)
c0027df4:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027df8:	0f be c8             	movsbl %al,%ecx
c0027dfb:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c0027dff:	8d 48 bb             	lea    -0x45(%eax),%ecx
c0027e02:	80 f9 33             	cmp    $0x33,%cl
c0027e05:	0f 87 74 05 00 00    	ja     c002837f <.L101>
c0027e0b:	0f b6 c9             	movzbl %cl,%ecx
c0027e0e:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027e12:	03 9c 8b 04 21 ff ff 	add    -0xdefc(%ebx,%ecx,4),%ebx
c0027e19:	ff e3                	jmp    *%ebx

c0027e1b <.L97>:
    if (*format == 'l')
c0027e1b:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027e1f:	3c 6c                	cmp    $0x6c,%al
c0027e21:	74 2d                	je     c0027e50 <.L97+0x35>
      c->type = LONG;
c0027e23:	c7 44 24 4c 05 00 00 	movl   $0x5,0x4c(%esp)
c0027e2a:	00 
    switch (*format)
c0027e2b:	0f be d0             	movsbl %al,%edx
c0027e2e:	89 54 24 1c          	mov    %edx,0x1c(%esp)
c0027e32:	8d 48 bb             	lea    -0x45(%eax),%ecx
c0027e35:	80 f9 33             	cmp    $0x33,%cl
c0027e38:	0f 87 41 05 00 00    	ja     c002837f <.L101>
c0027e3e:	0f b6 c9             	movzbl %cl,%ecx
c0027e41:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0027e45:	89 d6                	mov    %edx,%esi
c0027e47:	03 b4 8a d4 21 ff ff 	add    -0xde2c(%edx,%ecx,4),%esi
c0027e4e:	ff e6                	jmp    *%esi
      format++;
c0027e50:	8d 43 02             	lea    0x2(%ebx),%eax
c0027e53:	89 44 24 18          	mov    %eax,0x18(%esp)
      c->type = LONGLONG;
c0027e57:	c7 44 24 4c 06 00 00 	movl   $0x6,0x4c(%esp)
c0027e5e:	00 
    switch (*format)
c0027e5f:	0f b6 43 02          	movzbl 0x2(%ebx),%eax
c0027e63:	0f be c8             	movsbl %al,%ecx
c0027e66:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c0027e6a:	8d 48 bb             	lea    -0x45(%eax),%ecx
c0027e6d:	80 f9 33             	cmp    $0x33,%cl
c0027e70:	0f 87 09 05 00 00    	ja     c002837f <.L101>
c0027e76:	0f b6 c9             	movzbl %cl,%ecx
c0027e79:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0027e7d:	89 d6                	mov    %edx,%esi
c0027e7f:	03 b4 8a a4 22 ff ff 	add    -0xdd5c(%edx,%ecx,4),%esi
c0027e86:	ff e6                	jmp    *%esi

c0027e88 <.L98>:
    c->type = PTRDIFFT;
c0027e88:	c7 44 24 4c 07 00 00 	movl   $0x7,0x4c(%esp)
c0027e8f:	00 
    switch (*format)
c0027e90:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027e94:	0f be c8             	movsbl %al,%ecx
c0027e97:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c0027e9b:	8d 48 bb             	lea    -0x45(%eax),%ecx
c0027e9e:	80 f9 33             	cmp    $0x33,%cl
c0027ea1:	0f 87 d8 04 00 00    	ja     c002837f <.L101>
c0027ea7:	0f b6 c9             	movzbl %cl,%ecx
c0027eaa:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027eae:	03 9c 8b 74 23 ff ff 	add    -0xdc8c(%ebx,%ecx,4),%ebx
c0027eb5:	ff e3                	jmp    *%ebx

c0027eb7 <.L99>:
    c->type = SIZET;
c0027eb7:	c7 44 24 4c 08 00 00 	movl   $0x8,0x4c(%esp)
c0027ebe:	00 
    switch (*format)
c0027ebf:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0027ec3:	0f be c8             	movsbl %al,%ecx
c0027ec6:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c0027eca:	8d 48 bb             	lea    -0x45(%eax),%ecx
c0027ecd:	80 f9 33             	cmp    $0x33,%cl
c0027ed0:	0f 87 a9 04 00 00    	ja     c002837f <.L101>
c0027ed6:	0f b6 c9             	movzbl %cl,%ecx
c0027ed9:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0027edd:	03 9c 8b 44 24 ff ff 	add    -0xdbbc(%ebx,%ecx,4),%ebx
c0027ee4:	ff e3                	jmp    *%ebx

c0027ee6 <.L93>:
c0027ee6:	0f be c8             	movsbl %al,%ecx
c0027ee9:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
c0027eed:	8d 48 bb             	lea    -0x45(%eax),%ecx
c0027ef0:	80 f9 33             	cmp    $0x33,%cl
c0027ef3:	0f 87 82 04 00 00    	ja     c002837b <.L150>
c0027ef9:	0f b6 c9             	movzbl %cl,%ecx
c0027efc:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0027f00:	03 94 8a 14 25 ff ff 	add    -0xdaec(%edx,%ecx,4),%edx
c0027f07:	ff e2                	jmp    *%edx

c0027f09 <.L153>:
c0027f09:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c0027f0d <.L106>:
      switch (c.type)
c0027f0d:	83 7c 24 4c 08       	cmpl   $0x8,0x4c(%esp)
c0027f12:	0f 87 8b 01 00 00    	ja     c00280a3 <.L124>
c0027f18:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c0027f1c:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c0027f20:	03 8c 81 e4 25 ff ff 	add    -0xda1c(%ecx,%eax,4),%ecx
c0027f27:	ff e1                	jmp    *%ecx

c0027f29 <.L125>:
        value = (signed char)va_arg(args, int);
c0027f29:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027f2d:	0f be 08             	movsbl (%eax),%ecx
c0027f30:	89 c8                	mov    %ecx,%eax
c0027f32:	99                   	cltd   
c0027f33:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027f37:	89 54 24 14          	mov    %edx,0x14(%esp)
c0027f3b:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027f3f:	8d 40 04             	lea    0x4(%eax),%eax
c0027f42:	89 44 24 74          	mov    %eax,0x74(%esp)
      format_integer(value < 0 ? -value : value,
c0027f46:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0027f4a:	8b 74 24 14          	mov    0x14(%esp),%esi
c0027f4e:	89 f2                	mov    %esi,%edx
c0027f50:	c1 fa 1f             	sar    $0x1f,%edx
c0027f53:	89 d1                	mov    %edx,%ecx
c0027f55:	31 d9                	xor    %ebx,%ecx
c0027f57:	89 4c 24 28          	mov    %ecx,0x28(%esp)
c0027f5b:	89 d1                	mov    %edx,%ecx
c0027f5d:	33 4c 24 14          	xor    0x14(%esp),%ecx
c0027f61:	89 4c 24 2c          	mov    %ecx,0x2c(%esp)
c0027f65:	8b 4c 24 28          	mov    0x28(%esp),%ecx
c0027f69:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
c0027f6d:	29 d1                	sub    %edx,%ecx
c0027f6f:	19 d3                	sbb    %edx,%ebx
c0027f71:	89 c8                	mov    %ecx,%eax
c0027f73:	89 da                	mov    %ebx,%edx
c0027f75:	83 ec 0c             	sub    $0xc,%esp
c0027f78:	55                   	push   %ebp
c0027f79:	57                   	push   %edi
c0027f7a:	8d 4c 24 54          	lea    0x54(%esp),%ecx
c0027f7e:	51                   	push   %ecx
c0027f7f:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0027f83:	8d 89 b4 5d ff ff    	lea    -0xa24c(%ecx),%ecx
c0027f89:	51                   	push   %ecx
c0027f8a:	8b 4c 24 30          	mov    0x30(%esp),%ecx
c0027f8e:	c1 e9 1f             	shr    $0x1f,%ecx
c0027f91:	51                   	push   %ecx
c0027f92:	b9 01 00 00 00       	mov    $0x1,%ecx
c0027f97:	e8 93 f7 ff ff       	call   c002772f <format_integer>
    break;
c0027f9c:	83 c4 20             	add    $0x20,%esp
c0027f9f:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0027fa3:	e9 dc fb ff ff       	jmp    c0027b84 <__vprintf+0x44>

c0027fa8 <.L127>:
        value = (short)va_arg(args, int);
c0027fa8:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027fac:	0f bf 08             	movswl (%eax),%ecx
c0027faf:	89 c8                	mov    %ecx,%eax
c0027fb1:	99                   	cltd   
c0027fb2:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027fb6:	89 54 24 14          	mov    %edx,0x14(%esp)
c0027fba:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027fbe:	8d 40 04             	lea    0x4(%eax),%eax
c0027fc1:	89 44 24 74          	mov    %eax,0x74(%esp)
        break;
c0027fc5:	e9 7c ff ff ff       	jmp    c0027f46 <.L125+0x1d>

c0027fca <.L128>:
        value = va_arg(args, int);
c0027fca:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027fce:	8b 08                	mov    (%eax),%ecx
c0027fd0:	89 c8                	mov    %ecx,%eax
c0027fd2:	99                   	cltd   
c0027fd3:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0027fd7:	89 54 24 14          	mov    %edx,0x14(%esp)
c0027fdb:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027fdf:	8d 40 04             	lea    0x4(%eax),%eax
c0027fe2:	89 44 24 74          	mov    %eax,0x74(%esp)
        break;
c0027fe6:	e9 5b ff ff ff       	jmp    c0027f46 <.L125+0x1d>

c0027feb <.L129>:
        value = va_arg(args, intmax_t);
c0027feb:	8b 44 24 74          	mov    0x74(%esp),%eax
c0027fef:	8b 50 04             	mov    0x4(%eax),%edx
c0027ff2:	8b 00                	mov    (%eax),%eax
c0027ff4:	89 44 24 10          	mov    %eax,0x10(%esp)
c0027ff8:	89 54 24 14          	mov    %edx,0x14(%esp)
c0027ffc:	8b 44 24 74          	mov    0x74(%esp),%eax
c0028000:	8d 40 08             	lea    0x8(%eax),%eax
c0028003:	89 44 24 74          	mov    %eax,0x74(%esp)
        break;
c0028007:	e9 3a ff ff ff       	jmp    c0027f46 <.L125+0x1d>

c002800c <.L130>:
        value = va_arg(args, long);
c002800c:	8b 44 24 74          	mov    0x74(%esp),%eax
c0028010:	8b 08                	mov    (%eax),%ecx
c0028012:	89 c8                	mov    %ecx,%eax
c0028014:	99                   	cltd   
c0028015:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0028019:	89 54 24 14          	mov    %edx,0x14(%esp)
c002801d:	8b 44 24 74          	mov    0x74(%esp),%eax
c0028021:	8d 40 04             	lea    0x4(%eax),%eax
c0028024:	89 44 24 74          	mov    %eax,0x74(%esp)
        break;
c0028028:	e9 19 ff ff ff       	jmp    c0027f46 <.L125+0x1d>

c002802d <.L131>:
        value = va_arg(args, long long);
c002802d:	8b 44 24 74          	mov    0x74(%esp),%eax
c0028031:	8b 50 04             	mov    0x4(%eax),%edx
c0028034:	8b 00                	mov    (%eax),%eax
c0028036:	89 44 24 10          	mov    %eax,0x10(%esp)
c002803a:	89 54 24 14          	mov    %edx,0x14(%esp)
c002803e:	8b 44 24 74          	mov    0x74(%esp),%eax
c0028042:	8d 40 08             	lea    0x8(%eax),%eax
c0028045:	89 44 24 74          	mov    %eax,0x74(%esp)
        break;
c0028049:	e9 f8 fe ff ff       	jmp    c0027f46 <.L125+0x1d>

c002804e <.L132>:
        value = va_arg(args, ptrdiff_t);
c002804e:	8b 44 24 74          	mov    0x74(%esp),%eax
c0028052:	8b 08                	mov    (%eax),%ecx
c0028054:	89 c8                	mov    %ecx,%eax
c0028056:	99                   	cltd   
c0028057:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c002805b:	89 54 24 14          	mov    %edx,0x14(%esp)
c002805f:	8b 44 24 74          	mov    0x74(%esp),%eax
c0028063:	8d 40 04             	lea    0x4(%eax),%eax
c0028066:	89 44 24 74          	mov    %eax,0x74(%esp)
        break;
c002806a:	e9 d7 fe ff ff       	jmp    c0027f46 <.L125+0x1d>

c002806f <.L133>:
        value = va_arg(args, size_t);
c002806f:	8b 44 24 74          	mov    0x74(%esp),%eax
c0028073:	83 c0 04             	add    $0x4,%eax
c0028076:	8b 54 24 74          	mov    0x74(%esp),%edx
c002807a:	8b 0a                	mov    (%edx),%ecx
c002807c:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028081:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c0028085:	89 5c 24 14          	mov    %ebx,0x14(%esp)
c0028089:	89 44 24 74          	mov    %eax,0x74(%esp)
        if (value > SIZE_MAX / 2)
c002808d:	81 f9 ff ff ff 7f    	cmp    $0x7fffffff,%ecx
c0028093:	0f 86 ad fe ff ff    	jbe    c0027f46 <.L125+0x1d>
          value = value - SIZE_MAX - 1;
c0028099:	83 6c 24 14 01       	subl   $0x1,0x14(%esp)
c002809e:	e9 a3 fe ff ff       	jmp    c0027f46 <.L125+0x1d>

c00280a3 <.L124>:
        NOT_REACHED();
c00280a3:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c00280a7:	8d 83 60 34 ff ff    	lea    -0xcba0(%ebx),%eax
c00280ad:	50                   	push   %eax
c00280ae:	8d 83 08 26 ff ff    	lea    -0xd9f8(%ebx),%eax
c00280b4:	50                   	push   %eax
c00280b5:	68 d6 00 00 00       	push   $0xd6
c00280ba:	8d 83 91 46 ff ff    	lea    -0xb96f(%ebx),%eax
c00280c0:	50                   	push   %eax
c00280c1:	e8 cf 17 00 00       	call   c0029895 <debug_panic>

c00280c6 <.L123>:
        value = va_arg(args, unsigned);
c00280c6:	8b 54 24 74          	mov    0x74(%esp),%edx
c00280ca:	8b 12                	mov    (%edx),%edx
c00280cc:	b9 00 00 00 00       	mov    $0x0,%ecx
c00280d1:	89 54 24 20          	mov    %edx,0x20(%esp)
c00280d5:	89 4c 24 24          	mov    %ecx,0x24(%esp)
c00280d9:	8b 54 24 74          	mov    0x74(%esp),%edx
c00280dd:	8d 52 04             	lea    0x4(%edx),%edx
c00280e0:	89 54 24 74          	mov    %edx,0x74(%esp)
      switch (*format)
c00280e4:	3c 6f                	cmp    $0x6f,%al
c00280e6:	0f 84 81 01 00 00    	je     c002826d <.L121+0x87>
c00280ec:	3c 6f                	cmp    $0x6f,%al
c00280ee:	0f 8e 15 01 00 00    	jle    c0028209 <.L121+0x23>
c00280f4:	3c 75                	cmp    $0x75,%al
c00280f6:	0f 84 1d 01 00 00    	je     c0028219 <.L121+0x33>
c00280fc:	3c 78                	cmp    $0x78,%al
c00280fe:	0f 85 46 01 00 00    	jne    c002824a <.L121+0x64>
        b = &base_x;
c0028104:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0028108:	8d 80 94 5d ff ff    	lea    -0xa26c(%eax),%eax
c002810e:	e9 10 01 00 00       	jmp    c0028223 <.L121+0x3d>

c0028113 <.L104>:
        value = (unsigned char)va_arg(args, unsigned);
c0028113:	8b 54 24 74          	mov    0x74(%esp),%edx
c0028117:	0f b6 12             	movzbl (%edx),%edx
c002811a:	89 54 24 20          	mov    %edx,0x20(%esp)
c002811e:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0028125:	00 
        break;
c0028126:	8b 5c 24 18          	mov    0x18(%esp),%ebx
        value = (unsigned char)va_arg(args, unsigned);
c002812a:	8b 54 24 74          	mov    0x74(%esp),%edx
c002812e:	8d 52 04             	lea    0x4(%edx),%edx
c0028131:	89 54 24 74          	mov    %edx,0x74(%esp)
        break;
c0028135:	eb ad                	jmp    c00280e4 <.L123+0x1e>

c0028137 <.L110>:
        value = (unsigned short)va_arg(args, unsigned);
c0028137:	8b 54 24 74          	mov    0x74(%esp),%edx
c002813b:	0f b7 12             	movzwl (%edx),%edx
c002813e:	89 54 24 20          	mov    %edx,0x20(%esp)
c0028142:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0028149:	00 
        break;
c002814a:	8b 5c 24 18          	mov    0x18(%esp),%ebx
        value = (unsigned short)va_arg(args, unsigned);
c002814e:	8b 54 24 74          	mov    0x74(%esp),%edx
c0028152:	8d 52 04             	lea    0x4(%edx),%edx
c0028155:	89 54 24 74          	mov    %edx,0x74(%esp)
        break;
c0028159:	eb 89                	jmp    c00280e4 <.L123+0x1e>

c002815b <.L112>:
        value = va_arg(args, uintmax_t);
c002815b:	8b 54 24 74          	mov    0x74(%esp),%edx
c002815f:	8b 0a                	mov    (%edx),%ecx
c0028161:	8b 5a 04             	mov    0x4(%edx),%ebx
c0028164:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c0028168:	89 5c 24 24          	mov    %ebx,0x24(%esp)
        break;
c002816c:	8b 5c 24 18          	mov    0x18(%esp),%ebx
        value = va_arg(args, uintmax_t);
c0028170:	8d 52 08             	lea    0x8(%edx),%edx
c0028173:	89 54 24 74          	mov    %edx,0x74(%esp)
        break;
c0028177:	e9 68 ff ff ff       	jmp    c00280e4 <.L123+0x1e>

c002817c <.L117>:
        value = va_arg(args, unsigned long);
c002817c:	8b 54 24 74          	mov    0x74(%esp),%edx
c0028180:	8b 0a                	mov    (%edx),%ecx
c0028182:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028187:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c002818b:	89 5c 24 24          	mov    %ebx,0x24(%esp)
        break;
c002818f:	8b 5c 24 18          	mov    0x18(%esp),%ebx
        value = va_arg(args, unsigned long);
c0028193:	8d 52 04             	lea    0x4(%edx),%edx
c0028196:	89 54 24 74          	mov    %edx,0x74(%esp)
        break;
c002819a:	e9 45 ff ff ff       	jmp    c00280e4 <.L123+0x1e>

c002819f <.L115>:
        value = va_arg(args, unsigned long long);
c002819f:	8b 4c 24 74          	mov    0x74(%esp),%ecx
c00281a3:	8b 59 04             	mov    0x4(%ecx),%ebx
c00281a6:	8b 09                	mov    (%ecx),%ecx
c00281a8:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c00281ac:	89 5c 24 24          	mov    %ebx,0x24(%esp)
        break;
c00281b0:	8b 5c 24 18          	mov    0x18(%esp),%ebx
        value = va_arg(args, unsigned long long);
c00281b4:	8b 54 24 74          	mov    0x74(%esp),%edx
c00281b8:	8d 4a 08             	lea    0x8(%edx),%ecx
c00281bb:	89 4c 24 74          	mov    %ecx,0x74(%esp)
        break;
c00281bf:	e9 20 ff ff ff       	jmp    c00280e4 <.L123+0x1e>

c00281c4 <.L119>:
        value &= ((uintmax_t)PTRDIFF_MAX << 1) | 1;
c00281c4:	8b 54 24 74          	mov    0x74(%esp),%edx
c00281c8:	8b 0a                	mov    (%edx),%ecx
c00281ca:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c00281ce:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c00281d5:	00 
        break;
c00281d6:	8b 5c 24 18          	mov    0x18(%esp),%ebx
        value = va_arg(args, ptrdiff_t);
c00281da:	8d 4a 04             	lea    0x4(%edx),%ecx
c00281dd:	89 4c 24 74          	mov    %ecx,0x74(%esp)
        break;
c00281e1:	e9 fe fe ff ff       	jmp    c00280e4 <.L123+0x1e>

c00281e6 <.L121>:
        value = va_arg(args, size_t);
c00281e6:	8b 54 24 74          	mov    0x74(%esp),%edx
c00281ea:	8b 0a                	mov    (%edx),%ecx
c00281ec:	bb 00 00 00 00       	mov    $0x0,%ebx
c00281f1:	89 4c 24 20          	mov    %ecx,0x20(%esp)
c00281f5:	89 5c 24 24          	mov    %ebx,0x24(%esp)
        break;
c00281f9:	8b 5c 24 18          	mov    0x18(%esp),%ebx
        value = va_arg(args, size_t);
c00281fd:	8d 52 04             	lea    0x4(%edx),%edx
c0028200:	89 54 24 74          	mov    %edx,0x74(%esp)
        break;
c0028204:	e9 db fe ff ff       	jmp    c00280e4 <.L123+0x1e>
      switch (*format)
c0028209:	3c 58                	cmp    $0x58,%al
c002820b:	75 3d                	jne    c002824a <.L121+0x64>
        b = &base_X;
c002820d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0028211:	8d 80 84 5d ff ff    	lea    -0xa27c(%eax),%eax
        break;
c0028217:	eb 0a                	jmp    c0028223 <.L121+0x3d>
        b = &base_d;
c0028219:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002821d:	8d 80 b4 5d ff ff    	lea    -0xa24c(%eax),%eax
      format_integer(value, false, false, b, &c, output, aux);
c0028223:	83 ec 0c             	sub    $0xc,%esp
c0028226:	55                   	push   %ebp
c0028227:	57                   	push   %edi
c0028228:	8d 54 24 54          	lea    0x54(%esp),%edx
c002822c:	52                   	push   %edx
c002822d:	50                   	push   %eax
c002822e:	6a 00                	push   $0x0
c0028230:	b9 00 00 00 00       	mov    $0x0,%ecx
c0028235:	8b 44 24 40          	mov    0x40(%esp),%eax
c0028239:	8b 54 24 44          	mov    0x44(%esp),%edx
c002823d:	e8 ed f4 ff ff       	call   c002772f <format_integer>
    break;
c0028242:	83 c4 20             	add    $0x20,%esp
c0028245:	e9 3a f9 ff ff       	jmp    c0027b84 <__vprintf+0x44>
        NOT_REACHED();
c002824a:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c002824e:	8d 83 60 34 ff ff    	lea    -0xcba0(%ebx),%eax
c0028254:	50                   	push   %eax
c0028255:	8d 83 08 26 ff ff    	lea    -0xd9f8(%ebx),%eax
c002825b:	50                   	push   %eax
c002825c:	68 17 01 00 00       	push   $0x117
c0028261:	8d 83 91 46 ff ff    	lea    -0xb96f(%ebx),%eax
c0028267:	50                   	push   %eax
c0028268:	e8 28 16 00 00       	call   c0029895 <debug_panic>
        b = &base_o;
c002826d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0028271:	8d 80 a4 5d ff ff    	lea    -0xa25c(%eax),%eax
c0028277:	eb aa                	jmp    c0028223 <.L121+0x3d>

c0028279 <.L152>:
    switch (*format)
c0028279:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c002827d <.L105>:
      char ch = va_arg(args, int);
c002827d:	8b 44 24 74          	mov    0x74(%esp),%eax
c0028281:	8d 70 04             	lea    0x4(%eax),%esi
c0028284:	8b 00                	mov    (%eax),%eax
c0028286:	88 44 24 3f          	mov    %al,0x3f(%esp)
      format_string(&ch, 1, &c, output, aux);
c002828a:	8d 4c 24 40          	lea    0x40(%esp),%ecx
c002828e:	8d 44 24 3f          	lea    0x3f(%esp),%eax
c0028292:	83 ec 08             	sub    $0x8,%esp
c0028295:	55                   	push   %ebp
c0028296:	57                   	push   %edi
c0028297:	ba 01 00 00 00       	mov    $0x1,%edx
c002829c:	e8 cb f7 ff ff       	call   c0027a6c <format_string>
    break;
c00282a1:	83 c4 10             	add    $0x10,%esp
c00282a4:	8b 5c 24 18          	mov    0x18(%esp),%ebx
      char ch = va_arg(args, int);
c00282a8:	89 74 24 74          	mov    %esi,0x74(%esp)
    break;
c00282ac:	e9 d3 f8 ff ff       	jmp    c0027b84 <__vprintf+0x44>

c00282b1 <.L155>:
    switch (*format)
c00282b1:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c00282b5 <.L108>:
      const char *s = va_arg(args, char *);
c00282b5:	8b 44 24 74          	mov    0x74(%esp),%eax
c00282b9:	83 c0 04             	add    $0x4,%eax
c00282bc:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c00282c0:	8b 54 24 74          	mov    0x74(%esp),%edx
c00282c4:	8b 12                	mov    (%edx),%edx
        s = "(null)";
c00282c6:	85 d2                	test   %edx,%edx
c00282c8:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c00282cc:	8d 83 8a 46 ff ff    	lea    -0xb976(%ebx),%eax
c00282d2:	0f 45 c2             	cmovne %edx,%eax
c00282d5:	89 c6                	mov    %eax,%esi
      format_string(s, strnlen(s, c.precision), &c, output, aux);
c00282d7:	83 ec 08             	sub    $0x8,%esp
c00282da:	ff 74 24 18          	pushl  0x18(%esp)
c00282de:	50                   	push   %eax
c00282df:	e8 d9 0b 00 00       	call   c0028ebd <strnlen>
c00282e4:	8d 4c 24 50          	lea    0x50(%esp),%ecx
c00282e8:	83 c4 08             	add    $0x8,%esp
c00282eb:	55                   	push   %ebp
c00282ec:	57                   	push   %edi
c00282ed:	89 c2                	mov    %eax,%edx
c00282ef:	89 f0                	mov    %esi,%eax
c00282f1:	e8 76 f7 ff ff       	call   c0027a6c <format_string>
    break;
c00282f6:	83 c4 10             	add    $0x10,%esp
c00282f9:	8b 5c 24 18          	mov    0x18(%esp),%ebx
      const char *s = va_arg(args, char *);
c00282fd:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0028301:	89 44 24 74          	mov    %eax,0x74(%esp)
    break;
c0028305:	e9 7a f8 ff ff       	jmp    c0027b84 <__vprintf+0x44>

c002830a <.L154>:
    switch (*format)
c002830a:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c002830e <.L107>:
      void *p = va_arg(args, void *);
c002830e:	8b 44 24 74          	mov    0x74(%esp),%eax
c0028312:	8d 70 04             	lea    0x4(%eax),%esi
c0028315:	8b 00                	mov    (%eax),%eax
      c.flags = POUND;
c0028317:	c7 44 24 40 08 00 00 	movl   $0x8,0x40(%esp)
c002831e:	00 
      format_integer((uintptr_t)p, false, false,
c002831f:	ba 00 00 00 00       	mov    $0x0,%edx
c0028324:	83 ec 0c             	sub    $0xc,%esp
c0028327:	55                   	push   %ebp
c0028328:	57                   	push   %edi
c0028329:	8d 4c 24 54          	lea    0x54(%esp),%ecx
c002832d:	51                   	push   %ecx
c002832e:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0028332:	8d 89 94 5d ff ff    	lea    -0xa26c(%ecx),%ecx
c0028338:	51                   	push   %ecx
c0028339:	6a 00                	push   $0x0
c002833b:	b9 00 00 00 00       	mov    $0x0,%ecx
c0028340:	e8 ea f3 ff ff       	call   c002772f <format_integer>
    break;
c0028345:	83 c4 20             	add    $0x20,%esp
c0028348:	8b 5c 24 18          	mov    0x18(%esp),%ebx
      void *p = va_arg(args, void *);
c002834c:	89 74 24 74          	mov    %esi,0x74(%esp)
    break;
c0028350:	e9 2f f8 ff ff       	jmp    c0027b84 <__vprintf+0x44>

c0028355 <.L151>:
    switch (*format)
c0028355:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c0028359 <.L102>:
      __printf("<<no %%%c in kernel>>", output, aux, *format);
c0028359:	ff 74 24 1c          	pushl  0x1c(%esp)
c002835d:	55                   	push   %ebp
c002835e:	57                   	push   %edi
c002835f:	8b 44 24 18          	mov    0x18(%esp),%eax
c0028363:	8d 80 a3 46 ff ff    	lea    -0xb95d(%eax),%eax
c0028369:	50                   	push   %eax
c002836a:	e8 b4 f7 ff ff       	call   c0027b23 <__printf>
      break;
c002836f:	83 c4 10             	add    $0x10,%esp
c0028372:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0028376:	e9 09 f8 ff ff       	jmp    c0027b84 <__vprintf+0x44>

c002837b <.L150>:
    switch (*format)
c002837b:	89 5c 24 18          	mov    %ebx,0x18(%esp)

c002837f <.L101>:
      __printf("<<no %%%c conversion>>", output, aux, *format);
c002837f:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028383:	55                   	push   %ebp
c0028384:	57                   	push   %edi
c0028385:	8b 44 24 18          	mov    0x18(%esp),%eax
c0028389:	8d 80 b9 46 ff ff    	lea    -0xb947(%eax),%eax
c002838f:	50                   	push   %eax
c0028390:	e8 8e f7 ff ff       	call   c0027b23 <__printf>
      break;
c0028395:	83 c4 10             	add    $0x10,%esp
c0028398:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002839c:	e9 e3 f7 ff ff       	jmp    c0027b84 <__vprintf+0x44>

c00283a1 <vsnprintf>:
{
c00283a1:	56                   	push   %esi
c00283a2:	53                   	push   %ebx
c00283a3:	83 ec 14             	sub    $0x14,%esp
c00283a6:	e8 3b a1 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00283ab:	81 c3 91 88 01 00    	add    $0x18891,%ebx
c00283b1:	8b 44 24 24          	mov    0x24(%esp),%eax
c00283b5:	8b 54 24 28          	mov    0x28(%esp),%edx
c00283b9:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
  aux.p = buffer;
c00283bd:	8b 74 24 20          	mov    0x20(%esp),%esi
c00283c1:	89 74 24 04          	mov    %esi,0x4(%esp)
  aux.length = 0;
c00283c5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c00283cc:	00 
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c00283cd:	85 c0                	test   %eax,%eax
c00283cf:	74 2e                	je     c00283ff <vsnprintf+0x5e>
c00283d1:	83 e8 01             	sub    $0x1,%eax
c00283d4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  __vprintf(format, args, vsnprintf_helper, &aux);
c00283d8:	8d 44 24 04          	lea    0x4(%esp),%eax
c00283dc:	50                   	push   %eax
c00283dd:	8d 83 a0 6a fe ff    	lea    -0x19560(%ebx),%eax
c00283e3:	50                   	push   %eax
c00283e4:	51                   	push   %ecx
c00283e5:	52                   	push   %edx
c00283e6:	e8 55 f7 ff ff       	call   c0027b40 <__vprintf>
    *aux.p = '\0';
c00283eb:	8b 44 24 14          	mov    0x14(%esp),%eax
c00283ef:	c6 00 00             	movb   $0x0,(%eax)
c00283f2:	83 c4 10             	add    $0x10,%esp
  return aux.length;
c00283f5:	8b 44 24 08          	mov    0x8(%esp),%eax
}
c00283f9:	83 c4 14             	add    $0x14,%esp
c00283fc:	5b                   	pop    %ebx
c00283fd:	5e                   	pop    %esi
c00283fe:	c3                   	ret    
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c00283ff:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0028406:	00 
  __vprintf(format, args, vsnprintf_helper, &aux);
c0028407:	8d 44 24 04          	lea    0x4(%esp),%eax
c002840b:	50                   	push   %eax
c002840c:	8d 83 a0 6a fe ff    	lea    -0x19560(%ebx),%eax
c0028412:	50                   	push   %eax
c0028413:	51                   	push   %ecx
c0028414:	52                   	push   %edx
c0028415:	e8 26 f7 ff ff       	call   c0027b40 <__vprintf>
c002841a:	83 c4 10             	add    $0x10,%esp
c002841d:	eb d6                	jmp    c00283f5 <vsnprintf+0x54>

c002841f <snprintf>:
{
c002841f:	83 ec 0c             	sub    $0xc,%esp
  va_start(args, format);
c0028422:	8d 44 24 1c          	lea    0x1c(%esp),%eax
  retval = vsnprintf(buffer, buf_size, format, args);
c0028426:	50                   	push   %eax
c0028427:	ff 74 24 1c          	pushl  0x1c(%esp)
c002842b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002842f:	ff 74 24 1c          	pushl  0x1c(%esp)
c0028433:	e8 69 ff ff ff       	call   c00283a1 <vsnprintf>
}
c0028438:	83 c4 1c             	add    $0x1c,%esp
c002843b:	c3                   	ret    

c002843c <hex_dump>:
   arranged 16 per line.  Numeric offsets are also included,
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */
void hex_dump(uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c002843c:	55                   	push   %ebp
c002843d:	57                   	push   %edi
c002843e:	56                   	push   %esi
c002843f:	53                   	push   %ebx
c0028440:	83 ec 1c             	sub    $0x1c,%esp
c0028443:	e8 ae a0 00 00       	call   c00324f6 <__x86.get_pc_thunk.di>
c0028448:	81 c7 f4 87 01 00    	add    $0x187f4,%edi
c002844e:	0f b6 44 24 3c       	movzbl 0x3c(%esp),%eax
c0028453:	88 44 24 0b          	mov    %al,0xb(%esp)
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
c0028457:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c002845c:	0f 84 c6 01 00 00    	je     c0028628 <hex_dump+0x1ec>
    if (end - start > size)
      end = start + size;
    n = end - start;

    /* Print line. */
    printf("%08jx  ", (uintmax_t)ROUND_DOWN(ofs, per_line));
c0028462:	8d 87 d0 46 ff ff    	lea    -0xb930(%edi),%eax
c0028468:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002846c:	e9 9b 00 00 00       	jmp    c002850c <hex_dump+0xd0>
    for (i = 0; i < start; i++)
c0028471:	89 eb                	mov    %ebp,%ebx
c0028473:	e9 02 01 00 00       	jmp    c002857a <hex_dump+0x13e>
    if (ascii)
    {
      for (; i < per_line; i++)
        printf("   ");
      printf("|");
      for (i = 0; i < start; i++)
c0028478:	89 ee                	mov    %ebp,%esi
        printf(" ");
      for (; i < end; i++)
c002847a:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c002847f:	0f 84 9a 01 00 00    	je     c002861f <hex_dump+0x1e3>
        printf("%c",
               isprint(buf[i - start]) ? buf[i - start] : '.');
c0028485:	8b 44 24 34          	mov    0x34(%esp),%eax
c0028489:	29 e8                	sub    %ebp,%eax
c002848b:	89 c5                	mov    %eax,%ebp
c002848d:	0f b6 44 35 00       	movzbl 0x0(%ebp,%esi,1),%eax
static inline int isprint(int c) { return c >= 32 && c < 127; }
c0028492:	0f b6 d0             	movzbl %al,%edx
c0028495:	83 ea 20             	sub    $0x20,%edx
c0028498:	83 fa 5f             	cmp    $0x5f,%edx
c002849b:	b9 2e 00 00 00       	mov    $0x2e,%ecx
c00284a0:	0f 43 c1             	cmovae %ecx,%eax
        printf("%c",
c00284a3:	83 ec 0c             	sub    $0xc,%esp
c00284a6:	0f b6 c0             	movzbl %al,%eax
c00284a9:	50                   	push   %eax
c00284aa:	89 fb                	mov    %edi,%ebx
c00284ac:	e8 2f 34 00 00       	call   c002b8e0 <putchar>
      for (; i < end; i++)
c00284b1:	83 c6 01             	add    $0x1,%esi
c00284b4:	83 c4 10             	add    $0x10,%esp
c00284b7:	39 34 24             	cmp    %esi,(%esp)
c00284ba:	77 d1                	ja     c002848d <hex_dump+0x51>
      for (; i < per_line; i++)
c00284bc:	83 fe 0f             	cmp    $0xf,%esi
c00284bf:	77 17                	ja     c00284d8 <hex_dump+0x9c>
        printf(" ");
c00284c1:	83 ec 0c             	sub    $0xc,%esp
c00284c4:	6a 20                	push   $0x20
c00284c6:	89 fb                	mov    %edi,%ebx
c00284c8:	e8 13 34 00 00       	call   c002b8e0 <putchar>
      for (; i < per_line; i++)
c00284cd:	83 c6 01             	add    $0x1,%esi
c00284d0:	83 c4 10             	add    $0x10,%esp
c00284d3:	83 fe 0f             	cmp    $0xf,%esi
c00284d6:	76 e9                	jbe    c00284c1 <hex_dump+0x85>
      printf("|");
c00284d8:	83 ec 0c             	sub    $0xc,%esp
c00284db:	6a 7c                	push   $0x7c
c00284dd:	89 fb                	mov    %edi,%ebx
c00284df:	e8 fc 33 00 00       	call   c002b8e0 <putchar>
c00284e4:	83 c4 10             	add    $0x10,%esp
    }
    printf("\n");
c00284e7:	83 ec 0c             	sub    $0xc,%esp
c00284ea:	6a 0a                	push   $0xa
c00284ec:	89 fb                	mov    %edi,%ebx
c00284ee:	e8 ed 33 00 00       	call   c002b8e0 <putchar>

    ofs += n;
c00284f3:	8b 44 24 14          	mov    0x14(%esp),%eax
c00284f7:	01 44 24 40          	add    %eax,0x40(%esp)
    buf += n;
c00284fb:	01 44 24 44          	add    %eax,0x44(%esp)
  while (size > 0)
c00284ff:	83 c4 10             	add    $0x10,%esp
c0028502:	29 44 24 38          	sub    %eax,0x38(%esp)
c0028506:	0f 84 1c 01 00 00    	je     c0028628 <hex_dump+0x1ec>
    start = ofs % per_line;
c002850c:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c0028510:	83 e5 0f             	and    $0xf,%ebp
    if (end - start > size)
c0028513:	ba 10 00 00 00       	mov    $0x10,%edx
c0028518:	29 ea                	sub    %ebp,%edx
      end = start + size;
c002851a:	89 e8                	mov    %ebp,%eax
c002851c:	03 44 24 38          	add    0x38(%esp),%eax
c0028520:	3b 54 24 38          	cmp    0x38(%esp),%edx
c0028524:	b9 10 00 00 00       	mov    $0x10,%ecx
c0028529:	0f 46 c1             	cmovbe %ecx,%eax
c002852c:	89 04 24             	mov    %eax,(%esp)
    n = end - start;
c002852f:	29 e8                	sub    %ebp,%eax
c0028531:	89 44 24 04          	mov    %eax,0x4(%esp)
    printf("%08jx  ", (uintmax_t)ROUND_DOWN(ofs, per_line));
c0028535:	83 ec 04             	sub    $0x4,%esp
c0028538:	8b 44 24 34          	mov    0x34(%esp),%eax
c002853c:	83 e0 f0             	and    $0xfffffff0,%eax
c002853f:	ba 00 00 00 00       	mov    $0x0,%edx
c0028544:	52                   	push   %edx
c0028545:	50                   	push   %eax
c0028546:	ff 74 24 18          	pushl  0x18(%esp)
c002854a:	e8 af f5 ff ff       	call   c0027afe <printf>
    for (i = 0; i < start; i++)
c002854f:	83 c4 10             	add    $0x10,%esp
c0028552:	85 ed                	test   %ebp,%ebp
c0028554:	0f 84 17 ff ff ff    	je     c0028471 <hex_dump+0x35>
c002855a:	bb 00 00 00 00       	mov    $0x0,%ebx
      printf("   ");
c002855f:	8d b7 d8 46 ff ff    	lea    -0xb928(%edi),%esi
c0028565:	83 ec 0c             	sub    $0xc,%esp
c0028568:	56                   	push   %esi
c0028569:	e8 90 f5 ff ff       	call   c0027afe <printf>
    for (i = 0; i < start; i++)
c002856e:	83 c3 01             	add    $0x1,%ebx
c0028571:	83 c4 10             	add    $0x10,%esp
c0028574:	39 dd                	cmp    %ebx,%ebp
c0028576:	75 ed                	jne    c0028565 <hex_dump+0x129>
c0028578:	89 eb                	mov    %ebp,%ebx
    for (; i < end; i++)
c002857a:	39 1c 24             	cmp    %ebx,(%esp)
c002857d:	76 36                	jbe    c00285b5 <hex_dump+0x179>
      printf("%02hhx%c",
c002857f:	be 20 00 00 00       	mov    $0x20,%esi
c0028584:	83 fb 07             	cmp    $0x7,%ebx
c0028587:	b8 2d 00 00 00       	mov    $0x2d,%eax
c002858c:	0f 45 c6             	cmovne %esi,%eax
c002858f:	83 ec 04             	sub    $0x4,%esp
c0028592:	50                   	push   %eax
             buf[i - start], i == per_line / 2 - 1 ? '-' : ' ');
c0028593:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0028597:	29 e8                	sub    %ebp,%eax
      printf("%02hhx%c",
c0028599:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
c002859d:	50                   	push   %eax
c002859e:	8d 87 dc 46 ff ff    	lea    -0xb924(%edi),%eax
c00285a4:	50                   	push   %eax
c00285a5:	e8 54 f5 ff ff       	call   c0027afe <printf>
    for (; i < end; i++)
c00285aa:	83 c3 01             	add    $0x1,%ebx
c00285ad:	83 c4 10             	add    $0x10,%esp
c00285b0:	39 1c 24             	cmp    %ebx,(%esp)
c00285b3:	75 cf                	jne    c0028584 <hex_dump+0x148>
    if (ascii)
c00285b5:	80 7c 24 0b 00       	cmpb   $0x0,0xb(%esp)
c00285ba:	0f 84 27 ff ff ff    	je     c00284e7 <hex_dump+0xab>
      for (; i < per_line; i++)
c00285c0:	83 fb 0f             	cmp    $0xf,%ebx
c00285c3:	77 1a                	ja     c00285df <hex_dump+0x1a3>
        printf("   ");
c00285c5:	8d b7 d8 46 ff ff    	lea    -0xb928(%edi),%esi
c00285cb:	83 ec 0c             	sub    $0xc,%esp
c00285ce:	56                   	push   %esi
c00285cf:	e8 2a f5 ff ff       	call   c0027afe <printf>
      for (; i < per_line; i++)
c00285d4:	83 c3 01             	add    $0x1,%ebx
c00285d7:	83 c4 10             	add    $0x10,%esp
c00285da:	83 fb 10             	cmp    $0x10,%ebx
c00285dd:	75 ec                	jne    c00285cb <hex_dump+0x18f>
      printf("|");
c00285df:	83 ec 0c             	sub    $0xc,%esp
c00285e2:	6a 7c                	push   $0x7c
c00285e4:	89 fb                	mov    %edi,%ebx
c00285e6:	e8 f5 32 00 00       	call   c002b8e0 <putchar>
      for (i = 0; i < start; i++)
c00285eb:	83 c4 10             	add    $0x10,%esp
c00285ee:	85 ed                	test   %ebp,%ebp
c00285f0:	0f 84 82 fe ff ff    	je     c0028478 <hex_dump+0x3c>
c00285f6:	be 00 00 00 00       	mov    $0x0,%esi
        printf(" ");
c00285fb:	83 ec 0c             	sub    $0xc,%esp
c00285fe:	6a 20                	push   $0x20
c0028600:	89 fb                	mov    %edi,%ebx
c0028602:	e8 d9 32 00 00       	call   c002b8e0 <putchar>
      for (i = 0; i < start; i++)
c0028607:	83 c6 01             	add    $0x1,%esi
c002860a:	83 c4 10             	add    $0x10,%esp
c002860d:	39 f5                	cmp    %esi,%ebp
c002860f:	75 ea                	jne    c00285fb <hex_dump+0x1bf>
      for (; i < end; i++)
c0028611:	39 34 24             	cmp    %esi,(%esp)
c0028614:	0f 87 6b fe ff ff    	ja     c0028485 <hex_dump+0x49>
c002861a:	e9 9d fe ff ff       	jmp    c00284bc <hex_dump+0x80>
      for (i = 0; i < start; i++)
c002861f:	8b 74 24 04          	mov    0x4(%esp),%esi
c0028623:	e9 99 fe ff ff       	jmp    c00284c1 <hex_dump+0x85>
    size -= n;
  }
}
c0028628:	83 c4 1c             	add    $0x1c,%esp
c002862b:	5b                   	pop    %ebx
c002862c:	5e                   	pop    %esi
c002862d:	5f                   	pop    %edi
c002862e:	5d                   	pop    %ebp
c002862f:	c3                   	ret    

c0028630 <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void print_human_readable_size(uint64_t size)
{
c0028630:	57                   	push   %edi
c0028631:	56                   	push   %esi
c0028632:	53                   	push   %ebx
c0028633:	e8 b6 9e 00 00       	call   c00324ee <__x86.get_pc_thunk.dx>
c0028638:	81 c2 04 86 01 00    	add    $0x18604,%edx
c002863e:	8b 74 24 10          	mov    0x10(%esp),%esi
c0028642:	8b 7c 24 14          	mov    0x14(%esp),%edi
  if (size == 1)
c0028646:	89 f0                	mov    %esi,%eax
c0028648:	83 f0 01             	xor    $0x1,%eax
c002864b:	89 f9                	mov    %edi,%ecx
c002864d:	09 c1                	or     %eax,%ecx
c002864f:	74 24                	je     c0028675 <print_human_readable_size+0x45>
  else
  {
    static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
    const char **fp;

    for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0028651:	83 ff 00             	cmp    $0x0,%edi
c0028654:	77 0e                	ja     c0028664 <print_human_readable_size+0x34>
c0028656:	8d 82 e4 ff ff ff    	lea    -0x1c(%edx),%eax
c002865c:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
c0028662:	76 42                	jbe    c00286a6 <print_human_readable_size+0x76>
c0028664:	8d 82 e4 ff ff ff    	lea    -0x1c(%edx),%eax
c002866a:	83 ba e8 ff ff ff 00 	cmpl   $0x0,-0x18(%edx)
c0028671:	75 1c                	jne    c002868f <print_human_readable_size+0x5f>
c0028673:	eb 31                	jmp    c00286a6 <print_human_readable_size+0x76>
    printf("1 byte");
c0028675:	83 ec 0c             	sub    $0xc,%esp
c0028678:	8d 82 e5 46 ff ff    	lea    -0xb91b(%edx),%eax
c002867e:	50                   	push   %eax
c002867f:	e8 7a f4 ff ff       	call   c0027afe <printf>
c0028684:	83 c4 10             	add    $0x10,%esp
c0028687:	eb 30                	jmp    c00286b9 <print_human_readable_size+0x89>
    for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0028689:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c002868d:	74 17                	je     c00286a6 <print_human_readable_size+0x76>
      size /= 1024;
c002868f:	0f ac fe 0a          	shrd   $0xa,%edi,%esi
c0028693:	c1 ef 0a             	shr    $0xa,%edi
    for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c0028696:	83 c0 04             	add    $0x4,%eax
c0028699:	83 ff 00             	cmp    $0x0,%edi
c002869c:	77 eb                	ja     c0028689 <print_human_readable_size+0x59>
c002869e:	81 fe ff 03 00 00    	cmp    $0x3ff,%esi
c00286a4:	77 e3                	ja     c0028689 <print_human_readable_size+0x59>
    printf("%" PRIu64 " %s", size, *fp);
c00286a6:	ff 30                	pushl  (%eax)
c00286a8:	57                   	push   %edi
c00286a9:	56                   	push   %esi
c00286aa:	8d 82 ec 46 ff ff    	lea    -0xb914(%edx),%eax
c00286b0:	50                   	push   %eax
c00286b1:	e8 48 f4 ff ff       	call   c0027afe <printf>
c00286b6:	83 c4 10             	add    $0x10,%esp
  }
}
c00286b9:	5b                   	pop    %ebx
c00286ba:	5e                   	pop    %esi
c00286bb:	5f                   	pop    %edi
c00286bc:	c3                   	ret    

c00286bd <compare_thunk>:
}

/* Compares A and B by calling the AUX function. */
static int
compare_thunk(const void *a, const void *b, void *aux)
{
c00286bd:	83 ec 14             	sub    $0x14,%esp
  int (**compare)(const void *, const void *) = aux;
  return (*compare)(a, b);
c00286c0:	ff 74 24 1c          	pushl  0x1c(%esp)
c00286c4:	ff 74 24 1c          	pushl  0x1c(%esp)
c00286c8:	8b 44 24 28          	mov    0x28(%esp),%eax
c00286cc:	ff 10                	call   *(%eax)
}
c00286ce:	83 c4 1c             	add    $0x1c,%esp
c00286d1:	c3                   	ret    

c00286d2 <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap(unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c00286d2:	55                   	push   %ebp
c00286d3:	57                   	push   %edi
c00286d4:	56                   	push   %esi
c00286d5:	53                   	push   %ebx
c00286d6:	8b 7c 24 14          	mov    0x14(%esp),%edi
  unsigned char *a = array + (a_idx - 1) * size;
c00286da:	8d 5a ff             	lea    -0x1(%edx),%ebx
c00286dd:	0f af df             	imul   %edi,%ebx
  unsigned char *b = array + (b_idx - 1) * size;
c00286e0:	83 e9 01             	sub    $0x1,%ecx
c00286e3:	0f af cf             	imul   %edi,%ecx
  size_t i;

  for (i = 0; i < size; i++)
c00286e6:	85 ff                	test   %edi,%edi
c00286e8:	74 23                	je     c002870d <do_swap+0x3b>
c00286ea:	89 dd                	mov    %ebx,%ebp
c00286ec:	8d 14 18             	lea    (%eax,%ebx,1),%edx
c00286ef:	01 f8                	add    %edi,%eax
c00286f1:	8d 3c 18             	lea    (%eax,%ebx,1),%edi
  {
    unsigned char t = a[i];
c00286f4:	0f b6 32             	movzbl (%edx),%esi
c00286f7:	89 d0                	mov    %edx,%eax
c00286f9:	29 e8                	sub    %ebp,%eax
    a[i] = b[i];
c00286fb:	0f b6 1c 08          	movzbl (%eax,%ecx,1),%ebx
c00286ff:	88 1a                	mov    %bl,(%edx)
    b[i] = t;
c0028701:	89 f3                	mov    %esi,%ebx
c0028703:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
c0028706:	83 c2 01             	add    $0x1,%edx
  for (i = 0; i < size; i++)
c0028709:	39 fa                	cmp    %edi,%edx
c002870b:	75 e7                	jne    c00286f4 <do_swap+0x22>
  }
}
c002870d:	5b                   	pop    %ebx
c002870e:	5e                   	pop    %esi
c002870f:	5f                   	pop    %edi
c0028710:	5d                   	pop    %ebp
c0028711:	c3                   	ret    

c0028712 <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify(unsigned char *array, size_t i, size_t cnt, size_t size,
        int (*compare)(const void *, const void *, void *aux),
        void *aux)
{
c0028712:	55                   	push   %ebp
c0028713:	57                   	push   %edi
c0028714:	56                   	push   %esi
c0028715:	53                   	push   %ebx
c0028716:	83 ec 1c             	sub    $0x1c,%esp
c0028719:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002871d:	89 d7                	mov    %edx,%edi
c002871f:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c0028723:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c0028727:	eb 4a                	jmp    c0028773 <heapify+0x61>
  return compare(array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0028729:	83 ec 04             	sub    $0x4,%esp
c002872c:	ff 74 24 3c          	pushl  0x3c(%esp)
c0028730:	8d 47 ff             	lea    -0x1(%edi),%eax
c0028733:	0f af c5             	imul   %ebp,%eax
c0028736:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c002873a:	01 c8                	add    %ecx,%eax
c002873c:	50                   	push   %eax
c002873d:	8d 43 ff             	lea    -0x1(%ebx),%eax
c0028740:	0f af c5             	imul   %ebp,%eax
c0028743:	01 c8                	add    %ecx,%eax
c0028745:	50                   	push   %eax
c0028746:	ff 54 24 44          	call   *0x44(%esp)
    /* Set `max' to the index of the largest element among I
         and its children (if any). */
    size_t left = 2 * i;
    size_t right = 2 * i + 1;
    size_t max = i;
    if (left <= cnt && do_compare(array, left, max, size, compare, aux) > 0)
c002874a:	83 c4 10             	add    $0x10,%esp
c002874d:	85 c0                	test   %eax,%eax
c002874f:	7e 2e                	jle    c002877f <heapify+0x6d>
      max = left;
    if (right <= cnt && do_compare(array, right, max, size, compare, aux) > 0)
c0028751:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0028755:	76 5b                	jbe    c00287b2 <heapify+0xa0>
      max = left;
c0028757:	89 de                	mov    %ebx,%esi
      max = right;

    /* If the maximum value is already in element I, we're
         done. */
    if (max == i)
c0028759:	39 f7                	cmp    %esi,%edi
c002875b:	74 4d                	je     c00287aa <heapify+0x98>
      break;

    /* Swap and continue down the heap. */
    do_swap(array, i, max, size);
c002875d:	83 ec 0c             	sub    $0xc,%esp
c0028760:	55                   	push   %ebp
c0028761:	89 f1                	mov    %esi,%ecx
c0028763:	89 fa                	mov    %edi,%edx
c0028765:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0028769:	e8 64 ff ff ff       	call   c00286d2 <do_swap>
c002876e:	89 f7                	mov    %esi,%edi
  {
c0028770:	83 c4 10             	add    $0x10,%esp
    size_t left = 2 * i;
c0028773:	8d 1c 3f             	lea    (%edi,%edi,1),%ebx
    size_t right = 2 * i + 1;
c0028776:	8d 73 01             	lea    0x1(%ebx),%esi
    if (left <= cnt && do_compare(array, left, max, size, compare, aux) > 0)
c0028779:	3b 5c 24 08          	cmp    0x8(%esp),%ebx
c002877d:	76 aa                	jbe    c0028729 <heapify+0x17>
    if (right <= cnt && do_compare(array, right, max, size, compare, aux) > 0)
c002877f:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0028783:	77 25                	ja     c00287aa <heapify+0x98>
  return compare(array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0028785:	83 ec 04             	sub    $0x4,%esp
c0028788:	ff 74 24 3c          	pushl  0x3c(%esp)
c002878c:	8d 47 ff             	lea    -0x1(%edi),%eax
c002878f:	0f af c5             	imul   %ebp,%eax
c0028792:	8b 54 24 14          	mov    0x14(%esp),%edx
c0028796:	01 d0                	add    %edx,%eax
c0028798:	50                   	push   %eax
c0028799:	0f af dd             	imul   %ebp,%ebx
c002879c:	01 d3                	add    %edx,%ebx
c002879e:	53                   	push   %ebx
c002879f:	ff 54 24 44          	call   *0x44(%esp)
    if (right <= cnt && do_compare(array, right, max, size, compare, aux) > 0)
c00287a3:	83 c4 10             	add    $0x10,%esp
c00287a6:	85 c0                	test   %eax,%eax
c00287a8:	7f af                	jg     c0028759 <heapify+0x47>
    i = max;
  }
}
c00287aa:	83 c4 1c             	add    $0x1c,%esp
c00287ad:	5b                   	pop    %ebx
c00287ae:	5e                   	pop    %esi
c00287af:	5f                   	pop    %edi
c00287b0:	5d                   	pop    %ebp
c00287b1:	c3                   	ret    
  return compare(array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c00287b2:	83 ec 04             	sub    $0x4,%esp
c00287b5:	ff 74 24 3c          	pushl  0x3c(%esp)
c00287b9:	8d 43 ff             	lea    -0x1(%ebx),%eax
c00287bc:	0f af c5             	imul   %ebp,%eax
c00287bf:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c00287c3:	01 c8                	add    %ecx,%eax
c00287c5:	50                   	push   %eax
c00287c6:	89 d8                	mov    %ebx,%eax
c00287c8:	0f af c5             	imul   %ebp,%eax
c00287cb:	01 c8                	add    %ecx,%eax
c00287cd:	50                   	push   %eax
c00287ce:	ff 54 24 44          	call   *0x44(%esp)
    if (right <= cnt && do_compare(array, right, max, size, compare, aux) > 0)
c00287d2:	83 c4 10             	add    $0x10,%esp
c00287d5:	85 c0                	test   %eax,%eax
      max = left;
c00287d7:	0f 4e f3             	cmovle %ebx,%esi
c00287da:	e9 7a ff ff ff       	jmp    c0028759 <heapify+0x47>

c00287df <atoi>:
{
c00287df:	56                   	push   %esi
c00287e0:	53                   	push   %ebx
c00287e1:	83 ec 04             	sub    $0x4,%esp
c00287e4:	e8 fd 9c 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00287e9:	81 c3 53 84 01 00    	add    $0x18453,%ebx
c00287ef:	8b 54 24 10          	mov    0x10(%esp),%edx
  ASSERT(s != NULL);
c00287f3:	85 d2                	test   %edx,%edx
c00287f5:	75 29                	jne    c0028820 <atoi+0x41>
c00287f7:	83 ec 0c             	sub    $0xc,%esp
c00287fa:	8d 83 8b 47 ff ff    	lea    -0xb875(%ebx),%eax
c0028800:	50                   	push   %eax
c0028801:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0028807:	50                   	push   %eax
c0028808:	8d 83 1c 26 ff ff    	lea    -0xd9e4(%ebx),%eax
c002880e:	50                   	push   %eax
c002880f:	6a 0e                	push   $0xe
c0028811:	8d 83 3c 47 ff ff    	lea    -0xb8c4(%ebx),%eax
c0028817:	50                   	push   %eax
c0028818:	e8 78 10 00 00       	call   c0029895 <debug_panic>
    s++;
c002881d:	83 c2 01             	add    $0x1,%edx
  while (isspace((unsigned char)*s))
c0028820:	0f b6 02             	movzbl (%edx),%eax
  return (c == ' ' || c == '\f' || c == '\n' || c == '\r' || c == '\t' || c == '\v');
c0028823:	3c 20                	cmp    $0x20,%al
c0028825:	74 f6                	je     c002881d <atoi+0x3e>
c0028827:	8d 48 f7             	lea    -0x9(%eax),%ecx
c002882a:	80 f9 04             	cmp    $0x4,%cl
c002882d:	76 ee                	jbe    c002881d <atoi+0x3e>
  if (*s == '+')
c002882f:	3c 2b                	cmp    $0x2b,%al
c0028831:	74 40                	je     c0028873 <atoi+0x94>
  negative = false;
c0028833:	bb 00 00 00 00       	mov    $0x0,%ebx
  else if (*s == '-')
c0028838:	3c 2d                	cmp    $0x2d,%al
c002883a:	74 41                	je     c002887d <atoi+0x9e>
  for (value = 0; isdigit(*s); s++)
c002883c:	0f be 0a             	movsbl (%edx),%ecx
static inline int isdigit(int c) { return c >= '0' && c <= '9'; }
c002883f:	8d 41 d0             	lea    -0x30(%ecx),%eax
c0028842:	83 f8 09             	cmp    $0x9,%eax
c0028845:	77 40                	ja     c0028887 <atoi+0xa8>
c0028847:	b8 00 00 00 00       	mov    $0x0,%eax
    value = value * 10 - (*s - '0');
c002884c:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002884f:	01 c0                	add    %eax,%eax
c0028851:	83 e9 30             	sub    $0x30,%ecx
c0028854:	29 c8                	sub    %ecx,%eax
  for (value = 0; isdigit(*s); s++)
c0028856:	83 c2 01             	add    $0x1,%edx
c0028859:	0f be 0a             	movsbl (%edx),%ecx
c002885c:	8d 71 d0             	lea    -0x30(%ecx),%esi
c002885f:	83 fe 09             	cmp    $0x9,%esi
c0028862:	76 e8                	jbe    c002884c <atoi+0x6d>
    value = -value;
c0028864:	89 c2                	mov    %eax,%edx
c0028866:	f7 da                	neg    %edx
c0028868:	84 db                	test   %bl,%bl
c002886a:	0f 44 c2             	cmove  %edx,%eax
}
c002886d:	83 c4 04             	add    $0x4,%esp
c0028870:	5b                   	pop    %ebx
c0028871:	5e                   	pop    %esi
c0028872:	c3                   	ret    
    s++;
c0028873:	83 c2 01             	add    $0x1,%edx
  negative = false;
c0028876:	bb 00 00 00 00       	mov    $0x0,%ebx
c002887b:	eb bf                	jmp    c002883c <atoi+0x5d>
    s++;
c002887d:	83 c2 01             	add    $0x1,%edx
    negative = true;
c0028880:	bb 01 00 00 00       	mov    $0x1,%ebx
c0028885:	eb b5                	jmp    c002883c <atoi+0x5d>
  for (value = 0; isdigit(*s); s++)
c0028887:	b8 00 00 00 00       	mov    $0x0,%eax
c002888c:	eb d6                	jmp    c0028864 <atoi+0x85>

c002888e <sort>:
   than zero if A < B, zero if A == B, greater than zero if A >
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void sort(void *array, size_t cnt, size_t size,
          int (*compare)(const void *, const void *, void *aux),
          void *aux)
{
c002888e:	55                   	push   %ebp
c002888f:	57                   	push   %edi
c0028890:	56                   	push   %esi
c0028891:	53                   	push   %ebx
c0028892:	83 ec 0c             	sub    $0xc,%esp
c0028895:	e8 4c 9c 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002889a:	81 c3 a2 83 01 00    	add    $0x183a2,%ebx
c00288a0:	8b 7c 24 20          	mov    0x20(%esp),%edi
c00288a4:	8b 74 24 24          	mov    0x24(%esp),%esi
c00288a8:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  size_t i;

  ASSERT(array != NULL || cnt == 0);
c00288ac:	85 ff                	test   %edi,%edi
c00288ae:	75 08                	jne    c00288b8 <sort+0x2a>
c00288b0:	85 f6                	test   %esi,%esi
c00288b2:	0f 85 93 00 00 00    	jne    c002894b <sort+0xbd>
  ASSERT(compare != NULL);
c00288b8:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c00288bd:	0f 84 b1 00 00 00    	je     c0028974 <sort+0xe6>
  ASSERT(size > 0);
c00288c3:	85 ed                	test   %ebp,%ebp
c00288c5:	0f 84 d2 00 00 00    	je     c002899d <sort+0x10f>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c00288cb:	89 f3                	mov    %esi,%ebx
c00288cd:	d1 eb                	shr    %ebx
c00288cf:	74 33                	je     c0028904 <sort+0x76>
c00288d1:	89 74 24 24          	mov    %esi,0x24(%esp)
c00288d5:	89 fe                	mov    %edi,%esi
c00288d7:	8b 7c 24 24          	mov    0x24(%esp),%edi
    heapify(array, i, cnt, size, compare, aux);
c00288db:	83 ec 04             	sub    $0x4,%esp
c00288de:	ff 74 24 34          	pushl  0x34(%esp)
c00288e2:	ff 74 24 34          	pushl  0x34(%esp)
c00288e6:	55                   	push   %ebp
c00288e7:	89 f9                	mov    %edi,%ecx
c00288e9:	89 da                	mov    %ebx,%edx
c00288eb:	89 f0                	mov    %esi,%eax
c00288ed:	e8 20 fe ff ff       	call   c0028712 <heapify>
  for (i = cnt / 2; i > 0; i--)
c00288f2:	83 c4 10             	add    $0x10,%esp
c00288f5:	83 eb 01             	sub    $0x1,%ebx
c00288f8:	75 e1                	jne    c00288db <sort+0x4d>
c00288fa:	89 7c 24 24          	mov    %edi,0x24(%esp)
c00288fe:	89 f7                	mov    %esi,%edi
c0028900:	8b 74 24 24          	mov    0x24(%esp),%esi

  /* Sort the heap. */
  for (i = cnt; i > 1; i--)
c0028904:	83 fe 01             	cmp    $0x1,%esi
c0028907:	76 3a                	jbe    c0028943 <sort+0xb5>
c0028909:	89 fb                	mov    %edi,%ebx
c002890b:	8b 7c 24 30          	mov    0x30(%esp),%edi
  {
    do_swap(array, 1, i, size);
c002890f:	83 ec 0c             	sub    $0xc,%esp
c0028912:	55                   	push   %ebp
c0028913:	89 f1                	mov    %esi,%ecx
c0028915:	ba 01 00 00 00       	mov    $0x1,%edx
c002891a:	89 d8                	mov    %ebx,%eax
c002891c:	e8 b1 fd ff ff       	call   c00286d2 <do_swap>
    heapify(array, 1, i - 1, size, compare, aux);
c0028921:	83 ee 01             	sub    $0x1,%esi
c0028924:	83 c4 0c             	add    $0xc,%esp
c0028927:	57                   	push   %edi
c0028928:	ff 74 24 34          	pushl  0x34(%esp)
c002892c:	55                   	push   %ebp
c002892d:	89 f1                	mov    %esi,%ecx
c002892f:	ba 01 00 00 00       	mov    $0x1,%edx
c0028934:	89 d8                	mov    %ebx,%eax
c0028936:	e8 d7 fd ff ff       	call   c0028712 <heapify>
  for (i = cnt; i > 1; i--)
c002893b:	83 c4 10             	add    $0x10,%esp
c002893e:	83 fe 01             	cmp    $0x1,%esi
c0028941:	75 cc                	jne    c002890f <sort+0x81>
  }
}
c0028943:	83 c4 0c             	add    $0xc,%esp
c0028946:	5b                   	pop    %ebx
c0028947:	5e                   	pop    %esi
c0028948:	5f                   	pop    %edi
c0028949:	5d                   	pop    %ebp
c002894a:	c3                   	ret    
  ASSERT(array != NULL || cnt == 0);
c002894b:	83 ec 0c             	sub    $0xc,%esp
c002894e:	8d 83 4f 47 ff ff    	lea    -0xb8b1(%ebx),%eax
c0028954:	50                   	push   %eax
c0028955:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002895b:	50                   	push   %eax
c002895c:	8d 83 14 26 ff ff    	lea    -0xd9ec(%ebx),%eax
c0028962:	50                   	push   %eax
c0028963:	68 86 00 00 00       	push   $0x86
c0028968:	8d 83 3c 47 ff ff    	lea    -0xb8c4(%ebx),%eax
c002896e:	50                   	push   %eax
c002896f:	e8 21 0f 00 00       	call   c0029895 <debug_panic>
  ASSERT(compare != NULL);
c0028974:	83 ec 0c             	sub    $0xc,%esp
c0028977:	8d 83 69 47 ff ff    	lea    -0xb897(%ebx),%eax
c002897d:	50                   	push   %eax
c002897e:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0028984:	50                   	push   %eax
c0028985:	8d 83 14 26 ff ff    	lea    -0xd9ec(%ebx),%eax
c002898b:	50                   	push   %eax
c002898c:	68 87 00 00 00       	push   $0x87
c0028991:	8d 83 3c 47 ff ff    	lea    -0xb8c4(%ebx),%eax
c0028997:	50                   	push   %eax
c0028998:	e8 f8 0e 00 00       	call   c0029895 <debug_panic>
  ASSERT(size > 0);
c002899d:	83 ec 0c             	sub    $0xc,%esp
c00289a0:	8d 83 79 47 ff ff    	lea    -0xb887(%ebx),%eax
c00289a6:	50                   	push   %eax
c00289a7:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00289ad:	50                   	push   %eax
c00289ae:	8d 83 14 26 ff ff    	lea    -0xd9ec(%ebx),%eax
c00289b4:	50                   	push   %eax
c00289b5:	68 88 00 00 00       	push   $0x88
c00289ba:	8d 83 3c 47 ff ff    	lea    -0xb8c4(%ebx),%eax
c00289c0:	50                   	push   %eax
c00289c1:	e8 cf 0e 00 00       	call   c0029895 <debug_panic>

c00289c6 <qsort>:
{
c00289c6:	83 ec 18             	sub    $0x18,%esp
c00289c9:	e8 1c 9b 00 00       	call   c00324ea <__x86.get_pc_thunk.ax>
c00289ce:	05 6e 82 01 00       	add    $0x1826e,%eax
  sort(array, cnt, size, compare_thunk, &compare);
c00289d3:	8d 54 24 28          	lea    0x28(%esp),%edx
c00289d7:	52                   	push   %edx
c00289d8:	8d 80 81 7a fe ff    	lea    -0x1857f(%eax),%eax
c00289de:	50                   	push   %eax
c00289df:	ff 74 24 2c          	pushl  0x2c(%esp)
c00289e3:	ff 74 24 2c          	pushl  0x2c(%esp)
c00289e7:	ff 74 24 2c          	pushl  0x2c(%esp)
c00289eb:	e8 9e fe ff ff       	call   c002888e <sort>
}
c00289f0:	83 c4 2c             	add    $0x2c,%esp
c00289f3:	c3                   	ret    

c00289f4 <binary_search>:
   B. */
void *
binary_search(const void *key, const void *array, size_t cnt, size_t size,
              int (*compare)(const void *, const void *, void *aux),
              void *aux)
{
c00289f4:	55                   	push   %ebp
c00289f5:	57                   	push   %edi
c00289f6:	56                   	push   %esi
c00289f7:	53                   	push   %ebx
c00289f8:	83 ec 0c             	sub    $0xc,%esp
c00289fb:	8b 74 24 24          	mov    0x24(%esp),%esi
c00289ff:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  const unsigned char *first = array;
  const unsigned char *last = array + size * cnt;
c0028a03:	89 fd                	mov    %edi,%ebp
c0028a05:	0f af 6c 24 28       	imul   0x28(%esp),%ebp
c0028a0a:	01 f5                	add    %esi,%ebp

  while (first < last)
c0028a0c:	39 ee                	cmp    %ebp,%esi
c0028a0e:	72 0d                	jb     c0028a1d <binary_search+0x29>
      first = middle + size;
    else
      return (void *)middle;
  }

  return NULL;
c0028a10:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028a15:	eb 3e                	jmp    c0028a55 <binary_search+0x61>
    const unsigned char *middle = first + (range / 2) * size;
c0028a17:	89 dd                	mov    %ebx,%ebp
  while (first < last)
c0028a19:	39 ee                	cmp    %ebp,%esi
c0028a1b:	73 33                	jae    c0028a50 <binary_search+0x5c>
    size_t range = (last - first) / size;
c0028a1d:	89 e8                	mov    %ebp,%eax
c0028a1f:	29 f0                	sub    %esi,%eax
c0028a21:	ba 00 00 00 00       	mov    $0x0,%edx
c0028a26:	f7 f7                	div    %edi
    const unsigned char *middle = first + (range / 2) * size;
c0028a28:	d1 e8                	shr    %eax
c0028a2a:	0f af c7             	imul   %edi,%eax
c0028a2d:	8d 1c 06             	lea    (%esi,%eax,1),%ebx
    int cmp = compare(key, middle, aux);
c0028a30:	83 ec 04             	sub    $0x4,%esp
c0028a33:	ff 74 24 38          	pushl  0x38(%esp)
c0028a37:	53                   	push   %ebx
c0028a38:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028a3c:	ff 54 24 40          	call   *0x40(%esp)
    if (cmp < 0)
c0028a40:	83 c4 10             	add    $0x10,%esp
c0028a43:	85 c0                	test   %eax,%eax
c0028a45:	78 d0                	js     c0028a17 <binary_search+0x23>
    else if (cmp > 0)
c0028a47:	85 c0                	test   %eax,%eax
c0028a49:	7e 0a                	jle    c0028a55 <binary_search+0x61>
      first = middle + size;
c0028a4b:	8d 34 3b             	lea    (%ebx,%edi,1),%esi
c0028a4e:	eb c9                	jmp    c0028a19 <binary_search+0x25>
  return NULL;
c0028a50:	bb 00 00 00 00       	mov    $0x0,%ebx
}
c0028a55:	89 d8                	mov    %ebx,%eax
c0028a57:	83 c4 0c             	add    $0xc,%esp
c0028a5a:	5b                   	pop    %ebx
c0028a5b:	5e                   	pop    %esi
c0028a5c:	5f                   	pop    %edi
c0028a5d:	5d                   	pop    %ebp
c0028a5e:	c3                   	ret    

c0028a5f <bsearch>:
{
c0028a5f:	83 ec 14             	sub    $0x14,%esp
c0028a62:	e8 83 9a 00 00       	call   c00324ea <__x86.get_pc_thunk.ax>
c0028a67:	05 d5 81 01 00       	add    $0x181d5,%eax
  return binary_search(key, array, cnt, size, compare_thunk, &compare);
c0028a6c:	8d 54 24 28          	lea    0x28(%esp),%edx
c0028a70:	52                   	push   %edx
c0028a71:	8d 80 81 7a fe ff    	lea    -0x1857f(%eax),%eax
c0028a77:	50                   	push   %eax
c0028a78:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028a7c:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028a80:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028a84:	ff 74 24 2c          	pushl  0x2c(%esp)
c0028a88:	e8 67 ff ff ff       	call   c00289f4 <binary_search>
}
c0028a8d:	83 c4 2c             	add    $0x2c,%esp
c0028a90:	c3                   	ret    

c0028a91 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy(void *dst_, const void *src_, size_t size)
{
c0028a91:	56                   	push   %esi
c0028a92:	53                   	push   %ebx
c0028a93:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0028a97:	8b 74 24 10          	mov    0x10(%esp),%esi
c0028a9b:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  const unsigned char *src = src_;

  ASSERT(dst != NULL || size == 0);
  ASSERT(src != NULL || size == 0);

  while (size-- > 0)
c0028a9f:	85 db                	test   %ebx,%ebx
c0028aa1:	74 13                	je     c0028ab6 <memcpy+0x25>
c0028aa3:	ba 00 00 00 00       	mov    $0x0,%edx
    *dst++ = *src++;
c0028aa8:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
c0028aac:	88 0c 10             	mov    %cl,(%eax,%edx,1)
c0028aaf:	83 c2 01             	add    $0x1,%edx
  while (size-- > 0)
c0028ab2:	39 da                	cmp    %ebx,%edx
c0028ab4:	75 f2                	jne    c0028aa8 <memcpy+0x17>

  return dst_;
}
c0028ab6:	5b                   	pop    %ebx
c0028ab7:	5e                   	pop    %esi
c0028ab8:	c3                   	ret    

c0028ab9 <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove(void *dst_, const void *src_, size_t size)
{
c0028ab9:	57                   	push   %edi
c0028aba:	56                   	push   %esi
c0028abb:	53                   	push   %ebx
c0028abc:	8b 44 24 10          	mov    0x10(%esp),%eax
c0028ac0:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0028ac4:	8b 7c 24 18          	mov    0x18(%esp),%edi
  const unsigned char *src = src_;

  ASSERT(dst != NULL || size == 0);
  ASSERT(src != NULL || size == 0);

  if (dst < src)
c0028ac8:	39 c8                	cmp    %ecx,%eax
c0028aca:	73 1d                	jae    c0028ae9 <memmove+0x30>
  {
    while (size-- > 0)
c0028acc:	85 ff                	test   %edi,%edi
c0028ace:	74 15                	je     c0028ae5 <memmove+0x2c>
c0028ad0:	ba 00 00 00 00       	mov    $0x0,%edx
      *dst++ = *src++;
c0028ad5:	0f b6 1c 11          	movzbl (%ecx,%edx,1),%ebx
c0028ad9:	88 1c 10             	mov    %bl,(%eax,%edx,1)
c0028adc:	83 c2 01             	add    $0x1,%edx
    while (size-- > 0)
c0028adf:	39 fa                	cmp    %edi,%edx
c0028ae1:	75 f2                	jne    c0028ad5 <memmove+0x1c>
c0028ae3:	01 d0                	add    %edx,%eax
    while (size-- > 0)
      *--dst = *--src;
  }

  return dst;
}
c0028ae5:	5b                   	pop    %ebx
c0028ae6:	5e                   	pop    %esi
c0028ae7:	5f                   	pop    %edi
c0028ae8:	c3                   	ret    
    dst += size;
c0028ae9:	8d 34 38             	lea    (%eax,%edi,1),%esi
    while (size-- > 0)
c0028aec:	8d 57 ff             	lea    -0x1(%edi),%edx
c0028aef:	85 ff                	test   %edi,%edi
c0028af1:	74 11                	je     c0028b04 <memmove+0x4b>
      *--dst = *--src;
c0028af3:	0f b6 1c 11          	movzbl (%ecx,%edx,1),%ebx
c0028af7:	88 1c 10             	mov    %bl,(%eax,%edx,1)
    while (size-- > 0)
c0028afa:	83 ea 01             	sub    $0x1,%edx
c0028afd:	83 fa ff             	cmp    $0xffffffff,%edx
c0028b00:	75 f1                	jne    c0028af3 <memmove+0x3a>
c0028b02:	eb e1                	jmp    c0028ae5 <memmove+0x2c>
    dst += size;
c0028b04:	89 f0                	mov    %esi,%eax
c0028b06:	eb dd                	jmp    c0028ae5 <memmove+0x2c>

c0028b08 <memcmp>:
/* Find the first differing byte in the two blocks of SIZE bytes
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int memcmp(const void *a_, const void *b_, size_t size)
{
c0028b08:	57                   	push   %edi
c0028b09:	56                   	push   %esi
c0028b0a:	53                   	push   %ebx
c0028b0b:	8b 74 24 10          	mov    0x10(%esp),%esi
c0028b0f:	8b 7c 24 14          	mov    0x14(%esp),%edi
c0028b13:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  const unsigned char *b = b_;

  ASSERT(a != NULL || size == 0);
  ASSERT(b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
c0028b17:	85 db                	test   %ebx,%ebx
c0028b19:	74 38                	je     c0028b53 <memcmp+0x4b>
    if (*a != *b)
c0028b1b:	0f b6 16             	movzbl (%esi),%edx
c0028b1e:	0f b6 0f             	movzbl (%edi),%ecx
c0028b21:	38 ca                	cmp    %cl,%dl
c0028b23:	75 19                	jne    c0028b3e <memcmp+0x36>
c0028b25:	b8 01 00 00 00       	mov    $0x1,%eax
  for (; size-- > 0; a++, b++)
c0028b2a:	39 d8                	cmp    %ebx,%eax
c0028b2c:	74 1e                	je     c0028b4c <memcmp+0x44>
    if (*a != *b)
c0028b2e:	0f b6 14 06          	movzbl (%esi,%eax,1),%edx
c0028b32:	83 c0 01             	add    $0x1,%eax
c0028b35:	0f b6 4c 07 ff       	movzbl -0x1(%edi,%eax,1),%ecx
c0028b3a:	38 ca                	cmp    %cl,%dl
c0028b3c:	74 ec                	je     c0028b2a <memcmp+0x22>
      return *a > *b ? +1 : -1;
c0028b3e:	38 d1                	cmp    %dl,%cl
c0028b40:	19 c0                	sbb    %eax,%eax
c0028b42:	83 e0 02             	and    $0x2,%eax
c0028b45:	83 e8 01             	sub    $0x1,%eax
  return 0;
}
c0028b48:	5b                   	pop    %ebx
c0028b49:	5e                   	pop    %esi
c0028b4a:	5f                   	pop    %edi
c0028b4b:	c3                   	ret    
  return 0;
c0028b4c:	b8 00 00 00 00       	mov    $0x0,%eax
c0028b51:	eb f5                	jmp    c0028b48 <memcmp+0x40>
c0028b53:	b8 00 00 00 00       	mov    $0x0,%eax
c0028b58:	eb ee                	jmp    c0028b48 <memcmp+0x40>

c0028b5a <strcmp>:
   Returns a positive value if the character in A (as an unsigned
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int strcmp(const char *a_, const char *b_)
{
c0028b5a:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0028b5e:	8b 54 24 08          	mov    0x8(%esp),%edx
  const unsigned char *b = (const unsigned char *)b_;

  ASSERT(a != NULL);
  ASSERT(b != NULL);

  while (*a != '\0' && *a == *b)
c0028b62:	0f b6 01             	movzbl (%ecx),%eax
c0028b65:	84 c0                	test   %al,%al
c0028b67:	74 15                	je     c0028b7e <strcmp+0x24>
c0028b69:	3a 02                	cmp    (%edx),%al
c0028b6b:	75 11                	jne    c0028b7e <strcmp+0x24>
  {
    a++;
c0028b6d:	83 c1 01             	add    $0x1,%ecx
    b++;
c0028b70:	83 c2 01             	add    $0x1,%edx
  while (*a != '\0' && *a == *b)
c0028b73:	0f b6 01             	movzbl (%ecx),%eax
c0028b76:	84 c0                	test   %al,%al
c0028b78:	74 04                	je     c0028b7e <strcmp+0x24>
c0028b7a:	3a 02                	cmp    (%edx),%al
c0028b7c:	74 ef                	je     c0028b6d <strcmp+0x13>
  }

  return *a < *b ? -1 : *a > *b;
c0028b7e:	0f b6 12             	movzbl (%edx),%edx
c0028b81:	38 c2                	cmp    %al,%dl
c0028b83:	77 07                	ja     c0028b8c <strcmp+0x32>
c0028b85:	0f 92 c0             	setb   %al
c0028b88:	0f b6 c0             	movzbl %al,%eax
c0028b8b:	c3                   	ret    
c0028b8c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0028b91:	c3                   	ret    

c0028b92 <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr(const void *block_, int ch_, size_t size)
{
c0028b92:	53                   	push   %ebx
c0028b93:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028b97:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0028b9b:	8b 54 24 10          	mov    0x10(%esp),%edx
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT(block != NULL || size == 0);

  for (; size-- > 0; block++)
c0028b9f:	85 d2                	test   %edx,%edx
c0028ba1:	74 1c                	je     c0028bbf <memchr+0x2d>
c0028ba3:	89 d9                	mov    %ebx,%ecx
    if (*block == ch)
c0028ba5:	3a 18                	cmp    (%eax),%bl
c0028ba7:	74 14                	je     c0028bbd <memchr+0x2b>
c0028ba9:	01 c2                	add    %eax,%edx
  for (; size-- > 0; block++)
c0028bab:	83 c0 01             	add    $0x1,%eax
c0028bae:	39 c2                	cmp    %eax,%edx
c0028bb0:	74 06                	je     c0028bb8 <memchr+0x26>
    if (*block == ch)
c0028bb2:	38 08                	cmp    %cl,(%eax)
c0028bb4:	75 f5                	jne    c0028bab <memchr+0x19>
c0028bb6:	eb 05                	jmp    c0028bbd <memchr+0x2b>
      return (void *)block;

  return NULL;
c0028bb8:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028bbd:	5b                   	pop    %ebx
c0028bbe:	c3                   	ret    
  return NULL;
c0028bbf:	b8 00 00 00 00       	mov    $0x0,%eax
c0028bc4:	eb f7                	jmp    c0028bbd <memchr+0x2b>

c0028bc6 <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr(const char *string, int c_)
{
c0028bc6:	53                   	push   %ebx
c0028bc7:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028bcb:	8b 54 24 0c          	mov    0xc(%esp),%edx
  char c = c_;

  ASSERT(string != NULL);

  for (;;)
    if (*string == c)
c0028bcf:	0f b6 18             	movzbl (%eax),%ebx
c0028bd2:	38 da                	cmp    %bl,%dl
c0028bd4:	74 19                	je     c0028bef <strchr+0x29>
c0028bd6:	89 d1                	mov    %edx,%ecx
      return (char *)string;
    else if (*string == '\0')
c0028bd8:	84 db                	test   %bl,%bl
c0028bda:	74 15                	je     c0028bf1 <strchr+0x2b>
      return NULL;
    else
      string++;
c0028bdc:	83 c0 01             	add    $0x1,%eax
    if (*string == c)
c0028bdf:	0f b6 10             	movzbl (%eax),%edx
c0028be2:	38 ca                	cmp    %cl,%dl
c0028be4:	74 09                	je     c0028bef <strchr+0x29>
    else if (*string == '\0')
c0028be6:	84 d2                	test   %dl,%dl
c0028be8:	75 f2                	jne    c0028bdc <strchr+0x16>
      return NULL;
c0028bea:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028bef:	5b                   	pop    %ebx
c0028bf0:	c3                   	ret    
      return NULL;
c0028bf1:	b8 00 00 00 00       	mov    $0x0,%eax
c0028bf6:	eb f7                	jmp    c0028bef <strchr+0x29>

c0028bf8 <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn(const char *string, const char *stop)
{
c0028bf8:	57                   	push   %edi
c0028bf9:	56                   	push   %esi
c0028bfa:	53                   	push   %ebx
c0028bfb:	8b 74 24 10          	mov    0x10(%esp),%esi
c0028bff:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c0028c03:	0f b6 06             	movzbl (%esi),%eax
c0028c06:	84 c0                	test   %al,%al
c0028c08:	74 27                	je     c0028c31 <strcspn+0x39>
c0028c0a:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr(stop, string[length]) != NULL)
c0028c0f:	0f be c0             	movsbl %al,%eax
c0028c12:	50                   	push   %eax
c0028c13:	57                   	push   %edi
c0028c14:	e8 ad ff ff ff       	call   c0028bc6 <strchr>
c0028c19:	83 c4 08             	add    $0x8,%esp
c0028c1c:	85 c0                	test   %eax,%eax
c0028c1e:	75 0b                	jne    c0028c2b <strcspn+0x33>
  for (length = 0; string[length] != '\0'; length++)
c0028c20:	83 c3 01             	add    $0x1,%ebx
c0028c23:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
c0028c27:	84 c0                	test   %al,%al
c0028c29:	75 e4                	jne    c0028c0f <strcspn+0x17>
      break;
  return length;
}
c0028c2b:	89 d8                	mov    %ebx,%eax
c0028c2d:	5b                   	pop    %ebx
c0028c2e:	5e                   	pop    %esi
c0028c2f:	5f                   	pop    %edi
c0028c30:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c0028c31:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c0028c36:	eb f3                	jmp    c0028c2b <strcspn+0x33>

c0028c38 <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk(const char *string, const char *stop)
{
c0028c38:	56                   	push   %esi
c0028c39:	53                   	push   %ebx
c0028c3a:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0028c3e:	8b 74 24 10          	mov    0x10(%esp),%esi
  for (; *string != '\0'; string++)
c0028c42:	0f b6 13             	movzbl (%ebx),%edx
c0028c45:	84 d2                	test   %dl,%dl
c0028c47:	74 1d                	je     c0028c66 <strpbrk+0x2e>
    if (strchr(stop, *string) != NULL)
c0028c49:	0f be d2             	movsbl %dl,%edx
c0028c4c:	52                   	push   %edx
c0028c4d:	56                   	push   %esi
c0028c4e:	e8 73 ff ff ff       	call   c0028bc6 <strchr>
c0028c53:	83 c4 08             	add    $0x8,%esp
c0028c56:	85 c0                	test   %eax,%eax
c0028c58:	75 13                	jne    c0028c6d <strpbrk+0x35>
  for (; *string != '\0'; string++)
c0028c5a:	83 c3 01             	add    $0x1,%ebx
c0028c5d:	0f b6 13             	movzbl (%ebx),%edx
c0028c60:	84 d2                	test   %dl,%dl
c0028c62:	75 e5                	jne    c0028c49 <strpbrk+0x11>
c0028c64:	eb 09                	jmp    c0028c6f <strpbrk+0x37>
      return (char *)string;
  return NULL;
c0028c66:	b8 00 00 00 00       	mov    $0x0,%eax
c0028c6b:	eb 02                	jmp    c0028c6f <strpbrk+0x37>
c0028c6d:	89 d8                	mov    %ebx,%eax
}
c0028c6f:	5b                   	pop    %ebx
c0028c70:	5e                   	pop    %esi
c0028c71:	c3                   	ret    

c0028c72 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr(const char *string, int c_)
{
c0028c72:	53                   	push   %ebx
c0028c73:	8b 54 24 08          	mov    0x8(%esp),%edx
  char c = c_;
c0028c77:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
  const char *p = NULL;

  for (; *string != '\0'; string++)
c0028c7c:	0f b6 0a             	movzbl (%edx),%ecx
c0028c7f:	84 c9                	test   %cl,%cl
c0028c81:	74 16                	je     c0028c99 <strrchr+0x27>
  const char *p = NULL;
c0028c83:	b8 00 00 00 00       	mov    $0x0,%eax
    if (*string == c)
c0028c88:	38 cb                	cmp    %cl,%bl
c0028c8a:	0f 44 c2             	cmove  %edx,%eax
  for (; *string != '\0'; string++)
c0028c8d:	83 c2 01             	add    $0x1,%edx
c0028c90:	0f b6 0a             	movzbl (%edx),%ecx
c0028c93:	84 c9                	test   %cl,%cl
c0028c95:	75 f1                	jne    c0028c88 <strrchr+0x16>
      p = string;
  return (char *)p;
}
c0028c97:	5b                   	pop    %ebx
c0028c98:	c3                   	ret    
  const char *p = NULL;
c0028c99:	b8 00 00 00 00       	mov    $0x0,%eax
  return (char *)p;
c0028c9e:	eb f7                	jmp    c0028c97 <strrchr+0x25>

c0028ca0 <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn(const char *string, const char *skip)
{
c0028ca0:	57                   	push   %edi
c0028ca1:	56                   	push   %esi
c0028ca2:	53                   	push   %ebx
c0028ca3:	8b 74 24 10          	mov    0x10(%esp),%esi
c0028ca7:	8b 7c 24 14          	mov    0x14(%esp),%edi
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c0028cab:	0f b6 06             	movzbl (%esi),%eax
c0028cae:	84 c0                	test   %al,%al
c0028cb0:	74 27                	je     c0028cd9 <strspn+0x39>
c0028cb2:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (strchr(skip, string[length]) == NULL)
c0028cb7:	0f be c0             	movsbl %al,%eax
c0028cba:	50                   	push   %eax
c0028cbb:	57                   	push   %edi
c0028cbc:	e8 05 ff ff ff       	call   c0028bc6 <strchr>
c0028cc1:	83 c4 08             	add    $0x8,%esp
c0028cc4:	85 c0                	test   %eax,%eax
c0028cc6:	74 0b                	je     c0028cd3 <strspn+0x33>
  for (length = 0; string[length] != '\0'; length++)
c0028cc8:	83 c3 01             	add    $0x1,%ebx
c0028ccb:	0f b6 04 1e          	movzbl (%esi,%ebx,1),%eax
c0028ccf:	84 c0                	test   %al,%al
c0028cd1:	75 e4                	jne    c0028cb7 <strspn+0x17>
      break;
  return length;
}
c0028cd3:	89 d8                	mov    %ebx,%eax
c0028cd5:	5b                   	pop    %ebx
c0028cd6:	5e                   	pop    %esi
c0028cd7:	5f                   	pop    %edi
c0028cd8:	c3                   	ret    
  for (length = 0; string[length] != '\0'; length++)
c0028cd9:	bb 00 00 00 00       	mov    $0x0,%ebx
  return length;
c0028cde:	eb f3                	jmp    c0028cd3 <strspn+0x33>

c0028ce0 <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r(char *s, const char *delimiters, char **save_ptr)
{
c0028ce0:	55                   	push   %ebp
c0028ce1:	57                   	push   %edi
c0028ce2:	56                   	push   %esi
c0028ce3:	53                   	push   %ebx
c0028ce4:	83 ec 1c             	sub    $0x1c,%esp
c0028ce7:	e8 fa 97 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0028cec:	81 c3 50 7f 01 00    	add    $0x17f50,%ebx
c0028cf2:	8b 74 24 30          	mov    0x30(%esp),%esi
c0028cf6:	8b 7c 24 34          	mov    0x34(%esp),%edi
  char *token;

  ASSERT(delimiters != NULL);
c0028cfa:	85 ff                	test   %edi,%edi
c0028cfc:	74 33                	je     c0028d31 <strtok_r+0x51>
  ASSERT(save_ptr != NULL);
c0028cfe:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0028d03:	74 55                	je     c0028d5a <strtok_r+0x7a>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c0028d05:	85 f6                	test   %esi,%esi
c0028d07:	74 7a                	je     c0028d83 <strtok_r+0xa3>
    s = *save_ptr;
  ASSERT(s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr(delimiters, *s) != NULL)
c0028d09:	0f b6 1e             	movzbl (%esi),%ebx
c0028d0c:	83 ec 08             	sub    $0x8,%esp
c0028d0f:	0f be c3             	movsbl %bl,%eax
c0028d12:	50                   	push   %eax
c0028d13:	57                   	push   %edi
c0028d14:	e8 ad fe ff ff       	call   c0028bc6 <strchr>
c0028d19:	83 c4 10             	add    $0x10,%esp
c0028d1c:	85 c0                	test   %eax,%eax
c0028d1e:	0f 84 a9 00 00 00    	je     c0028dcd <strtok_r+0xed>
  {
    /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
    if (*s == '\0')
c0028d24:	84 db                	test   %bl,%bl
c0028d26:	0f 84 8e 00 00 00    	je     c0028dba <strtok_r+0xda>
    {
      *save_ptr = s;
      return NULL;
    }

    s++;
c0028d2c:	83 c6 01             	add    $0x1,%esi
c0028d2f:	eb d8                	jmp    c0028d09 <strtok_r+0x29>
  ASSERT(delimiters != NULL);
c0028d31:	83 ec 0c             	sub    $0xc,%esp
c0028d34:	8d 83 82 47 ff ff    	lea    -0xb87e(%ebx),%eax
c0028d3a:	50                   	push   %eax
c0028d3b:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0028d41:	50                   	push   %eax
c0028d42:	8d 83 34 26 ff ff    	lea    -0xd9cc(%ebx),%eax
c0028d48:	50                   	push   %eax
c0028d49:	68 ed 00 00 00       	push   $0xed
c0028d4e:	8d 83 95 47 ff ff    	lea    -0xb86b(%ebx),%eax
c0028d54:	50                   	push   %eax
c0028d55:	e8 3b 0b 00 00       	call   c0029895 <debug_panic>
  ASSERT(save_ptr != NULL);
c0028d5a:	83 ec 0c             	sub    $0xc,%esp
c0028d5d:	8d 83 a8 47 ff ff    	lea    -0xb858(%ebx),%eax
c0028d63:	50                   	push   %eax
c0028d64:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0028d6a:	50                   	push   %eax
c0028d6b:	8d 83 34 26 ff ff    	lea    -0xd9cc(%ebx),%eax
c0028d71:	50                   	push   %eax
c0028d72:	68 ee 00 00 00       	push   $0xee
c0028d77:	8d 83 95 47 ff ff    	lea    -0xb86b(%ebx),%eax
c0028d7d:	50                   	push   %eax
c0028d7e:	e8 12 0b 00 00       	call   c0029895 <debug_panic>
    s = *save_ptr;
c0028d83:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028d87:	8b 30                	mov    (%eax),%esi
  ASSERT(s != NULL);
c0028d89:	85 f6                	test   %esi,%esi
c0028d8b:	0f 85 78 ff ff ff    	jne    c0028d09 <strtok_r+0x29>
c0028d91:	83 ec 0c             	sub    $0xc,%esp
c0028d94:	8d 83 8b 47 ff ff    	lea    -0xb875(%ebx),%eax
c0028d9a:	50                   	push   %eax
c0028d9b:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0028da1:	50                   	push   %eax
c0028da2:	8d 83 34 26 ff ff    	lea    -0xd9cc(%ebx),%eax
c0028da8:	50                   	push   %eax
c0028da9:	68 f4 00 00 00       	push   $0xf4
c0028dae:	8d 83 95 47 ff ff    	lea    -0xb86b(%ebx),%eax
c0028db4:	50                   	push   %eax
c0028db5:	e8 db 0a 00 00       	call   c0029895 <debug_panic>
      *save_ptr = s;
c0028dba:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028dbe:	89 30                	mov    %esi,(%eax)
      return NULL;
c0028dc0:	b8 00 00 00 00       	mov    $0x0,%eax
    *save_ptr = s + 1;
  }
  else
    *save_ptr = s;
  return token;
}
c0028dc5:	83 c4 1c             	add    $0x1c,%esp
c0028dc8:	5b                   	pop    %ebx
c0028dc9:	5e                   	pop    %esi
c0028dca:	5f                   	pop    %edi
c0028dcb:	5d                   	pop    %ebp
c0028dcc:	c3                   	ret    
c0028dcd:	89 f3                	mov    %esi,%ebx
c0028dcf:	eb 02                	jmp    c0028dd3 <strtok_r+0xf3>
    s++;
c0028dd1:	89 eb                	mov    %ebp,%ebx
c0028dd3:	8d 6b 01             	lea    0x1(%ebx),%ebp
  while (strchr(delimiters, *s) == NULL)
c0028dd6:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
c0028dda:	88 44 24 0f          	mov    %al,0xf(%esp)
c0028dde:	83 ec 08             	sub    $0x8,%esp
c0028de1:	0f be c0             	movsbl %al,%eax
c0028de4:	50                   	push   %eax
c0028de5:	57                   	push   %edi
c0028de6:	e8 db fd ff ff       	call   c0028bc6 <strchr>
c0028deb:	83 c4 10             	add    $0x10,%esp
c0028dee:	85 c0                	test   %eax,%eax
c0028df0:	74 df                	je     c0028dd1 <strtok_r+0xf1>
  if (*s != '\0')
c0028df2:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c0028df7:	75 0a                	jne    c0028e03 <strtok_r+0x123>
    *save_ptr = s;
c0028df9:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028dfd:	89 28                	mov    %ebp,(%eax)
c0028dff:	89 f0                	mov    %esi,%eax
c0028e01:	eb c2                	jmp    c0028dc5 <strtok_r+0xe5>
    *s = '\0';
c0028e03:	c6 45 00 00          	movb   $0x0,0x0(%ebp)
    *save_ptr = s + 1;
c0028e07:	83 c3 02             	add    $0x2,%ebx
c0028e0a:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028e0e:	89 18                	mov    %ebx,(%eax)
c0028e10:	89 f0                	mov    %esi,%eax
c0028e12:	eb b1                	jmp    c0028dc5 <strtok_r+0xe5>

c0028e14 <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset(void *dst_, int value, size_t size)
{
c0028e14:	53                   	push   %ebx
c0028e15:	8b 44 24 08          	mov    0x8(%esp),%eax
c0028e19:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c0028e1d:	8b 4c 24 10          	mov    0x10(%esp),%ecx
  unsigned char *dst = dst_;

  ASSERT(dst != NULL || size == 0);

  while (size-- > 0)
c0028e21:	85 c9                	test   %ecx,%ecx
c0028e23:	74 0e                	je     c0028e33 <memset+0x1f>
c0028e25:	01 c1                	add    %eax,%ecx
  unsigned char *dst = dst_;
c0028e27:	89 c2                	mov    %eax,%edx
    *dst++ = value;
c0028e29:	83 c2 01             	add    $0x1,%edx
c0028e2c:	88 5a ff             	mov    %bl,-0x1(%edx)
  while (size-- > 0)
c0028e2f:	39 d1                	cmp    %edx,%ecx
c0028e31:	75 f6                	jne    c0028e29 <memset+0x15>

  return dst_;
}
c0028e33:	5b                   	pop    %ebx
c0028e34:	c3                   	ret    

c0028e35 <strlen>:

/* Returns the length of STRING. */
size_t
strlen(const char *string)
{
c0028e35:	8b 54 24 04          	mov    0x4(%esp),%edx
  const char *p;

  ASSERT(string != NULL);

  for (p = string; *p != '\0'; p++)
c0028e39:	89 d0                	mov    %edx,%eax
c0028e3b:	80 3a 00             	cmpb   $0x0,(%edx)
c0028e3e:	75 03                	jne    c0028e43 <strlen+0xe>
    continue;
  return p - string;
c0028e40:	29 d0                	sub    %edx,%eax
}
c0028e42:	c3                   	ret    
  for (p = string; *p != '\0'; p++)
c0028e43:	83 c0 01             	add    $0x1,%eax
c0028e46:	80 38 00             	cmpb   $0x0,(%eax)
c0028e49:	74 f5                	je     c0028e40 <strlen+0xb>
c0028e4b:	eb f6                	jmp    c0028e43 <strlen+0xe>

c0028e4d <strstr>:
{
c0028e4d:	55                   	push   %ebp
c0028e4e:	57                   	push   %edi
c0028e4f:	56                   	push   %esi
c0028e50:	53                   	push   %ebx
c0028e51:	83 ec 04             	sub    $0x4,%esp
c0028e54:	8b 6c 24 1c          	mov    0x1c(%esp),%ebp
  size_t haystack_len = strlen(haystack);
c0028e58:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
c0028e5d:	b8 00 00 00 00       	mov    $0x0,%eax
c0028e62:	89 d9                	mov    %ebx,%ecx
c0028e64:	8b 7c 24 18          	mov    0x18(%esp),%edi
c0028e68:	f2 ae                	repnz scas %es:(%edi),%al
c0028e6a:	f7 d1                	not    %ecx
c0028e6c:	8d 51 ff             	lea    -0x1(%ecx),%edx
  size_t needle_len = strlen(needle);
c0028e6f:	89 d9                	mov    %ebx,%ecx
c0028e71:	89 ef                	mov    %ebp,%edi
c0028e73:	f2 ae                	repnz scas %es:(%edi),%al
c0028e75:	89 c8                	mov    %ecx,%eax
c0028e77:	f7 d0                	not    %eax
c0028e79:	8d 70 ff             	lea    -0x1(%eax),%esi
  if (haystack_len >= needle_len)
c0028e7c:	39 f2                	cmp    %esi,%edx
c0028e7e:	72 36                	jb     c0028eb6 <strstr+0x69>
    for (i = 0; i <= haystack_len - needle_len; i++)
c0028e80:	29 f2                	sub    %esi,%edx
c0028e82:	89 14 24             	mov    %edx,(%esp)
c0028e85:	bb 00 00 00 00       	mov    $0x0,%ebx
c0028e8a:	89 df                	mov    %ebx,%edi
c0028e8c:	03 7c 24 18          	add    0x18(%esp),%edi
      if (!memcmp(haystack + i, needle, needle_len))
c0028e90:	56                   	push   %esi
c0028e91:	55                   	push   %ebp
c0028e92:	57                   	push   %edi
c0028e93:	e8 70 fc ff ff       	call   c0028b08 <memcmp>
c0028e98:	83 c4 0c             	add    $0xc,%esp
c0028e9b:	85 c0                	test   %eax,%eax
c0028e9d:	74 0d                	je     c0028eac <strstr+0x5f>
    for (i = 0; i <= haystack_len - needle_len; i++)
c0028e9f:	83 c3 01             	add    $0x1,%ebx
c0028ea2:	3b 1c 24             	cmp    (%esp),%ebx
c0028ea5:	76 e3                	jbe    c0028e8a <strstr+0x3d>
  return NULL;
c0028ea7:	bf 00 00 00 00       	mov    $0x0,%edi
}
c0028eac:	89 f8                	mov    %edi,%eax
c0028eae:	83 c4 04             	add    $0x4,%esp
c0028eb1:	5b                   	pop    %ebx
c0028eb2:	5e                   	pop    %esi
c0028eb3:	5f                   	pop    %edi
c0028eb4:	5d                   	pop    %ebp
c0028eb5:	c3                   	ret    
  return NULL;
c0028eb6:	bf 00 00 00 00       	mov    $0x0,%edi
c0028ebb:	eb ef                	jmp    c0028eac <strstr+0x5f>

c0028ebd <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen(const char *string, size_t maxlen)
{
c0028ebd:	8b 54 24 04          	mov    0x4(%esp),%edx
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c0028ec1:	80 3a 00             	cmpb   $0x0,(%edx)
c0028ec4:	74 07                	je     c0028ecd <strnlen+0x10>
c0028ec6:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0028ecb:	75 07                	jne    c0028ed4 <strnlen+0x17>
c0028ecd:	b8 00 00 00 00       	mov    $0x0,%eax
    continue;
  return length;
}
c0028ed2:	f3 c3                	repz ret 
  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c0028ed4:	b8 00 00 00 00       	mov    $0x0,%eax
c0028ed9:	83 c0 01             	add    $0x1,%eax
c0028edc:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
c0028ee0:	74 f0                	je     c0028ed2 <strnlen+0x15>
c0028ee2:	39 44 24 08          	cmp    %eax,0x8(%esp)
c0028ee6:	76 ea                	jbe    c0028ed2 <strnlen+0x15>
c0028ee8:	eb ef                	jmp    c0028ed9 <strnlen+0x1c>

c0028eea <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy(char *dst, const char *src, size_t size)
{
c0028eea:	55                   	push   %ebp
c0028eeb:	57                   	push   %edi
c0028eec:	56                   	push   %esi
c0028eed:	53                   	push   %ebx
c0028eee:	83 ec 0c             	sub    $0xc,%esp
c0028ef1:	e8 f0 95 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0028ef6:	81 c3 46 7d 01 00    	add    $0x17d46,%ebx
c0028efc:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c0028f00:	8b 54 24 24          	mov    0x24(%esp),%edx
  size_t src_len;

  ASSERT(dst != NULL);
c0028f04:	85 ed                	test   %ebp,%ebp
c0028f06:	74 49                	je     c0028f51 <strlcpy+0x67>
  ASSERT(src != NULL);
c0028f08:	85 d2                	test   %edx,%edx
c0028f0a:	74 6e                	je     c0028f7a <strlcpy+0x90>

  src_len = strlen(src);
c0028f0c:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c0028f11:	b8 00 00 00 00       	mov    $0x0,%eax
c0028f16:	89 d7                	mov    %edx,%edi
c0028f18:	f2 ae                	repnz scas %es:(%edi),%al
c0028f1a:	89 ce                	mov    %ecx,%esi
c0028f1c:	f7 d6                	not    %esi
c0028f1e:	8d 76 ff             	lea    -0x1(%esi),%esi
  if (size > 0)
c0028f21:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0028f26:	74 1f                	je     c0028f47 <strlcpy+0x5d>
  {
    size_t dst_len = size - 1;
c0028f28:	8b 44 24 28          	mov    0x28(%esp),%eax
c0028f2c:	8d 78 ff             	lea    -0x1(%eax),%edi
c0028f2f:	39 fe                	cmp    %edi,%esi
c0028f31:	0f 46 fe             	cmovbe %esi,%edi
    if (src_len < dst_len)
      dst_len = src_len;
    memcpy(dst, src, dst_len);
c0028f34:	83 ec 04             	sub    $0x4,%esp
c0028f37:	57                   	push   %edi
c0028f38:	52                   	push   %edx
c0028f39:	55                   	push   %ebp
c0028f3a:	e8 52 fb ff ff       	call   c0028a91 <memcpy>
    dst[dst_len] = '\0';
c0028f3f:	c6 44 3d 00 00       	movb   $0x0,0x0(%ebp,%edi,1)
c0028f44:	83 c4 10             	add    $0x10,%esp
  }
  return src_len;
}
c0028f47:	89 f0                	mov    %esi,%eax
c0028f49:	83 c4 0c             	add    $0xc,%esp
c0028f4c:	5b                   	pop    %ebx
c0028f4d:	5e                   	pop    %esi
c0028f4e:	5f                   	pop    %edi
c0028f4f:	5d                   	pop    %ebp
c0028f50:	c3                   	ret    
  ASSERT(dst != NULL);
c0028f51:	83 ec 0c             	sub    $0xc,%esp
c0028f54:	8d 83 b9 47 ff ff    	lea    -0xb847(%ebx),%eax
c0028f5a:	50                   	push   %eax
c0028f5b:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0028f61:	50                   	push   %eax
c0028f62:	8d 83 2c 26 ff ff    	lea    -0xd9d4(%ebx),%eax
c0028f68:	50                   	push   %eax
c0028f69:	68 48 01 00 00       	push   $0x148
c0028f6e:	8d 83 95 47 ff ff    	lea    -0xb86b(%ebx),%eax
c0028f74:	50                   	push   %eax
c0028f75:	e8 1b 09 00 00       	call   c0029895 <debug_panic>
  ASSERT(src != NULL);
c0028f7a:	83 ec 0c             	sub    $0xc,%esp
c0028f7d:	8d 83 c5 47 ff ff    	lea    -0xb83b(%ebx),%eax
c0028f83:	50                   	push   %eax
c0028f84:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0028f8a:	50                   	push   %eax
c0028f8b:	8d 83 2c 26 ff ff    	lea    -0xd9d4(%ebx),%eax
c0028f91:	50                   	push   %eax
c0028f92:	68 49 01 00 00       	push   $0x149
c0028f97:	8d 83 95 47 ff ff    	lea    -0xb86b(%ebx),%eax
c0028f9d:	50                   	push   %eax
c0028f9e:	e8 f2 08 00 00       	call   c0029895 <debug_panic>

c0028fa3 <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat(char *dst, const char *src, size_t size)
{
c0028fa3:	55                   	push   %ebp
c0028fa4:	57                   	push   %edi
c0028fa5:	56                   	push   %esi
c0028fa6:	53                   	push   %ebx
c0028fa7:	83 ec 1c             	sub    $0x1c,%esp
c0028faa:	e8 37 95 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0028faf:	81 c3 8d 7c 01 00    	add    $0x17c8d,%ebx
c0028fb5:	8b 54 24 34          	mov    0x34(%esp),%edx
  size_t src_len, dst_len;

  ASSERT(dst != NULL);
c0028fb9:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0028fbe:	74 75                	je     c0029035 <strlcat+0x92>
  ASSERT(src != NULL);
c0028fc0:	85 d2                	test   %edx,%edx
c0028fc2:	0f 84 96 00 00 00    	je     c002905e <strlcat+0xbb>

  src_len = strlen(src);
c0028fc8:	be ff ff ff ff       	mov    $0xffffffff,%esi
c0028fcd:	b8 00 00 00 00       	mov    $0x0,%eax
c0028fd2:	89 f1                	mov    %esi,%ecx
c0028fd4:	89 d7                	mov    %edx,%edi
c0028fd6:	f2 ae                	repnz scas %es:(%edi),%al
c0028fd8:	f7 d1                	not    %ecx
c0028fda:	8d 69 ff             	lea    -0x1(%ecx),%ebp
  dst_len = strlen(dst);
c0028fdd:	89 f1                	mov    %esi,%ecx
c0028fdf:	8b 7c 24 30          	mov    0x30(%esp),%edi
c0028fe3:	f2 ae                	repnz scas %es:(%edi),%al
c0028fe5:	89 ce                	mov    %ecx,%esi
c0028fe7:	f7 d6                	not    %esi
c0028fe9:	83 ee 01             	sub    $0x1,%esi
  if (size > 0 && dst_len < size)
c0028fec:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0028ff1:	74 36                	je     c0029029 <strlcat+0x86>
c0028ff3:	3b 74 24 38          	cmp    0x38(%esp),%esi
c0028ff7:	73 30                	jae    c0029029 <strlcat+0x86>
  {
    size_t copy_cnt = size - dst_len - 1;
c0028ff9:	8b 44 24 38          	mov    0x38(%esp),%eax
c0028ffd:	83 e8 01             	sub    $0x1,%eax
c0029000:	29 f0                	sub    %esi,%eax
c0029002:	39 c5                	cmp    %eax,%ebp
c0029004:	0f 46 c5             	cmovbe %ebp,%eax
c0029007:	89 c7                	mov    %eax,%edi
    if (src_len < copy_cnt)
      copy_cnt = src_len;
    memcpy(dst + dst_len, src, copy_cnt);
c0029009:	89 f0                	mov    %esi,%eax
c002900b:	03 44 24 30          	add    0x30(%esp),%eax
c002900f:	83 ec 04             	sub    $0x4,%esp
c0029012:	57                   	push   %edi
c0029013:	52                   	push   %edx
c0029014:	89 44 24 18          	mov    %eax,0x18(%esp)
c0029018:	50                   	push   %eax
c0029019:	e8 73 fa ff ff       	call   c0028a91 <memcpy>
    dst[dst_len + copy_cnt] = '\0';
c002901e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0029022:	c6 04 38 00          	movb   $0x0,(%eax,%edi,1)
c0029026:	83 c4 10             	add    $0x10,%esp
  }
  return src_len + dst_len;
c0029029:	8d 44 35 00          	lea    0x0(%ebp,%esi,1),%eax
}
c002902d:	83 c4 1c             	add    $0x1c,%esp
c0029030:	5b                   	pop    %ebx
c0029031:	5e                   	pop    %esi
c0029032:	5f                   	pop    %edi
c0029033:	5d                   	pop    %ebp
c0029034:	c3                   	ret    
  ASSERT(dst != NULL);
c0029035:	83 ec 0c             	sub    $0xc,%esp
c0029038:	8d 83 b9 47 ff ff    	lea    -0xb847(%ebx),%eax
c002903e:	50                   	push   %eax
c002903f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029045:	50                   	push   %eax
c0029046:	8d 83 24 26 ff ff    	lea    -0xd9dc(%ebx),%eax
c002904c:	50                   	push   %eax
c002904d:	68 66 01 00 00       	push   $0x166
c0029052:	8d 83 95 47 ff ff    	lea    -0xb86b(%ebx),%eax
c0029058:	50                   	push   %eax
c0029059:	e8 37 08 00 00       	call   c0029895 <debug_panic>
  ASSERT(src != NULL);
c002905e:	83 ec 0c             	sub    $0xc,%esp
c0029061:	8d 83 c5 47 ff ff    	lea    -0xb83b(%ebx),%eax
c0029067:	50                   	push   %eax
c0029068:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002906e:	50                   	push   %eax
c002906f:	8d 83 24 26 ff ff    	lea    -0xd9dc(%ebx),%eax
c0029075:	50                   	push   %eax
c0029076:	68 67 01 00 00       	push   $0x167
c002907b:	8d 83 95 47 ff ff    	lea    -0xb86b(%ebx),%eax
c0029081:	50                   	push   %eax
c0029082:	e8 0e 08 00 00       	call   c0029895 <debug_panic>

c0029087 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64(uint64_t n, uint64_t d)
{
c0029087:	55                   	push   %ebp
c0029088:	57                   	push   %edi
c0029089:	56                   	push   %esi
c002908a:	53                   	push   %ebx
c002908b:	83 ec 1c             	sub    $0x1c,%esp
c002908e:	89 44 24 08          	mov    %eax,0x8(%esp)
c0029092:	89 54 24 0c          	mov    %edx,0xc(%esp)
c0029096:	8b 5c 24 30          	mov    0x30(%esp),%ebx
c002909a:	8b 74 24 34          	mov    0x34(%esp),%esi
c002909e:	89 1c 24             	mov    %ebx,(%esp)
c00290a1:	89 74 24 04          	mov    %esi,0x4(%esp)
  if ((d >> 32) == 0)
c00290a5:	85 f6                	test   %esi,%esi
c00290a7:	0f 84 fc 00 00 00    	je     c00291a9 <udiv64+0x122>
c00290ad:	89 f0                	mov    %esi,%eax
  }
  else
  {
    /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
    if (n < d)
c00290af:	8b 5c 24 08          	mov    0x8(%esp),%ebx
c00290b3:	8b 74 24 0c          	mov    0xc(%esp),%esi
c00290b7:	8b 14 24             	mov    (%esp),%edx
c00290ba:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c00290be:	39 f1                	cmp    %esi,%ecx
c00290c0:	0f 87 27 01 00 00    	ja     c00291ed <udiv64+0x166>
c00290c6:	72 08                	jb     c00290d0 <udiv64+0x49>
c00290c8:	39 da                	cmp    %ebx,%edx
c00290ca:	0f 87 1d 01 00 00    	ja     c00291ed <udiv64+0x166>
      return 0;
    else
    {
      uint32_t d1 = d >> 32;
c00290d0:	89 c2                	mov    %eax,%edx
  int n = 0;
c00290d2:	b9 00 00 00 00       	mov    $0x0,%ecx
  if (x <= 0x0000FFFF)
c00290d7:	3d ff ff 00 00       	cmp    $0xffff,%eax
c00290dc:	77 0a                	ja     c00290e8 <udiv64+0x61>
    x <<= 16;
c00290de:	c1 e0 10             	shl    $0x10,%eax
c00290e1:	89 c2                	mov    %eax,%edx
    n += 16;
c00290e3:	b9 10 00 00 00       	mov    $0x10,%ecx
  if (x <= 0x00FFFFFF)
c00290e8:	81 fa ff ff ff 00    	cmp    $0xffffff,%edx
c00290ee:	77 06                	ja     c00290f6 <udiv64+0x6f>
    n += 8;
c00290f0:	83 c1 08             	add    $0x8,%ecx
    x <<= 8;
c00290f3:	c1 e2 08             	shl    $0x8,%edx
  if (x <= 0x0FFFFFFF)
c00290f6:	81 fa ff ff ff 0f    	cmp    $0xfffffff,%edx
c00290fc:	77 06                	ja     c0029104 <udiv64+0x7d>
    n += 4;
c00290fe:	83 c1 04             	add    $0x4,%ecx
    x <<= 4;
c0029101:	c1 e2 04             	shl    $0x4,%edx
  if (x <= 0x3FFFFFFF)
c0029104:	81 fa ff ff ff 3f    	cmp    $0x3fffffff,%edx
c002910a:	77 06                	ja     c0029112 <udiv64+0x8b>
    n += 2;
c002910c:	83 c1 02             	add    $0x2,%ecx
    x <<= 2;
c002910f:	c1 e2 02             	shl    $0x2,%edx
    n++;
c0029112:	81 fa 00 00 00 80    	cmp    $0x80000000,%edx
c0029118:	83 d1 00             	adc    $0x0,%ecx
  uint32_t n1 = n >> 32;
c002911b:	8b 74 24 08          	mov    0x8(%esp),%esi
c002911f:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c0029123:	89 fb                	mov    %edi,%ebx
c0029125:	d1 eb                	shr    %ebx
      int s = nlz(d1);
      uint64_t q = divl(n >> 1, (d << s) >> 32) >> (31 - s);
c0029127:	89 f0                	mov    %esi,%eax
c0029129:	0f ac f8 01          	shrd   $0x1,%edi,%eax
c002912d:	8b 3c 24             	mov    (%esp),%edi
c0029130:	8b 6c 24 04          	mov    0x4(%esp),%ebp
c0029134:	0f a5 fd             	shld   %cl,%edi,%ebp
c0029137:	d3 e7                	shl    %cl,%edi
c0029139:	f6 c1 20             	test   $0x20,%cl
c002913c:	74 02                	je     c0029140 <udiv64+0xb9>
c002913e:	89 fd                	mov    %edi,%ebp
  asm("divl %4"
c0029140:	89 da                	mov    %ebx,%edx
c0029142:	f7 f5                	div    %ebp
      uint64_t q = divl(n >> 1, (d << s) >> 32) >> (31 - s);
c0029144:	ba 1f 00 00 00       	mov    $0x1f,%edx
c0029149:	29 ca                	sub    %ecx,%edx
c002914b:	89 d1                	mov    %edx,%ecx
c002914d:	d3 e8                	shr    %cl,%eax
c002914f:	89 c1                	mov    %eax,%ecx
c0029151:	bb 00 00 00 00       	mov    $0x0,%ebx
c0029156:	89 44 24 10          	mov    %eax,0x10(%esp)
c002915a:	89 5c 24 14          	mov    %ebx,0x14(%esp)
      return n - (q - 1) * d < d ? q - 1 : q;
c002915e:	83 c1 ff             	add    $0xffffffff,%ecx
c0029161:	83 d3 ff             	adc    $0xffffffff,%ebx
c0029164:	89 dd                	mov    %ebx,%ebp
c0029166:	8b 34 24             	mov    (%esp),%esi
c0029169:	8b 7c 24 04          	mov    0x4(%esp),%edi
c002916d:	0f af ee             	imul   %esi,%ebp
c0029170:	89 f8                	mov    %edi,%eax
c0029172:	0f af c1             	imul   %ecx,%eax
c0029175:	01 c5                	add    %eax,%ebp
c0029177:	89 c8                	mov    %ecx,%eax
c0029179:	f7 24 24             	mull   (%esp)
c002917c:	01 ea                	add    %ebp,%edx
c002917e:	8b 74 24 08          	mov    0x8(%esp),%esi
c0029182:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c0029186:	29 c6                	sub    %eax,%esi
c0029188:	19 d7                	sbb    %edx,%edi
c002918a:	89 f0                	mov    %esi,%eax
c002918c:	89 fa                	mov    %edi,%edx
c002918e:	8b 34 24             	mov    (%esp),%esi
c0029191:	8b 7c 24 04          	mov    0x4(%esp),%edi
c0029195:	39 fa                	cmp    %edi,%edx
c0029197:	72 48                	jb     c00291e1 <udiv64+0x15a>
c0029199:	77 04                	ja     c002919f <udiv64+0x118>
c002919b:	39 f0                	cmp    %esi,%eax
c002919d:	72 42                	jb     c00291e1 <udiv64+0x15a>
c002919f:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c00291a3:	8b 5c 24 14          	mov    0x14(%esp),%ebx
c00291a7:	eb 38                	jmp    c00291e1 <udiv64+0x15a>
    uint32_t n1 = n >> 32;
c00291a9:	89 d0                	mov    %edx,%eax
    return divl(b * (n1 % d0) + n0, d0) + b * (n1 / d0);
c00291ab:	ba 00 00 00 00       	mov    $0x0,%edx
c00291b0:	f7 f3                	div    %ebx
c00291b2:	89 c7                	mov    %eax,%edi
c00291b4:	89 d3                	mov    %edx,%ebx
c00291b6:	89 da                	mov    %ebx,%edx
c00291b8:	b8 00 00 00 00       	mov    $0x0,%eax
c00291bd:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c00291c1:	bb 00 00 00 00       	mov    $0x0,%ebx
c00291c6:	01 c8                	add    %ecx,%eax
c00291c8:	11 da                	adc    %ebx,%edx
  asm("divl %4"
c00291ca:	f7 34 24             	divl   (%esp)
    return divl(b * (n1 % d0) + n0, d0) + b * (n1 / d0);
c00291cd:	89 fd                	mov    %edi,%ebp
c00291cf:	bf 00 00 00 00       	mov    $0x0,%edi
c00291d4:	89 f9                	mov    %edi,%ecx
c00291d6:	89 eb                	mov    %ebp,%ebx
c00291d8:	ba 00 00 00 00       	mov    $0x0,%edx
c00291dd:	01 c1                	add    %eax,%ecx
c00291df:	11 d3                	adc    %edx,%ebx
    }
  }
}
c00291e1:	89 c8                	mov    %ecx,%eax
c00291e3:	89 da                	mov    %ebx,%edx
c00291e5:	83 c4 1c             	add    $0x1c,%esp
c00291e8:	5b                   	pop    %ebx
c00291e9:	5e                   	pop    %esi
c00291ea:	5f                   	pop    %edi
c00291eb:	5d                   	pop    %ebp
c00291ec:	c3                   	ret    
      return 0;
c00291ed:	b9 00 00 00 00       	mov    $0x0,%ecx
c00291f2:	bb 00 00 00 00       	mov    $0x0,%ebx
c00291f7:	eb e8                	jmp    c00291e1 <udiv64+0x15a>

c00291f9 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64(int64_t n, int64_t d)
{
c00291f9:	57                   	push   %edi
c00291fa:	56                   	push   %esi
c00291fb:	53                   	push   %ebx
c00291fc:	83 ec 08             	sub    $0x8,%esp
c00291ff:	89 04 24             	mov    %eax,(%esp)
c0029202:	89 54 24 04          	mov    %edx,0x4(%esp)
c0029206:	8b 74 24 18          	mov    0x18(%esp),%esi
c002920a:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  uint64_t n_abs = n >= 0 ? (uint64_t)n : -(uint64_t)n;
c002920e:	85 d2                	test   %edx,%edx
c0029210:	78 2b                	js     c002923d <sdiv64+0x44>
  uint64_t d_abs = d >= 0 ? (uint64_t)d : -(uint64_t)d;
c0029212:	89 f1                	mov    %esi,%ecx
c0029214:	89 fb                	mov    %edi,%ebx
c0029216:	85 ff                	test   %edi,%edi
c0029218:	78 2c                	js     c0029246 <sdiv64+0x4d>
  uint64_t q_abs = udiv64(n_abs, d_abs);
c002921a:	53                   	push   %ebx
c002921b:	51                   	push   %ecx
c002921c:	e8 66 fe ff ff       	call   c0029087 <udiv64>
c0029221:	83 c4 08             	add    $0x8,%esp
  return (n < 0) == (d < 0) ? (int64_t)q_abs : -(int64_t)q_abs;
c0029224:	8b 4c 24 04          	mov    0x4(%esp),%ecx
c0029228:	f7 d1                	not    %ecx
c002922a:	c1 e9 1f             	shr    $0x1f,%ecx
c002922d:	89 fb                	mov    %edi,%ebx
c002922f:	c1 eb 1f             	shr    $0x1f,%ebx
c0029232:	38 d9                	cmp    %bl,%cl
c0029234:	74 19                	je     c002924f <sdiv64+0x56>
}
c0029236:	83 c4 08             	add    $0x8,%esp
c0029239:	5b                   	pop    %ebx
c002923a:	5e                   	pop    %esi
c002923b:	5f                   	pop    %edi
c002923c:	c3                   	ret    
  uint64_t n_abs = n >= 0 ? (uint64_t)n : -(uint64_t)n;
c002923d:	f7 d8                	neg    %eax
c002923f:	83 d2 00             	adc    $0x0,%edx
c0029242:	f7 da                	neg    %edx
c0029244:	eb cc                	jmp    c0029212 <sdiv64+0x19>
  uint64_t d_abs = d >= 0 ? (uint64_t)d : -(uint64_t)d;
c0029246:	f7 d9                	neg    %ecx
c0029248:	83 d3 00             	adc    $0x0,%ebx
c002924b:	f7 db                	neg    %ebx
c002924d:	eb cb                	jmp    c002921a <sdiv64+0x21>
  return (n < 0) == (d < 0) ? (int64_t)q_abs : -(int64_t)q_abs;
c002924f:	f7 d8                	neg    %eax
c0029251:	83 d2 00             	adc    $0x0,%edx
c0029254:	f7 da                	neg    %edx
c0029256:	eb de                	jmp    c0029236 <sdiv64+0x3d>

c0029258 <__divdi3>:
unsigned long long __umoddi3(unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3(long long n, long long d)
{
c0029258:	83 ec 04             	sub    $0x4,%esp
  return sdiv64(n, d);
c002925b:	ff 74 24 14          	pushl  0x14(%esp)
c002925f:	ff 74 24 14          	pushl  0x14(%esp)
c0029263:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029267:	8b 54 24 14          	mov    0x14(%esp),%edx
c002926b:	e8 89 ff ff ff       	call   c00291f9 <sdiv64>
}
c0029270:	83 c4 0c             	add    $0xc,%esp
c0029273:	c3                   	ret    

c0029274 <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3(long long n, long long d)
{
c0029274:	57                   	push   %edi
c0029275:	56                   	push   %esi
c0029276:	53                   	push   %ebx
c0029277:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002927b:	8b 74 24 18          	mov    0x18(%esp),%esi
c002927f:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * sdiv64(n, d);
c0029283:	57                   	push   %edi
c0029284:	56                   	push   %esi
c0029285:	89 d8                	mov    %ebx,%eax
c0029287:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c002928b:	e8 69 ff ff ff       	call   c00291f9 <sdiv64>
c0029290:	83 c4 08             	add    $0x8,%esp
c0029293:	0f af c6             	imul   %esi,%eax
c0029296:	29 c3                	sub    %eax,%ebx
  return smod64(n, d);
c0029298:	89 d8                	mov    %ebx,%eax
c002929a:	99                   	cltd   
}
c002929b:	5b                   	pop    %ebx
c002929c:	5e                   	pop    %esi
c002929d:	5f                   	pop    %edi
c002929e:	c3                   	ret    

c002929f <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3(unsigned long long n, unsigned long long d)
{
c002929f:	83 ec 04             	sub    $0x4,%esp
  return udiv64(n, d);
c00292a2:	ff 74 24 14          	pushl  0x14(%esp)
c00292a6:	ff 74 24 14          	pushl  0x14(%esp)
c00292aa:	8b 44 24 10          	mov    0x10(%esp),%eax
c00292ae:	8b 54 24 14          	mov    0x14(%esp),%edx
c00292b2:	e8 d0 fd ff ff       	call   c0029087 <udiv64>
}
c00292b7:	83 c4 0c             	add    $0xc,%esp
c00292ba:	c3                   	ret    

c00292bb <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3(unsigned long long n, unsigned long long d)
{
c00292bb:	57                   	push   %edi
c00292bc:	56                   	push   %esi
c00292bd:	53                   	push   %ebx
c00292be:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c00292c2:	8b 74 24 18          	mov    0x18(%esp),%esi
c00292c6:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  return n - d * udiv64(n, d);
c00292ca:	57                   	push   %edi
c00292cb:	56                   	push   %esi
c00292cc:	89 d8                	mov    %ebx,%eax
c00292ce:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c00292d2:	e8 b0 fd ff ff       	call   c0029087 <udiv64>
c00292d7:	83 c4 08             	add    $0x8,%esp
c00292da:	0f af c6             	imul   %esi,%eax
c00292dd:	29 c3                	sub    %eax,%ebx
  return umod64(n, d);
c00292df:	89 d8                	mov    %ebx,%eax
c00292e1:	ba 00 00 00 00       	mov    $0x0,%edx
}
c00292e6:	5b                   	pop    %ebx
c00292e7:	5e                   	pop    %esi
c00292e8:	5f                   	pop    %edi
c00292e9:	c3                   	ret    

c00292ea <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field(const char *s, size_t size, unsigned long int *value)
{
c00292ea:	55                   	push   %ebp
c00292eb:	57                   	push   %edi
c00292ec:	56                   	push   %esi
c00292ed:	53                   	push   %ebx
c00292ee:	83 ec 04             	sub    $0x4,%esp
c00292f1:	89 04 24             	mov    %eax,(%esp)
  size_t ofs;

  *value = 0;
c00292f4:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
      return false;
    }
  }

  /* Field did not end in space or null byte. */
  return false;
c00292fa:	b8 00 00 00 00       	mov    $0x0,%eax
  for (ofs = 0; ofs < size; ofs++)
c00292ff:	85 d2                	test   %edx,%edx
c0029301:	74 4d                	je     c0029350 <parse_octal_field+0x66>
    char c = s[ofs];
c0029303:	8b 04 24             	mov    (%esp),%eax
c0029306:	0f b6 18             	movzbl (%eax),%ebx
    if (c >= '0' && c <= '7')
c0029309:	8d 6b d0             	lea    -0x30(%ebx),%ebp
  for (ofs = 0; ofs < size; ofs++)
c002930c:	be 00 00 00 00       	mov    $0x0,%esi
      if (*value > ULONG_MAX / 8)
c0029311:	bf 00 00 00 00       	mov    $0x0,%edi
    if (c >= '0' && c <= '7')
c0029316:	89 e8                	mov    %ebp,%eax
c0029318:	3c 07                	cmp    $0x7,%al
c002931a:	77 3c                	ja     c0029358 <parse_octal_field+0x6e>
      *value = c - '0' + *value * 8;
c002931c:	0f be db             	movsbl %bl,%ebx
c002931f:	8d 7c fb d0          	lea    -0x30(%ebx,%edi,8),%edi
c0029323:	89 39                	mov    %edi,(%ecx)
  for (ofs = 0; ofs < size; ofs++)
c0029325:	83 c6 01             	add    $0x1,%esi
c0029328:	39 f2                	cmp    %esi,%edx
c002932a:	74 1f                	je     c002934b <parse_octal_field+0x61>
    char c = s[ofs];
c002932c:	8b 04 24             	mov    (%esp),%eax
c002932f:	0f b6 1c 30          	movzbl (%eax,%esi,1),%ebx
    if (c >= '0' && c <= '7')
c0029333:	8d 6b d0             	lea    -0x30(%ebx),%ebp
c0029336:	89 e8                	mov    %ebp,%eax
c0029338:	3c 07                	cmp    $0x7,%al
c002933a:	77 1c                	ja     c0029358 <parse_octal_field+0x6e>
      if (*value > ULONG_MAX / 8)
c002933c:	81 ff ff ff ff 1f    	cmp    $0x1fffffff,%edi
c0029342:	76 d8                	jbe    c002931c <parse_octal_field+0x32>
        return false;
c0029344:	b8 00 00 00 00       	mov    $0x0,%eax
c0029349:	eb 05                	jmp    c0029350 <parse_octal_field+0x66>
  return false;
c002934b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0029350:	83 c4 04             	add    $0x4,%esp
c0029353:	5b                   	pop    %ebx
c0029354:	5e                   	pop    %esi
c0029355:	5f                   	pop    %edi
c0029356:	5d                   	pop    %ebp
c0029357:	c3                   	ret    
      return false;
c0029358:	b8 00 00 00 00       	mov    $0x0,%eax
    else if (c == ' ' || c == '\0')
c002935d:	f6 c3 df             	test   $0xdf,%bl
c0029360:	75 ee                	jne    c0029350 <parse_octal_field+0x66>
      return ofs > 0;
c0029362:	85 f6                	test   %esi,%esi
c0029364:	0f 95 c0             	setne  %al
c0029367:	eb e7                	jmp    c0029350 <parse_octal_field+0x66>

c0029369 <strip_antisocial_prefixes>:
{
c0029369:	55                   	push   %ebp
c002936a:	57                   	push   %edi
c002936b:	56                   	push   %esi
c002936c:	53                   	push   %ebx
c002936d:	83 ec 1c             	sub    $0x1c,%esp
c0029370:	e8 71 91 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0029375:	81 c3 c7 78 01 00    	add    $0x178c7,%ebx
c002937b:	89 c5                	mov    %eax,%ebp
  while (*file_name == '/' || !memcmp(file_name, "./", 2) || !memcmp(file_name, "../", 3))
c002937d:	8d bb 06 3c ff ff    	lea    -0xc3fa(%ebx),%edi
c0029383:	8d 83 d1 47 ff ff    	lea    -0xb82f(%ebx),%eax
c0029389:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002938d:	eb 11                	jmp    c00293a0 <strip_antisocial_prefixes+0x37>
    file_name = strchr(file_name, '/') + 1;
c002938f:	83 ec 08             	sub    $0x8,%esp
c0029392:	6a 2f                	push   $0x2f
c0029394:	55                   	push   %ebp
c0029395:	e8 2c f8 ff ff       	call   c0028bc6 <strchr>
c002939a:	83 c4 10             	add    $0x10,%esp
c002939d:	8d 68 01             	lea    0x1(%eax),%ebp
  while (*file_name == '/' || !memcmp(file_name, "./", 2) || !memcmp(file_name, "../", 3))
c00293a0:	0f b6 75 00          	movzbl 0x0(%ebp),%esi
c00293a4:	89 f0                	mov    %esi,%eax
c00293a6:	3c 2f                	cmp    $0x2f,%al
c00293a8:	74 e5                	je     c002938f <strip_antisocial_prefixes+0x26>
c00293aa:	83 ec 04             	sub    $0x4,%esp
c00293ad:	6a 02                	push   $0x2
c00293af:	57                   	push   %edi
c00293b0:	55                   	push   %ebp
c00293b1:	e8 52 f7 ff ff       	call   c0028b08 <memcmp>
c00293b6:	83 c4 10             	add    $0x10,%esp
c00293b9:	85 c0                	test   %eax,%eax
c00293bb:	74 d2                	je     c002938f <strip_antisocial_prefixes+0x26>
c00293bd:	83 ec 04             	sub    $0x4,%esp
c00293c0:	6a 03                	push   $0x3
c00293c2:	ff 74 24 14          	pushl  0x14(%esp)
c00293c6:	55                   	push   %ebp
c00293c7:	e8 3c f7 ff ff       	call   c0028b08 <memcmp>
c00293cc:	83 c4 10             	add    $0x10,%esp
c00293cf:	85 c0                	test   %eax,%eax
c00293d1:	74 bc                	je     c002938f <strip_antisocial_prefixes+0x26>
  return *file_name == '\0' || !strcmp(file_name, "..") ? "." : file_name;
c00293d3:	8d 83 83 41 ff ff    	lea    -0xbe7d(%ebx),%eax
c00293d9:	89 f2                	mov    %esi,%edx
c00293db:	84 d2                	test   %dl,%dl
c00293dd:	74 22                	je     c0029401 <strip_antisocial_prefixes+0x98>
c00293df:	b9 03 00 00 00       	mov    $0x3,%ecx
c00293e4:	8d bb 82 41 ff ff    	lea    -0xbe7e(%ebx),%edi
c00293ea:	89 ee                	mov    %ebp,%esi
c00293ec:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
c00293ee:	0f 97 c0             	seta   %al
c00293f1:	1c 00                	sbb    $0x0,%al
c00293f3:	0f be c0             	movsbl %al,%eax
c00293f6:	85 c0                	test   %eax,%eax
c00293f8:	8d 83 83 41 ff ff    	lea    -0xbe7d(%ebx),%eax
c00293fe:	0f 45 c5             	cmovne %ebp,%eax
}
c0029401:	83 c4 1c             	add    $0x1c,%esp
c0029404:	5b                   	pop    %ebx
c0029405:	5e                   	pop    %esi
c0029406:	5f                   	pop    %edi
c0029407:	5d                   	pop    %ebp
c0029408:	c3                   	ret    

c0029409 <ustar_make_header>:
{
c0029409:	55                   	push   %ebp
c002940a:	57                   	push   %edi
c002940b:	56                   	push   %esi
c002940c:	53                   	push   %ebx
c002940d:	83 ec 1c             	sub    $0x1c,%esp
c0029410:	e8 d1 90 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0029415:	81 c3 27 78 01 00    	add    $0x17827,%ebx
c002941b:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c002941f:	8b 74 24 3c          	mov    0x3c(%esp),%esi
  ASSERT(type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c0029423:	83 fd 30             	cmp    $0x30,%ebp
c0029426:	0f 94 c2             	sete   %dl
c0029429:	83 fd 35             	cmp    $0x35,%ebp
c002942c:	0f 94 c0             	sete   %al
c002942f:	08 c2                	or     %al,%dl
c0029431:	88 54 24 0f          	mov    %dl,0xf(%esp)
c0029435:	0f 84 77 01 00 00    	je     c00295b2 <ustar_make_header+0x1a9>
  file_name = strip_antisocial_prefixes(file_name);
c002943b:	8b 44 24 30          	mov    0x30(%esp),%eax
c002943f:	e8 25 ff ff ff       	call   c0029369 <strip_antisocial_prefixes>
c0029444:	89 c2                	mov    %eax,%edx
  if (strlen(file_name) > 99)
c0029446:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002944b:	b8 00 00 00 00       	mov    $0x0,%eax
c0029450:	89 d7                	mov    %edx,%edi
c0029452:	f2 ae                	repnz scas %es:(%edi),%al
c0029454:	f7 d1                	not    %ecx
c0029456:	83 e9 01             	sub    $0x1,%ecx
c0029459:	83 f9 63             	cmp    $0x63,%ecx
c002945c:	0f 87 76 01 00 00    	ja     c00295d8 <ustar_make_header+0x1cf>
  memset(h, 0, sizeof *h);
c0029462:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
c0029468:	c7 86 fc 01 00 00 00 	movl   $0x0,0x1fc(%esi)
c002946f:	00 00 00 
c0029472:	8d 7e 04             	lea    0x4(%esi),%edi
c0029475:	83 e7 fc             	and    $0xfffffffc,%edi
c0029478:	89 f1                	mov    %esi,%ecx
c002947a:	29 f9                	sub    %edi,%ecx
c002947c:	81 c1 00 02 00 00    	add    $0x200,%ecx
c0029482:	c1 e9 02             	shr    $0x2,%ecx
c0029485:	b8 00 00 00 00       	mov    $0x0,%eax
c002948a:	f3 ab                	rep stos %eax,%es:(%edi)
  strlcpy(h->name, file_name, sizeof h->name);
c002948c:	83 ec 04             	sub    $0x4,%esp
c002948f:	6a 64                	push   $0x64
c0029491:	52                   	push   %edx
c0029492:	56                   	push   %esi
c0029493:	e8 52 fa ff ff       	call   c0028eea <strlcpy>
  snprintf(h->mode, sizeof h->mode, "%07o",
c0029498:	83 c4 10             	add    $0x10,%esp
c002949b:	83 fd 30             	cmp    $0x30,%ebp
c002949e:	b8 a4 01 00 00       	mov    $0x1a4,%eax
c00294a3:	ba ed 01 00 00       	mov    $0x1ed,%edx
c00294a8:	0f 45 c2             	cmovne %edx,%eax
c00294ab:	50                   	push   %eax
c00294ac:	8d 83 ff 47 ff ff    	lea    -0xb801(%ebx),%eax
c00294b2:	50                   	push   %eax
c00294b3:	6a 08                	push   $0x8
c00294b5:	8d 46 64             	lea    0x64(%esi),%eax
c00294b8:	50                   	push   %eax
c00294b9:	e8 61 ef ff ff       	call   c002841f <snprintf>
  strlcpy(h->uid, "0000000", sizeof h->uid);
c00294be:	83 c4 0c             	add    $0xc,%esp
c00294c1:	6a 08                	push   $0x8
c00294c3:	8d bb 04 48 ff ff    	lea    -0xb7fc(%ebx),%edi
c00294c9:	57                   	push   %edi
c00294ca:	8d 46 6c             	lea    0x6c(%esi),%eax
c00294cd:	50                   	push   %eax
c00294ce:	e8 17 fa ff ff       	call   c0028eea <strlcpy>
  strlcpy(h->gid, "0000000", sizeof h->gid);
c00294d3:	83 c4 0c             	add    $0xc,%esp
c00294d6:	6a 08                	push   $0x8
c00294d8:	57                   	push   %edi
c00294d9:	8d 46 74             	lea    0x74(%esi),%eax
c00294dc:	50                   	push   %eax
c00294dd:	e8 08 fa ff ff       	call   c0028eea <strlcpy>
  snprintf(h->size, sizeof h->size, "%011o", size);
c00294e2:	ff 74 24 48          	pushl  0x48(%esp)
c00294e6:	8d bb 0c 48 ff ff    	lea    -0xb7f4(%ebx),%edi
c00294ec:	57                   	push   %edi
c00294ed:	6a 0c                	push   $0xc
c00294ef:	8d 46 7c             	lea    0x7c(%esi),%eax
c00294f2:	50                   	push   %eax
c00294f3:	e8 27 ef ff ff       	call   c002841f <snprintf>
  snprintf(h->mtime, sizeof h->size, "%011o", 1136102400);
c00294f8:	83 c4 20             	add    $0x20,%esp
c00294fb:	68 00 8c b7 43       	push   $0x43b78c00
c0029500:	57                   	push   %edi
c0029501:	6a 0c                	push   $0xc
c0029503:	8d 86 88 00 00 00    	lea    0x88(%esi),%eax
c0029509:	50                   	push   %eax
c002950a:	e8 10 ef ff ff       	call   c002841f <snprintf>
  h->typeflag = type;
c002950f:	89 e8                	mov    %ebp,%eax
c0029511:	88 86 9c 00 00 00    	mov    %al,0x9c(%esi)
  strlcpy(h->magic, "ustar", sizeof h->magic);
c0029517:	83 c4 0c             	add    $0xc,%esp
c002951a:	6a 06                	push   $0x6
c002951c:	8d 83 12 48 ff ff    	lea    -0xb7ee(%ebx),%eax
c0029522:	50                   	push   %eax
c0029523:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c0029529:	50                   	push   %eax
c002952a:	e8 bb f9 ff ff       	call   c0028eea <strlcpy>
  h->version[0] = h->version[1] = '0';
c002952f:	c6 86 08 01 00 00 30 	movb   $0x30,0x108(%esi)
c0029536:	c6 86 07 01 00 00 30 	movb   $0x30,0x107(%esi)
  strlcpy(h->gname, "root", sizeof h->gname);
c002953d:	83 c4 0c             	add    $0xc,%esp
c0029540:	6a 20                	push   $0x20
c0029542:	8d bb b4 3d ff ff    	lea    -0xc24c(%ebx),%edi
c0029548:	57                   	push   %edi
c0029549:	8d 86 29 01 00 00    	lea    0x129(%esi),%eax
c002954f:	50                   	push   %eax
c0029550:	e8 95 f9 ff ff       	call   c0028eea <strlcpy>
  strlcpy(h->uname, "root", sizeof h->uname);
c0029555:	83 c4 0c             	add    $0xc,%esp
c0029558:	6a 20                	push   $0x20
c002955a:	57                   	push   %edi
c002955b:	8d 86 09 01 00 00    	lea    0x109(%esi),%eax
c0029561:	50                   	push   %eax
c0029562:	e8 83 f9 ff ff       	call   c0028eea <strlcpy>
c0029567:	83 c4 10             	add    $0x10,%esp
c002956a:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c002956f:	ba 00 00 00 00       	mov    $0x0,%edx
    chksum += in_chksum_field ? ' ' : header[i];
c0029574:	bf 20 00 00 00       	mov    $0x20,%edi
c0029579:	83 f8 07             	cmp    $0x7,%eax
c002957c:	77 74                	ja     c00295f2 <ustar_make_header+0x1e9>
c002957e:	89 f9                	mov    %edi,%ecx
c0029580:	01 ca                	add    %ecx,%edx
c0029582:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0029585:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c002958a:	75 ed                	jne    c0029579 <ustar_make_header+0x170>
  snprintf(h->chksum, sizeof h->chksum, "%07o", calculate_chksum(h));
c002958c:	52                   	push   %edx
c002958d:	8d 83 ff 47 ff ff    	lea    -0xb801(%ebx),%eax
c0029593:	50                   	push   %eax
c0029594:	6a 08                	push   $0x8
c0029596:	81 c6 94 00 00 00    	add    $0x94,%esi
c002959c:	56                   	push   %esi
c002959d:	e8 7d ee ff ff       	call   c002841f <snprintf>
  return true;
c00295a2:	83 c4 10             	add    $0x10,%esp
}
c00295a5:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
c00295aa:	83 c4 1c             	add    $0x1c,%esp
c00295ad:	5b                   	pop    %ebx
c00295ae:	5e                   	pop    %esi
c00295af:	5f                   	pop    %edi
c00295b0:	5d                   	pop    %ebp
c00295b1:	c3                   	ret    
  ASSERT(type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c00295b2:	83 ec 0c             	sub    $0xc,%esp
c00295b5:	8d 83 bc 48 ff ff    	lea    -0xb744(%ebx),%eax
c00295bb:	50                   	push   %eax
c00295bc:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00295c2:	50                   	push   %eax
c00295c3:	8d 83 40 26 ff ff    	lea    -0xd9c0(%ebx),%eax
c00295c9:	50                   	push   %eax
c00295ca:	6a 55                	push   $0x55
c00295cc:	8d 83 d5 47 ff ff    	lea    -0xb82b(%ebx),%eax
c00295d2:	50                   	push   %eax
c00295d3:	e8 bd 02 00 00       	call   c0029895 <debug_panic>
    printf("%s: file name too long\n", file_name);
c00295d8:	83 ec 08             	sub    $0x8,%esp
c00295db:	52                   	push   %edx
c00295dc:	8d 83 e7 47 ff ff    	lea    -0xb819(%ebx),%eax
c00295e2:	50                   	push   %eax
c00295e3:	e8 16 e5 ff ff       	call   c0027afe <printf>
    return false;
c00295e8:	83 c4 10             	add    $0x10,%esp
c00295eb:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
c00295f0:	eb b3                	jmp    c00295a5 <ustar_make_header+0x19c>
    chksum += in_chksum_field ? ' ' : header[i];
c00295f2:	0f b6 8c 06 94 00 00 	movzbl 0x94(%esi,%eax,1),%ecx
c00295f9:	00 
c00295fa:	eb 84                	jmp    c0029580 <ustar_make_header+0x177>

c00295fc <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header(const char header[USTAR_HEADER_SIZE],
                   const char **file_name, enum ustar_type *type, int *size)
{
c00295fc:	57                   	push   %edi
c00295fd:	56                   	push   %esi
c00295fe:	53                   	push   %ebx
c00295ff:	83 ec 10             	sub    $0x10,%esp
c0029602:	e8 df 8e 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0029607:	81 c3 35 76 01 00    	add    $0x17635,%ebx
c002960d:	8b 74 24 20          	mov    0x20(%esp),%esi
c0029611:	8d 96 00 02 00 00    	lea    0x200(%esi),%edx
c0029617:	89 f0                	mov    %esi,%eax
    if (*block++ != 0)
c0029619:	83 c0 01             	add    $0x1,%eax
c002961c:	80 78 ff 00          	cmpb   $0x0,-0x1(%eax)
c0029620:	75 70                	jne    c0029692 <ustar_parse_header+0x96>
  while (cnt-- > 0)
c0029622:	39 c2                	cmp    %eax,%edx
c0029624:	75 f3                	jne    c0029619 <ustar_parse_header+0x1d>
  ASSERT(sizeof(struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros(header, USTAR_HEADER_SIZE))
  {
    *file_name = NULL;
c0029626:	8b 44 24 24          	mov    0x24(%esp),%eax
c002962a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    *type = USTAR_EOF;
c0029630:	8b 44 24 28          	mov    0x28(%esp),%eax
c0029634:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
    *size = 0;
c002963a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002963e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    return NULL;
c0029644:	b9 00 00 00 00       	mov    $0x0,%ecx
  /* Success. */
  *file_name = strip_antisocial_prefixes(h->name);
  *type = h->typeflag;
  *size = size_ul;
  return NULL;
}
c0029649:	89 c8                	mov    %ecx,%eax
c002964b:	83 c4 10             	add    $0x10,%esp
c002964e:	5b                   	pop    %ebx
c002964f:	5e                   	pop    %esi
c0029650:	5f                   	pop    %edi
c0029651:	c3                   	ret    
    chksum += in_chksum_field ? ' ' : header[i];
c0029652:	0f b6 8c 06 94 00 00 	movzbl 0x94(%esi,%eax,1),%ecx
c0029659:	00 
c002965a:	e9 b0 00 00 00       	jmp    c002970f <ustar_parse_header+0x113>
    size_ul = 0;
c002965f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0029666:	00 
  *file_name = strip_antisocial_prefixes(h->name);
c0029667:	89 f0                	mov    %esi,%eax
c0029669:	e8 fb fc ff ff       	call   c0029369 <strip_antisocial_prefixes>
c002966e:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0029672:	89 07                	mov    %eax,(%edi)
  *type = h->typeflag;
c0029674:	0f be 86 9c 00 00 00 	movsbl 0x9c(%esi),%eax
c002967b:	8b 7c 24 28          	mov    0x28(%esp),%edi
c002967f:	89 07                	mov    %eax,(%edi)
  *size = size_ul;
c0029681:	8b 44 24 08          	mov    0x8(%esp),%eax
c0029685:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c0029689:	89 07                	mov    %eax,(%edi)
  return NULL;
c002968b:	b9 00 00 00 00       	mov    $0x0,%ecx
c0029690:	eb b7                	jmp    c0029649 <ustar_parse_header+0x4d>
  if (memcmp(h->magic, "ustar", 6))
c0029692:	83 ec 04             	sub    $0x4,%esp
c0029695:	6a 06                	push   $0x6
c0029697:	8d 83 12 48 ff ff    	lea    -0xb7ee(%ebx),%eax
c002969d:	50                   	push   %eax
c002969e:	8d 86 01 01 00 00    	lea    0x101(%esi),%eax
c00296a4:	50                   	push   %eax
c00296a5:	e8 5e f4 ff ff       	call   c0028b08 <memcmp>
c00296aa:	83 c4 10             	add    $0x10,%esp
    return "not a ustar archive";
c00296ad:	8d 8b 18 48 ff ff    	lea    -0xb7e8(%ebx),%ecx
  if (memcmp(h->magic, "ustar", 6))
c00296b3:	85 c0                	test   %eax,%eax
c00296b5:	75 92                	jne    c0029649 <ustar_parse_header+0x4d>
    return "invalid ustar version";
c00296b7:	8d 8b 2c 48 ff ff    	lea    -0xb7d4(%ebx),%ecx
  else if (h->version[0] != '0' || h->version[1] != '0')
c00296bd:	80 be 07 01 00 00 30 	cmpb   $0x30,0x107(%esi)
c00296c4:	75 83                	jne    c0029649 <ustar_parse_header+0x4d>
c00296c6:	80 be 08 01 00 00 30 	cmpb   $0x30,0x108(%esi)
c00296cd:	0f 85 76 ff ff ff    	jne    c0029649 <ustar_parse_header+0x4d>
  else if (!parse_octal_field(h->chksum, sizeof h->chksum, &chksum))
c00296d3:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c00296d7:	8d 86 94 00 00 00    	lea    0x94(%esi),%eax
c00296dd:	ba 08 00 00 00       	mov    $0x8,%edx
c00296e2:	e8 03 fc ff ff       	call   c00292ea <parse_octal_field>
    return "corrupt chksum field";
c00296e7:	8d 8b 42 48 ff ff    	lea    -0xb7be(%ebx),%ecx
  else if (!parse_octal_field(h->chksum, sizeof h->chksum, &chksum))
c00296ed:	84 c0                	test   %al,%al
c00296ef:	0f 84 54 ff ff ff    	je     c0029649 <ustar_parse_header+0x4d>
c00296f5:	b8 6c ff ff ff       	mov    $0xffffff6c,%eax
  chksum = 0;
c00296fa:	ba 00 00 00 00       	mov    $0x0,%edx
    chksum += in_chksum_field ? ' ' : header[i];
c00296ff:	bf 20 00 00 00       	mov    $0x20,%edi
c0029704:	83 f8 07             	cmp    $0x7,%eax
c0029707:	0f 87 45 ff ff ff    	ja     c0029652 <ustar_parse_header+0x56>
c002970d:	89 f9                	mov    %edi,%ecx
c002970f:	01 ca                	add    %ecx,%edx
c0029711:	83 c0 01             	add    $0x1,%eax
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c0029714:	3d 6c 01 00 00       	cmp    $0x16c,%eax
c0029719:	75 e9                	jne    c0029704 <ustar_parse_header+0x108>
    return "checksum mismatch";
c002971b:	8d 8b 57 48 ff ff    	lea    -0xb7a9(%ebx),%ecx
  else if (chksum != calculate_chksum(h))
c0029721:	39 54 24 0c          	cmp    %edx,0xc(%esp)
c0029725:	0f 85 1e ff ff ff    	jne    c0029649 <ustar_parse_header+0x4d>
    return "file name too long";
c002972b:	8d 8b 69 48 ff ff    	lea    -0xb797(%ebx),%ecx
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c0029731:	80 7e 63 00          	cmpb   $0x0,0x63(%esi)
c0029735:	0f 85 0e ff ff ff    	jne    c0029649 <ustar_parse_header+0x4d>
c002973b:	80 be 59 01 00 00 00 	cmpb   $0x0,0x159(%esi)
c0029742:	0f 85 01 ff ff ff    	jne    c0029649 <ustar_parse_header+0x4d>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0029748:	0f b6 86 9c 00 00 00 	movzbl 0x9c(%esi),%eax
c002974f:	3c 30                	cmp    $0x30,%al
c0029751:	74 0e                	je     c0029761 <ustar_parse_header+0x165>
    return "unimplemented file type";
c0029753:	8d 8b 7c 48 ff ff    	lea    -0xb784(%ebx),%ecx
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0029759:	3c 35                	cmp    $0x35,%al
c002975b:	0f 85 e8 fe ff ff    	jne    c0029649 <ustar_parse_header+0x4d>
  if (h->typeflag == USTAR_REGULAR)
c0029761:	3c 30                	cmp    $0x30,%al
c0029763:	0f 85 f6 fe ff ff    	jne    c002965f <ustar_parse_header+0x63>
    if (!parse_octal_field(h->size, sizeof h->size, &size_ul))
c0029769:	8d 4c 24 08          	lea    0x8(%esp),%ecx
c002976d:	8d 46 7c             	lea    0x7c(%esi),%eax
c0029770:	ba 0c 00 00 00       	mov    $0xc,%edx
c0029775:	e8 70 fb ff ff       	call   c00292ea <parse_octal_field>
      return "corrupt file size field";
c002977a:	8d 8b 94 48 ff ff    	lea    -0xb76c(%ebx),%ecx
    if (!parse_octal_field(h->size, sizeof h->size, &size_ul))
c0029780:	84 c0                	test   %al,%al
c0029782:	0f 84 c1 fe ff ff    	je     c0029649 <ustar_parse_header+0x4d>
      return "file too large";
c0029788:	8d 8b ac 48 ff ff    	lea    -0xb754(%ebx),%ecx
    else if (size_ul > INT_MAX)
c002978e:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0029793:	0f 88 b0 fe ff ff    	js     c0029649 <ustar_parse_header+0x4d>
c0029799:	e9 c9 fe ff ff       	jmp    c0029667 <ustar_parse_header+0x6b>

c002979e <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c002979e:	55                   	push   %ebp
c002979f:	89 e5                	mov    %esp,%ebp
c00297a1:	57                   	push   %edi
c00297a2:	56                   	push   %esi
c00297a3:	53                   	push   %ebx
c00297a4:	83 ec 0c             	sub    $0xc,%esp
c00297a7:	e8 3a 8d 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00297ac:	81 c3 90 74 01 00    	add    $0x17490,%ebx
c00297b2:	8b 75 08             	mov    0x8(%ebp),%esi
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status)
c00297b5:	8b 56 04             	mov    0x4(%esi),%edx
  case THREAD_RUNNING:
    status = "RUNNING";
    break;

  case THREAD_READY:
    status = "READY";
c00297b8:	8d 83 ed 48 ff ff    	lea    -0xb713(%ebx),%eax
  switch (t->status)
c00297be:	83 fa 01             	cmp    $0x1,%edx
c00297c1:	74 1d                	je     c00297e0 <print_stacktrace+0x42>
    status = "RUNNING";
c00297c3:	8d 83 b6 33 ff ff    	lea    -0xcc4a(%ebx),%eax
  switch (t->status)
c00297c9:	83 fa 01             	cmp    $0x1,%edx
c00297cc:	72 12                	jb     c00297e0 <print_stacktrace+0x42>
  const char *status = "UNKNOWN";
c00297ce:	83 fa 02             	cmp    $0x2,%edx
c00297d1:	8d 83 63 33 ff ff    	lea    -0xcc9d(%ebx),%eax
c00297d7:	8d 93 f3 48 ff ff    	lea    -0xb70d(%ebx),%edx
c00297dd:	0f 45 c2             	cmovne %edx,%eax

  default:
    break;
  }

  printf("Call stack of thread `%s' (status %s):", t->name, status);
c00297e0:	83 ec 04             	sub    $0x4,%esp
c00297e3:	50                   	push   %eax
c00297e4:	8d 46 08             	lea    0x8(%esi),%eax
c00297e7:	50                   	push   %eax
c00297e8:	8d 83 18 49 ff ff    	lea    -0xb6e8(%ebx),%eax
c00297ee:	50                   	push   %eax
c00297ef:	e8 0a e3 ff ff       	call   c0027afe <printf>

  if (t == thread_current())
c00297f4:	e8 4c 78 ff ff       	call   c0021045 <thread_current>
c00297f9:	83 c4 10             	add    $0x10,%esp
c00297fc:	39 f0                	cmp    %esi,%eax
c00297fe:	74 79                	je     c0029879 <print_stacktrace+0xdb>
  {
    /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
    struct switch_threads_frame *saved_frame;

    saved_frame = (struct switch_threads_frame *)t->stack;
c0029800:	8b 56 18             	mov    0x18(%esi),%edx
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
    if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c0029803:	81 c6 00 10 00 00    	add    $0x1000,%esi
c0029809:	39 f2                	cmp    %esi,%edx
c002980b:	74 74                	je     c0029881 <print_stacktrace+0xe3>
c002980d:	8b 42 10             	mov    0x10(%edx),%eax
c0029810:	81 f8 e9 1d 02 c0    	cmp    $0xc0021de9,%eax
c0029816:	74 69                	je     c0029881 <print_stacktrace+0xe3>
    {
      printf(" thread was never scheduled.\n");
      return;
    }

    frame = (void **)saved_frame->ebp;
c0029818:	8b 72 08             	mov    0x8(%edx),%esi
    retaddr = (void *)saved_frame->eip;
  }

  printf(" %p", retaddr);
c002981b:	83 ec 08             	sub    $0x8,%esp
c002981e:	50                   	push   %eax
c002981f:	8d 83 ea 45 ff ff    	lea    -0xba16(%ebx),%eax
c0029825:	50                   	push   %eax
c0029826:	e8 d3 e2 ff ff       	call   c0027afe <printf>
  for (; (uintptr_t)frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c002982b:	83 c4 10             	add    $0x10,%esp
c002982e:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0029834:	76 29                	jbe    c002985f <print_stacktrace+0xc1>
c0029836:	83 3e 00             	cmpl   $0x0,(%esi)
c0029839:	74 24                	je     c002985f <print_stacktrace+0xc1>
    printf(" %p", frame[1]);
c002983b:	8d bb ea 45 ff ff    	lea    -0xba16(%ebx),%edi
c0029841:	83 ec 08             	sub    $0x8,%esp
c0029844:	ff 76 04             	pushl  0x4(%esi)
c0029847:	57                   	push   %edi
c0029848:	e8 b1 e2 ff ff       	call   c0027afe <printf>
  for (; (uintptr_t)frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c002984d:	8b 36                	mov    (%esi),%esi
c002984f:	83 c4 10             	add    $0x10,%esp
c0029852:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
c0029858:	76 05                	jbe    c002985f <print_stacktrace+0xc1>
c002985a:	83 3e 00             	cmpl   $0x0,(%esi)
c002985d:	75 e2                	jne    c0029841 <print_stacktrace+0xa3>
  printf(".\n");
c002985f:	83 ec 0c             	sub    $0xc,%esp
c0029862:	8d 83 83 41 ff ff    	lea    -0xbe7d(%ebx),%eax
c0029868:	50                   	push   %eax
c0029869:	e8 00 20 00 00       	call   c002b86e <puts>
c002986e:	83 c4 10             	add    $0x10,%esp
}
c0029871:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0029874:	5b                   	pop    %ebx
c0029875:	5e                   	pop    %esi
c0029876:	5f                   	pop    %edi
c0029877:	5d                   	pop    %ebp
c0029878:	c3                   	ret    
    frame = __builtin_frame_address(1);
c0029879:	8b 75 00             	mov    0x0(%ebp),%esi
    retaddr = __builtin_return_address(0);
c002987c:	8b 45 04             	mov    0x4(%ebp),%eax
c002987f:	eb 9a                	jmp    c002981b <print_stacktrace+0x7d>
      printf(" thread was never scheduled.\n");
c0029881:	83 ec 0c             	sub    $0xc,%esp
c0029884:	8d 83 fb 48 ff ff    	lea    -0xb705(%ebx),%eax
c002988a:	50                   	push   %eax
c002988b:	e8 de 1f 00 00       	call   c002b86e <puts>
      return;
c0029890:	83 c4 10             	add    $0x10,%esp
c0029893:	eb dc                	jmp    c0029871 <print_stacktrace+0xd3>

c0029895 <debug_panic>:
{
c0029895:	55                   	push   %ebp
c0029896:	57                   	push   %edi
c0029897:	56                   	push   %esi
c0029898:	53                   	push   %ebx
c0029899:	83 ec 0c             	sub    $0xc,%esp
c002989c:	e8 45 8c 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00298a1:	81 c3 9b 73 01 00    	add    $0x1739b,%ebx
c00298a7:	8b 74 24 20          	mov    0x20(%esp),%esi
c00298ab:	8b 7c 24 24          	mov    0x24(%esp),%edi
c00298af:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  intr_disable();
c00298b3:	e8 f3 86 ff ff       	call   c0021fab <intr_disable>
  console_panic();
c00298b8:	e8 30 1f 00 00       	call   c002b7ed <console_panic>
  level++;
c00298bd:	8b 83 44 1d 00 00    	mov    0x1d44(%ebx),%eax
c00298c3:	83 c0 01             	add    $0x1,%eax
c00298c6:	89 83 44 1d 00 00    	mov    %eax,0x1d44(%ebx)
  if (level == 1)
c00298cc:	83 f8 01             	cmp    $0x1,%eax
c00298cf:	74 11                	je     c00298e2 <debug_panic+0x4d>
  else if (level == 2)
c00298d1:	83 f8 02             	cmp    $0x2,%eax
c00298d4:	74 42                	je     c0029918 <debug_panic+0x83>
  serial_flush();
c00298d6:	e8 bf bc ff ff       	call   c002559a <serial_flush>
  shutdown();
c00298db:	e8 1b db ff ff       	call   c00273fb <shutdown>
c00298e0:	eb fe                	jmp    c00298e0 <debug_panic+0x4b>
    printf("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c00298e2:	55                   	push   %ebp
c00298e3:	57                   	push   %edi
c00298e4:	56                   	push   %esi
c00298e5:	8d 83 40 49 ff ff    	lea    -0xb6c0(%ebx),%eax
c00298eb:	50                   	push   %eax
c00298ec:	e8 0d e2 ff ff       	call   c0027afe <printf>
    va_start(args, message);
c00298f1:	8d 44 24 40          	lea    0x40(%esp),%eax
    vprintf(message, args);
c00298f5:	83 c4 08             	add    $0x8,%esp
c00298f8:	50                   	push   %eax
c00298f9:	ff 74 24 38          	pushl  0x38(%esp)
c00298fd:	e8 29 1f 00 00       	call   c002b82b <vprintf>
    printf("\n");
c0029902:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
c0029909:	e8 d2 1f 00 00       	call   c002b8e0 <putchar>
    debug_backtrace();
c002990e:	e8 cf db ff ff       	call   c00274e2 <debug_backtrace>
c0029913:	83 c4 10             	add    $0x10,%esp
c0029916:	eb be                	jmp    c00298d6 <debug_panic+0x41>
    printf("Kernel PANIC recursion at %s:%d in %s().\n",
c0029918:	55                   	push   %ebp
c0029919:	57                   	push   %edi
c002991a:	56                   	push   %esi
c002991b:	8d 83 60 49 ff ff    	lea    -0xb6a0(%ebx),%eax
c0029921:	50                   	push   %eax
c0029922:	e8 d7 e1 ff ff       	call   c0027afe <printf>
c0029927:	83 c4 10             	add    $0x10,%esp
c002992a:	eb aa                	jmp    c00298d6 <debug_panic+0x41>

c002992c <debug_backtrace_all>:

/* Prints call stack of all threads. */
void debug_backtrace_all(void)
{
c002992c:	56                   	push   %esi
c002992d:	53                   	push   %ebx
c002992e:	83 ec 04             	sub    $0x4,%esp
c0029931:	e8 b0 8b 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0029936:	81 c3 06 73 01 00    	add    $0x17306,%ebx
  enum intr_level oldlevel = intr_disable();
c002993c:	e8 6a 86 ff ff       	call   c0021fab <intr_disable>
c0029941:	89 c6                	mov    %eax,%esi

  thread_foreach(print_stacktrace, 0);
c0029943:	83 ec 08             	sub    $0x8,%esp
c0029946:	6a 00                	push   $0x0
c0029948:	8d 83 62 8b fe ff    	lea    -0x1749e(%ebx),%eax
c002994e:	50                   	push   %eax
c002994f:	e8 fc 77 ff ff       	call   c0021150 <thread_foreach>
  intr_set_level(oldlevel);
c0029954:	89 34 24             	mov    %esi,(%esp)
c0029957:	e8 56 86 ff ff       	call   c0021fb2 <intr_set_level>
}
c002995c:	83 c4 14             	add    $0x14,%esp
c002995f:	5b                   	pop    %ebx
c0029960:	5e                   	pop    %esi
c0029961:	c3                   	ret    

c0029962 <list_init>:
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
}

/* Initializes LIST as an empty list. */
void list_init(struct list *list)
{
c0029962:	53                   	push   %ebx
c0029963:	83 ec 08             	sub    $0x8,%esp
c0029966:	e8 7b 8b 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002996b:	81 c3 d1 72 01 00    	add    $0x172d1,%ebx
c0029971:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(list != NULL);
c0029975:	85 c0                	test   %eax,%eax
c0029977:	74 1b                	je     c0029994 <list_init+0x32>
  list->head.prev = NULL;
c0029979:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c002997f:	8d 50 08             	lea    0x8(%eax),%edx
c0029982:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c0029985:	89 40 08             	mov    %eax,0x8(%eax)
  list->tail.next = NULL;
c0029988:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c002998f:	83 c4 08             	add    $0x8,%esp
c0029992:	5b                   	pop    %ebx
c0029993:	c3                   	ret    
  ASSERT(list != NULL);
c0029994:	83 ec 0c             	sub    $0xc,%esp
c0029997:	8d 83 8a 49 ff ff    	lea    -0xb676(%ebx),%eax
c002999d:	50                   	push   %eax
c002999e:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00299a4:	50                   	push   %eax
c00299a5:	8d 83 3c 27 ff ff    	lea    -0xd8c4(%ebx),%eax
c00299ab:	50                   	push   %eax
c00299ac:	6a 3e                	push   $0x3e
c00299ae:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c00299b4:	50                   	push   %eax
c00299b5:	e8 db fe ff ff       	call   c0029895 <debug_panic>

c00299ba <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin(struct list *list)
{
c00299ba:	53                   	push   %ebx
c00299bb:	83 ec 08             	sub    $0x8,%esp
c00299be:	e8 23 8b 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00299c3:	81 c3 79 72 01 00    	add    $0x17279,%ebx
c00299c9:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(list != NULL);
c00299cd:	85 c0                	test   %eax,%eax
c00299cf:	74 08                	je     c00299d9 <list_begin+0x1f>
  return list->head.next;
c00299d1:	8b 40 04             	mov    0x4(%eax),%eax
}
c00299d4:	83 c4 08             	add    $0x8,%esp
c00299d7:	5b                   	pop    %ebx
c00299d8:	c3                   	ret    
  ASSERT(list != NULL);
c00299d9:	83 ec 0c             	sub    $0xc,%esp
c00299dc:	8d 83 8a 49 ff ff    	lea    -0xb676(%ebx),%eax
c00299e2:	50                   	push   %eax
c00299e3:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00299e9:	50                   	push   %eax
c00299ea:	8d 83 30 27 ff ff    	lea    -0xd8d0(%ebx),%eax
c00299f0:	50                   	push   %eax
c00299f1:	6a 49                	push   $0x49
c00299f3:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c00299f9:	50                   	push   %eax
c00299fa:	e8 96 fe ff ff       	call   c0029895 <debug_panic>

c00299ff <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next(struct list_elem *elem)
{
c00299ff:	53                   	push   %ebx
c0029a00:	83 ec 08             	sub    $0x8,%esp
c0029a03:	e8 de 8a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0029a08:	81 c3 34 72 01 00    	add    $0x17234,%ebx
c0029a0e:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0029a12:	85 c0                	test   %eax,%eax
c0029a14:	74 20                	je     c0029a36 <list_next+0x37>
c0029a16:	83 38 00             	cmpl   $0x0,(%eax)
c0029a19:	74 13                	je     c0029a2e <list_next+0x2f>
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029a1b:	83 38 00             	cmpl   $0x0,(%eax)
c0029a1e:	74 16                	je     c0029a36 <list_next+0x37>
c0029a20:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029a24:	74 10                	je     c0029a36 <list_next+0x37>
  ASSERT(is_head(elem) || is_interior(elem));
  return elem->next;
c0029a26:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029a29:	83 c4 08             	add    $0x8,%esp
c0029a2c:	5b                   	pop    %ebx
c0029a2d:	c3                   	ret    
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0029a2e:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029a32:	75 f2                	jne    c0029a26 <list_next+0x27>
c0029a34:	eb e5                	jmp    c0029a1b <list_next+0x1c>
  ASSERT(is_head(elem) || is_interior(elem));
c0029a36:	83 ec 0c             	sub    $0xc,%esp
c0029a39:	8d 83 48 4a ff ff    	lea    -0xb5b8(%ebx),%eax
c0029a3f:	50                   	push   %eax
c0029a40:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029a46:	50                   	push   %eax
c0029a47:	8d 83 24 27 ff ff    	lea    -0xd8dc(%ebx),%eax
c0029a4d:	50                   	push   %eax
c0029a4e:	6a 53                	push   $0x53
c0029a50:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029a56:	50                   	push   %eax
c0029a57:	e8 39 fe ff ff       	call   c0029895 <debug_panic>

c0029a5c <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end(struct list *list)
{
c0029a5c:	53                   	push   %ebx
c0029a5d:	83 ec 08             	sub    $0x8,%esp
c0029a60:	e8 81 8a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0029a65:	81 c3 d7 71 01 00    	add    $0x171d7,%ebx
c0029a6b:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(list != NULL);
c0029a6f:	85 c0                	test   %eax,%eax
c0029a71:	74 08                	je     c0029a7b <list_end+0x1f>
  return &list->tail;
c0029a73:	83 c0 08             	add    $0x8,%eax
}
c0029a76:	83 c4 08             	add    $0x8,%esp
c0029a79:	5b                   	pop    %ebx
c0029a7a:	c3                   	ret    
  ASSERT(list != NULL);
c0029a7b:	83 ec 0c             	sub    $0xc,%esp
c0029a7e:	8d 83 8a 49 ff ff    	lea    -0xb676(%ebx),%eax
c0029a84:	50                   	push   %eax
c0029a85:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029a8b:	50                   	push   %eax
c0029a8c:	8d 83 18 27 ff ff    	lea    -0xd8e8(%ebx),%eax
c0029a92:	50                   	push   %eax
c0029a93:	6a 5f                	push   $0x5f
c0029a95:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029a9b:	50                   	push   %eax
c0029a9c:	e8 f4 fd ff ff       	call   c0029895 <debug_panic>

c0029aa1 <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin(struct list *list)
{
c0029aa1:	53                   	push   %ebx
c0029aa2:	83 ec 08             	sub    $0x8,%esp
c0029aa5:	e8 3c 8a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0029aaa:	81 c3 92 71 01 00    	add    $0x17192,%ebx
c0029ab0:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(list != NULL);
c0029ab4:	85 c0                	test   %eax,%eax
c0029ab6:	74 08                	je     c0029ac0 <list_rbegin+0x1f>
  return list->tail.prev;
c0029ab8:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029abb:	83 c4 08             	add    $0x8,%esp
c0029abe:	5b                   	pop    %ebx
c0029abf:	c3                   	ret    
  ASSERT(list != NULL);
c0029ac0:	83 ec 0c             	sub    $0xc,%esp
c0029ac3:	8d 83 8a 49 ff ff    	lea    -0xb676(%ebx),%eax
c0029ac9:	50                   	push   %eax
c0029aca:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029ad0:	50                   	push   %eax
c0029ad1:	8d 83 0c 27 ff ff    	lea    -0xd8f4(%ebx),%eax
c0029ad7:	50                   	push   %eax
c0029ad8:	6a 68                	push   $0x68
c0029ada:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029ae0:	50                   	push   %eax
c0029ae1:	e8 af fd ff ff       	call   c0029895 <debug_panic>

c0029ae6 <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev(struct list_elem *elem)
{
c0029ae6:	53                   	push   %ebx
c0029ae7:	83 ec 08             	sub    $0x8,%esp
c0029aea:	e8 f7 89 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0029aef:	81 c3 4d 71 01 00    	add    $0x1714d,%ebx
c0029af5:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029af9:	85 c0                	test   %eax,%eax
c0029afb:	74 1d                	je     c0029b1a <list_prev+0x34>
c0029afd:	83 38 00             	cmpl   $0x0,(%eax)
c0029b00:	74 0d                	je     c0029b0f <list_prev+0x29>
c0029b02:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029b06:	74 07                	je     c0029b0f <list_prev+0x29>
  ASSERT(is_interior(elem) || is_tail(elem));
  return elem->prev;
c0029b08:	8b 00                	mov    (%eax),%eax
}
c0029b0a:	83 c4 08             	add    $0x8,%esp
c0029b0d:	5b                   	pop    %ebx
c0029b0e:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0029b0f:	83 38 00             	cmpl   $0x0,(%eax)
c0029b12:	74 06                	je     c0029b1a <list_prev+0x34>
c0029b14:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029b18:	74 ee                	je     c0029b08 <list_prev+0x22>
  ASSERT(is_interior(elem) || is_tail(elem));
c0029b1a:	83 ec 0c             	sub    $0xc,%esp
c0029b1d:	8d 83 6c 4a ff ff    	lea    -0xb594(%ebx),%eax
c0029b23:	50                   	push   %eax
c0029b24:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029b2a:	50                   	push   %eax
c0029b2b:	8d 83 00 27 ff ff    	lea    -0xd900(%ebx),%eax
c0029b31:	50                   	push   %eax
c0029b32:	6a 72                	push   $0x72
c0029b34:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029b3a:	50                   	push   %eax
c0029b3b:	e8 55 fd ff ff       	call   c0029895 <debug_panic>

c0029b40 <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run(struct list_elem *a, struct list_elem *b,
                list_less_func *less, void *aux)
{
c0029b40:	55                   	push   %ebp
c0029b41:	57                   	push   %edi
c0029b42:	56                   	push   %esi
c0029b43:	53                   	push   %ebx
c0029b44:	83 ec 1c             	sub    $0x1c,%esp
c0029b47:	e8 aa 89 00 00       	call   c00324f6 <__x86.get_pc_thunk.di>
c0029b4c:	81 c7 f0 70 01 00    	add    $0x170f0,%edi
c0029b52:	89 7c 24 0c          	mov    %edi,0xc(%esp)
c0029b56:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  ASSERT(a != NULL);
c0029b5a:	85 c0                	test   %eax,%eax
c0029b5c:	74 50                	je     c0029bae <find_end_of_run+0x6e>
c0029b5e:	89 c3                	mov    %eax,%ebx
c0029b60:	89 d6                	mov    %edx,%esi
c0029b62:	89 cf                	mov    %ecx,%edi
  ASSERT(b != NULL);
c0029b64:	85 d2                	test   %edx,%edx
c0029b66:	74 73                	je     c0029bdb <find_end_of_run+0x9b>
  ASSERT(less != NULL);
c0029b68:	85 c9                	test   %ecx,%ecx
c0029b6a:	0f 84 98 00 00 00    	je     c0029c08 <find_end_of_run+0xc8>
  ASSERT(a != b);
c0029b70:	39 d0                	cmp    %edx,%eax
c0029b72:	0f 84 bd 00 00 00    	je     c0029c35 <find_end_of_run+0xf5>

  do
  {
    a = list_next(a);
c0029b78:	83 ec 0c             	sub    $0xc,%esp
c0029b7b:	53                   	push   %ebx
c0029b7c:	e8 7e fe ff ff       	call   c00299ff <list_next>
c0029b81:	83 c4 10             	add    $0x10,%esp
c0029b84:	89 c3                	mov    %eax,%ebx
  } while (a != b && !less(a, list_prev(a), aux));
c0029b86:	39 c6                	cmp    %eax,%esi
c0029b88:	74 1a                	je     c0029ba4 <find_end_of_run+0x64>
c0029b8a:	83 ec 0c             	sub    $0xc,%esp
c0029b8d:	50                   	push   %eax
c0029b8e:	e8 53 ff ff ff       	call   c0029ae6 <list_prev>
c0029b93:	83 c4 0c             	add    $0xc,%esp
c0029b96:	55                   	push   %ebp
c0029b97:	50                   	push   %eax
c0029b98:	53                   	push   %ebx
c0029b99:	ff d7                	call   *%edi
c0029b9b:	83 c4 10             	add    $0x10,%esp
c0029b9e:	84 c0                	test   %al,%al
c0029ba0:	74 d6                	je     c0029b78 <find_end_of_run+0x38>
    a = list_next(a);
c0029ba2:	89 de                	mov    %ebx,%esi
  return a;
}
c0029ba4:	89 f0                	mov    %esi,%eax
c0029ba6:	83 c4 1c             	add    $0x1c,%esp
c0029ba9:	5b                   	pop    %ebx
c0029baa:	5e                   	pop    %esi
c0029bab:	5f                   	pop    %edi
c0029bac:	5d                   	pop    %ebp
c0029bad:	c3                   	ret    
  ASSERT(a != NULL);
c0029bae:	83 ec 0c             	sub    $0xc,%esp
c0029bb1:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029bb5:	8d 83 67 57 ff ff    	lea    -0xa899(%ebx),%eax
c0029bbb:	50                   	push   %eax
c0029bbc:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029bc2:	50                   	push   %eax
c0029bc3:	8d 83 84 26 ff ff    	lea    -0xd97c(%ebx),%eax
c0029bc9:	50                   	push   %eax
c0029bca:	68 62 01 00 00       	push   $0x162
c0029bcf:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029bd5:	50                   	push   %eax
c0029bd6:	e8 ba fc ff ff       	call   c0029895 <debug_panic>
  ASSERT(b != NULL);
c0029bdb:	83 ec 0c             	sub    $0xc,%esp
c0029bde:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029be2:	8d 83 af 49 ff ff    	lea    -0xb651(%ebx),%eax
c0029be8:	50                   	push   %eax
c0029be9:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029bef:	50                   	push   %eax
c0029bf0:	8d 83 84 26 ff ff    	lea    -0xd97c(%ebx),%eax
c0029bf6:	50                   	push   %eax
c0029bf7:	68 63 01 00 00       	push   $0x163
c0029bfc:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029c02:	50                   	push   %eax
c0029c03:	e8 8d fc ff ff       	call   c0029895 <debug_panic>
  ASSERT(less != NULL);
c0029c08:	83 ec 0c             	sub    $0xc,%esp
c0029c0b:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029c0f:	8d 83 b9 49 ff ff    	lea    -0xb647(%ebx),%eax
c0029c15:	50                   	push   %eax
c0029c16:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029c1c:	50                   	push   %eax
c0029c1d:	8d 83 84 26 ff ff    	lea    -0xd97c(%ebx),%eax
c0029c23:	50                   	push   %eax
c0029c24:	68 64 01 00 00       	push   $0x164
c0029c29:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029c2f:	50                   	push   %eax
c0029c30:	e8 60 fc ff ff       	call   c0029895 <debug_panic>
  ASSERT(a != b);
c0029c35:	83 ec 0c             	sub    $0xc,%esp
c0029c38:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c0029c3c:	8d 83 c6 49 ff ff    	lea    -0xb63a(%ebx),%eax
c0029c42:	50                   	push   %eax
c0029c43:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029c49:	50                   	push   %eax
c0029c4a:	8d 83 84 26 ff ff    	lea    -0xd97c(%ebx),%eax
c0029c50:	50                   	push   %eax
c0029c51:	68 65 01 00 00       	push   $0x165
c0029c56:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029c5c:	50                   	push   %eax
c0029c5d:	e8 33 fc ff ff       	call   c0029895 <debug_panic>

c0029c62 <is_sorted>:
{
c0029c62:	55                   	push   %ebp
c0029c63:	57                   	push   %edi
c0029c64:	56                   	push   %esi
c0029c65:	53                   	push   %ebx
c0029c66:	83 ec 0c             	sub    $0xc,%esp
c0029c69:	89 c3                	mov    %eax,%ebx
c0029c6b:	89 d6                	mov    %edx,%esi
c0029c6d:	89 cd                	mov    %ecx,%ebp
c0029c6f:	8b 7c 24 20          	mov    0x20(%esp),%edi
  if (a != b)
c0029c73:	39 d0                	cmp    %edx,%eax
c0029c75:	74 31                	je     c0029ca8 <is_sorted+0x46>
    while ((a = list_next(a)) != b)
c0029c77:	83 ec 0c             	sub    $0xc,%esp
c0029c7a:	53                   	push   %ebx
c0029c7b:	e8 7f fd ff ff       	call   c00299ff <list_next>
c0029c80:	83 c4 10             	add    $0x10,%esp
c0029c83:	89 c3                	mov    %eax,%ebx
c0029c85:	39 c6                	cmp    %eax,%esi
c0029c87:	74 26                	je     c0029caf <is_sorted+0x4d>
      if (less(a, list_prev(a), aux))
c0029c89:	83 ec 0c             	sub    $0xc,%esp
c0029c8c:	53                   	push   %ebx
c0029c8d:	e8 54 fe ff ff       	call   c0029ae6 <list_prev>
c0029c92:	83 c4 0c             	add    $0xc,%esp
c0029c95:	57                   	push   %edi
c0029c96:	50                   	push   %eax
c0029c97:	53                   	push   %ebx
c0029c98:	ff d5                	call   *%ebp
c0029c9a:	83 c4 10             	add    $0x10,%esp
c0029c9d:	84 c0                	test   %al,%al
c0029c9f:	74 d6                	je     c0029c77 <is_sorted+0x15>
        return false;
c0029ca1:	b8 00 00 00 00       	mov    $0x0,%eax
c0029ca6:	eb 0c                	jmp    c0029cb4 <is_sorted+0x52>
  return true;
c0029ca8:	b8 01 00 00 00       	mov    $0x1,%eax
c0029cad:	eb 05                	jmp    c0029cb4 <is_sorted+0x52>
c0029caf:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0029cb4:	83 c4 0c             	add    $0xc,%esp
c0029cb7:	5b                   	pop    %ebx
c0029cb8:	5e                   	pop    %esi
c0029cb9:	5f                   	pop    %edi
c0029cba:	5d                   	pop    %ebp
c0029cbb:	c3                   	ret    

c0029cbc <list_rend>:
{
c0029cbc:	53                   	push   %ebx
c0029cbd:	83 ec 08             	sub    $0x8,%esp
c0029cc0:	e8 21 88 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0029cc5:	81 c3 77 6f 01 00    	add    $0x16f77,%ebx
c0029ccb:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(list != NULL);
c0029ccf:	85 c0                	test   %eax,%eax
c0029cd1:	74 05                	je     c0029cd8 <list_rend+0x1c>
}
c0029cd3:	83 c4 08             	add    $0x8,%esp
c0029cd6:	5b                   	pop    %ebx
c0029cd7:	c3                   	ret    
  ASSERT(list != NULL);
c0029cd8:	83 ec 0c             	sub    $0xc,%esp
c0029cdb:	8d 83 8a 49 ff ff    	lea    -0xb676(%ebx),%eax
c0029ce1:	50                   	push   %eax
c0029ce2:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029ce8:	50                   	push   %eax
c0029ce9:	8d 83 f4 26 ff ff    	lea    -0xd90c(%ebx),%eax
c0029cef:	50                   	push   %eax
c0029cf0:	68 86 00 00 00       	push   $0x86
c0029cf5:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029cfb:	50                   	push   %eax
c0029cfc:	e8 94 fb ff ff       	call   c0029895 <debug_panic>

c0029d01 <list_head>:
{
c0029d01:	53                   	push   %ebx
c0029d02:	83 ec 08             	sub    $0x8,%esp
c0029d05:	e8 dc 87 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0029d0a:	81 c3 32 6f 01 00    	add    $0x16f32,%ebx
c0029d10:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(list != NULL);
c0029d14:	85 c0                	test   %eax,%eax
c0029d16:	74 05                	je     c0029d1d <list_head+0x1c>
}
c0029d18:	83 c4 08             	add    $0x8,%esp
c0029d1b:	5b                   	pop    %ebx
c0029d1c:	c3                   	ret    
  ASSERT(list != NULL);
c0029d1d:	83 ec 0c             	sub    $0xc,%esp
c0029d20:	8d 83 8a 49 ff ff    	lea    -0xb676(%ebx),%eax
c0029d26:	50                   	push   %eax
c0029d27:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029d2d:	50                   	push   %eax
c0029d2e:	8d 83 e8 26 ff ff    	lea    -0xd918(%ebx),%eax
c0029d34:	50                   	push   %eax
c0029d35:	68 98 00 00 00       	push   $0x98
c0029d3a:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029d40:	50                   	push   %eax
c0029d41:	e8 4f fb ff ff       	call   c0029895 <debug_panic>

c0029d46 <list_tail>:
{
c0029d46:	53                   	push   %ebx
c0029d47:	83 ec 08             	sub    $0x8,%esp
c0029d4a:	e8 97 87 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0029d4f:	81 c3 ed 6e 01 00    	add    $0x16eed,%ebx
c0029d55:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(list != NULL);
c0029d59:	85 c0                	test   %eax,%eax
c0029d5b:	74 08                	je     c0029d65 <list_tail+0x1f>
  return &list->tail;
c0029d5d:	83 c0 08             	add    $0x8,%eax
}
c0029d60:	83 c4 08             	add    $0x8,%esp
c0029d63:	5b                   	pop    %ebx
c0029d64:	c3                   	ret    
  ASSERT(list != NULL);
c0029d65:	83 ec 0c             	sub    $0xc,%esp
c0029d68:	8d 83 8a 49 ff ff    	lea    -0xb676(%ebx),%eax
c0029d6e:	50                   	push   %eax
c0029d6f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029d75:	50                   	push   %eax
c0029d76:	8d 83 dc 26 ff ff    	lea    -0xd924(%ebx),%eax
c0029d7c:	50                   	push   %eax
c0029d7d:	68 a0 00 00 00       	push   $0xa0
c0029d82:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029d88:	50                   	push   %eax
c0029d89:	e8 07 fb ff ff       	call   c0029895 <debug_panic>

c0029d8e <list_insert>:
{
c0029d8e:	53                   	push   %ebx
c0029d8f:	83 ec 08             	sub    $0x8,%esp
c0029d92:	e8 4f 87 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0029d97:	81 c3 a5 6e 01 00    	add    $0x16ea5,%ebx
c0029d9d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0029da1:	8b 54 24 14          	mov    0x14(%esp),%edx
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029da5:	85 c0                	test   %eax,%eax
c0029da7:	74 2d                	je     c0029dd6 <list_insert+0x48>
c0029da9:	83 38 00             	cmpl   $0x0,(%eax)
c0029dac:	74 1d                	je     c0029dcb <list_insert+0x3d>
c0029dae:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029db2:	74 17                	je     c0029dcb <list_insert+0x3d>
  ASSERT(elem != NULL);
c0029db4:	85 d2                	test   %edx,%edx
c0029db6:	74 47                	je     c0029dff <list_insert+0x71>
  elem->prev = before->prev;
c0029db8:	8b 08                	mov    (%eax),%ecx
c0029dba:	89 0a                	mov    %ecx,(%edx)
  elem->next = before;
c0029dbc:	89 42 04             	mov    %eax,0x4(%edx)
  before->prev->next = elem;
c0029dbf:	8b 08                	mov    (%eax),%ecx
c0029dc1:	89 51 04             	mov    %edx,0x4(%ecx)
  before->prev = elem;
c0029dc4:	89 10                	mov    %edx,(%eax)
}
c0029dc6:	83 c4 08             	add    $0x8,%esp
c0029dc9:	5b                   	pop    %ebx
c0029dca:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0029dcb:	83 38 00             	cmpl   $0x0,(%eax)
c0029dce:	74 06                	je     c0029dd6 <list_insert+0x48>
c0029dd0:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0029dd4:	74 de                	je     c0029db4 <list_insert+0x26>
  ASSERT(is_interior(before) || is_tail(before));
c0029dd6:	83 ec 0c             	sub    $0xc,%esp
c0029dd9:	8d 83 90 4a ff ff    	lea    -0xb570(%ebx),%eax
c0029ddf:	50                   	push   %eax
c0029de0:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029de6:	50                   	push   %eax
c0029de7:	8d 83 d0 26 ff ff    	lea    -0xd930(%ebx),%eax
c0029ded:	50                   	push   %eax
c0029dee:	68 a9 00 00 00       	push   $0xa9
c0029df3:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029df9:	50                   	push   %eax
c0029dfa:	e8 96 fa ff ff       	call   c0029895 <debug_panic>
  ASSERT(elem != NULL);
c0029dff:	83 ec 0c             	sub    $0xc,%esp
c0029e02:	8d 83 cd 49 ff ff    	lea    -0xb633(%ebx),%eax
c0029e08:	50                   	push   %eax
c0029e09:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029e0f:	50                   	push   %eax
c0029e10:	8d 83 d0 26 ff ff    	lea    -0xd930(%ebx),%eax
c0029e16:	50                   	push   %eax
c0029e17:	68 aa 00 00 00       	push   $0xaa
c0029e1c:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029e22:	50                   	push   %eax
c0029e23:	e8 6d fa ff ff       	call   c0029895 <debug_panic>

c0029e28 <list_splice>:
{
c0029e28:	57                   	push   %edi
c0029e29:	56                   	push   %esi
c0029e2a:	53                   	push   %ebx
c0029e2b:	e8 b6 86 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0029e30:	81 c3 0c 6e 01 00    	add    $0x16e0c,%ebx
c0029e36:	8b 74 24 10          	mov    0x10(%esp),%esi
c0029e3a:	8b 7c 24 14          	mov    0x14(%esp),%edi
c0029e3e:	8b 44 24 18          	mov    0x18(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029e42:	85 f6                	test   %esi,%esi
c0029e44:	74 6a                	je     c0029eb0 <list_splice+0x88>
c0029e46:	83 3e 00             	cmpl   $0x0,(%esi)
c0029e49:	74 5a                	je     c0029ea5 <list_splice+0x7d>
c0029e4b:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0029e4f:	74 54                	je     c0029ea5 <list_splice+0x7d>
  if (first == last)
c0029e51:	39 c7                	cmp    %eax,%edi
c0029e53:	74 4c                	je     c0029ea1 <list_splice+0x79>
  last = list_prev(last);
c0029e55:	83 ec 0c             	sub    $0xc,%esp
c0029e58:	50                   	push   %eax
c0029e59:	e8 88 fc ff ff       	call   c0029ae6 <list_prev>
c0029e5e:	83 c4 10             	add    $0x10,%esp
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029e61:	85 ff                	test   %edi,%edi
c0029e63:	74 74                	je     c0029ed9 <list_splice+0xb1>
c0029e65:	8b 17                	mov    (%edi),%edx
c0029e67:	85 d2                	test   %edx,%edx
c0029e69:	74 6e                	je     c0029ed9 <list_splice+0xb1>
c0029e6b:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
c0029e6f:	74 68                	je     c0029ed9 <list_splice+0xb1>
c0029e71:	85 c0                	test   %eax,%eax
c0029e73:	0f 84 89 00 00 00    	je     c0029f02 <list_splice+0xda>
c0029e79:	83 38 00             	cmpl   $0x0,(%eax)
c0029e7c:	0f 84 80 00 00 00    	je     c0029f02 <list_splice+0xda>
c0029e82:	8b 48 04             	mov    0x4(%eax),%ecx
c0029e85:	85 c9                	test   %ecx,%ecx
c0029e87:	74 79                	je     c0029f02 <list_splice+0xda>
  first->prev->next = last->next;
c0029e89:	89 4a 04             	mov    %ecx,0x4(%edx)
  last->next->prev = first->prev;
c0029e8c:	8b 50 04             	mov    0x4(%eax),%edx
c0029e8f:	8b 0f                	mov    (%edi),%ecx
c0029e91:	89 0a                	mov    %ecx,(%edx)
  first->prev = before->prev;
c0029e93:	8b 16                	mov    (%esi),%edx
c0029e95:	89 17                	mov    %edx,(%edi)
  last->next = before;
c0029e97:	89 70 04             	mov    %esi,0x4(%eax)
  before->prev->next = first;
c0029e9a:	8b 16                	mov    (%esi),%edx
c0029e9c:	89 7a 04             	mov    %edi,0x4(%edx)
  before->prev = last;
c0029e9f:	89 06                	mov    %eax,(%esi)
}
c0029ea1:	5b                   	pop    %ebx
c0029ea2:	5e                   	pop    %esi
c0029ea3:	5f                   	pop    %edi
c0029ea4:	c3                   	ret    
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0029ea5:	83 3e 00             	cmpl   $0x0,(%esi)
c0029ea8:	74 06                	je     c0029eb0 <list_splice+0x88>
c0029eaa:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
c0029eae:	74 a1                	je     c0029e51 <list_splice+0x29>
  ASSERT(is_interior(before) || is_tail(before));
c0029eb0:	83 ec 0c             	sub    $0xc,%esp
c0029eb3:	8d 83 90 4a ff ff    	lea    -0xb570(%ebx),%eax
c0029eb9:	50                   	push   %eax
c0029eba:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029ec0:	50                   	push   %eax
c0029ec1:	8d 83 c4 26 ff ff    	lea    -0xd93c(%ebx),%eax
c0029ec7:	50                   	push   %eax
c0029ec8:	68 b8 00 00 00       	push   $0xb8
c0029ecd:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029ed3:	50                   	push   %eax
c0029ed4:	e8 bc f9 ff ff       	call   c0029895 <debug_panic>
  ASSERT(is_interior(first));
c0029ed9:	83 ec 0c             	sub    $0xc,%esp
c0029edc:	8d 83 da 49 ff ff    	lea    -0xb626(%ebx),%eax
c0029ee2:	50                   	push   %eax
c0029ee3:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029ee9:	50                   	push   %eax
c0029eea:	8d 83 c4 26 ff ff    	lea    -0xd93c(%ebx),%eax
c0029ef0:	50                   	push   %eax
c0029ef1:	68 bd 00 00 00       	push   $0xbd
c0029ef6:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029efc:	50                   	push   %eax
c0029efd:	e8 93 f9 ff ff       	call   c0029895 <debug_panic>
  ASSERT(is_interior(last));
c0029f02:	83 ec 0c             	sub    $0xc,%esp
c0029f05:	8d 83 ed 49 ff ff    	lea    -0xb613(%ebx),%eax
c0029f0b:	50                   	push   %eax
c0029f0c:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029f12:	50                   	push   %eax
c0029f13:	8d 83 c4 26 ff ff    	lea    -0xd93c(%ebx),%eax
c0029f19:	50                   	push   %eax
c0029f1a:	68 be 00 00 00       	push   $0xbe
c0029f1f:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029f25:	50                   	push   %eax
c0029f26:	e8 6a f9 ff ff       	call   c0029895 <debug_panic>

c0029f2b <list_push_front>:
{
c0029f2b:	83 ec 18             	sub    $0x18,%esp
  list_insert(list_begin(list), elem);
c0029f2e:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029f32:	e8 83 fa ff ff       	call   c00299ba <list_begin>
c0029f37:	83 c4 08             	add    $0x8,%esp
c0029f3a:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029f3e:	50                   	push   %eax
c0029f3f:	e8 4a fe ff ff       	call   c0029d8e <list_insert>
}
c0029f44:	83 c4 1c             	add    $0x1c,%esp
c0029f47:	c3                   	ret    

c0029f48 <list_push_back>:
{
c0029f48:	83 ec 18             	sub    $0x18,%esp
  list_insert(list_end(list), elem);
c0029f4b:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029f4f:	e8 08 fb ff ff       	call   c0029a5c <list_end>
c0029f54:	83 c4 08             	add    $0x8,%esp
c0029f57:	ff 74 24 1c          	pushl  0x1c(%esp)
c0029f5b:	50                   	push   %eax
c0029f5c:	e8 2d fe ff ff       	call   c0029d8e <list_insert>
}
c0029f61:	83 c4 1c             	add    $0x1c,%esp
c0029f64:	c3                   	ret    

c0029f65 <list_remove>:
{
c0029f65:	53                   	push   %ebx
c0029f66:	83 ec 08             	sub    $0x8,%esp
c0029f69:	e8 78 85 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0029f6e:	81 c3 ce 6c 01 00    	add    $0x16cce,%ebx
c0029f74:	8b 44 24 10          	mov    0x10(%esp),%eax
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029f78:	85 c0                	test   %eax,%eax
c0029f7a:	74 1f                	je     c0029f9b <list_remove+0x36>
c0029f7c:	8b 10                	mov    (%eax),%edx
c0029f7e:	85 d2                	test   %edx,%edx
c0029f80:	74 19                	je     c0029f9b <list_remove+0x36>
c0029f82:	8b 48 04             	mov    0x4(%eax),%ecx
c0029f85:	85 c9                	test   %ecx,%ecx
c0029f87:	74 12                	je     c0029f9b <list_remove+0x36>
  elem->prev->next = elem->next;
c0029f89:	89 4a 04             	mov    %ecx,0x4(%edx)
  elem->next->prev = elem->prev;
c0029f8c:	8b 50 04             	mov    0x4(%eax),%edx
c0029f8f:	8b 08                	mov    (%eax),%ecx
c0029f91:	89 0a                	mov    %ecx,(%edx)
  return elem->next;
c0029f93:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029f96:	83 c4 08             	add    $0x8,%esp
c0029f99:	5b                   	pop    %ebx
c0029f9a:	c3                   	ret    
  ASSERT(is_interior(elem));
c0029f9b:	83 ec 0c             	sub    $0xc,%esp
c0029f9e:	8d 83 ff 49 ff ff    	lea    -0xb601(%ebx),%eax
c0029fa4:	50                   	push   %eax
c0029fa5:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0029fab:	50                   	push   %eax
c0029fac:	8d 83 b8 26 ff ff    	lea    -0xd948(%ebx),%eax
c0029fb2:	50                   	push   %eax
c0029fb3:	68 f6 00 00 00       	push   $0xf6
c0029fb8:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c0029fbe:	50                   	push   %eax
c0029fbf:	e8 d1 f8 ff ff       	call   c0029895 <debug_panic>

c0029fc4 <list_size>:
{
c0029fc4:	57                   	push   %edi
c0029fc5:	56                   	push   %esi
c0029fc6:	53                   	push   %ebx
c0029fc7:	8b 7c 24 10          	mov    0x10(%esp),%edi
  for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029fcb:	83 ec 0c             	sub    $0xc,%esp
c0029fce:	57                   	push   %edi
c0029fcf:	e8 e6 f9 ff ff       	call   c00299ba <list_begin>
c0029fd4:	83 c4 10             	add    $0x10,%esp
c0029fd7:	89 c3                	mov    %eax,%ebx
  size_t cnt = 0;
c0029fd9:	be 00 00 00 00       	mov    $0x0,%esi
  for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029fde:	eb 11                	jmp    c0029ff1 <list_size+0x2d>
    cnt++;
c0029fe0:	83 c6 01             	add    $0x1,%esi
  for (e = list_begin(list); e != list_end(list); e = list_next(e))
c0029fe3:	83 ec 0c             	sub    $0xc,%esp
c0029fe6:	53                   	push   %ebx
c0029fe7:	e8 13 fa ff ff       	call   c00299ff <list_next>
c0029fec:	83 c4 10             	add    $0x10,%esp
c0029fef:	89 c3                	mov    %eax,%ebx
c0029ff1:	83 ec 0c             	sub    $0xc,%esp
c0029ff4:	57                   	push   %edi
c0029ff5:	e8 62 fa ff ff       	call   c0029a5c <list_end>
c0029ffa:	83 c4 10             	add    $0x10,%esp
c0029ffd:	39 d8                	cmp    %ebx,%eax
c0029fff:	75 df                	jne    c0029fe0 <list_size+0x1c>
}
c002a001:	89 f0                	mov    %esi,%eax
c002a003:	5b                   	pop    %ebx
c002a004:	5e                   	pop    %esi
c002a005:	5f                   	pop    %edi
c002a006:	c3                   	ret    

c002a007 <list_empty>:
{
c002a007:	56                   	push   %esi
c002a008:	53                   	push   %ebx
c002a009:	83 ec 10             	sub    $0x10,%esp
c002a00c:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
  return list_begin(list) == list_end(list);
c002a010:	53                   	push   %ebx
c002a011:	e8 a4 f9 ff ff       	call   c00299ba <list_begin>
c002a016:	89 c6                	mov    %eax,%esi
c002a018:	89 1c 24             	mov    %ebx,(%esp)
c002a01b:	e8 3c fa ff ff       	call   c0029a5c <list_end>
c002a020:	39 c6                	cmp    %eax,%esi
c002a022:	0f 94 c0             	sete   %al
}
c002a025:	83 c4 14             	add    $0x14,%esp
c002a028:	5b                   	pop    %ebx
c002a029:	5e                   	pop    %esi
c002a02a:	c3                   	ret    

c002a02b <list_front>:
{
c002a02b:	56                   	push   %esi
c002a02c:	53                   	push   %ebx
c002a02d:	83 ec 10             	sub    $0x10,%esp
c002a030:	e8 b1 84 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002a035:	81 c3 07 6c 01 00    	add    $0x16c07,%ebx
c002a03b:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  ASSERT(!list_empty(list));
c002a03f:	56                   	push   %esi
c002a040:	e8 c2 ff ff ff       	call   c002a007 <list_empty>
c002a045:	83 c4 10             	add    $0x10,%esp
c002a048:	84 c0                	test   %al,%al
c002a04a:	75 09                	jne    c002a055 <list_front+0x2a>
  return list->head.next;
c002a04c:	8b 46 04             	mov    0x4(%esi),%eax
}
c002a04f:	83 c4 04             	add    $0x4,%esp
c002a052:	5b                   	pop    %ebx
c002a053:	5e                   	pop    %esi
c002a054:	c3                   	ret    
  ASSERT(!list_empty(list));
c002a055:	83 ec 0c             	sub    $0xc,%esp
c002a058:	8d 83 11 4a ff ff    	lea    -0xb5ef(%ebx),%eax
c002a05e:	50                   	push   %eax
c002a05f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a065:	50                   	push   %eax
c002a066:	8d 83 ac 26 ff ff    	lea    -0xd954(%ebx),%eax
c002a06c:	50                   	push   %eax
c002a06d:	68 15 01 00 00       	push   $0x115
c002a072:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a078:	50                   	push   %eax
c002a079:	e8 17 f8 ff ff       	call   c0029895 <debug_panic>

c002a07e <list_pop_front>:
{
c002a07e:	53                   	push   %ebx
c002a07f:	83 ec 14             	sub    $0x14,%esp
  struct list_elem *front = list_front(list);
c002a082:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a086:	e8 a0 ff ff ff       	call   c002a02b <list_front>
c002a08b:	89 c3                	mov    %eax,%ebx
  list_remove(front);
c002a08d:	89 04 24             	mov    %eax,(%esp)
c002a090:	e8 d0 fe ff ff       	call   c0029f65 <list_remove>
}
c002a095:	89 d8                	mov    %ebx,%eax
c002a097:	83 c4 18             	add    $0x18,%esp
c002a09a:	5b                   	pop    %ebx
c002a09b:	c3                   	ret    

c002a09c <list_back>:
{
c002a09c:	56                   	push   %esi
c002a09d:	53                   	push   %ebx
c002a09e:	83 ec 10             	sub    $0x10,%esp
c002a0a1:	e8 40 84 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002a0a6:	81 c3 96 6b 01 00    	add    $0x16b96,%ebx
c002a0ac:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  ASSERT(!list_empty(list));
c002a0b0:	56                   	push   %esi
c002a0b1:	e8 51 ff ff ff       	call   c002a007 <list_empty>
c002a0b6:	83 c4 10             	add    $0x10,%esp
c002a0b9:	84 c0                	test   %al,%al
c002a0bb:	75 09                	jne    c002a0c6 <list_back+0x2a>
  return list->tail.prev;
c002a0bd:	8b 46 08             	mov    0x8(%esi),%eax
}
c002a0c0:	83 c4 04             	add    $0x4,%esp
c002a0c3:	5b                   	pop    %ebx
c002a0c4:	5e                   	pop    %esi
c002a0c5:	c3                   	ret    
  ASSERT(!list_empty(list));
c002a0c6:	83 ec 0c             	sub    $0xc,%esp
c002a0c9:	8d 83 11 4a ff ff    	lea    -0xb5ef(%ebx),%eax
c002a0cf:	50                   	push   %eax
c002a0d0:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a0d6:	50                   	push   %eax
c002a0d7:	8d 83 a0 26 ff ff    	lea    -0xd960(%ebx),%eax
c002a0dd:	50                   	push   %eax
c002a0de:	68 1e 01 00 00       	push   $0x11e
c002a0e3:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a0e9:	50                   	push   %eax
c002a0ea:	e8 a6 f7 ff ff       	call   c0029895 <debug_panic>

c002a0ef <list_pop_back>:
{
c002a0ef:	53                   	push   %ebx
c002a0f0:	83 ec 14             	sub    $0x14,%esp
  struct list_elem *back = list_back(list);
c002a0f3:	ff 74 24 1c          	pushl  0x1c(%esp)
c002a0f7:	e8 a0 ff ff ff       	call   c002a09c <list_back>
c002a0fc:	89 c3                	mov    %eax,%ebx
  list_remove(back);
c002a0fe:	89 04 24             	mov    %eax,(%esp)
c002a101:	e8 5f fe ff ff       	call   c0029f65 <list_remove>
}
c002a106:	89 d8                	mov    %ebx,%eax
c002a108:	83 c4 18             	add    $0x18,%esp
c002a10b:	5b                   	pop    %ebx
c002a10c:	c3                   	ret    

c002a10d <list_reverse>:
{
c002a10d:	56                   	push   %esi
c002a10e:	53                   	push   %ebx
c002a10f:	83 ec 10             	sub    $0x10,%esp
c002a112:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  if (!list_empty(list))
c002a116:	56                   	push   %esi
c002a117:	e8 eb fe ff ff       	call   c002a007 <list_empty>
c002a11c:	83 c4 10             	add    $0x10,%esp
c002a11f:	84 c0                	test   %al,%al
c002a121:	74 06                	je     c002a129 <list_reverse+0x1c>
}
c002a123:	83 c4 04             	add    $0x4,%esp
c002a126:	5b                   	pop    %ebx
c002a127:	5e                   	pop    %esi
c002a128:	c3                   	ret    
    for (e = list_begin(list); e != list_end(list); e = e->prev)
c002a129:	83 ec 0c             	sub    $0xc,%esp
c002a12c:	56                   	push   %esi
c002a12d:	e8 88 f8 ff ff       	call   c00299ba <list_begin>
c002a132:	83 c4 10             	add    $0x10,%esp
c002a135:	89 c3                	mov    %eax,%ebx
c002a137:	eb 0c                	jmp    c002a145 <list_reverse+0x38>
  struct list_elem *t = *a;
c002a139:	8b 13                	mov    (%ebx),%edx
  *a = *b;
c002a13b:	8b 43 04             	mov    0x4(%ebx),%eax
c002a13e:	89 03                	mov    %eax,(%ebx)
  *b = t;
c002a140:	89 53 04             	mov    %edx,0x4(%ebx)
    for (e = list_begin(list); e != list_end(list); e = e->prev)
c002a143:	89 c3                	mov    %eax,%ebx
c002a145:	83 ec 0c             	sub    $0xc,%esp
c002a148:	56                   	push   %esi
c002a149:	e8 0e f9 ff ff       	call   c0029a5c <list_end>
c002a14e:	83 c4 10             	add    $0x10,%esp
c002a151:	39 d8                	cmp    %ebx,%eax
c002a153:	75 e4                	jne    c002a139 <list_reverse+0x2c>
  struct list_elem *t = *a;
c002a155:	8b 46 04             	mov    0x4(%esi),%eax
  *a = *b;
c002a158:	8b 56 08             	mov    0x8(%esi),%edx
c002a15b:	89 56 04             	mov    %edx,0x4(%esi)
  *b = t;
c002a15e:	89 46 08             	mov    %eax,0x8(%esi)
  struct list_elem *t = *a;
c002a161:	8b 0a                	mov    (%edx),%ecx
  *a = *b;
c002a163:	8b 58 04             	mov    0x4(%eax),%ebx
c002a166:	89 1a                	mov    %ebx,(%edx)
  *b = t;
c002a168:	89 48 04             	mov    %ecx,0x4(%eax)
}
c002a16b:	eb b6                	jmp    c002a123 <list_reverse+0x16>

c002a16d <list_sort>:

/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void list_sort(struct list *list, list_less_func *less, void *aux)
{
c002a16d:	55                   	push   %ebp
c002a16e:	57                   	push   %edi
c002a16f:	56                   	push   %esi
c002a170:	53                   	push   %ebx
c002a171:	83 ec 1c             	sub    $0x1c,%esp
c002a174:	e8 71 83 00 00       	call   c00324ea <__x86.get_pc_thunk.ax>
c002a179:	05 c3 6a 01 00       	add    $0x16ac3,%eax
c002a17e:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002a182:	8b 6c 24 34          	mov    0x34(%esp),%ebp
c002a186:	8b 7c 24 38          	mov    0x38(%esp),%edi
  size_t output_run_cnt; /* Number of runs output in current pass. */

  ASSERT(list != NULL);
c002a18a:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c002a18f:	74 35                	je     c002a1c6 <list_sort+0x59>
  ASSERT(less != NULL);
c002a191:	85 ed                	test   %ebp,%ebp
c002a193:	0f 85 41 02 00 00    	jne    c002a3da <list_sort+0x26d>
c002a199:	83 ec 0c             	sub    $0xc,%esp
c002a19c:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002a1a0:	8d 83 b9 49 ff ff    	lea    -0xb647(%ebx),%eax
c002a1a6:	50                   	push   %eax
c002a1a7:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a1ad:	50                   	push   %eax
c002a1ae:	8d 83 94 26 ff ff    	lea    -0xd96c(%ebx),%eax
c002a1b4:	50                   	push   %eax
c002a1b5:	68 91 01 00 00       	push   $0x191
c002a1ba:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a1c0:	50                   	push   %eax
c002a1c1:	e8 cf f6 ff ff       	call   c0029895 <debug_panic>
  ASSERT(list != NULL);
c002a1c6:	83 ec 0c             	sub    $0xc,%esp
c002a1c9:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002a1cd:	8d 83 8a 49 ff ff    	lea    -0xb676(%ebx),%eax
c002a1d3:	50                   	push   %eax
c002a1d4:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a1da:	50                   	push   %eax
c002a1db:	8d 83 94 26 ff ff    	lea    -0xd96c(%ebx),%eax
c002a1e1:	50                   	push   %eax
c002a1e2:	68 90 01 00 00       	push   $0x190
c002a1e7:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a1ed:	50                   	push   %eax
c002a1ee:	e8 a2 f6 ff ff       	call   c0029895 <debug_panic>
  ASSERT(a0 != NULL);
c002a1f3:	83 ec 0c             	sub    $0xc,%esp
c002a1f6:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002a1fa:	8d 83 23 4a ff ff    	lea    -0xb5dd(%ebx),%eax
c002a200:	50                   	push   %eax
c002a201:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a207:	50                   	push   %eax
c002a208:	8d 83 74 26 ff ff    	lea    -0xd98c(%ebx),%eax
c002a20e:	50                   	push   %eax
c002a20f:	68 78 01 00 00       	push   $0x178
c002a214:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a21a:	50                   	push   %eax
c002a21b:	e8 75 f6 ff ff       	call   c0029895 <debug_panic>
  ASSERT(a1b0 != NULL);
c002a220:	83 ec 0c             	sub    $0xc,%esp
c002a223:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002a227:	8d 83 2e 4a ff ff    	lea    -0xb5d2(%ebx),%eax
c002a22d:	50                   	push   %eax
c002a22e:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a234:	50                   	push   %eax
c002a235:	8d 83 74 26 ff ff    	lea    -0xd98c(%ebx),%eax
c002a23b:	50                   	push   %eax
c002a23c:	68 79 01 00 00       	push   $0x179
c002a241:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a247:	50                   	push   %eax
c002a248:	e8 48 f6 ff ff       	call   c0029895 <debug_panic>
  ASSERT(b1 != NULL);
c002a24d:	83 ec 0c             	sub    $0xc,%esp
c002a250:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002a254:	8d 83 3b 4a ff ff    	lea    -0xb5c5(%ebx),%eax
c002a25a:	50                   	push   %eax
c002a25b:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a261:	50                   	push   %eax
c002a262:	8d 83 74 26 ff ff    	lea    -0xd98c(%ebx),%eax
c002a268:	50                   	push   %eax
c002a269:	68 7a 01 00 00       	push   $0x17a
c002a26e:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a274:	50                   	push   %eax
c002a275:	e8 1b f6 ff ff       	call   c0029895 <debug_panic>
  ASSERT(is_sorted(a0, a1b0, less, aux));
c002a27a:	83 ec 0c             	sub    $0xc,%esp
c002a27d:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002a281:	8d 83 b8 4a ff ff    	lea    -0xb548(%ebx),%eax
c002a287:	50                   	push   %eax
c002a288:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a28e:	50                   	push   %eax
c002a28f:	8d 83 74 26 ff ff    	lea    -0xd98c(%ebx),%eax
c002a295:	50                   	push   %eax
c002a296:	68 7c 01 00 00       	push   $0x17c
c002a29b:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a2a1:	50                   	push   %eax
c002a2a2:	e8 ee f5 ff ff       	call   c0029895 <debug_panic>
      a1b0 = list_next(a1b0);
c002a2a7:	83 ec 0c             	sub    $0xc,%esp
c002a2aa:	53                   	push   %ebx
c002a2ab:	e8 4f f7 ff ff       	call   c00299ff <list_next>
c002a2b0:	89 c3                	mov    %eax,%ebx
      list_splice(a0, list_prev(a1b0), a1b0);
c002a2b2:	89 04 24             	mov    %eax,(%esp)
c002a2b5:	e8 2c f8 ff ff       	call   c0029ae6 <list_prev>
c002a2ba:	83 c4 0c             	add    $0xc,%esp
c002a2bd:	53                   	push   %ebx
c002a2be:	50                   	push   %eax
c002a2bf:	56                   	push   %esi
c002a2c0:	e8 63 fb ff ff       	call   c0029e28 <list_splice>
c002a2c5:	83 c4 10             	add    $0x10,%esp
  while (a0 != a1b0 && a1b0 != b1)
c002a2c8:	39 f3                	cmp    %esi,%ebx
c002a2ca:	0f 95 c2             	setne  %dl
c002a2cd:	39 5c 24 04          	cmp    %ebx,0x4(%esp)
c002a2d1:	0f 95 c0             	setne  %al
c002a2d4:	84 c2                	test   %al,%dl
c002a2d6:	74 1f                	je     c002a2f7 <list_sort+0x18a>
    if (!less(a1b0, a0, aux))
c002a2d8:	83 ec 04             	sub    $0x4,%esp
c002a2db:	57                   	push   %edi
c002a2dc:	56                   	push   %esi
c002a2dd:	53                   	push   %ebx
c002a2de:	ff d5                	call   *%ebp
c002a2e0:	83 c4 10             	add    $0x10,%esp
c002a2e3:	84 c0                	test   %al,%al
c002a2e5:	75 c0                	jne    c002a2a7 <list_sort+0x13a>
      a0 = list_next(a0);
c002a2e7:	83 ec 0c             	sub    $0xc,%esp
c002a2ea:	56                   	push   %esi
c002a2eb:	e8 0f f7 ff ff       	call   c00299ff <list_next>
c002a2f0:	83 c4 10             	add    $0x10,%esp
c002a2f3:	89 c6                	mov    %eax,%esi
c002a2f5:	eb d1                	jmp    c002a2c8 <list_sort+0x15b>
    struct list_elem *a0;   /* Start of first run. */
    struct list_elem *a1b0; /* End of first run, start of second. */
    struct list_elem *b1;   /* End of second run. */

    output_run_cnt = 0;
    for (a0 = list_begin(list); a0 != list_end(list); a0 = b1)
c002a2f7:	8b 74 24 04          	mov    0x4(%esp),%esi
c002a2fb:	83 ec 0c             	sub    $0xc,%esp
c002a2fe:	ff 74 24 3c          	pushl  0x3c(%esp)
c002a302:	e8 55 f7 ff ff       	call   c0029a5c <list_end>
c002a307:	83 c4 10             	add    $0x10,%esp
c002a30a:	39 f0                	cmp    %esi,%eax
c002a30c:	0f 84 c1 00 00 00    	je     c002a3d3 <list_sort+0x266>
    {
      /* Each iteration produces one output run. */
      output_run_cnt++;
c002a312:	83 44 24 08 01       	addl   $0x1,0x8(%esp)

      /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
      a1b0 = find_end_of_run(a0, list_end(list), less, aux);
c002a317:	83 ec 0c             	sub    $0xc,%esp
c002a31a:	57                   	push   %edi
c002a31b:	89 e9                	mov    %ebp,%ecx
c002a31d:	89 c2                	mov    %eax,%edx
c002a31f:	89 f0                	mov    %esi,%eax
c002a321:	e8 1a f8 ff ff       	call   c0029b40 <find_end_of_run>
c002a326:	89 c3                	mov    %eax,%ebx
      if (a1b0 == list_end(list))
c002a328:	83 c4 04             	add    $0x4,%esp
c002a32b:	ff 74 24 3c          	pushl  0x3c(%esp)
c002a32f:	e8 28 f7 ff ff       	call   c0029a5c <list_end>
c002a334:	83 c4 10             	add    $0x10,%esp
c002a337:	39 d8                	cmp    %ebx,%eax
c002a339:	0f 84 94 00 00 00    	je     c002a3d3 <list_sort+0x266>
        break;
      b1 = find_end_of_run(a1b0, list_end(list), less, aux);
c002a33f:	83 ec 0c             	sub    $0xc,%esp
c002a342:	57                   	push   %edi
c002a343:	89 e9                	mov    %ebp,%ecx
c002a345:	89 c2                	mov    %eax,%edx
c002a347:	89 d8                	mov    %ebx,%eax
c002a349:	e8 f2 f7 ff ff       	call   c0029b40 <find_end_of_run>
c002a34e:	89 44 24 14          	mov    %eax,0x14(%esp)
  ASSERT(a0 != NULL);
c002a352:	83 c4 10             	add    $0x10,%esp
c002a355:	85 f6                	test   %esi,%esi
c002a357:	0f 84 96 fe ff ff    	je     c002a1f3 <list_sort+0x86>
  ASSERT(a1b0 != NULL);
c002a35d:	85 db                	test   %ebx,%ebx
c002a35f:	0f 84 bb fe ff ff    	je     c002a220 <list_sort+0xb3>
  ASSERT(b1 != NULL);
c002a365:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c002a36a:	0f 84 dd fe ff ff    	je     c002a24d <list_sort+0xe0>
  ASSERT(is_sorted(a0, a1b0, less, aux));
c002a370:	83 ec 0c             	sub    $0xc,%esp
c002a373:	57                   	push   %edi
c002a374:	89 e9                	mov    %ebp,%ecx
c002a376:	89 da                	mov    %ebx,%edx
c002a378:	89 f0                	mov    %esi,%eax
c002a37a:	e8 e3 f8 ff ff       	call   c0029c62 <is_sorted>
c002a37f:	83 c4 10             	add    $0x10,%esp
c002a382:	84 c0                	test   %al,%al
c002a384:	0f 84 f0 fe ff ff    	je     c002a27a <list_sort+0x10d>
  ASSERT(is_sorted(a1b0, b1, less, aux));
c002a38a:	83 ec 0c             	sub    $0xc,%esp
c002a38d:	57                   	push   %edi
c002a38e:	89 e9                	mov    %ebp,%ecx
c002a390:	8b 54 24 14          	mov    0x14(%esp),%edx
c002a394:	89 d8                	mov    %ebx,%eax
c002a396:	e8 c7 f8 ff ff       	call   c0029c62 <is_sorted>
c002a39b:	83 c4 10             	add    $0x10,%esp
c002a39e:	84 c0                	test   %al,%al
c002a3a0:	0f 85 22 ff ff ff    	jne    c002a2c8 <list_sort+0x15b>
c002a3a6:	83 ec 0c             	sub    $0xc,%esp
c002a3a9:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002a3ad:	8d 83 d8 4a ff ff    	lea    -0xb528(%ebx),%eax
c002a3b3:	50                   	push   %eax
c002a3b4:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a3ba:	50                   	push   %eax
c002a3bb:	8d 83 74 26 ff ff    	lea    -0xd98c(%ebx),%eax
c002a3c1:	50                   	push   %eax
c002a3c2:	68 7d 01 00 00       	push   $0x17d
c002a3c7:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a3cd:	50                   	push   %eax
c002a3ce:	e8 c2 f4 ff ff       	call   c0029895 <debug_panic>

      /* Merge the runs. */
      inplace_merge(a0, a1b0, b1, less, aux);
    }
  } while (output_run_cnt > 1);
c002a3d3:	83 7c 24 08 01       	cmpl   $0x1,0x8(%esp)
c002a3d8:	76 1e                	jbe    c002a3f8 <list_sort+0x28b>
    for (a0 = list_begin(list); a0 != list_end(list); a0 = b1)
c002a3da:	83 ec 0c             	sub    $0xc,%esp
c002a3dd:	ff 74 24 3c          	pushl  0x3c(%esp)
c002a3e1:	e8 d4 f5 ff ff       	call   c00299ba <list_begin>
c002a3e6:	83 c4 10             	add    $0x10,%esp
c002a3e9:	89 c6                	mov    %eax,%esi
    output_run_cnt = 0;
c002a3eb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c002a3f2:	00 
    for (a0 = list_begin(list); a0 != list_end(list); a0 = b1)
c002a3f3:	e9 03 ff ff ff       	jmp    c002a2fb <list_sort+0x18e>

  ASSERT(is_sorted(list_begin(list), list_end(list), less, aux));
c002a3f8:	83 ec 0c             	sub    $0xc,%esp
c002a3fb:	ff 74 24 3c          	pushl  0x3c(%esp)
c002a3ff:	e8 58 f6 ff ff       	call   c0029a5c <list_end>
c002a404:	83 c4 04             	add    $0x4,%esp
c002a407:	89 c3                	mov    %eax,%ebx
c002a409:	ff 74 24 3c          	pushl  0x3c(%esp)
c002a40d:	e8 a8 f5 ff ff       	call   c00299ba <list_begin>
c002a412:	89 3c 24             	mov    %edi,(%esp)
c002a415:	89 e9                	mov    %ebp,%ecx
c002a417:	89 da                	mov    %ebx,%edx
c002a419:	e8 44 f8 ff ff       	call   c0029c62 <is_sorted>
c002a41e:	83 c4 10             	add    $0x10,%esp
c002a421:	84 c0                	test   %al,%al
c002a423:	74 08                	je     c002a42d <list_sort+0x2c0>
}
c002a425:	83 c4 1c             	add    $0x1c,%esp
c002a428:	5b                   	pop    %ebx
c002a429:	5e                   	pop    %esi
c002a42a:	5f                   	pop    %edi
c002a42b:	5d                   	pop    %ebp
c002a42c:	c3                   	ret    
  ASSERT(is_sorted(list_begin(list), list_end(list), less, aux));
c002a42d:	83 ec 0c             	sub    $0xc,%esp
c002a430:	8b 5c 24 18          	mov    0x18(%esp),%ebx
c002a434:	8d 83 f8 4a ff ff    	lea    -0xb508(%ebx),%eax
c002a43a:	50                   	push   %eax
c002a43b:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a441:	50                   	push   %eax
c002a442:	8d 83 94 26 ff ff    	lea    -0xd96c(%ebx),%eax
c002a448:	50                   	push   %eax
c002a449:	68 ad 01 00 00       	push   $0x1ad
c002a44e:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a454:	50                   	push   %eax
c002a455:	e8 3b f4 ff ff       	call   c0029895 <debug_panic>

c002a45a <list_insert_ordered>:
/* Inserts ELEM in the proper position in LIST, which must be
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void list_insert_ordered(struct list *list, struct list_elem *elem,
                         list_less_func *less, void *aux)
{
c002a45a:	55                   	push   %ebp
c002a45b:	57                   	push   %edi
c002a45c:	56                   	push   %esi
c002a45d:	53                   	push   %ebx
c002a45e:	83 ec 0c             	sub    $0xc,%esp
c002a461:	e8 80 80 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002a466:	81 c3 d6 67 01 00    	add    $0x167d6,%ebx
c002a46c:	8b 74 24 20          	mov    0x20(%esp),%esi
c002a470:	8b 7c 24 24          	mov    0x24(%esp),%edi
c002a474:	8b 6c 24 28          	mov    0x28(%esp),%ebp
  struct list_elem *e;

  ASSERT(list != NULL);
c002a478:	85 f6                	test   %esi,%esi
c002a47a:	74 54                	je     c002a4d0 <list_insert_ordered+0x76>
  ASSERT(elem != NULL);
c002a47c:	85 ff                	test   %edi,%edi
c002a47e:	74 79                	je     c002a4f9 <list_insert_ordered+0x9f>
  ASSERT(less != NULL);
c002a480:	85 ed                	test   %ebp,%ebp
c002a482:	0f 84 9a 00 00 00    	je     c002a522 <list_insert_ordered+0xc8>

  for (e = list_begin(list); e != list_end(list); e = list_next(e))
c002a488:	83 ec 0c             	sub    $0xc,%esp
c002a48b:	56                   	push   %esi
c002a48c:	e8 29 f5 ff ff       	call   c00299ba <list_begin>
c002a491:	83 c4 10             	add    $0x10,%esp
c002a494:	89 c3                	mov    %eax,%ebx
c002a496:	83 ec 0c             	sub    $0xc,%esp
c002a499:	56                   	push   %esi
c002a49a:	e8 bd f5 ff ff       	call   c0029a5c <list_end>
c002a49f:	83 c4 10             	add    $0x10,%esp
c002a4a2:	39 d8                	cmp    %ebx,%eax
c002a4a4:	0f 84 a3 00 00 00    	je     c002a54d <list_insert_ordered+0xf3>
    if (less(elem, e, aux))
c002a4aa:	83 ec 04             	sub    $0x4,%esp
c002a4ad:	ff 74 24 30          	pushl  0x30(%esp)
c002a4b1:	53                   	push   %ebx
c002a4b2:	57                   	push   %edi
c002a4b3:	ff d5                	call   *%ebp
c002a4b5:	83 c4 10             	add    $0x10,%esp
c002a4b8:	84 c0                	test   %al,%al
c002a4ba:	0f 85 8b 00 00 00    	jne    c002a54b <list_insert_ordered+0xf1>
  for (e = list_begin(list); e != list_end(list); e = list_next(e))
c002a4c0:	83 ec 0c             	sub    $0xc,%esp
c002a4c3:	53                   	push   %ebx
c002a4c4:	e8 36 f5 ff ff       	call   c00299ff <list_next>
c002a4c9:	83 c4 10             	add    $0x10,%esp
c002a4cc:	89 c3                	mov    %eax,%ebx
c002a4ce:	eb c6                	jmp    c002a496 <list_insert_ordered+0x3c>
  ASSERT(list != NULL);
c002a4d0:	83 ec 0c             	sub    $0xc,%esp
c002a4d3:	8d 83 8a 49 ff ff    	lea    -0xb676(%ebx),%eax
c002a4d9:	50                   	push   %eax
c002a4da:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a4e0:	50                   	push   %eax
c002a4e1:	8d 83 60 26 ff ff    	lea    -0xd9a0(%ebx),%eax
c002a4e7:	50                   	push   %eax
c002a4e8:	68 b8 01 00 00       	push   $0x1b8
c002a4ed:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a4f3:	50                   	push   %eax
c002a4f4:	e8 9c f3 ff ff       	call   c0029895 <debug_panic>
  ASSERT(elem != NULL);
c002a4f9:	83 ec 0c             	sub    $0xc,%esp
c002a4fc:	8d 83 cd 49 ff ff    	lea    -0xb633(%ebx),%eax
c002a502:	50                   	push   %eax
c002a503:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a509:	50                   	push   %eax
c002a50a:	8d 83 60 26 ff ff    	lea    -0xd9a0(%ebx),%eax
c002a510:	50                   	push   %eax
c002a511:	68 b9 01 00 00       	push   $0x1b9
c002a516:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a51c:	50                   	push   %eax
c002a51d:	e8 73 f3 ff ff       	call   c0029895 <debug_panic>
  ASSERT(less != NULL);
c002a522:	83 ec 0c             	sub    $0xc,%esp
c002a525:	8d 83 b9 49 ff ff    	lea    -0xb647(%ebx),%eax
c002a52b:	50                   	push   %eax
c002a52c:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a532:	50                   	push   %eax
c002a533:	8d 83 60 26 ff ff    	lea    -0xd9a0(%ebx),%eax
c002a539:	50                   	push   %eax
c002a53a:	68 ba 01 00 00       	push   $0x1ba
c002a53f:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a545:	50                   	push   %eax
c002a546:	e8 4a f3 ff ff       	call   c0029895 <debug_panic>
c002a54b:	89 d8                	mov    %ebx,%eax
      break;
  return list_insert(e, elem);
c002a54d:	83 ec 08             	sub    $0x8,%esp
c002a550:	57                   	push   %edi
c002a551:	50                   	push   %eax
c002a552:	e8 37 f8 ff ff       	call   c0029d8e <list_insert>
}
c002a557:	83 c4 1c             	add    $0x1c,%esp
c002a55a:	5b                   	pop    %ebx
c002a55b:	5e                   	pop    %esi
c002a55c:	5f                   	pop    %edi
c002a55d:	5d                   	pop    %ebp
c002a55e:	c3                   	ret    

c002a55f <list_unique>:
   set of adjacent elements that are equal according to LESS
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void list_unique(struct list *list, struct list *duplicates,
                 list_less_func *less, void *aux)
{
c002a55f:	55                   	push   %ebp
c002a560:	57                   	push   %edi
c002a561:	56                   	push   %esi
c002a562:	53                   	push   %ebx
c002a563:	83 ec 0c             	sub    $0xc,%esp
c002a566:	e8 7b 7f 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002a56b:	81 c3 d1 66 01 00    	add    $0x166d1,%ebx
c002a571:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c002a575:	8b 7c 24 28          	mov    0x28(%esp),%edi
  struct list_elem *elem, *next;

  ASSERT(list != NULL);
c002a579:	85 ed                	test   %ebp,%ebp
c002a57b:	74 1c                	je     c002a599 <list_unique+0x3a>
  ASSERT(less != NULL);
c002a57d:	85 ff                	test   %edi,%edi
c002a57f:	74 41                	je     c002a5c2 <list_unique+0x63>
  if (list_empty(list))
c002a581:	83 ec 0c             	sub    $0xc,%esp
c002a584:	55                   	push   %ebp
c002a585:	e8 7d fa ff ff       	call   c002a007 <list_empty>
c002a58a:	83 c4 10             	add    $0x10,%esp
c002a58d:	84 c0                	test   %al,%al
c002a58f:	74 5a                	je     c002a5eb <list_unique+0x8c>
      if (duplicates != NULL)
        list_push_back(duplicates, next);
    }
    else
      elem = next;
}
c002a591:	83 c4 0c             	add    $0xc,%esp
c002a594:	5b                   	pop    %ebx
c002a595:	5e                   	pop    %esi
c002a596:	5f                   	pop    %edi
c002a597:	5d                   	pop    %ebp
c002a598:	c3                   	ret    
  ASSERT(list != NULL);
c002a599:	83 ec 0c             	sub    $0xc,%esp
c002a59c:	8d 83 8a 49 ff ff    	lea    -0xb676(%ebx),%eax
c002a5a2:	50                   	push   %eax
c002a5a3:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a5a9:	50                   	push   %eax
c002a5aa:	8d 83 54 26 ff ff    	lea    -0xd9ac(%ebx),%eax
c002a5b0:	50                   	push   %eax
c002a5b1:	68 cb 01 00 00       	push   $0x1cb
c002a5b6:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a5bc:	50                   	push   %eax
c002a5bd:	e8 d3 f2 ff ff       	call   c0029895 <debug_panic>
  ASSERT(less != NULL);
c002a5c2:	83 ec 0c             	sub    $0xc,%esp
c002a5c5:	8d 83 b9 49 ff ff    	lea    -0xb647(%ebx),%eax
c002a5cb:	50                   	push   %eax
c002a5cc:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a5d2:	50                   	push   %eax
c002a5d3:	8d 83 54 26 ff ff    	lea    -0xd9ac(%ebx),%eax
c002a5d9:	50                   	push   %eax
c002a5da:	68 cc 01 00 00       	push   $0x1cc
c002a5df:	8d 83 97 49 ff ff    	lea    -0xb669(%ebx),%eax
c002a5e5:	50                   	push   %eax
c002a5e6:	e8 aa f2 ff ff       	call   c0029895 <debug_panic>
  elem = list_begin(list);
c002a5eb:	83 ec 0c             	sub    $0xc,%esp
c002a5ee:	55                   	push   %ebp
c002a5ef:	e8 c6 f3 ff ff       	call   c00299ba <list_begin>
c002a5f4:	83 c4 10             	add    $0x10,%esp
c002a5f7:	89 c6                	mov    %eax,%esi
  while ((next = list_next(elem)) != list_end(list))
c002a5f9:	eb 04                	jmp    c002a5ff <list_unique+0xa0>
c002a5fb:	89 f3                	mov    %esi,%ebx
c002a5fd:	89 de                	mov    %ebx,%esi
c002a5ff:	83 ec 0c             	sub    $0xc,%esp
c002a602:	56                   	push   %esi
c002a603:	e8 f7 f3 ff ff       	call   c00299ff <list_next>
c002a608:	89 c3                	mov    %eax,%ebx
c002a60a:	89 2c 24             	mov    %ebp,(%esp)
c002a60d:	e8 4a f4 ff ff       	call   c0029a5c <list_end>
c002a612:	83 c4 10             	add    $0x10,%esp
c002a615:	39 d8                	cmp    %ebx,%eax
c002a617:	0f 84 74 ff ff ff    	je     c002a591 <list_unique+0x32>
    if (!less(elem, next, aux) && !less(next, elem, aux))
c002a61d:	83 ec 04             	sub    $0x4,%esp
c002a620:	ff 74 24 30          	pushl  0x30(%esp)
c002a624:	53                   	push   %ebx
c002a625:	56                   	push   %esi
c002a626:	ff d7                	call   *%edi
c002a628:	83 c4 10             	add    $0x10,%esp
c002a62b:	84 c0                	test   %al,%al
c002a62d:	75 ce                	jne    c002a5fd <list_unique+0x9e>
c002a62f:	83 ec 04             	sub    $0x4,%esp
c002a632:	ff 74 24 30          	pushl  0x30(%esp)
c002a636:	56                   	push   %esi
c002a637:	53                   	push   %ebx
c002a638:	ff d7                	call   *%edi
c002a63a:	83 c4 10             	add    $0x10,%esp
c002a63d:	84 c0                	test   %al,%al
c002a63f:	75 bc                	jne    c002a5fd <list_unique+0x9e>
      list_remove(next);
c002a641:	83 ec 0c             	sub    $0xc,%esp
c002a644:	53                   	push   %ebx
c002a645:	e8 1b f9 ff ff       	call   c0029f65 <list_remove>
      if (duplicates != NULL)
c002a64a:	83 c4 10             	add    $0x10,%esp
c002a64d:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c002a652:	74 a7                	je     c002a5fb <list_unique+0x9c>
        list_push_back(duplicates, next);
c002a654:	83 ec 08             	sub    $0x8,%esp
c002a657:	53                   	push   %ebx
c002a658:	ff 74 24 30          	pushl  0x30(%esp)
c002a65c:	e8 e7 f8 ff ff       	call   c0029f48 <list_push_back>
c002a661:	83 c4 10             	add    $0x10,%esp
c002a664:	89 f3                	mov    %esi,%ebx
c002a666:	eb 95                	jmp    c002a5fd <list_unique+0x9e>

c002a668 <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max(struct list *list, list_less_func *less, void *aux)
{
c002a668:	55                   	push   %ebp
c002a669:	57                   	push   %edi
c002a66a:	56                   	push   %esi
c002a66b:	53                   	push   %ebx
c002a66c:	83 ec 18             	sub    $0x18,%esp
c002a66f:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c002a673:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  struct list_elem *max = list_begin(list);
c002a677:	57                   	push   %edi
c002a678:	e8 3d f3 ff ff       	call   c00299ba <list_begin>
c002a67d:	89 c6                	mov    %eax,%esi
  if (max != list_end(list))
c002a67f:	89 3c 24             	mov    %edi,(%esp)
c002a682:	e8 d5 f3 ff ff       	call   c0029a5c <list_end>
c002a687:	83 c4 10             	add    $0x10,%esp
c002a68a:	39 f0                	cmp    %esi,%eax
c002a68c:	74 3c                	je     c002a6ca <list_max+0x62>
  {
    struct list_elem *e;

    for (e = list_next(max); e != list_end(list); e = list_next(e))
c002a68e:	83 ec 0c             	sub    $0xc,%esp
c002a691:	56                   	push   %esi
c002a692:	e8 68 f3 ff ff       	call   c00299ff <list_next>
c002a697:	83 c4 10             	add    $0x10,%esp
c002a69a:	89 c3                	mov    %eax,%ebx
c002a69c:	eb 1c                	jmp    c002a6ba <list_max+0x52>
      if (less(max, e, aux))
c002a69e:	83 ec 04             	sub    $0x4,%esp
c002a6a1:	55                   	push   %ebp
c002a6a2:	53                   	push   %ebx
c002a6a3:	56                   	push   %esi
c002a6a4:	ff 54 24 34          	call   *0x34(%esp)
c002a6a8:	84 c0                	test   %al,%al
        max = e;
c002a6aa:	0f 45 f3             	cmovne %ebx,%esi
    for (e = list_next(max); e != list_end(list); e = list_next(e))
c002a6ad:	89 1c 24             	mov    %ebx,(%esp)
c002a6b0:	e8 4a f3 ff ff       	call   c00299ff <list_next>
c002a6b5:	83 c4 10             	add    $0x10,%esp
c002a6b8:	89 c3                	mov    %eax,%ebx
c002a6ba:	83 ec 0c             	sub    $0xc,%esp
c002a6bd:	57                   	push   %edi
c002a6be:	e8 99 f3 ff ff       	call   c0029a5c <list_end>
c002a6c3:	83 c4 10             	add    $0x10,%esp
c002a6c6:	39 d8                	cmp    %ebx,%eax
c002a6c8:	75 d4                	jne    c002a69e <list_max+0x36>
  }
  return max;
}
c002a6ca:	89 f0                	mov    %esi,%eax
c002a6cc:	83 c4 0c             	add    $0xc,%esp
c002a6cf:	5b                   	pop    %ebx
c002a6d0:	5e                   	pop    %esi
c002a6d1:	5f                   	pop    %edi
c002a6d2:	5d                   	pop    %ebp
c002a6d3:	c3                   	ret    

c002a6d4 <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min(struct list *list, list_less_func *less, void *aux)
{
c002a6d4:	55                   	push   %ebp
c002a6d5:	57                   	push   %edi
c002a6d6:	56                   	push   %esi
c002a6d7:	53                   	push   %ebx
c002a6d8:	83 ec 18             	sub    $0x18,%esp
c002a6db:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c002a6df:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  struct list_elem *min = list_begin(list);
c002a6e3:	57                   	push   %edi
c002a6e4:	e8 d1 f2 ff ff       	call   c00299ba <list_begin>
c002a6e9:	89 c6                	mov    %eax,%esi
  if (min != list_end(list))
c002a6eb:	89 3c 24             	mov    %edi,(%esp)
c002a6ee:	e8 69 f3 ff ff       	call   c0029a5c <list_end>
c002a6f3:	83 c4 10             	add    $0x10,%esp
c002a6f6:	39 f0                	cmp    %esi,%eax
c002a6f8:	74 3c                	je     c002a736 <list_min+0x62>
  {
    struct list_elem *e;

    for (e = list_next(min); e != list_end(list); e = list_next(e))
c002a6fa:	83 ec 0c             	sub    $0xc,%esp
c002a6fd:	56                   	push   %esi
c002a6fe:	e8 fc f2 ff ff       	call   c00299ff <list_next>
c002a703:	83 c4 10             	add    $0x10,%esp
c002a706:	89 c3                	mov    %eax,%ebx
c002a708:	eb 1c                	jmp    c002a726 <list_min+0x52>
      if (less(e, min, aux))
c002a70a:	83 ec 04             	sub    $0x4,%esp
c002a70d:	55                   	push   %ebp
c002a70e:	56                   	push   %esi
c002a70f:	53                   	push   %ebx
c002a710:	ff 54 24 34          	call   *0x34(%esp)
c002a714:	84 c0                	test   %al,%al
        min = e;
c002a716:	0f 45 f3             	cmovne %ebx,%esi
    for (e = list_next(min); e != list_end(list); e = list_next(e))
c002a719:	89 1c 24             	mov    %ebx,(%esp)
c002a71c:	e8 de f2 ff ff       	call   c00299ff <list_next>
c002a721:	83 c4 10             	add    $0x10,%esp
c002a724:	89 c3                	mov    %eax,%ebx
c002a726:	83 ec 0c             	sub    $0xc,%esp
c002a729:	57                   	push   %edi
c002a72a:	e8 2d f3 ff ff       	call   c0029a5c <list_end>
c002a72f:	83 c4 10             	add    $0x10,%esp
c002a732:	39 d8                	cmp    %ebx,%eax
c002a734:	75 d4                	jne    c002a70a <list_min+0x36>
  }
  return min;
}
c002a736:	89 f0                	mov    %esi,%eax
c002a738:	83 c4 0c             	add    $0xc,%esp
c002a73b:	5b                   	pop    %ebx
c002a73c:	5e                   	pop    %esi
c002a73d:	5f                   	pop    %edi
c002a73e:	5d                   	pop    %ebp
c002a73f:	c3                   	ret    

c002a740 <bitmap_buf_size>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt(size_t bit_cnt)
{
  return DIV_ROUND_UP(bit_cnt, ELEM_BITS);
c002a740:	8b 44 24 04          	mov    0x4(%esp),%eax
c002a744:	83 c0 1f             	add    $0x1f,%eax
c002a747:	c1 e8 05             	shr    $0x5,%eax
/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size(size_t bit_cnt)
{
  return sizeof(struct bitmap) + byte_cnt(bit_cnt);
c002a74a:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
}
c002a751:	c3                   	ret    

c002a752 <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void bitmap_destroy(struct bitmap *b)
{
c002a752:	56                   	push   %esi
c002a753:	53                   	push   %ebx
c002a754:	83 ec 04             	sub    $0x4,%esp
c002a757:	e8 8a 7d 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002a75c:	81 c3 e0 64 01 00    	add    $0x164e0,%ebx
c002a762:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (b != NULL)
c002a766:	85 f6                	test   %esi,%esi
c002a768:	74 16                	je     c002a780 <bitmap_destroy+0x2e>
  {
    free(b->bits);
c002a76a:	83 ec 0c             	sub    $0xc,%esp
c002a76d:	ff 76 04             	pushl  0x4(%esi)
c002a770:	e8 25 9d ff ff       	call   c002449a <free>
    free(b);
c002a775:	89 34 24             	mov    %esi,(%esp)
c002a778:	e8 1d 9d ff ff       	call   c002449a <free>
c002a77d:	83 c4 10             	add    $0x10,%esp
  }
}
c002a780:	83 c4 04             	add    $0x4,%esp
c002a783:	5b                   	pop    %ebx
c002a784:	5e                   	pop    %esi
c002a785:	c3                   	ret    

c002a786 <bitmap_size>:

/* Returns the number of bits in B. */
size_t
bitmap_size(const struct bitmap *b)
{
  return b->bit_cnt;
c002a786:	8b 44 24 04          	mov    0x4(%esp),%eax
c002a78a:	8b 00                	mov    (%eax),%eax
}
c002a78c:	c3                   	ret    

c002a78d <bitmap_mark>:
    bitmap_reset(b, idx);
}

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void bitmap_mark(struct bitmap *b, size_t bit_idx)
{
c002a78d:	53                   	push   %ebx
c002a78e:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c002a792:	89 cb                	mov    %ecx,%ebx
c002a794:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask(bit_idx);

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm("orl %1, %0"
c002a797:	8b 44 24 08          	mov    0x8(%esp),%eax
c002a79b:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type)1 << (bit_idx % ELEM_BITS);
c002a79e:	b8 01 00 00 00       	mov    $0x1,%eax
c002a7a3:	d3 e0                	shl    %cl,%eax
  asm("orl %1, %0"
c002a7a5:	09 04 9a             	or     %eax,(%edx,%ebx,4)
      : "=m"(b->bits[idx])
      : "r"(mask)
      : "cc");
}
c002a7a8:	5b                   	pop    %ebx
c002a7a9:	c3                   	ret    

c002a7aa <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void bitmap_reset(struct bitmap *b, size_t bit_idx)
{
c002a7aa:	53                   	push   %ebx
c002a7ab:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c002a7af:	89 cb                	mov    %ecx,%ebx
c002a7b1:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask(bit_idx);

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm("andl %1, %0"
c002a7b4:	8b 44 24 08          	mov    0x8(%esp),%eax
c002a7b8:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type)1 << (bit_idx % ELEM_BITS);
c002a7bb:	b8 01 00 00 00       	mov    $0x1,%eax
c002a7c0:	d3 e0                	shl    %cl,%eax
      : "=m"(b->bits[idx])
      : "r"(~mask)
c002a7c2:	f7 d0                	not    %eax
  asm("andl %1, %0"
c002a7c4:	21 04 9a             	and    %eax,(%edx,%ebx,4)
      : "cc");
}
c002a7c7:	5b                   	pop    %ebx
c002a7c8:	c3                   	ret    

c002a7c9 <bitmap_set>:
{
c002a7c9:	53                   	push   %ebx
c002a7ca:	83 ec 08             	sub    $0x8,%esp
c002a7cd:	e8 14 7d 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002a7d2:	81 c3 6a 64 01 00    	add    $0x1646a,%ebx
c002a7d8:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a7dc:	8b 54 24 14          	mov    0x14(%esp),%edx
c002a7e0:	8b 4c 24 18          	mov    0x18(%esp),%ecx
  ASSERT(b != NULL);
c002a7e4:	85 c0                	test   %eax,%eax
c002a7e6:	74 1a                	je     c002a802 <bitmap_set+0x39>
  ASSERT(idx < b->bit_cnt);
c002a7e8:	39 10                	cmp    %edx,(%eax)
c002a7ea:	76 3f                	jbe    c002a82b <bitmap_set+0x62>
  if (value)
c002a7ec:	84 c9                	test   %cl,%cl
c002a7ee:	75 64                	jne    c002a854 <bitmap_set+0x8b>
    bitmap_reset(b, idx);
c002a7f0:	83 ec 08             	sub    $0x8,%esp
c002a7f3:	52                   	push   %edx
c002a7f4:	50                   	push   %eax
c002a7f5:	e8 b0 ff ff ff       	call   c002a7aa <bitmap_reset>
c002a7fa:	83 c4 10             	add    $0x10,%esp
}
c002a7fd:	83 c4 08             	add    $0x8,%esp
c002a800:	5b                   	pop    %ebx
c002a801:	c3                   	ret    
  ASSERT(b != NULL);
c002a802:	83 ec 0c             	sub    $0xc,%esp
c002a805:	8d 83 af 49 ff ff    	lea    -0xb651(%ebx),%eax
c002a80b:	50                   	push   %eax
c002a80c:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a812:	50                   	push   %eax
c002a813:	8d 83 a4 27 ff ff    	lea    -0xd85c(%ebx),%eax
c002a819:	50                   	push   %eax
c002a81a:	68 91 00 00 00       	push   $0x91
c002a81f:	8d 83 2f 4b ff ff    	lea    -0xb4d1(%ebx),%eax
c002a825:	50                   	push   %eax
c002a826:	e8 6a f0 ff ff       	call   c0029895 <debug_panic>
  ASSERT(idx < b->bit_cnt);
c002a82b:	83 ec 0c             	sub    $0xc,%esp
c002a82e:	8d 83 49 4b ff ff    	lea    -0xb4b7(%ebx),%eax
c002a834:	50                   	push   %eax
c002a835:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a83b:	50                   	push   %eax
c002a83c:	8d 83 a4 27 ff ff    	lea    -0xd85c(%ebx),%eax
c002a842:	50                   	push   %eax
c002a843:	68 92 00 00 00       	push   $0x92
c002a848:	8d 83 2f 4b ff ff    	lea    -0xb4d1(%ebx),%eax
c002a84e:	50                   	push   %eax
c002a84f:	e8 41 f0 ff ff       	call   c0029895 <debug_panic>
    bitmap_mark(b, idx);
c002a854:	83 ec 08             	sub    $0x8,%esp
c002a857:	52                   	push   %edx
c002a858:	50                   	push   %eax
c002a859:	e8 2f ff ff ff       	call   c002a78d <bitmap_mark>
c002a85e:	83 c4 10             	add    $0x10,%esp
c002a861:	eb 9a                	jmp    c002a7fd <bitmap_set+0x34>

c002a863 <bitmap_flip>:

/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void bitmap_flip(struct bitmap *b, size_t bit_idx)
{
c002a863:	53                   	push   %ebx
c002a864:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
  return bit_idx / ELEM_BITS;
c002a868:	89 cb                	mov    %ecx,%ebx
c002a86a:	c1 eb 05             	shr    $0x5,%ebx
  elem_type mask = bit_mask(bit_idx);

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm("xorl %1, %0"
c002a86d:	8b 44 24 08          	mov    0x8(%esp),%eax
c002a871:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type)1 << (bit_idx % ELEM_BITS);
c002a874:	b8 01 00 00 00       	mov    $0x1,%eax
c002a879:	d3 e0                	shl    %cl,%eax
  asm("xorl %1, %0"
c002a87b:	31 04 9a             	xor    %eax,(%edx,%ebx,4)
      : "=m"(b->bits[idx])
      : "r"(mask)
      : "cc");
}
c002a87e:	5b                   	pop    %ebx
c002a87f:	c3                   	ret    

c002a880 <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool bitmap_test(const struct bitmap *b, size_t idx)
{
c002a880:	53                   	push   %ebx
c002a881:	83 ec 08             	sub    $0x8,%esp
c002a884:	e8 5d 7c 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002a889:	81 c3 b3 63 01 00    	add    $0x163b3,%ebx
c002a88f:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a893:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT(b != NULL);
c002a897:	85 c0                	test   %eax,%eax
c002a899:	74 1e                	je     c002a8b9 <bitmap_test+0x39>
  ASSERT(idx < b->bit_cnt);
c002a89b:	39 08                	cmp    %ecx,(%eax)
c002a89d:	76 43                	jbe    c002a8e2 <bitmap_test+0x62>
  return bit_idx / ELEM_BITS;
c002a89f:	89 cb                	mov    %ecx,%ebx
c002a8a1:	c1 eb 05             	shr    $0x5,%ebx
  return (b->bits[elem_idx(idx)] & bit_mask(idx)) != 0;
c002a8a4:	8b 50 04             	mov    0x4(%eax),%edx
  return (elem_type)1 << (bit_idx % ELEM_BITS);
c002a8a7:	b8 01 00 00 00       	mov    $0x1,%eax
c002a8ac:	d3 e0                	shl    %cl,%eax
  return (b->bits[elem_idx(idx)] & bit_mask(idx)) != 0;
c002a8ae:	85 04 9a             	test   %eax,(%edx,%ebx,4)
c002a8b1:	0f 95 c0             	setne  %al
}
c002a8b4:	83 c4 08             	add    $0x8,%esp
c002a8b7:	5b                   	pop    %ebx
c002a8b8:	c3                   	ret    
  ASSERT(b != NULL);
c002a8b9:	83 ec 0c             	sub    $0xc,%esp
c002a8bc:	8d 83 af 49 ff ff    	lea    -0xb651(%ebx),%eax
c002a8c2:	50                   	push   %eax
c002a8c3:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a8c9:	50                   	push   %eax
c002a8ca:	8d 83 98 27 ff ff    	lea    -0xd868(%ebx),%eax
c002a8d0:	50                   	push   %eax
c002a8d1:	68 cb 00 00 00       	push   $0xcb
c002a8d6:	8d 83 2f 4b ff ff    	lea    -0xb4d1(%ebx),%eax
c002a8dc:	50                   	push   %eax
c002a8dd:	e8 b3 ef ff ff       	call   c0029895 <debug_panic>
  ASSERT(idx < b->bit_cnt);
c002a8e2:	83 ec 0c             	sub    $0xc,%esp
c002a8e5:	8d 83 49 4b ff ff    	lea    -0xb4b7(%ebx),%eax
c002a8eb:	50                   	push   %eax
c002a8ec:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002a8f2:	50                   	push   %eax
c002a8f3:	8d 83 98 27 ff ff    	lea    -0xd868(%ebx),%eax
c002a8f9:	50                   	push   %eax
c002a8fa:	68 cc 00 00 00       	push   $0xcc
c002a8ff:	8d 83 2f 4b ff ff    	lea    -0xb4d1(%ebx),%eax
c002a905:	50                   	push   %eax
c002a906:	e8 8a ef ff ff       	call   c0029895 <debug_panic>

c002a90b <bitmap_set_multiple>:
  bitmap_set_multiple(b, 0, bitmap_size(b), value);
}

/* Sets the CNT bits starting at START in B to VALUE. */
void bitmap_set_multiple(struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002a90b:	55                   	push   %ebp
c002a90c:	57                   	push   %edi
c002a90d:	56                   	push   %esi
c002a90e:	53                   	push   %ebx
c002a90f:	83 ec 0c             	sub    $0xc,%esp
c002a912:	e8 e3 7b 00 00       	call   c00324fa <__x86.get_pc_thunk.cx>
c002a917:	81 c1 25 63 01 00    	add    $0x16325,%ecx
c002a91d:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002a921:	8b 74 24 24          	mov    0x24(%esp),%esi
c002a925:	8b 44 24 28          	mov    0x28(%esp),%eax
c002a929:	0f b6 5c 24 2c       	movzbl 0x2c(%esp),%ebx
  size_t i;

  ASSERT(b != NULL);
c002a92e:	85 ff                	test   %edi,%edi
c002a930:	74 31                	je     c002a963 <bitmap_set_multiple+0x58>
  ASSERT(start <= b->bit_cnt);
c002a932:	8b 17                	mov    (%edi),%edx
c002a934:	39 f2                	cmp    %esi,%edx
c002a936:	72 56                	jb     c002a98e <bitmap_set_multiple+0x83>
  ASSERT(start + cnt <= b->bit_cnt);
c002a938:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002a93b:	39 ea                	cmp    %ebp,%edx
c002a93d:	72 7a                	jb     c002a9b9 <bitmap_set_multiple+0xae>

  for (i = 0; i < cnt; i++)
    bitmap_set(b, start + i, value);
c002a93f:	0f b6 db             	movzbl %bl,%ebx
  for (i = 0; i < cnt; i++)
c002a942:	85 c0                	test   %eax,%eax
c002a944:	74 15                	je     c002a95b <bitmap_set_multiple+0x50>
    bitmap_set(b, start + i, value);
c002a946:	83 ec 04             	sub    $0x4,%esp
c002a949:	53                   	push   %ebx
c002a94a:	56                   	push   %esi
c002a94b:	57                   	push   %edi
c002a94c:	e8 78 fe ff ff       	call   c002a7c9 <bitmap_set>
c002a951:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002a954:	83 c4 10             	add    $0x10,%esp
c002a957:	39 f5                	cmp    %esi,%ebp
c002a959:	75 eb                	jne    c002a946 <bitmap_set_multiple+0x3b>
}
c002a95b:	83 c4 0c             	add    $0xc,%esp
c002a95e:	5b                   	pop    %ebx
c002a95f:	5e                   	pop    %esi
c002a960:	5f                   	pop    %edi
c002a961:	5d                   	pop    %ebp
c002a962:	c3                   	ret    
  ASSERT(b != NULL);
c002a963:	83 ec 0c             	sub    $0xc,%esp
c002a966:	8d 81 af 49 ff ff    	lea    -0xb651(%ecx),%eax
c002a96c:	50                   	push   %eax
c002a96d:	8d 81 fc 2c ff ff    	lea    -0xd304(%ecx),%eax
c002a973:	50                   	push   %eax
c002a974:	8d 81 74 27 ff ff    	lea    -0xd88c(%ecx),%eax
c002a97a:	50                   	push   %eax
c002a97b:	68 df 00 00 00       	push   $0xdf
c002a980:	8d 81 2f 4b ff ff    	lea    -0xb4d1(%ecx),%eax
c002a986:	50                   	push   %eax
c002a987:	89 cb                	mov    %ecx,%ebx
c002a989:	e8 07 ef ff ff       	call   c0029895 <debug_panic>
  ASSERT(start <= b->bit_cnt);
c002a98e:	83 ec 0c             	sub    $0xc,%esp
c002a991:	8d 81 5a 4b ff ff    	lea    -0xb4a6(%ecx),%eax
c002a997:	50                   	push   %eax
c002a998:	8d 81 fc 2c ff ff    	lea    -0xd304(%ecx),%eax
c002a99e:	50                   	push   %eax
c002a99f:	8d 81 74 27 ff ff    	lea    -0xd88c(%ecx),%eax
c002a9a5:	50                   	push   %eax
c002a9a6:	68 e0 00 00 00       	push   $0xe0
c002a9ab:	8d 81 2f 4b ff ff    	lea    -0xb4d1(%ecx),%eax
c002a9b1:	50                   	push   %eax
c002a9b2:	89 cb                	mov    %ecx,%ebx
c002a9b4:	e8 dc ee ff ff       	call   c0029895 <debug_panic>
  ASSERT(start + cnt <= b->bit_cnt);
c002a9b9:	83 ec 0c             	sub    $0xc,%esp
c002a9bc:	8d 81 6e 4b ff ff    	lea    -0xb492(%ecx),%eax
c002a9c2:	50                   	push   %eax
c002a9c3:	8d 81 fc 2c ff ff    	lea    -0xd304(%ecx),%eax
c002a9c9:	50                   	push   %eax
c002a9ca:	8d 81 74 27 ff ff    	lea    -0xd88c(%ecx),%eax
c002a9d0:	50                   	push   %eax
c002a9d1:	68 e1 00 00 00       	push   $0xe1
c002a9d6:	8d 81 2f 4b ff ff    	lea    -0xb4d1(%ecx),%eax
c002a9dc:	50                   	push   %eax
c002a9dd:	89 cb                	mov    %ecx,%ebx
c002a9df:	e8 b1 ee ff ff       	call   c0029895 <debug_panic>

c002a9e4 <bitmap_set_all>:
{
c002a9e4:	53                   	push   %ebx
c002a9e5:	83 ec 08             	sub    $0x8,%esp
c002a9e8:	e8 f9 7a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002a9ed:	81 c3 4f 62 01 00    	add    $0x1624f,%ebx
c002a9f3:	8b 44 24 10          	mov    0x10(%esp),%eax
c002a9f7:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT(b != NULL);
c002a9fb:	85 c0                	test   %eax,%eax
c002a9fd:	74 13                	je     c002aa12 <bitmap_set_all+0x2e>
  bitmap_set_multiple(b, 0, bitmap_size(b), value);
c002a9ff:	0f b6 d2             	movzbl %dl,%edx
c002aa02:	52                   	push   %edx
c002aa03:	ff 30                	pushl  (%eax)
c002aa05:	6a 00                	push   $0x0
c002aa07:	50                   	push   %eax
c002aa08:	e8 fe fe ff ff       	call   c002a90b <bitmap_set_multiple>
}
c002aa0d:	83 c4 18             	add    $0x18,%esp
c002aa10:	5b                   	pop    %ebx
c002aa11:	c3                   	ret    
  ASSERT(b != NULL);
c002aa12:	83 ec 0c             	sub    $0xc,%esp
c002aa15:	8d 83 af 49 ff ff    	lea    -0xb651(%ebx),%eax
c002aa1b:	50                   	push   %eax
c002aa1c:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002aa22:	50                   	push   %eax
c002aa23:	8d 83 88 27 ff ff    	lea    -0xd878(%ebx),%eax
c002aa29:	50                   	push   %eax
c002aa2a:	68 d5 00 00 00       	push   $0xd5
c002aa2f:	8d 83 2f 4b ff ff    	lea    -0xb4d1(%ebx),%eax
c002aa35:	50                   	push   %eax
c002aa36:	e8 5a ee ff ff       	call   c0029895 <debug_panic>

c002aa3b <bitmap_create>:
{
c002aa3b:	57                   	push   %edi
c002aa3c:	56                   	push   %esi
c002aa3d:	53                   	push   %ebx
c002aa3e:	e8 a3 7a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002aa43:	81 c3 f9 61 01 00    	add    $0x161f9,%ebx
c002aa49:	8b 7c 24 10          	mov    0x10(%esp),%edi
  struct bitmap *b = malloc(sizeof *b);
c002aa4d:	83 ec 0c             	sub    $0xc,%esp
c002aa50:	6a 08                	push   $0x8
c002aa52:	e8 8d 98 ff ff       	call   c00242e4 <malloc>
c002aa57:	89 c6                	mov    %eax,%esi
  if (b != NULL)
c002aa59:	83 c4 10             	add    $0x10,%esp
c002aa5c:	85 c0                	test   %eax,%eax
c002aa5e:	74 30                	je     c002aa90 <bitmap_create+0x55>
    b->bit_cnt = bit_cnt;
c002aa60:	89 38                	mov    %edi,(%eax)
    b->bits = malloc(byte_cnt(bit_cnt));
c002aa62:	83 ec 0c             	sub    $0xc,%esp
  return DIV_ROUND_UP(bit_cnt, ELEM_BITS);
c002aa65:	8d 47 1f             	lea    0x1f(%edi),%eax
c002aa68:	c1 e8 05             	shr    $0x5,%eax
  return sizeof(elem_type) * elem_cnt(bit_cnt);
c002aa6b:	c1 e0 02             	shl    $0x2,%eax
    b->bits = malloc(byte_cnt(bit_cnt));
c002aa6e:	50                   	push   %eax
c002aa6f:	e8 70 98 ff ff       	call   c00242e4 <malloc>
c002aa74:	89 46 04             	mov    %eax,0x4(%esi)
    if (b->bits != NULL || bit_cnt == 0)
c002aa77:	83 c4 10             	add    $0x10,%esp
c002aa7a:	85 ff                	test   %edi,%edi
c002aa7c:	74 04                	je     c002aa82 <bitmap_create+0x47>
c002aa7e:	85 c0                	test   %eax,%eax
c002aa80:	74 14                	je     c002aa96 <bitmap_create+0x5b>
      bitmap_set_all(b, false);
c002aa82:	83 ec 08             	sub    $0x8,%esp
c002aa85:	6a 00                	push   $0x0
c002aa87:	56                   	push   %esi
c002aa88:	e8 57 ff ff ff       	call   c002a9e4 <bitmap_set_all>
      return b;
c002aa8d:	83 c4 10             	add    $0x10,%esp
}
c002aa90:	89 f0                	mov    %esi,%eax
c002aa92:	5b                   	pop    %ebx
c002aa93:	5e                   	pop    %esi
c002aa94:	5f                   	pop    %edi
c002aa95:	c3                   	ret    
    free(b);
c002aa96:	83 ec 0c             	sub    $0xc,%esp
c002aa99:	56                   	push   %esi
c002aa9a:	e8 fb 99 ff ff       	call   c002449a <free>
c002aa9f:	83 c4 10             	add    $0x10,%esp
  return NULL;
c002aaa2:	be 00 00 00 00       	mov    $0x0,%esi
c002aaa7:	eb e7                	jmp    c002aa90 <bitmap_create+0x55>

c002aaa9 <bitmap_create_in_buf>:
{
c002aaa9:	57                   	push   %edi
c002aaaa:	56                   	push   %esi
c002aaab:	53                   	push   %ebx
c002aaac:	e8 35 7a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002aab1:	81 c3 8b 61 01 00    	add    $0x1618b,%ebx
c002aab7:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002aabb:	8b 74 24 14          	mov    0x14(%esp),%esi
  ASSERT(block_size >= bitmap_buf_size(bit_cnt));
c002aabf:	57                   	push   %edi
c002aac0:	e8 7b fc ff ff       	call   c002a740 <bitmap_buf_size>
c002aac5:	83 c4 04             	add    $0x4,%esp
c002aac8:	3b 44 24 18          	cmp    0x18(%esp),%eax
c002aacc:	77 1c                	ja     c002aaea <bitmap_create_in_buf+0x41>
  b->bit_cnt = bit_cnt;
c002aace:	89 3e                	mov    %edi,(%esi)
  b->bits = (elem_type *)(b + 1);
c002aad0:	8d 46 08             	lea    0x8(%esi),%eax
c002aad3:	89 46 04             	mov    %eax,0x4(%esi)
  bitmap_set_all(b, false);
c002aad6:	83 ec 08             	sub    $0x8,%esp
c002aad9:	6a 00                	push   $0x0
c002aadb:	56                   	push   %esi
c002aadc:	e8 03 ff ff ff       	call   c002a9e4 <bitmap_set_all>
  return b;
c002aae1:	83 c4 10             	add    $0x10,%esp
}
c002aae4:	89 f0                	mov    %esi,%eax
c002aae6:	5b                   	pop    %ebx
c002aae7:	5e                   	pop    %esi
c002aae8:	5f                   	pop    %edi
c002aae9:	c3                   	ret    
  ASSERT(block_size >= bitmap_buf_size(bit_cnt));
c002aaea:	83 ec 0c             	sub    $0xc,%esp
c002aaed:	8d 83 88 4b ff ff    	lea    -0xb478(%ebx),%eax
c002aaf3:	50                   	push   %eax
c002aaf4:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002aafa:	50                   	push   %eax
c002aafb:	8d 83 b0 27 ff ff    	lea    -0xd850(%ebx),%eax
c002ab01:	50                   	push   %eax
c002ab02:	6a 68                	push   $0x68
c002ab04:	8d 83 2f 4b ff ff    	lea    -0xb4d1(%ebx),%eax
c002ab0a:	50                   	push   %eax
c002ab0b:	e8 85 ed ff ff       	call   c0029895 <debug_panic>

c002ab10 <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count(const struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002ab10:	55                   	push   %ebp
c002ab11:	57                   	push   %edi
c002ab12:	56                   	push   %esi
c002ab13:	53                   	push   %ebx
c002ab14:	83 ec 1c             	sub    $0x1c,%esp
c002ab17:	e8 ca 79 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ab1c:	81 c3 20 61 01 00    	add    $0x16120,%ebx
c002ab22:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002ab26:	8b 74 24 34          	mov    0x34(%esp),%esi
c002ab2a:	8b 44 24 38          	mov    0x38(%esp),%eax
c002ab2e:	0f b6 54 24 3c       	movzbl 0x3c(%esp),%edx
c002ab33:	88 54 24 0f          	mov    %dl,0xf(%esp)
  size_t i, value_cnt;

  ASSERT(b != NULL);
c002ab37:	85 ff                	test   %edi,%edi
c002ab39:	74 44                	je     c002ab7f <bitmap_count+0x6f>
  ASSERT(start <= b->bit_cnt);
c002ab3b:	8b 17                	mov    (%edi),%edx
c002ab3d:	39 f2                	cmp    %esi,%edx
c002ab3f:	72 67                	jb     c002aba8 <bitmap_count+0x98>
  ASSERT(start + cnt <= b->bit_cnt);
c002ab41:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002ab44:	39 ea                	cmp    %ebp,%edx
c002ab46:	0f 82 89 00 00 00    	jb     c002abd5 <bitmap_count+0xc5>

  value_cnt = 0;
c002ab4c:	bb 00 00 00 00       	mov    $0x0,%ebx
  for (i = 0; i < cnt; i++)
c002ab51:	85 c0                	test   %eax,%eax
c002ab53:	74 7c                	je     c002abd1 <bitmap_count+0xc1>
    if (bitmap_test(b, start + i) == value)
c002ab55:	83 ec 08             	sub    $0x8,%esp
c002ab58:	56                   	push   %esi
c002ab59:	57                   	push   %edi
c002ab5a:	e8 21 fd ff ff       	call   c002a880 <bitmap_test>
c002ab5f:	83 c4 10             	add    $0x10,%esp
      value_cnt++;
c002ab62:	3a 44 24 0f          	cmp    0xf(%esp),%al
c002ab66:	0f 94 c0             	sete   %al
c002ab69:	0f b6 c0             	movzbl %al,%eax
c002ab6c:	01 c3                	add    %eax,%ebx
c002ab6e:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002ab71:	39 f5                	cmp    %esi,%ebp
c002ab73:	75 e0                	jne    c002ab55 <bitmap_count+0x45>
  return value_cnt;
}
c002ab75:	89 d8                	mov    %ebx,%eax
c002ab77:	83 c4 1c             	add    $0x1c,%esp
c002ab7a:	5b                   	pop    %ebx
c002ab7b:	5e                   	pop    %esi
c002ab7c:	5f                   	pop    %edi
c002ab7d:	5d                   	pop    %ebp
c002ab7e:	c3                   	ret    
  ASSERT(b != NULL);
c002ab7f:	83 ec 0c             	sub    $0xc,%esp
c002ab82:	8d 83 af 49 ff ff    	lea    -0xb651(%ebx),%eax
c002ab88:	50                   	push   %eax
c002ab89:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002ab8f:	50                   	push   %eax
c002ab90:	8d 83 64 27 ff ff    	lea    -0xd89c(%ebx),%eax
c002ab96:	50                   	push   %eax
c002ab97:	68 ee 00 00 00       	push   $0xee
c002ab9c:	8d 83 2f 4b ff ff    	lea    -0xb4d1(%ebx),%eax
c002aba2:	50                   	push   %eax
c002aba3:	e8 ed ec ff ff       	call   c0029895 <debug_panic>
  ASSERT(start <= b->bit_cnt);
c002aba8:	83 ec 0c             	sub    $0xc,%esp
c002abab:	8d 83 5a 4b ff ff    	lea    -0xb4a6(%ebx),%eax
c002abb1:	50                   	push   %eax
c002abb2:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002abb8:	50                   	push   %eax
c002abb9:	8d 83 64 27 ff ff    	lea    -0xd89c(%ebx),%eax
c002abbf:	50                   	push   %eax
c002abc0:	68 ef 00 00 00       	push   $0xef
c002abc5:	8d 83 2f 4b ff ff    	lea    -0xb4d1(%ebx),%eax
c002abcb:	50                   	push   %eax
c002abcc:	e8 c4 ec ff ff       	call   c0029895 <debug_panic>
  value_cnt = 0;
c002abd1:	89 c3                	mov    %eax,%ebx
c002abd3:	eb a0                	jmp    c002ab75 <bitmap_count+0x65>
  ASSERT(start + cnt <= b->bit_cnt);
c002abd5:	83 ec 0c             	sub    $0xc,%esp
c002abd8:	8d 83 6e 4b ff ff    	lea    -0xb492(%ebx),%eax
c002abde:	50                   	push   %eax
c002abdf:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002abe5:	50                   	push   %eax
c002abe6:	8d 83 64 27 ff ff    	lea    -0xd89c(%ebx),%eax
c002abec:	50                   	push   %eax
c002abed:	68 f0 00 00 00       	push   $0xf0
c002abf2:	8d 83 2f 4b ff ff    	lea    -0xb4d1(%ebx),%eax
c002abf8:	50                   	push   %eax
c002abf9:	e8 97 ec ff ff       	call   c0029895 <debug_panic>

c002abfe <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool bitmap_contains(const struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002abfe:	55                   	push   %ebp
c002abff:	57                   	push   %edi
c002ac00:	56                   	push   %esi
c002ac01:	53                   	push   %ebx
c002ac02:	83 ec 0c             	sub    $0xc,%esp
c002ac05:	e8 f0 78 00 00       	call   c00324fa <__x86.get_pc_thunk.cx>
c002ac0a:	81 c1 32 60 01 00    	add    $0x16032,%ecx
c002ac10:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002ac14:	8b 74 24 24          	mov    0x24(%esp),%esi
c002ac18:	8b 44 24 28          	mov    0x28(%esp),%eax
c002ac1c:	0f b6 5c 24 2c       	movzbl 0x2c(%esp),%ebx
  size_t i;

  ASSERT(b != NULL);
c002ac21:	85 ff                	test   %edi,%edi
c002ac23:	74 3f                	je     c002ac64 <bitmap_contains+0x66>
  ASSERT(start <= b->bit_cnt);
c002ac25:	8b 17                	mov    (%edi),%edx
c002ac27:	39 f2                	cmp    %esi,%edx
c002ac29:	72 64                	jb     c002ac8f <bitmap_contains+0x91>
  ASSERT(start + cnt <= b->bit_cnt);
c002ac2b:	8d 2c 06             	lea    (%esi,%eax,1),%ebp
c002ac2e:	39 ea                	cmp    %ebp,%edx
c002ac30:	0f 82 84 00 00 00    	jb     c002acba <bitmap_contains+0xbc>

  for (i = 0; i < cnt; i++)
c002ac36:	85 c0                	test   %eax,%eax
c002ac38:	0f 84 ac 00 00 00    	je     c002acea <bitmap_contains+0xec>
    if (bitmap_test(b, start + i) == value)
c002ac3e:	83 ec 08             	sub    $0x8,%esp
c002ac41:	56                   	push   %esi
c002ac42:	57                   	push   %edi
c002ac43:	e8 38 fc ff ff       	call   c002a880 <bitmap_test>
c002ac48:	83 c4 10             	add    $0x10,%esp
c002ac4b:	38 d8                	cmp    %bl,%al
c002ac4d:	0f 84 92 00 00 00    	je     c002ace5 <bitmap_contains+0xe7>
c002ac53:	83 c6 01             	add    $0x1,%esi
  for (i = 0; i < cnt; i++)
c002ac56:	39 f5                	cmp    %esi,%ebp
c002ac58:	75 e4                	jne    c002ac3e <bitmap_contains+0x40>
      return true;
  return false;
c002ac5a:	b8 00 00 00 00       	mov    $0x0,%eax
c002ac5f:	e9 86 00 00 00       	jmp    c002acea <bitmap_contains+0xec>
  ASSERT(b != NULL);
c002ac64:	83 ec 0c             	sub    $0xc,%esp
c002ac67:	8d 81 af 49 ff ff    	lea    -0xb651(%ecx),%eax
c002ac6d:	50                   	push   %eax
c002ac6e:	8d 81 fc 2c ff ff    	lea    -0xd304(%ecx),%eax
c002ac74:	50                   	push   %eax
c002ac75:	8d 81 54 27 ff ff    	lea    -0xd8ac(%ecx),%eax
c002ac7b:	50                   	push   %eax
c002ac7c:	68 ff 00 00 00       	push   $0xff
c002ac81:	8d 81 2f 4b ff ff    	lea    -0xb4d1(%ecx),%eax
c002ac87:	50                   	push   %eax
c002ac88:	89 cb                	mov    %ecx,%ebx
c002ac8a:	e8 06 ec ff ff       	call   c0029895 <debug_panic>
  ASSERT(start <= b->bit_cnt);
c002ac8f:	83 ec 0c             	sub    $0xc,%esp
c002ac92:	8d 81 5a 4b ff ff    	lea    -0xb4a6(%ecx),%eax
c002ac98:	50                   	push   %eax
c002ac99:	8d 81 fc 2c ff ff    	lea    -0xd304(%ecx),%eax
c002ac9f:	50                   	push   %eax
c002aca0:	8d 81 54 27 ff ff    	lea    -0xd8ac(%ecx),%eax
c002aca6:	50                   	push   %eax
c002aca7:	68 00 01 00 00       	push   $0x100
c002acac:	8d 81 2f 4b ff ff    	lea    -0xb4d1(%ecx),%eax
c002acb2:	50                   	push   %eax
c002acb3:	89 cb                	mov    %ecx,%ebx
c002acb5:	e8 db eb ff ff       	call   c0029895 <debug_panic>
  ASSERT(start + cnt <= b->bit_cnt);
c002acba:	83 ec 0c             	sub    $0xc,%esp
c002acbd:	8d 81 6e 4b ff ff    	lea    -0xb492(%ecx),%eax
c002acc3:	50                   	push   %eax
c002acc4:	8d 81 fc 2c ff ff    	lea    -0xd304(%ecx),%eax
c002acca:	50                   	push   %eax
c002accb:	8d 81 54 27 ff ff    	lea    -0xd8ac(%ecx),%eax
c002acd1:	50                   	push   %eax
c002acd2:	68 01 01 00 00       	push   $0x101
c002acd7:	8d 81 2f 4b ff ff    	lea    -0xb4d1(%ecx),%eax
c002acdd:	50                   	push   %eax
c002acde:	89 cb                	mov    %ecx,%ebx
c002ace0:	e8 b0 eb ff ff       	call   c0029895 <debug_panic>
      return true;
c002ace5:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002acea:	83 c4 0c             	add    $0xc,%esp
c002aced:	5b                   	pop    %ebx
c002acee:	5e                   	pop    %esi
c002acef:	5f                   	pop    %edi
c002acf0:	5d                   	pop    %ebp
c002acf1:	c3                   	ret    

c002acf2 <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool bitmap_any(const struct bitmap *b, size_t start, size_t cnt)
{
c002acf2:	83 ec 0c             	sub    $0xc,%esp
  return bitmap_contains(b, start, cnt, true);
c002acf5:	6a 01                	push   $0x1
c002acf7:	ff 74 24 1c          	pushl  0x1c(%esp)
c002acfb:	ff 74 24 1c          	pushl  0x1c(%esp)
c002acff:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ad03:	e8 f6 fe ff ff       	call   c002abfe <bitmap_contains>
}
c002ad08:	83 c4 1c             	add    $0x1c,%esp
c002ad0b:	c3                   	ret    

c002ad0c <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool bitmap_none(const struct bitmap *b, size_t start, size_t cnt)
{
c002ad0c:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains(b, start, cnt, true);
c002ad0f:	6a 01                	push   $0x1
c002ad11:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ad15:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ad19:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ad1d:	e8 dc fe ff ff       	call   c002abfe <bitmap_contains>
c002ad22:	83 f0 01             	xor    $0x1,%eax
}
c002ad25:	83 c4 1c             	add    $0x1c,%esp
c002ad28:	c3                   	ret    

c002ad29 <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool bitmap_all(const struct bitmap *b, size_t start, size_t cnt)
{
c002ad29:	83 ec 0c             	sub    $0xc,%esp
  return !bitmap_contains(b, start, cnt, false);
c002ad2c:	6a 00                	push   $0x0
c002ad2e:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ad32:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ad36:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ad3a:	e8 bf fe ff ff       	call   c002abfe <bitmap_contains>
c002ad3f:	83 f0 01             	xor    $0x1,%eax
}
c002ad42:	83 c4 1c             	add    $0x1c,%esp
c002ad45:	c3                   	ret    

c002ad46 <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan(const struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002ad46:	55                   	push   %ebp
c002ad47:	57                   	push   %edi
c002ad48:	56                   	push   %esi
c002ad49:	53                   	push   %ebx
c002ad4a:	83 ec 1c             	sub    $0x1c,%esp
c002ad4d:	e8 98 77 00 00       	call   c00324ea <__x86.get_pc_thunk.ax>
c002ad52:	05 ea 5e 01 00       	add    $0x15eea,%eax
c002ad57:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002ad5b:	8b 74 24 34          	mov    0x34(%esp),%esi
c002ad5f:	8b 6c 24 38          	mov    0x38(%esp),%ebp
c002ad63:	0f b6 5c 24 3c       	movzbl 0x3c(%esp),%ebx
  ASSERT(b != NULL);
c002ad68:	85 ff                	test   %edi,%edi
c002ad6a:	74 43                	je     c002adaf <bitmap_scan+0x69>
  ASSERT(start <= b->bit_cnt);
c002ad6c:	8b 17                	mov    (%edi),%edx
c002ad6e:	39 f2                	cmp    %esi,%edx
c002ad70:	72 68                	jb     c002adda <bitmap_scan+0x94>
    size_t i;
    for (i = start; i <= last; i++)
      if (!bitmap_contains(b, i, cnt, !value))
        return i;
  }
  return BITMAP_ERROR;
c002ad72:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  if (cnt <= b->bit_cnt)
c002ad77:	39 ea                	cmp    %ebp,%edx
c002ad79:	0f 82 8f 00 00 00    	jb     c002ae0e <bitmap_scan+0xc8>
    size_t last = b->bit_cnt - cnt;
c002ad7f:	29 ea                	sub    %ebp,%edx
c002ad81:	89 54 24 0c          	mov    %edx,0xc(%esp)
    for (i = start; i <= last; i++)
c002ad85:	39 d6                	cmp    %edx,%esi
c002ad87:	77 7c                	ja     c002ae05 <bitmap_scan+0xbf>
      if (!bitmap_contains(b, i, cnt, !value))
c002ad89:	83 f3 01             	xor    $0x1,%ebx
c002ad8c:	0f b6 db             	movzbl %bl,%ebx
c002ad8f:	53                   	push   %ebx
c002ad90:	55                   	push   %ebp
c002ad91:	56                   	push   %esi
c002ad92:	57                   	push   %edi
c002ad93:	e8 66 fe ff ff       	call   c002abfe <bitmap_contains>
c002ad98:	83 c4 10             	add    $0x10,%esp
c002ad9b:	84 c0                	test   %al,%al
c002ad9d:	74 6d                	je     c002ae0c <bitmap_scan+0xc6>
    for (i = start; i <= last; i++)
c002ad9f:	83 c6 01             	add    $0x1,%esi
c002ada2:	39 74 24 0c          	cmp    %esi,0xc(%esp)
c002ada6:	73 e7                	jae    c002ad8f <bitmap_scan+0x49>
  return BITMAP_ERROR;
c002ada8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002adad:	eb 5f                	jmp    c002ae0e <bitmap_scan+0xc8>
  ASSERT(b != NULL);
c002adaf:	83 ec 0c             	sub    $0xc,%esp
c002adb2:	8d 90 af 49 ff ff    	lea    -0xb651(%eax),%edx
c002adb8:	52                   	push   %edx
c002adb9:	8d 90 fc 2c ff ff    	lea    -0xd304(%eax),%edx
c002adbf:	52                   	push   %edx
c002adc0:	8d 90 48 27 ff ff    	lea    -0xd8b8(%eax),%edx
c002adc6:	52                   	push   %edx
c002adc7:	68 27 01 00 00       	push   $0x127
c002adcc:	8d 90 2f 4b ff ff    	lea    -0xb4d1(%eax),%edx
c002add2:	52                   	push   %edx
c002add3:	89 c3                	mov    %eax,%ebx
c002add5:	e8 bb ea ff ff       	call   c0029895 <debug_panic>
  ASSERT(start <= b->bit_cnt);
c002adda:	83 ec 0c             	sub    $0xc,%esp
c002addd:	8d 90 5a 4b ff ff    	lea    -0xb4a6(%eax),%edx
c002ade3:	52                   	push   %edx
c002ade4:	8d 90 fc 2c ff ff    	lea    -0xd304(%eax),%edx
c002adea:	52                   	push   %edx
c002adeb:	8d 90 48 27 ff ff    	lea    -0xd8b8(%eax),%edx
c002adf1:	52                   	push   %edx
c002adf2:	68 28 01 00 00       	push   $0x128
c002adf7:	8d 90 2f 4b ff ff    	lea    -0xb4d1(%eax),%edx
c002adfd:	52                   	push   %edx
c002adfe:	89 c3                	mov    %eax,%ebx
c002ae00:	e8 90 ea ff ff       	call   c0029895 <debug_panic>
  return BITMAP_ERROR;
c002ae05:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002ae0a:	eb 02                	jmp    c002ae0e <bitmap_scan+0xc8>
c002ae0c:	89 f0                	mov    %esi,%eax
}
c002ae0e:	83 c4 1c             	add    $0x1c,%esp
c002ae11:	5b                   	pop    %ebx
c002ae12:	5e                   	pop    %esi
c002ae13:	5f                   	pop    %edi
c002ae14:	5d                   	pop    %ebp
c002ae15:	c3                   	ret    

c002ae16 <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip(struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002ae16:	55                   	push   %ebp
c002ae17:	57                   	push   %edi
c002ae18:	56                   	push   %esi
c002ae19:	53                   	push   %ebx
c002ae1a:	83 ec 0c             	sub    $0xc,%esp
c002ae1d:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002ae21:	8b 6c 24 28          	mov    0x28(%esp),%ebp
c002ae25:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
  size_t idx = bitmap_scan(b, start, cnt, value);
c002ae29:	0f b6 c3             	movzbl %bl,%eax
c002ae2c:	50                   	push   %eax
c002ae2d:	55                   	push   %ebp
c002ae2e:	ff 74 24 2c          	pushl  0x2c(%esp)
c002ae32:	57                   	push   %edi
c002ae33:	e8 0e ff ff ff       	call   c002ad46 <bitmap_scan>
c002ae38:	83 c4 10             	add    $0x10,%esp
c002ae3b:	89 c6                	mov    %eax,%esi
  if (idx != BITMAP_ERROR)
c002ae3d:	83 f8 ff             	cmp    $0xffffffff,%eax
c002ae40:	74 12                	je     c002ae54 <bitmap_scan_and_flip+0x3e>
    bitmap_set_multiple(b, idx, cnt, !value);
c002ae42:	83 f3 01             	xor    $0x1,%ebx
c002ae45:	0f b6 db             	movzbl %bl,%ebx
c002ae48:	53                   	push   %ebx
c002ae49:	55                   	push   %ebp
c002ae4a:	50                   	push   %eax
c002ae4b:	57                   	push   %edi
c002ae4c:	e8 ba fa ff ff       	call   c002a90b <bitmap_set_multiple>
c002ae51:	83 c4 10             	add    $0x10,%esp
  return idx;
}
c002ae54:	89 f0                	mov    %esi,%eax
c002ae56:	83 c4 0c             	add    $0xc,%esp
c002ae59:	5b                   	pop    %ebx
c002ae5a:	5e                   	pop    %esi
c002ae5b:	5f                   	pop    %edi
c002ae5c:	5d                   	pop    %ebp
c002ae5d:	c3                   	ret    

c002ae5e <bitmap_file_size>:
  return DIV_ROUND_UP(bit_cnt, ELEM_BITS);
c002ae5e:	8b 44 24 04          	mov    0x4(%esp),%eax
c002ae62:	8b 00                	mov    (%eax),%eax
c002ae64:	83 c0 1f             	add    $0x1f,%eax
c002ae67:	c1 e8 05             	shr    $0x5,%eax
  return sizeof(elem_type) * elem_cnt(bit_cnt);
c002ae6a:	c1 e0 02             	shl    $0x2,%eax
/* Returns the number of bytes needed to store B in a file. */
size_t
bitmap_file_size(const struct bitmap *b)
{
  return byte_cnt(b->bit_cnt);
}
c002ae6d:	c3                   	ret    

c002ae6e <bitmap_read>:

/* Reads B from FILE.  Returns true if successful, false
   otherwise. */
bool bitmap_read(struct bitmap *b, struct file *file)
{
c002ae6e:	57                   	push   %edi
c002ae6f:	56                   	push   %esi
c002ae70:	53                   	push   %ebx
c002ae71:	e8 70 76 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ae76:	81 c3 c6 5d 01 00    	add    $0x15dc6,%ebx
c002ae7c:	8b 7c 24 10          	mov    0x10(%esp),%edi
  bool success = true;
  if (b->bit_cnt > 0)
c002ae80:	8b 17                	mov    (%edi),%edx
  bool success = true;
c002ae82:	b8 01 00 00 00       	mov    $0x1,%eax
  if (b->bit_cnt > 0)
c002ae87:	85 d2                	test   %edx,%edx
c002ae89:	75 04                	jne    c002ae8f <bitmap_read+0x21>
    off_t size = byte_cnt(b->bit_cnt);
    success = file_read_at(file, b->bits, size, 0) == size;
    b->bits[elem_cnt(b->bit_cnt) - 1] &= last_mask(b);
  }
  return success;
}
c002ae8b:	5b                   	pop    %ebx
c002ae8c:	5e                   	pop    %esi
c002ae8d:	5f                   	pop    %edi
c002ae8e:	c3                   	ret    
  return DIV_ROUND_UP(bit_cnt, ELEM_BITS);
c002ae8f:	83 c2 1f             	add    $0x1f,%edx
c002ae92:	c1 ea 05             	shr    $0x5,%edx
  return sizeof(elem_type) * elem_cnt(bit_cnt);
c002ae95:	8d 34 95 00 00 00 00 	lea    0x0(,%edx,4),%esi
    success = file_read_at(file, b->bits, size, 0) == size;
c002ae9c:	6a 00                	push   $0x0
c002ae9e:	56                   	push   %esi
c002ae9f:	ff 77 04             	pushl  0x4(%edi)
c002aea2:	ff 74 24 20          	pushl  0x20(%esp)
c002aea6:	e8 6f 3b 00 00       	call   c002ea1a <file_read_at>
c002aeab:	83 c4 10             	add    $0x10,%esp
c002aeae:	39 f0                	cmp    %esi,%eax
c002aeb0:	0f 94 c0             	sete   %al
  int last_bits = b->bit_cnt % ELEM_BITS;
c002aeb3:	8b 17                	mov    (%edi),%edx
  return last_bits ? ((elem_type)1 << last_bits) - 1 : (elem_type)-1;
c002aeb5:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002aeba:	89 d1                	mov    %edx,%ecx
c002aebc:	83 e1 1f             	and    $0x1f,%ecx
c002aebf:	74 0a                	je     c002aecb <bitmap_read+0x5d>
c002aec1:	be 01 00 00 00       	mov    $0x1,%esi
c002aec6:	d3 e6                	shl    %cl,%esi
c002aec8:	83 ee 01             	sub    $0x1,%esi
  return DIV_ROUND_UP(bit_cnt, ELEM_BITS);
c002aecb:	83 c2 1f             	add    $0x1f,%edx
c002aece:	c1 ea 05             	shr    $0x5,%edx
    b->bits[elem_cnt(b->bit_cnt) - 1] &= last_mask(b);
c002aed1:	8b 4f 04             	mov    0x4(%edi),%ecx
c002aed4:	21 74 91 fc          	and    %esi,-0x4(%ecx,%edx,4)
c002aed8:	eb b1                	jmp    c002ae8b <bitmap_read+0x1d>

c002aeda <bitmap_write>:

/* Writes B to FILE.  Return true if successful, false
   otherwise. */
bool bitmap_write(const struct bitmap *b, struct file *file)
{
c002aeda:	56                   	push   %esi
c002aedb:	53                   	push   %ebx
c002aedc:	83 ec 04             	sub    $0x4,%esp
c002aedf:	e8 02 76 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002aee4:	81 c3 58 5d 01 00    	add    $0x15d58,%ebx
c002aeea:	8b 44 24 10          	mov    0x10(%esp),%eax
  return DIV_ROUND_UP(bit_cnt, ELEM_BITS);
c002aeee:	8b 10                	mov    (%eax),%edx
c002aef0:	8d 72 1f             	lea    0x1f(%edx),%esi
c002aef3:	c1 ee 05             	shr    $0x5,%esi
  return sizeof(elem_type) * elem_cnt(bit_cnt);
c002aef6:	c1 e6 02             	shl    $0x2,%esi
  off_t size = byte_cnt(b->bit_cnt);
  return file_write_at(file, b->bits, size, 0) == size;
c002aef9:	6a 00                	push   $0x0
c002aefb:	56                   	push   %esi
c002aefc:	ff 70 04             	pushl  0x4(%eax)
c002aeff:	ff 74 24 20          	pushl  0x20(%esp)
c002af03:	e8 6c 3b 00 00       	call   c002ea74 <file_write_at>
c002af08:	39 f0                	cmp    %esi,%eax
c002af0a:	0f 94 c0             	sete   %al
}
c002af0d:	83 c4 14             	add    $0x14,%esp
c002af10:	5b                   	pop    %ebx
c002af11:	5e                   	pop    %esi
c002af12:	c3                   	ret    

c002af13 <bitmap_dump>:

/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void bitmap_dump(const struct bitmap *b)
{
c002af13:	53                   	push   %ebx
c002af14:	83 ec 08             	sub    $0x8,%esp
c002af17:	e8 ca 75 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002af1c:	81 c3 20 5d 01 00    	add    $0x15d20,%ebx
c002af22:	8b 54 24 10          	mov    0x10(%esp),%edx
  hex_dump(0, b->bits, byte_cnt(b->bit_cnt), false);
c002af26:	6a 00                	push   $0x0
  return DIV_ROUND_UP(bit_cnt, ELEM_BITS);
c002af28:	8b 02                	mov    (%edx),%eax
c002af2a:	83 c0 1f             	add    $0x1f,%eax
c002af2d:	c1 e8 05             	shr    $0x5,%eax
  return sizeof(elem_type) * elem_cnt(bit_cnt);
c002af30:	c1 e0 02             	shl    $0x2,%eax
  hex_dump(0, b->bits, byte_cnt(b->bit_cnt), false);
c002af33:	50                   	push   %eax
c002af34:	ff 72 04             	pushl  0x4(%edx)
c002af37:	6a 00                	push   $0x0
c002af39:	e8 fe d4 ff ff       	call   c002843c <hex_dump>
}
c002af3e:	83 c4 18             	add    $0x18,%esp
c002af41:	5b                   	pop    %ebx
c002af42:	c3                   	ret    

c002af43 <find_bucket>:
}

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket(struct hash *h, struct hash_elem *e)
{
c002af43:	53                   	push   %ebx
c002af44:	83 ec 10             	sub    $0x10,%esp
c002af47:	89 c3                	mov    %eax,%ebx
  size_t bucket_idx = h->hash(e, h->aux) & (h->bucket_cnt - 1);
c002af49:	ff 70 14             	pushl  0x14(%eax)
c002af4c:	52                   	push   %edx
c002af4d:	ff 50 0c             	call   *0xc(%eax)
c002af50:	8b 4b 04             	mov    0x4(%ebx),%ecx
c002af53:	8d 51 ff             	lea    -0x1(%ecx),%edx
c002af56:	21 d0                	and    %edx,%eax
  return &h->buckets[bucket_idx];
c002af58:	c1 e0 04             	shl    $0x4,%eax
c002af5b:	03 43 08             	add    0x8(%ebx),%eax
}
c002af5e:	83 c4 18             	add    $0x18,%esp
c002af61:	5b                   	pop    %ebx
c002af62:	c3                   	ret    

c002af63 <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem(struct hash *h, struct list *bucket, struct hash_elem *e)
{
c002af63:	55                   	push   %ebp
c002af64:	57                   	push   %edi
c002af65:	56                   	push   %esi
c002af66:	53                   	push   %ebx
c002af67:	83 ec 28             	sub    $0x28,%esp
c002af6a:	e8 77 75 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002af6f:	81 c3 cd 5c 01 00    	add    $0x15ccd,%ebx
c002af75:	89 c7                	mov    %eax,%edi
c002af77:	89 54 24 18          	mov    %edx,0x18(%esp)
c002af7b:	89 cd                	mov    %ecx,%ebp
  struct list_elem *i;

  for (i = list_begin(bucket); i != list_end(bucket); i = list_next(i))
c002af7d:	52                   	push   %edx
c002af7e:	e8 37 ea ff ff       	call   c00299ba <list_begin>
c002af83:	89 c6                	mov    %eax,%esi
c002af85:	83 c4 10             	add    $0x10,%esp
c002af88:	eb 0e                	jmp    c002af98 <find_elem+0x35>
c002af8a:	83 ec 0c             	sub    $0xc,%esp
c002af8d:	56                   	push   %esi
c002af8e:	e8 6c ea ff ff       	call   c00299ff <list_next>
c002af93:	89 c6                	mov    %eax,%esi
c002af95:	83 c4 10             	add    $0x10,%esp
c002af98:	83 ec 0c             	sub    $0xc,%esp
c002af9b:	ff 74 24 18          	pushl  0x18(%esp)
c002af9f:	e8 b8 ea ff ff       	call   c0029a5c <list_end>
c002afa4:	83 c4 10             	add    $0x10,%esp
c002afa7:	39 f0                	cmp    %esi,%eax
c002afa9:	74 26                	je     c002afd1 <find_elem+0x6e>
  {
    struct hash_elem *hi = list_elem_to_hash_elem(i);
    if (!h->less(hi, e, h->aux) && !h->less(e, hi, h->aux))
c002afab:	83 ec 04             	sub    $0x4,%esp
c002afae:	ff 77 14             	pushl  0x14(%edi)
c002afb1:	55                   	push   %ebp
c002afb2:	56                   	push   %esi
c002afb3:	ff 57 10             	call   *0x10(%edi)
c002afb6:	83 c4 10             	add    $0x10,%esp
c002afb9:	84 c0                	test   %al,%al
c002afbb:	75 cd                	jne    c002af8a <find_elem+0x27>
c002afbd:	83 ec 04             	sub    $0x4,%esp
c002afc0:	ff 77 14             	pushl  0x14(%edi)
c002afc3:	56                   	push   %esi
c002afc4:	55                   	push   %ebp
c002afc5:	ff 57 10             	call   *0x10(%edi)
c002afc8:	83 c4 10             	add    $0x10,%esp
c002afcb:	84 c0                	test   %al,%al
c002afcd:	75 bb                	jne    c002af8a <find_elem+0x27>
c002afcf:	eb 05                	jmp    c002afd6 <find_elem+0x73>
      return hi;
  }
  return NULL;
c002afd1:	be 00 00 00 00       	mov    $0x0,%esi
}
c002afd6:	89 f0                	mov    %esi,%eax
c002afd8:	83 c4 1c             	add    $0x1c,%esp
c002afdb:	5b                   	pop    %ebx
c002afdc:	5e                   	pop    %esi
c002afdd:	5f                   	pop    %edi
c002afde:	5d                   	pop    %ebp
c002afdf:	c3                   	ret    

c002afe0 <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash(struct hash *h)
{
c002afe0:	55                   	push   %ebp
c002afe1:	57                   	push   %edi
c002afe2:	56                   	push   %esi
c002afe3:	53                   	push   %ebx
c002afe4:	83 ec 2c             	sub    $0x2c,%esp
c002afe7:	e8 fa 74 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002afec:	81 c3 50 5c 01 00    	add    $0x15c50,%ebx
c002aff2:	89 44 24 10          	mov    %eax,0x10(%esp)
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT(h != NULL);
c002aff6:	85 c0                	test   %eax,%eax
c002aff8:	74 22                	je     c002b01c <rehash+0x3c>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
  old_bucket_cnt = h->bucket_cnt;
c002affa:	8b 44 24 10          	mov    0x10(%esp),%eax
c002affe:	8b 48 04             	mov    0x4(%eax),%ecx
c002b001:	89 4c 24 0c          	mov    %ecx,0xc(%esp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002b005:	8b 00                	mov    (%eax),%eax
c002b007:	89 44 24 14          	mov    %eax,0x14(%esp)
c002b00b:	89 c6                	mov    %eax,%esi
c002b00d:	d1 ee                	shr    %esi
c002b00f:	83 fe 04             	cmp    $0x4,%esi
c002b012:	b8 04 00 00 00       	mov    $0x4,%eax
c002b017:	0f 42 f0             	cmovb  %eax,%esi
c002b01a:	eb 2e                	jmp    c002b04a <rehash+0x6a>
  ASSERT(h != NULL);
c002b01c:	83 ec 0c             	sub    $0xc,%esp
c002b01f:	8d 83 af 4b ff ff    	lea    -0xb451(%ebx),%eax
c002b025:	50                   	push   %eax
c002b026:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002b02c:	50                   	push   %eax
c002b02d:	8d 83 04 28 ff ff    	lea    -0xd7fc(%ebx),%eax
c002b033:	50                   	push   %eax
c002b034:	68 60 01 00 00       	push   $0x160
c002b039:	8d 83 b9 4b ff ff    	lea    -0xb447(%ebx),%eax
c002b03f:	50                   	push   %eax
c002b040:	e8 50 e8 ff ff       	call   c0029895 <debug_panic>
  return x & (x - 1);
c002b045:	8d 46 ff             	lea    -0x1(%esi),%eax
c002b048:	21 c6                	and    %eax,%esi
  return x != 0 && turn_off_least_1bit(x) == 0;
c002b04a:	85 f6                	test   %esi,%esi
c002b04c:	74 f7                	je     c002b045 <rehash+0x65>
  return x & (x - 1);
c002b04e:	8d 46 ff             	lea    -0x1(%esi),%eax
  if (new_bucket_cnt < 4)
    new_bucket_cnt = 4;
  while (!is_power_of_2(new_bucket_cnt))
c002b051:	85 f0                	test   %esi,%eax
c002b053:	75 f0                	jne    c002b045 <rehash+0x65>
    new_bucket_cnt = turn_off_least_1bit(new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002b055:	3b 74 24 0c          	cmp    0xc(%esp),%esi
c002b059:	0f 84 df 00 00 00    	je     c002b13e <rehash+0x15e>
  old_buckets = h->buckets;
c002b05f:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b063:	8b 40 08             	mov    0x8(%eax),%eax
c002b066:	89 44 24 1c          	mov    %eax,0x1c(%esp)
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc(sizeof *new_buckets * new_bucket_cnt);
c002b06a:	89 f5                	mov    %esi,%ebp
c002b06c:	c1 e5 04             	shl    $0x4,%ebp
c002b06f:	83 ec 0c             	sub    $0xc,%esp
c002b072:	55                   	push   %ebp
c002b073:	e8 6c 92 ff ff       	call   c00242e4 <malloc>
c002b078:	89 44 24 24          	mov    %eax,0x24(%esp)
  if (new_buckets == NULL)
c002b07c:	83 c4 10             	add    $0x10,%esp
c002b07f:	85 c0                	test   %eax,%eax
c002b081:	0f 84 b7 00 00 00    	je     c002b13e <rehash+0x15e>
c002b087:	89 c7                	mov    %eax,%edi
c002b089:	01 c5                	add    %eax,%ebp
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
    return;
  }
  for (i = 0; i < new_bucket_cnt; i++)
    list_init(&new_buckets[i]);
c002b08b:	83 ec 0c             	sub    $0xc,%esp
c002b08e:	57                   	push   %edi
c002b08f:	e8 ce e8 ff ff       	call   c0029962 <list_init>
c002b094:	83 c7 10             	add    $0x10,%edi
  for (i = 0; i < new_bucket_cnt; i++)
c002b097:	83 c4 10             	add    $0x10,%esp
c002b09a:	39 ef                	cmp    %ebp,%edi
c002b09c:	75 ed                	jne    c002b08b <rehash+0xab>

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002b09e:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b0a2:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c002b0a6:	89 48 08             	mov    %ecx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002b0a9:	89 70 04             	mov    %esi,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++)
c002b0ac:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002b0b0:	85 c0                	test   %eax,%eax
c002b0b2:	74 7b                	je     c002b12f <rehash+0x14f>
c002b0b4:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c002b0b8:	89 4c 24 14          	mov    %ecx,0x14(%esp)
c002b0bc:	c1 e0 04             	shl    $0x4,%eax
c002b0bf:	01 c8                	add    %ecx,%eax
c002b0c1:	89 44 24 18          	mov    %eax,0x18(%esp)
c002b0c5:	eb 52                	jmp    c002b119 <rehash+0x139>

    old_bucket = &old_buckets[i];
    for (elem = list_begin(old_bucket);
         elem != list_end(old_bucket); elem = next)
    {
      struct list *new_bucket = find_bucket(h, list_elem_to_hash_elem(elem));
c002b0c7:	89 f2                	mov    %esi,%edx
c002b0c9:	8b 44 24 10          	mov    0x10(%esp),%eax
c002b0cd:	e8 71 fe ff ff       	call   c002af43 <find_bucket>
c002b0d2:	89 c5                	mov    %eax,%ebp
      next = list_next(elem);
c002b0d4:	83 ec 0c             	sub    $0xc,%esp
c002b0d7:	56                   	push   %esi
c002b0d8:	e8 22 e9 ff ff       	call   c00299ff <list_next>
c002b0dd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
      list_remove(elem);
c002b0e1:	89 34 24             	mov    %esi,(%esp)
c002b0e4:	e8 7c ee ff ff       	call   c0029f65 <list_remove>
      list_push_front(new_bucket, elem);
c002b0e9:	83 c4 08             	add    $0x8,%esp
c002b0ec:	56                   	push   %esi
c002b0ed:	55                   	push   %ebp
c002b0ee:	e8 38 ee ff ff       	call   c0029f2b <list_push_front>
         elem != list_end(old_bucket); elem = next)
c002b0f3:	83 c4 10             	add    $0x10,%esp
c002b0f6:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002b0fa:	83 ec 0c             	sub    $0xc,%esp
c002b0fd:	57                   	push   %edi
c002b0fe:	e8 59 e9 ff ff       	call   c0029a5c <list_end>
    for (elem = list_begin(old_bucket);
c002b103:	83 c4 10             	add    $0x10,%esp
c002b106:	39 f0                	cmp    %esi,%eax
c002b108:	75 bd                	jne    c002b0c7 <rehash+0xe7>
c002b10a:	83 44 24 14 10       	addl   $0x10,0x14(%esp)
c002b10f:	8b 44 24 14          	mov    0x14(%esp),%eax
  for (i = 0; i < old_bucket_cnt; i++)
c002b113:	39 44 24 18          	cmp    %eax,0x18(%esp)
c002b117:	74 16                	je     c002b12f <rehash+0x14f>
    old_bucket = &old_buckets[i];
c002b119:	8b 44 24 14          	mov    0x14(%esp),%eax
c002b11d:	89 c7                	mov    %eax,%edi
    for (elem = list_begin(old_bucket);
c002b11f:	83 ec 0c             	sub    $0xc,%esp
c002b122:	50                   	push   %eax
c002b123:	e8 92 e8 ff ff       	call   c00299ba <list_begin>
c002b128:	89 c6                	mov    %eax,%esi
c002b12a:	83 c4 10             	add    $0x10,%esp
c002b12d:	eb cb                	jmp    c002b0fa <rehash+0x11a>
    }
  }

  free(old_buckets);
c002b12f:	83 ec 0c             	sub    $0xc,%esp
c002b132:	ff 74 24 28          	pushl  0x28(%esp)
c002b136:	e8 5f 93 ff ff       	call   c002449a <free>
c002b13b:	83 c4 10             	add    $0x10,%esp
}
c002b13e:	83 c4 2c             	add    $0x2c,%esp
c002b141:	5b                   	pop    %ebx
c002b142:	5e                   	pop    %esi
c002b143:	5f                   	pop    %edi
c002b144:	5d                   	pop    %ebp
c002b145:	c3                   	ret    

c002b146 <hash_clear>:
{
c002b146:	55                   	push   %ebp
c002b147:	57                   	push   %edi
c002b148:	56                   	push   %esi
c002b149:	53                   	push   %ebx
c002b14a:	83 ec 1c             	sub    $0x1c,%esp
c002b14d:	e8 94 73 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b152:	81 c3 ea 5a 01 00    	add    $0x15aea,%ebx
c002b158:	8b 7c 24 30          	mov    0x30(%esp),%edi
c002b15c:	8b 6c 24 34          	mov    0x34(%esp),%ebp
  for (i = 0; i < h->bucket_cnt; i++)
c002b160:	83 7f 04 00          	cmpl   $0x0,0x4(%edi)
c002b164:	74 59                	je     c002b1bf <hash_clear+0x79>
c002b166:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002b16d:	00 
c002b16e:	eb 3f                	jmp    c002b1af <hash_clear+0x69>
        struct list_elem *list_elem = list_pop_front(bucket);
c002b170:	83 ec 0c             	sub    $0xc,%esp
c002b173:	56                   	push   %esi
c002b174:	e8 05 ef ff ff       	call   c002a07e <list_pop_front>
        destructor(hash_elem, h->aux);
c002b179:	83 c4 08             	add    $0x8,%esp
c002b17c:	ff 77 14             	pushl  0x14(%edi)
c002b17f:	50                   	push   %eax
c002b180:	ff d5                	call   *%ebp
c002b182:	83 c4 10             	add    $0x10,%esp
      while (!list_empty(bucket))
c002b185:	83 ec 0c             	sub    $0xc,%esp
c002b188:	56                   	push   %esi
c002b189:	e8 79 ee ff ff       	call   c002a007 <list_empty>
c002b18e:	83 c4 10             	add    $0x10,%esp
c002b191:	84 c0                	test   %al,%al
c002b193:	74 db                	je     c002b170 <hash_clear+0x2a>
    list_init(bucket);
c002b195:	83 ec 0c             	sub    $0xc,%esp
c002b198:	56                   	push   %esi
c002b199:	e8 c4 e7 ff ff       	call   c0029962 <list_init>
  for (i = 0; i < h->bucket_cnt; i++)
c002b19e:	83 44 24 1c 01       	addl   $0x1,0x1c(%esp)
c002b1a3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002b1a7:	83 c4 10             	add    $0x10,%esp
c002b1aa:	39 47 04             	cmp    %eax,0x4(%edi)
c002b1ad:	76 10                	jbe    c002b1bf <hash_clear+0x79>
    struct list *bucket = &h->buckets[i];
c002b1af:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002b1b3:	c1 e6 04             	shl    $0x4,%esi
c002b1b6:	03 77 08             	add    0x8(%edi),%esi
    if (destructor != NULL)
c002b1b9:	85 ed                	test   %ebp,%ebp
c002b1bb:	75 c8                	jne    c002b185 <hash_clear+0x3f>
c002b1bd:	eb d6                	jmp    c002b195 <hash_clear+0x4f>
  h->elem_cnt = 0;
c002b1bf:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
}
c002b1c5:	83 c4 1c             	add    $0x1c,%esp
c002b1c8:	5b                   	pop    %ebx
c002b1c9:	5e                   	pop    %esi
c002b1ca:	5f                   	pop    %edi
c002b1cb:	5d                   	pop    %ebp
c002b1cc:	c3                   	ret    

c002b1cd <hash_init>:
{
c002b1cd:	56                   	push   %esi
c002b1ce:	53                   	push   %ebx
c002b1cf:	83 ec 10             	sub    $0x10,%esp
c002b1d2:	e8 0f 73 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b1d7:	81 c3 65 5a 01 00    	add    $0x15a65,%ebx
c002b1dd:	8b 74 24 1c          	mov    0x1c(%esp),%esi
  h->elem_cnt = 0;
c002b1e1:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  h->bucket_cnt = 4;
c002b1e7:	c7 46 04 04 00 00 00 	movl   $0x4,0x4(%esi)
  h->buckets = malloc(sizeof *h->buckets * h->bucket_cnt);
c002b1ee:	6a 40                	push   $0x40
c002b1f0:	e8 ef 90 ff ff       	call   c00242e4 <malloc>
c002b1f5:	89 c2                	mov    %eax,%edx
c002b1f7:	89 46 08             	mov    %eax,0x8(%esi)
  h->hash = hash;
c002b1fa:	8b 44 24 24          	mov    0x24(%esp),%eax
c002b1fe:	89 46 0c             	mov    %eax,0xc(%esi)
  h->less = less;
c002b201:	8b 44 24 28          	mov    0x28(%esp),%eax
c002b205:	89 46 10             	mov    %eax,0x10(%esi)
  h->aux = aux;
c002b208:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002b20c:	89 46 14             	mov    %eax,0x14(%esi)
  if (h->buckets != NULL)
c002b20f:	83 c4 10             	add    $0x10,%esp
    return false;
c002b212:	b8 00 00 00 00       	mov    $0x0,%eax
  if (h->buckets != NULL)
c002b217:	85 d2                	test   %edx,%edx
c002b219:	74 13                	je     c002b22e <hash_init+0x61>
    hash_clear(h, NULL);
c002b21b:	83 ec 08             	sub    $0x8,%esp
c002b21e:	6a 00                	push   $0x0
c002b220:	56                   	push   %esi
c002b221:	e8 20 ff ff ff       	call   c002b146 <hash_clear>
    return true;
c002b226:	83 c4 10             	add    $0x10,%esp
c002b229:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002b22e:	83 c4 04             	add    $0x4,%esp
c002b231:	5b                   	pop    %ebx
c002b232:	5e                   	pop    %esi
c002b233:	c3                   	ret    

c002b234 <hash_destroy>:
{
c002b234:	56                   	push   %esi
c002b235:	53                   	push   %ebx
c002b236:	83 ec 04             	sub    $0x4,%esp
c002b239:	e8 a8 72 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b23e:	81 c3 fe 59 01 00    	add    $0x159fe,%ebx
c002b244:	8b 74 24 10          	mov    0x10(%esp),%esi
c002b248:	8b 44 24 14          	mov    0x14(%esp),%eax
  if (destructor != NULL)
c002b24c:	85 c0                	test   %eax,%eax
c002b24e:	74 0d                	je     c002b25d <hash_destroy+0x29>
    hash_clear(h, destructor);
c002b250:	83 ec 08             	sub    $0x8,%esp
c002b253:	50                   	push   %eax
c002b254:	56                   	push   %esi
c002b255:	e8 ec fe ff ff       	call   c002b146 <hash_clear>
c002b25a:	83 c4 10             	add    $0x10,%esp
  free(h->buckets);
c002b25d:	83 ec 0c             	sub    $0xc,%esp
c002b260:	ff 76 08             	pushl  0x8(%esi)
c002b263:	e8 32 92 ff ff       	call   c002449a <free>
}
c002b268:	83 c4 14             	add    $0x14,%esp
c002b26b:	5b                   	pop    %ebx
c002b26c:	5e                   	pop    %esi
c002b26d:	c3                   	ret    

c002b26e <hash_insert>:
{
c002b26e:	55                   	push   %ebp
c002b26f:	57                   	push   %edi
c002b270:	56                   	push   %esi
c002b271:	53                   	push   %ebx
c002b272:	83 ec 0c             	sub    $0xc,%esp
c002b275:	e8 6c 72 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b27a:	81 c3 c2 59 01 00    	add    $0x159c2,%ebx
c002b280:	8b 74 24 20          	mov    0x20(%esp),%esi
  struct list *bucket = find_bucket(h, new);
c002b284:	8b 54 24 24          	mov    0x24(%esp),%edx
c002b288:	89 f0                	mov    %esi,%eax
c002b28a:	e8 b4 fc ff ff       	call   c002af43 <find_bucket>
c002b28f:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem(h, bucket, new);
c002b291:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002b295:	89 c2                	mov    %eax,%edx
c002b297:	89 f0                	mov    %esi,%eax
c002b299:	e8 c5 fc ff ff       	call   c002af63 <find_elem>
c002b29e:	89 c7                	mov    %eax,%edi
  if (old == NULL)
c002b2a0:	85 c0                	test   %eax,%eax
c002b2a2:	74 11                	je     c002b2b5 <hash_insert+0x47>
  rehash(h);
c002b2a4:	89 f0                	mov    %esi,%eax
c002b2a6:	e8 35 fd ff ff       	call   c002afe0 <rehash>
}
c002b2ab:	89 f8                	mov    %edi,%eax
c002b2ad:	83 c4 0c             	add    $0xc,%esp
c002b2b0:	5b                   	pop    %ebx
c002b2b1:	5e                   	pop    %esi
c002b2b2:	5f                   	pop    %edi
c002b2b3:	5d                   	pop    %ebp
c002b2b4:	c3                   	ret    

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem(struct hash *h, struct list *bucket, struct hash_elem *e)
{
  h->elem_cnt++;
c002b2b5:	83 06 01             	addl   $0x1,(%esi)
  list_push_front(bucket, &e->list_elem);
c002b2b8:	83 ec 08             	sub    $0x8,%esp
c002b2bb:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b2bf:	55                   	push   %ebp
c002b2c0:	e8 66 ec ff ff       	call   c0029f2b <list_push_front>
c002b2c5:	83 c4 10             	add    $0x10,%esp
c002b2c8:	eb da                	jmp    c002b2a4 <hash_insert+0x36>

c002b2ca <hash_replace>:
{
c002b2ca:	55                   	push   %ebp
c002b2cb:	57                   	push   %edi
c002b2cc:	56                   	push   %esi
c002b2cd:	53                   	push   %ebx
c002b2ce:	83 ec 0c             	sub    $0xc,%esp
c002b2d1:	e8 10 72 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b2d6:	81 c3 66 59 01 00    	add    $0x15966,%ebx
c002b2dc:	8b 74 24 20          	mov    0x20(%esp),%esi
  struct list *bucket = find_bucket(h, new);
c002b2e0:	8b 54 24 24          	mov    0x24(%esp),%edx
c002b2e4:	89 f0                	mov    %esi,%eax
c002b2e6:	e8 58 fc ff ff       	call   c002af43 <find_bucket>
c002b2eb:	89 c5                	mov    %eax,%ebp
  struct hash_elem *old = find_elem(h, bucket, new);
c002b2ed:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c002b2f1:	89 c2                	mov    %eax,%edx
c002b2f3:	89 f0                	mov    %esi,%eax
c002b2f5:	e8 69 fc ff ff       	call   c002af63 <find_elem>
c002b2fa:	89 c7                	mov    %eax,%edi
  if (old != NULL)
c002b2fc:	85 c0                	test   %eax,%eax
c002b2fe:	74 0f                	je     c002b30f <hash_replace+0x45>

/* Removes E from hash table H. */
static void
remove_elem(struct hash *h, struct hash_elem *e)
{
  h->elem_cnt--;
c002b300:	83 2e 01             	subl   $0x1,(%esi)
  list_remove(&e->list_elem);
c002b303:	83 ec 0c             	sub    $0xc,%esp
c002b306:	50                   	push   %eax
c002b307:	e8 59 ec ff ff       	call   c0029f65 <list_remove>
c002b30c:	83 c4 10             	add    $0x10,%esp
  h->elem_cnt++;
c002b30f:	83 06 01             	addl   $0x1,(%esi)
  list_push_front(bucket, &e->list_elem);
c002b312:	83 ec 08             	sub    $0x8,%esp
c002b315:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b319:	55                   	push   %ebp
c002b31a:	e8 0c ec ff ff       	call   c0029f2b <list_push_front>
  rehash(h);
c002b31f:	89 f0                	mov    %esi,%eax
c002b321:	e8 ba fc ff ff       	call   c002afe0 <rehash>
}
c002b326:	89 f8                	mov    %edi,%eax
c002b328:	83 c4 1c             	add    $0x1c,%esp
c002b32b:	5b                   	pop    %ebx
c002b32c:	5e                   	pop    %esi
c002b32d:	5f                   	pop    %edi
c002b32e:	5d                   	pop    %ebp
c002b32f:	c3                   	ret    

c002b330 <hash_find>:
{
c002b330:	56                   	push   %esi
c002b331:	53                   	push   %ebx
c002b332:	83 ec 04             	sub    $0x4,%esp
c002b335:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002b339:	8b 74 24 14          	mov    0x14(%esp),%esi
  return find_elem(h, find_bucket(h, e), e);
c002b33d:	89 f2                	mov    %esi,%edx
c002b33f:	89 d8                	mov    %ebx,%eax
c002b341:	e8 fd fb ff ff       	call   c002af43 <find_bucket>
c002b346:	89 f1                	mov    %esi,%ecx
c002b348:	89 c2                	mov    %eax,%edx
c002b34a:	89 d8                	mov    %ebx,%eax
c002b34c:	e8 12 fc ff ff       	call   c002af63 <find_elem>
}
c002b351:	83 c4 04             	add    $0x4,%esp
c002b354:	5b                   	pop    %ebx
c002b355:	5e                   	pop    %esi
c002b356:	c3                   	ret    

c002b357 <hash_delete>:
{
c002b357:	57                   	push   %edi
c002b358:	56                   	push   %esi
c002b359:	53                   	push   %ebx
c002b35a:	e8 87 71 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b35f:	81 c3 dd 58 01 00    	add    $0x158dd,%ebx
c002b365:	8b 74 24 10          	mov    0x10(%esp),%esi
c002b369:	8b 7c 24 14          	mov    0x14(%esp),%edi
  struct hash_elem *found = find_elem(h, find_bucket(h, e), e);
c002b36d:	89 fa                	mov    %edi,%edx
c002b36f:	89 f0                	mov    %esi,%eax
c002b371:	e8 cd fb ff ff       	call   c002af43 <find_bucket>
c002b376:	89 f9                	mov    %edi,%ecx
c002b378:	89 c2                	mov    %eax,%edx
c002b37a:	89 f0                	mov    %esi,%eax
c002b37c:	e8 e2 fb ff ff       	call   c002af63 <find_elem>
c002b381:	89 c7                	mov    %eax,%edi
  if (found != NULL)
c002b383:	85 c0                	test   %eax,%eax
c002b385:	74 16                	je     c002b39d <hash_delete+0x46>
  h->elem_cnt--;
c002b387:	83 2e 01             	subl   $0x1,(%esi)
  list_remove(&e->list_elem);
c002b38a:	83 ec 0c             	sub    $0xc,%esp
c002b38d:	50                   	push   %eax
c002b38e:	e8 d2 eb ff ff       	call   c0029f65 <list_remove>
    rehash(h);
c002b393:	89 f0                	mov    %esi,%eax
c002b395:	e8 46 fc ff ff       	call   c002afe0 <rehash>
c002b39a:	83 c4 10             	add    $0x10,%esp
}
c002b39d:	89 f8                	mov    %edi,%eax
c002b39f:	5b                   	pop    %ebx
c002b3a0:	5e                   	pop    %esi
c002b3a1:	5f                   	pop    %edi
c002b3a2:	c3                   	ret    

c002b3a3 <hash_apply>:
{
c002b3a3:	55                   	push   %ebp
c002b3a4:	57                   	push   %edi
c002b3a5:	56                   	push   %esi
c002b3a6:	53                   	push   %ebx
c002b3a7:	83 ec 1c             	sub    $0x1c,%esp
c002b3aa:	e8 37 71 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b3af:	81 c3 8d 58 01 00    	add    $0x1588d,%ebx
c002b3b5:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  ASSERT(action != NULL);
c002b3b9:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c002b3be:	74 16                	je     c002b3d6 <hash_apply+0x33>
  for (i = 0; i < h->bucket_cnt; i++)
c002b3c0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002b3c7:	00 
c002b3c8:	83 7d 04 00          	cmpl   $0x0,0x4(%ebp)
c002b3cc:	75 6e                	jne    c002b43c <hash_apply+0x99>
}
c002b3ce:	83 c4 1c             	add    $0x1c,%esp
c002b3d1:	5b                   	pop    %ebx
c002b3d2:	5e                   	pop    %esi
c002b3d3:	5f                   	pop    %edi
c002b3d4:	5d                   	pop    %ebp
c002b3d5:	c3                   	ret    
  ASSERT(action != NULL);
c002b3d6:	83 ec 0c             	sub    $0xc,%esp
c002b3d9:	8d 83 d1 4b ff ff    	lea    -0xb42f(%ebx),%eax
c002b3df:	50                   	push   %eax
c002b3e0:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002b3e6:	50                   	push   %eax
c002b3e7:	8d 83 f8 27 ff ff    	lea    -0xd808(%ebx),%eax
c002b3ed:	50                   	push   %eax
c002b3ee:	68 a3 00 00 00       	push   $0xa3
c002b3f3:	8d 83 b9 4b ff ff    	lea    -0xb447(%ebx),%eax
c002b3f9:	50                   	push   %eax
c002b3fa:	e8 96 e4 ff ff       	call   c0029895 <debug_panic>
      next = list_next(elem);
c002b3ff:	83 ec 0c             	sub    $0xc,%esp
c002b402:	56                   	push   %esi
c002b403:	e8 f7 e5 ff ff       	call   c00299ff <list_next>
c002b408:	89 44 24 18          	mov    %eax,0x18(%esp)
      action(list_elem_to_hash_elem(elem), h->aux);
c002b40c:	83 c4 08             	add    $0x8,%esp
c002b40f:	ff 75 14             	pushl  0x14(%ebp)
c002b412:	56                   	push   %esi
c002b413:	ff 54 24 44          	call   *0x44(%esp)
    for (elem = list_begin(bucket); elem != list_end(bucket); elem = next)
c002b417:	83 c4 10             	add    $0x10,%esp
c002b41a:	8b 74 24 08          	mov    0x8(%esp),%esi
c002b41e:	83 ec 0c             	sub    $0xc,%esp
c002b421:	57                   	push   %edi
c002b422:	e8 35 e6 ff ff       	call   c0029a5c <list_end>
c002b427:	83 c4 10             	add    $0x10,%esp
c002b42a:	39 f0                	cmp    %esi,%eax
c002b42c:	75 d1                	jne    c002b3ff <hash_apply+0x5c>
  for (i = 0; i < h->bucket_cnt; i++)
c002b42e:	83 44 24 0c 01       	addl   $0x1,0xc(%esp)
c002b433:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002b437:	39 45 04             	cmp    %eax,0x4(%ebp)
c002b43a:	76 92                	jbe    c002b3ce <hash_apply+0x2b>
    struct list *bucket = &h->buckets[i];
c002b43c:	8b 7c 24 0c          	mov    0xc(%esp),%edi
c002b440:	c1 e7 04             	shl    $0x4,%edi
c002b443:	03 7d 08             	add    0x8(%ebp),%edi
    for (elem = list_begin(bucket); elem != list_end(bucket); elem = next)
c002b446:	83 ec 0c             	sub    $0xc,%esp
c002b449:	57                   	push   %edi
c002b44a:	e8 6b e5 ff ff       	call   c00299ba <list_begin>
c002b44f:	89 c6                	mov    %eax,%esi
c002b451:	83 c4 10             	add    $0x10,%esp
c002b454:	eb c8                	jmp    c002b41e <hash_apply+0x7b>

c002b456 <hash_first>:
{
c002b456:	56                   	push   %esi
c002b457:	53                   	push   %ebx
c002b458:	83 ec 04             	sub    $0x4,%esp
c002b45b:	e8 86 70 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b460:	81 c3 dc 57 01 00    	add    $0x157dc,%ebx
c002b466:	8b 74 24 10          	mov    0x10(%esp),%esi
c002b46a:	8b 44 24 14          	mov    0x14(%esp),%eax
  ASSERT(i != NULL);
c002b46e:	85 f6                	test   %esi,%esi
c002b470:	74 1e                	je     c002b490 <hash_first+0x3a>
  ASSERT(h != NULL);
c002b472:	85 c0                	test   %eax,%eax
c002b474:	74 43                	je     c002b4b9 <hash_first+0x63>
  i->hash = h;
c002b476:	89 06                	mov    %eax,(%esi)
  i->bucket = i->hash->buckets;
c002b478:	8b 40 08             	mov    0x8(%eax),%eax
c002b47b:	89 46 04             	mov    %eax,0x4(%esi)
  i->elem = list_elem_to_hash_elem(list_head(i->bucket));
c002b47e:	83 ec 0c             	sub    $0xc,%esp
c002b481:	50                   	push   %eax
c002b482:	e8 7a e8 ff ff       	call   c0029d01 <list_head>
c002b487:	89 46 08             	mov    %eax,0x8(%esi)
}
c002b48a:	83 c4 14             	add    $0x14,%esp
c002b48d:	5b                   	pop    %ebx
c002b48e:	5e                   	pop    %esi
c002b48f:	c3                   	ret    
  ASSERT(i != NULL);
c002b490:	83 ec 0c             	sub    $0xc,%esp
c002b493:	8d 83 e0 4b ff ff    	lea    -0xb420(%ebx),%eax
c002b499:	50                   	push   %eax
c002b49a:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002b4a0:	50                   	push   %eax
c002b4a1:	8d 83 ec 27 ff ff    	lea    -0xd814(%ebx),%eax
c002b4a7:	50                   	push   %eax
c002b4a8:	68 c5 00 00 00       	push   $0xc5
c002b4ad:	8d 83 b9 4b ff ff    	lea    -0xb447(%ebx),%eax
c002b4b3:	50                   	push   %eax
c002b4b4:	e8 dc e3 ff ff       	call   c0029895 <debug_panic>
  ASSERT(h != NULL);
c002b4b9:	83 ec 0c             	sub    $0xc,%esp
c002b4bc:	8d 83 af 4b ff ff    	lea    -0xb451(%ebx),%eax
c002b4c2:	50                   	push   %eax
c002b4c3:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002b4c9:	50                   	push   %eax
c002b4ca:	8d 83 ec 27 ff ff    	lea    -0xd814(%ebx),%eax
c002b4d0:	50                   	push   %eax
c002b4d1:	68 c6 00 00 00       	push   $0xc6
c002b4d6:	8d 83 b9 4b ff ff    	lea    -0xb447(%ebx),%eax
c002b4dc:	50                   	push   %eax
c002b4dd:	e8 b3 e3 ff ff       	call   c0029895 <debug_panic>

c002b4e2 <hash_next>:
{
c002b4e2:	57                   	push   %edi
c002b4e3:	56                   	push   %esi
c002b4e4:	53                   	push   %ebx
c002b4e5:	e8 fc 6f 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b4ea:	81 c3 52 57 01 00    	add    $0x15752,%ebx
c002b4f0:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT(i != NULL);
c002b4f4:	85 f6                	test   %esi,%esi
c002b4f6:	74 4f                	je     c002b547 <hash_next+0x65>
  i->elem = list_elem_to_hash_elem(list_next(&i->elem->list_elem));
c002b4f8:	83 ec 0c             	sub    $0xc,%esp
c002b4fb:	ff 76 08             	pushl  0x8(%esi)
c002b4fe:	e8 fc e4 ff ff       	call   c00299ff <list_next>
c002b503:	89 46 08             	mov    %eax,0x8(%esi)
  while (i->elem == list_elem_to_hash_elem(list_end(i->bucket)))
c002b506:	83 c4 10             	add    $0x10,%esp
c002b509:	8b 7e 08             	mov    0x8(%esi),%edi
c002b50c:	83 ec 0c             	sub    $0xc,%esp
c002b50f:	ff 76 04             	pushl  0x4(%esi)
c002b512:	e8 45 e5 ff ff       	call   c0029a5c <list_end>
c002b517:	83 c4 10             	add    $0x10,%esp
c002b51a:	39 c7                	cmp    %eax,%edi
c002b51c:	75 59                	jne    c002b577 <hash_next+0x95>
    if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002b51e:	8b 46 04             	mov    0x4(%esi),%eax
c002b521:	8d 50 10             	lea    0x10(%eax),%edx
c002b524:	89 56 04             	mov    %edx,0x4(%esi)
c002b527:	8b 0e                	mov    (%esi),%ecx
c002b529:	8b 41 04             	mov    0x4(%ecx),%eax
c002b52c:	c1 e0 04             	shl    $0x4,%eax
c002b52f:	03 41 08             	add    0x8(%ecx),%eax
c002b532:	39 c2                	cmp    %eax,%edx
c002b534:	73 3a                	jae    c002b570 <hash_next+0x8e>
    i->elem = list_elem_to_hash_elem(list_begin(i->bucket));
c002b536:	83 ec 0c             	sub    $0xc,%esp
c002b539:	52                   	push   %edx
c002b53a:	e8 7b e4 ff ff       	call   c00299ba <list_begin>
c002b53f:	89 46 08             	mov    %eax,0x8(%esi)
c002b542:	83 c4 10             	add    $0x10,%esp
c002b545:	eb c2                	jmp    c002b509 <hash_next+0x27>
  ASSERT(i != NULL);
c002b547:	83 ec 0c             	sub    $0xc,%esp
c002b54a:	8d 83 e0 4b ff ff    	lea    -0xb420(%ebx),%eax
c002b550:	50                   	push   %eax
c002b551:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002b557:	50                   	push   %eax
c002b558:	8d 83 e0 27 ff ff    	lea    -0xd820(%ebx),%eax
c002b55e:	50                   	push   %eax
c002b55f:	68 d8 00 00 00       	push   $0xd8
c002b564:	8d 83 b9 4b ff ff    	lea    -0xb447(%ebx),%eax
c002b56a:	50                   	push   %eax
c002b56b:	e8 25 e3 ff ff       	call   c0029895 <debug_panic>
      i->elem = NULL;
c002b570:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
  return i->elem;
c002b577:	8b 46 08             	mov    0x8(%esi),%eax
}
c002b57a:	5b                   	pop    %ebx
c002b57b:	5e                   	pop    %esi
c002b57c:	5f                   	pop    %edi
c002b57d:	c3                   	ret    

c002b57e <hash_cur>:
  return i->elem;
c002b57e:	8b 44 24 04          	mov    0x4(%esp),%eax
c002b582:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b585:	c3                   	ret    

c002b586 <hash_size>:
  return h->elem_cnt;
c002b586:	8b 44 24 04          	mov    0x4(%esp),%eax
c002b58a:	8b 00                	mov    (%eax),%eax
}
c002b58c:	c3                   	ret    

c002b58d <hash_empty>:
  return h->elem_cnt == 0;
c002b58d:	8b 44 24 04          	mov    0x4(%esp),%eax
c002b591:	83 38 00             	cmpl   $0x0,(%eax)
c002b594:	0f 94 c0             	sete   %al
}
c002b597:	c3                   	ret    

c002b598 <hash_bytes>:
{
c002b598:	53                   	push   %ebx
c002b599:	83 ec 08             	sub    $0x8,%esp
c002b59c:	e8 45 6f 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b5a1:	81 c3 9b 56 01 00    	add    $0x1569b,%ebx
c002b5a7:	8b 54 24 10          	mov    0x10(%esp),%edx
c002b5ab:	8b 4c 24 14          	mov    0x14(%esp),%ecx
  ASSERT(buf != NULL);
c002b5af:	85 d2                	test   %edx,%edx
c002b5b1:	74 24                	je     c002b5d7 <hash_bytes+0x3f>
c002b5b3:	8d 1c 0a             	lea    (%edx,%ecx,1),%ebx
  hash = FNV_32_BASIS;
c002b5b6:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
  while (size-- > 0)
c002b5bb:	85 c9                	test   %ecx,%ecx
c002b5bd:	74 13                	je     c002b5d2 <hash_bytes+0x3a>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002b5bf:	69 c0 93 01 00 01    	imul   $0x1000193,%eax,%eax
c002b5c5:	83 c2 01             	add    $0x1,%edx
c002b5c8:	0f b6 4a ff          	movzbl -0x1(%edx),%ecx
c002b5cc:	31 c8                	xor    %ecx,%eax
  while (size-- > 0)
c002b5ce:	39 da                	cmp    %ebx,%edx
c002b5d0:	75 ed                	jne    c002b5bf <hash_bytes+0x27>
}
c002b5d2:	83 c4 08             	add    $0x8,%esp
c002b5d5:	5b                   	pop    %ebx
c002b5d6:	c3                   	ret    
  ASSERT(buf != NULL);
c002b5d7:	83 ec 0c             	sub    $0xc,%esp
c002b5da:	8d 83 ea 4b ff ff    	lea    -0xb416(%ebx),%eax
c002b5e0:	50                   	push   %eax
c002b5e1:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002b5e7:	50                   	push   %eax
c002b5e8:	8d 83 d4 27 ff ff    	lea    -0xd82c(%ebx),%eax
c002b5ee:	50                   	push   %eax
c002b5ef:	68 0a 01 00 00       	push   $0x10a
c002b5f4:	8d 83 b9 4b ff ff    	lea    -0xb447(%ebx),%eax
c002b5fa:	50                   	push   %eax
c002b5fb:	e8 95 e2 ff ff       	call   c0029895 <debug_panic>

c002b600 <hash_string>:
{
c002b600:	56                   	push   %esi
c002b601:	53                   	push   %ebx
c002b602:	83 ec 04             	sub    $0x4,%esp
c002b605:	e8 dc 6e 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b60a:	81 c3 32 56 01 00    	add    $0x15632,%ebx
c002b610:	8b 74 24 10          	mov    0x10(%esp),%esi
  ASSERT(s != NULL);
c002b614:	85 f6                	test   %esi,%esi
c002b616:	74 27                	je     c002b63f <hash_string+0x3f>
  while (*s != '\0')
c002b618:	0f b6 16             	movzbl (%esi),%edx
  hash = FNV_32_BASIS;
c002b61b:	b8 c5 9d 1c 81       	mov    $0x811c9dc5,%eax
  while (*s != '\0')
c002b620:	84 d2                	test   %dl,%dl
c002b622:	74 15                	je     c002b639 <hash_string+0x39>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002b624:	69 c8 93 01 00 01    	imul   $0x1000193,%eax,%ecx
c002b62a:	83 c6 01             	add    $0x1,%esi
c002b62d:	0f b6 c2             	movzbl %dl,%eax
c002b630:	31 c8                	xor    %ecx,%eax
  while (*s != '\0')
c002b632:	0f b6 16             	movzbl (%esi),%edx
c002b635:	84 d2                	test   %dl,%dl
c002b637:	75 eb                	jne    c002b624 <hash_string+0x24>
}
c002b639:	83 c4 04             	add    $0x4,%esp
c002b63c:	5b                   	pop    %ebx
c002b63d:	5e                   	pop    %esi
c002b63e:	c3                   	ret    
  ASSERT(s != NULL);
c002b63f:	83 ec 0c             	sub    $0xc,%esp
c002b642:	8d 93 8b 47 ff ff    	lea    -0xb875(%ebx),%edx
c002b648:	52                   	push   %edx
c002b649:	8d 93 fc 2c ff ff    	lea    -0xd304(%ebx),%edx
c002b64f:	52                   	push   %edx
c002b650:	8d 93 c8 27 ff ff    	lea    -0xd838(%ebx),%edx
c002b656:	52                   	push   %edx
c002b657:	68 1a 01 00 00       	push   $0x11a
c002b65c:	8d 93 b9 4b ff ff    	lea    -0xb447(%ebx),%edx
c002b662:	52                   	push   %edx
c002b663:	e8 2d e2 ff ff       	call   c0029895 <debug_panic>

c002b668 <hash_int>:
{
c002b668:	83 ec 14             	sub    $0x14,%esp
  return hash_bytes(&i, sizeof i);
c002b66b:	6a 04                	push   $0x4
c002b66d:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002b671:	50                   	push   %eax
c002b672:	e8 21 ff ff ff       	call   c002b598 <hash_bytes>
}
c002b677:	83 c4 1c             	add    $0x1c,%esp
c002b67a:	c3                   	ret    

c002b67b <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock(uint8_t c)
{
c002b67b:	56                   	push   %esi
c002b67c:	53                   	push   %ebx
c002b67d:	83 ec 04             	sub    $0x4,%esp
c002b680:	e8 61 6e 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b685:	81 c3 b7 55 01 00    	add    $0x155b7,%ebx
c002b68b:	89 c6                	mov    %eax,%esi
  return (intr_context() || !use_console_lock || lock_held_by_current_thread(&console_lock));
c002b68d:	e8 bd 6b ff ff       	call   c002224f <intr_context>
c002b692:	84 c0                	test   %al,%al
c002b694:	75 09                	jne    c002b69f <putchar_have_lock+0x24>
c002b696:	80 bb 70 1d 00 00 00 	cmpb   $0x0,0x1d70(%ebx)
c002b69d:	75 2a                	jne    c002b6c9 <putchar_have_lock+0x4e>
  ASSERT(console_locked_by_current_thread());
  write_cnt++;
c002b69f:	83 83 64 1d 00 00 01 	addl   $0x1,0x1d64(%ebx)
c002b6a6:	83 93 68 1d 00 00 00 	adcl   $0x0,0x1d68(%ebx)
  serial_putc(c);
c002b6ad:	89 f0                	mov    %esi,%eax
c002b6af:	0f b6 f0             	movzbl %al,%esi
c002b6b2:	83 ec 0c             	sub    $0xc,%esp
c002b6b5:	56                   	push   %esi
c002b6b6:	e8 41 9e ff ff       	call   c00254fc <serial_putc>
  vga_putc(c);
c002b6bb:	89 34 24             	mov    %esi,(%esp)
c002b6be:	e8 07 9a ff ff       	call   c00250ca <vga_putc>
}
c002b6c3:	83 c4 14             	add    $0x14,%esp
c002b6c6:	5b                   	pop    %ebx
c002b6c7:	5e                   	pop    %esi
c002b6c8:	c3                   	ret    
  return (intr_context() || !use_console_lock || lock_held_by_current_thread(&console_lock));
c002b6c9:	83 ec 0c             	sub    $0xc,%esp
c002b6cc:	8d 83 84 1d 00 00    	lea    0x1d84(%ebx),%eax
c002b6d2:	50                   	push   %eax
c002b6d3:	e8 97 7e ff ff       	call   c002356f <lock_held_by_current_thread>
  ASSERT(console_locked_by_current_thread());
c002b6d8:	83 c4 10             	add    $0x10,%esp
c002b6db:	84 c0                	test   %al,%al
c002b6dd:	75 c0                	jne    c002b69f <putchar_have_lock+0x24>
c002b6df:	83 ec 0c             	sub    $0xc,%esp
c002b6e2:	8d 83 f8 4b ff ff    	lea    -0xb408(%ebx),%eax
c002b6e8:	50                   	push   %eax
c002b6e9:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002b6ef:	50                   	push   %eax
c002b6f0:	8d 83 0c 28 ff ff    	lea    -0xd7f4(%ebx),%eax
c002b6f6:	50                   	push   %eax
c002b6f7:	68 b2 00 00 00       	push   $0xb2
c002b6fc:	8d 83 3d 4c ff ff    	lea    -0xb3c3(%ebx),%eax
c002b702:	50                   	push   %eax
c002b703:	e8 8d e1 ff ff       	call   c0029895 <debug_panic>

c002b708 <vprintf_helper>:
{
c002b708:	83 ec 0c             	sub    $0xc,%esp
c002b70b:	8b 44 24 14          	mov    0x14(%esp),%eax
  (*char_cnt)++;
c002b70f:	83 00 01             	addl   $0x1,(%eax)
  putchar_have_lock(c);
c002b712:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
c002b717:	e8 5f ff ff ff       	call   c002b67b <putchar_have_lock>
}
c002b71c:	83 c4 0c             	add    $0xc,%esp
c002b71f:	c3                   	ret    

c002b720 <acquire_console>:
{
c002b720:	53                   	push   %ebx
c002b721:	83 ec 08             	sub    $0x8,%esp
c002b724:	e8 bd 6d 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b729:	81 c3 13 55 01 00    	add    $0x15513,%ebx
  if (!intr_context() && use_console_lock)
c002b72f:	e8 1b 6b ff ff       	call   c002224f <intr_context>
c002b734:	84 c0                	test   %al,%al
c002b736:	75 09                	jne    c002b741 <acquire_console+0x21>
c002b738:	80 bb 70 1d 00 00 00 	cmpb   $0x0,0x1d70(%ebx)
c002b73f:	75 05                	jne    c002b746 <acquire_console+0x26>
}
c002b741:	83 c4 08             	add    $0x8,%esp
c002b744:	5b                   	pop    %ebx
c002b745:	c3                   	ret    
    if (lock_held_by_current_thread(&console_lock))
c002b746:	83 ec 0c             	sub    $0xc,%esp
c002b749:	8d 83 84 1d 00 00    	lea    0x1d84(%ebx),%eax
c002b74f:	50                   	push   %eax
c002b750:	e8 1a 7e ff ff       	call   c002356f <lock_held_by_current_thread>
c002b755:	83 c4 10             	add    $0x10,%esp
c002b758:	84 c0                	test   %al,%al
c002b75a:	74 09                	je     c002b765 <acquire_console+0x45>
      console_lock_depth++;
c002b75c:	83 83 6c 1d 00 00 01 	addl   $0x1,0x1d6c(%ebx)
c002b763:	eb dc                	jmp    c002b741 <acquire_console+0x21>
      lock_acquire(&console_lock);
c002b765:	83 ec 0c             	sub    $0xc,%esp
c002b768:	8d 83 84 1d 00 00    	lea    0x1d84(%ebx),%eax
c002b76e:	50                   	push   %eax
c002b76f:	e8 4e 7e ff ff       	call   c00235c2 <lock_acquire>
c002b774:	83 c4 10             	add    $0x10,%esp
}
c002b777:	eb c8                	jmp    c002b741 <acquire_console+0x21>

c002b779 <release_console>:
{
c002b779:	53                   	push   %ebx
c002b77a:	83 ec 08             	sub    $0x8,%esp
c002b77d:	e8 64 6d 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b782:	81 c3 ba 54 01 00    	add    $0x154ba,%ebx
  if (!intr_context() && use_console_lock)
c002b788:	e8 c2 6a ff ff       	call   c002224f <intr_context>
c002b78d:	84 c0                	test   %al,%al
c002b78f:	75 1c                	jne    c002b7ad <release_console+0x34>
c002b791:	80 bb 70 1d 00 00 00 	cmpb   $0x0,0x1d70(%ebx)
c002b798:	74 13                	je     c002b7ad <release_console+0x34>
    if (console_lock_depth > 0)
c002b79a:	8b 83 6c 1d 00 00    	mov    0x1d6c(%ebx),%eax
c002b7a0:	85 c0                	test   %eax,%eax
c002b7a2:	7e 0e                	jle    c002b7b2 <release_console+0x39>
      console_lock_depth--;
c002b7a4:	83 e8 01             	sub    $0x1,%eax
c002b7a7:	89 83 6c 1d 00 00    	mov    %eax,0x1d6c(%ebx)
}
c002b7ad:	83 c4 08             	add    $0x8,%esp
c002b7b0:	5b                   	pop    %ebx
c002b7b1:	c3                   	ret    
      lock_release(&console_lock);
c002b7b2:	83 ec 0c             	sub    $0xc,%esp
c002b7b5:	8d 83 84 1d 00 00    	lea    0x1d84(%ebx),%eax
c002b7bb:	50                   	push   %eax
c002b7bc:	e8 d5 7f ff ff       	call   c0023796 <lock_release>
c002b7c1:	83 c4 10             	add    $0x10,%esp
}
c002b7c4:	eb e7                	jmp    c002b7ad <release_console+0x34>

c002b7c6 <console_init>:
{
c002b7c6:	53                   	push   %ebx
c002b7c7:	83 ec 14             	sub    $0x14,%esp
c002b7ca:	e8 17 6d 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b7cf:	81 c3 6d 54 01 00    	add    $0x1546d,%ebx
  lock_init(&console_lock);
c002b7d5:	8d 83 84 1d 00 00    	lea    0x1d84(%ebx),%eax
c002b7db:	50                   	push   %eax
c002b7dc:	e8 21 7d ff ff       	call   c0023502 <lock_init>
  use_console_lock = true;
c002b7e1:	c6 83 70 1d 00 00 01 	movb   $0x1,0x1d70(%ebx)
}
c002b7e8:	83 c4 18             	add    $0x18,%esp
c002b7eb:	5b                   	pop    %ebx
c002b7ec:	c3                   	ret    

c002b7ed <console_panic>:
{
c002b7ed:	e8 f8 6c 00 00       	call   c00324ea <__x86.get_pc_thunk.ax>
c002b7f2:	05 4a 54 01 00       	add    $0x1544a,%eax
  use_console_lock = false;
c002b7f7:	c6 80 70 1d 00 00 00 	movb   $0x0,0x1d70(%eax)
}
c002b7fe:	c3                   	ret    

c002b7ff <console_print_stats>:
{
c002b7ff:	53                   	push   %ebx
c002b800:	83 ec 0c             	sub    $0xc,%esp
c002b803:	e8 de 6c 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b808:	81 c3 34 54 01 00    	add    $0x15434,%ebx
  printf("Console: %lld characters output\n", write_cnt);
c002b80e:	ff b3 68 1d 00 00    	pushl  0x1d68(%ebx)
c002b814:	ff b3 64 1d 00 00    	pushl  0x1d64(%ebx)
c002b81a:	8d 83 1c 4c ff ff    	lea    -0xb3e4(%ebx),%eax
c002b820:	50                   	push   %eax
c002b821:	e8 d8 c2 ff ff       	call   c0027afe <printf>
}
c002b826:	83 c4 18             	add    $0x18,%esp
c002b829:	5b                   	pop    %ebx
c002b82a:	c3                   	ret    

c002b82b <vprintf>:
{
c002b82b:	53                   	push   %ebx
c002b82c:	83 ec 18             	sub    $0x18,%esp
c002b82f:	e8 b2 6c 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b834:	81 c3 08 54 01 00    	add    $0x15408,%ebx
  int char_cnt = 0;
c002b83a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002b841:	00 
  acquire_console();
c002b842:	e8 d9 fe ff ff       	call   c002b720 <acquire_console>
  __vprintf(format, args, vprintf_helper, &char_cnt);
c002b847:	8d 44 24 0c          	lea    0xc(%esp),%eax
c002b84b:	50                   	push   %eax
c002b84c:	8d 83 cc aa fe ff    	lea    -0x15534(%ebx),%eax
c002b852:	50                   	push   %eax
c002b853:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b857:	ff 74 24 2c          	pushl  0x2c(%esp)
c002b85b:	e8 e0 c2 ff ff       	call   c0027b40 <__vprintf>
  release_console();
c002b860:	e8 14 ff ff ff       	call   c002b779 <release_console>
}
c002b865:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002b869:	83 c4 28             	add    $0x28,%esp
c002b86c:	5b                   	pop    %ebx
c002b86d:	c3                   	ret    

c002b86e <puts>:
{
c002b86e:	53                   	push   %ebx
c002b86f:	83 ec 08             	sub    $0x8,%esp
c002b872:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console();
c002b876:	e8 a5 fe ff ff       	call   c002b720 <acquire_console>
  while (*s != '\0')
c002b87b:	0f b6 03             	movzbl (%ebx),%eax
c002b87e:	84 c0                	test   %al,%al
c002b880:	74 12                	je     c002b894 <puts+0x26>
    putchar_have_lock(*s++);
c002b882:	83 c3 01             	add    $0x1,%ebx
c002b885:	0f b6 c0             	movzbl %al,%eax
c002b888:	e8 ee fd ff ff       	call   c002b67b <putchar_have_lock>
  while (*s != '\0')
c002b88d:	0f b6 03             	movzbl (%ebx),%eax
c002b890:	84 c0                	test   %al,%al
c002b892:	75 ee                	jne    c002b882 <puts+0x14>
  putchar_have_lock('\n');
c002b894:	b8 0a 00 00 00       	mov    $0xa,%eax
c002b899:	e8 dd fd ff ff       	call   c002b67b <putchar_have_lock>
  release_console();
c002b89e:	e8 d6 fe ff ff       	call   c002b779 <release_console>
}
c002b8a3:	b8 00 00 00 00       	mov    $0x0,%eax
c002b8a8:	83 c4 08             	add    $0x8,%esp
c002b8ab:	5b                   	pop    %ebx
c002b8ac:	c3                   	ret    

c002b8ad <putbuf>:
{
c002b8ad:	56                   	push   %esi
c002b8ae:	53                   	push   %ebx
c002b8af:	83 ec 04             	sub    $0x4,%esp
c002b8b2:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c002b8b6:	8b 74 24 14          	mov    0x14(%esp),%esi
  acquire_console();
c002b8ba:	e8 61 fe ff ff       	call   c002b720 <acquire_console>
  while (n-- > 0)
c002b8bf:	85 f6                	test   %esi,%esi
c002b8c1:	74 12                	je     c002b8d5 <putbuf+0x28>
c002b8c3:	01 de                	add    %ebx,%esi
    putchar_have_lock(*buffer++);
c002b8c5:	83 c3 01             	add    $0x1,%ebx
c002b8c8:	0f b6 43 ff          	movzbl -0x1(%ebx),%eax
c002b8cc:	e8 aa fd ff ff       	call   c002b67b <putchar_have_lock>
  while (n-- > 0)
c002b8d1:	39 de                	cmp    %ebx,%esi
c002b8d3:	75 f0                	jne    c002b8c5 <putbuf+0x18>
  release_console();
c002b8d5:	e8 9f fe ff ff       	call   c002b779 <release_console>
}
c002b8da:	83 c4 04             	add    $0x4,%esp
c002b8dd:	5b                   	pop    %ebx
c002b8de:	5e                   	pop    %esi
c002b8df:	c3                   	ret    

c002b8e0 <putchar>:
{
c002b8e0:	53                   	push   %ebx
c002b8e1:	83 ec 08             	sub    $0x8,%esp
c002b8e4:	8b 5c 24 10          	mov    0x10(%esp),%ebx
  acquire_console();
c002b8e8:	e8 33 fe ff ff       	call   c002b720 <acquire_console>
  putchar_have_lock(c);
c002b8ed:	0f b6 c3             	movzbl %bl,%eax
c002b8f0:	e8 86 fd ff ff       	call   c002b67b <putchar_have_lock>
  release_console();
c002b8f5:	e8 7f fe ff ff       	call   c002b779 <release_console>
}
c002b8fa:	89 d8                	mov    %ebx,%eax
c002b8fc:	83 c4 08             	add    $0x8,%esp
c002b8ff:	5b                   	pop    %ebx
c002b900:	c3                   	ret    

c002b901 <process_execute>:
/* Starts a new thread running a user program loaded from
   FILENAME.  The new thread may be scheduled (and may even exit)
   before process_execute() returns.  Returns the new process's
   thread id, or TID_ERROR if the thread cannot be created. */
tid_t process_execute(const char *file_name_)
{
c002b901:	55                   	push   %ebp
c002b902:	57                   	push   %edi
c002b903:	56                   	push   %esi
c002b904:	53                   	push   %ebx
c002b905:	83 ec 28             	sub    $0x28,%esp
c002b908:	e8 d9 6b 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b90d:	81 c3 2f 53 01 00    	add    $0x1532f,%ebx
  char *fn_copy;
  tid_t tid;

  /* Make a copy of FILE_NAME.
     Otherwise there's a race between the caller and load(). */
  char *file_name = palloc_get_page(0);
c002b913:	6a 00                	push   $0x0
c002b915:	e8 b5 85 ff ff       	call   c0023ecf <palloc_get_page>
c002b91a:	89 c6                	mov    %eax,%esi
  strlcpy(file_name, file_name_, PGSIZE);
c002b91c:	83 c4 0c             	add    $0xc,%esp
c002b91f:	68 00 10 00 00       	push   $0x1000
c002b924:	ff 74 24 38          	pushl  0x38(%esp)
c002b928:	50                   	push   %eax
c002b929:	e8 bc d5 ff ff       	call   c0028eea <strlcpy>

  fn_copy = palloc_get_page(0);
c002b92e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c002b935:	e8 95 85 ff ff       	call   c0023ecf <palloc_get_page>
  if (fn_copy == NULL)
c002b93a:	83 c4 10             	add    $0x10,%esp
c002b93d:	85 c0                	test   %eax,%eax
c002b93f:	0f 84 83 00 00 00    	je     c002b9c8 <process_execute+0xc7>
c002b945:	89 c7                	mov    %eax,%edi
    return TID_ERROR;
  strlcpy(fn_copy, file_name, PGSIZE);
c002b947:	83 ec 04             	sub    $0x4,%esp
c002b94a:	68 00 10 00 00       	push   $0x1000
c002b94f:	56                   	push   %esi
c002b950:	50                   	push   %eax
c002b951:	e8 94 d5 ff ff       	call   c0028eea <strlcpy>

  char *save_ptr;
  char *thread_name = strtok_r(file_name, " ", &save_ptr);
c002b956:	83 c4 0c             	add    $0xc,%esp
c002b959:	8d 44 24 10          	lea    0x10(%esp),%eax
c002b95d:	50                   	push   %eax
c002b95e:	8d 83 da 46 ff ff    	lea    -0xb926(%ebx),%eax
c002b964:	50                   	push   %eax
c002b965:	56                   	push   %esi
c002b966:	e8 75 d3 ff ff       	call   c0028ce0 <strtok_r>

  /* Create a new thread to execute FILE_NAME. */
  tid = thread_create(thread_name, PRI_DEFAULT, start_process, fn_copy);
c002b96b:	57                   	push   %edi
c002b96c:	8d 93 64 ae fe ff    	lea    -0x1519c(%ebx),%edx
c002b972:	52                   	push   %edx
c002b973:	6a 1f                	push   $0x1f
c002b975:	50                   	push   %eax
c002b976:	e8 82 5f ff ff       	call   c00218fd <thread_create>
c002b97b:	89 c5                	mov    %eax,%ebp
  if (tid == TID_ERROR)
c002b97d:	83 c4 20             	add    $0x20,%esp
c002b980:	83 f8 ff             	cmp    $0xffffffff,%eax
c002b983:	74 35                	je     c002b9ba <process_execute+0xb9>
    palloc_free_page(fn_copy);
  palloc_free_page(file_name); /* this is part of pudding */
c002b985:	83 ec 0c             	sub    $0xc,%esp
c002b988:	56                   	push   %esi
c002b989:	e8 af 86 ff ff       	call   c002403d <palloc_free_page>

  list_push_back(&thread_current()->child_list,
                 &thread_get_child_message(tid)->elem);
c002b98e:	89 2c 24             	mov    %ebp,(%esp)
c002b991:	e8 e4 62 ff ff       	call   c0021c7a <thread_get_child_message>
c002b996:	89 c6                	mov    %eax,%esi
  list_push_back(&thread_current()->child_list,
c002b998:	e8 a8 56 ff ff       	call   c0021045 <thread_current>
c002b99d:	83 c4 08             	add    $0x8,%esp
c002b9a0:	83 c6 18             	add    $0x18,%esi
c002b9a3:	56                   	push   %esi
c002b9a4:	83 c0 70             	add    $0x70,%eax
c002b9a7:	50                   	push   %eax
c002b9a8:	e8 9b e5 ff ff       	call   c0029f48 <list_push_back>
  return tid;
c002b9ad:	83 c4 10             	add    $0x10,%esp
}
c002b9b0:	89 e8                	mov    %ebp,%eax
c002b9b2:	83 c4 1c             	add    $0x1c,%esp
c002b9b5:	5b                   	pop    %ebx
c002b9b6:	5e                   	pop    %esi
c002b9b7:	5f                   	pop    %edi
c002b9b8:	5d                   	pop    %ebp
c002b9b9:	c3                   	ret    
    palloc_free_page(fn_copy);
c002b9ba:	83 ec 0c             	sub    $0xc,%esp
c002b9bd:	57                   	push   %edi
c002b9be:	e8 7a 86 ff ff       	call   c002403d <palloc_free_page>
c002b9c3:	83 c4 10             	add    $0x10,%esp
c002b9c6:	eb bd                	jmp    c002b985 <process_execute+0x84>
    return TID_ERROR;
c002b9c8:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c002b9cd:	eb e1                	jmp    c002b9b0 <process_execute+0xaf>

c002b9cf <process_wait>:
   immediately, without waiting.

   This function will be implemented in problem 2-2.  For now, it
   does nothing. */
int process_wait(tid_t child_tid UNUSED)
{
c002b9cf:	55                   	push   %ebp
c002b9d0:	57                   	push   %edi
c002b9d1:	56                   	push   %esi
c002b9d2:	53                   	push   %ebx
c002b9d3:	83 ec 0c             	sub    $0xc,%esp
c002b9d6:	e8 0b 6b 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002b9db:	81 c3 61 52 01 00    	add    $0x15261,%ebx
c002b9e1:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  struct list_elem *e;
  struct thread *cur = thread_current();
c002b9e5:	e8 5b 56 ff ff       	call   c0021045 <thread_current>
  struct child_message *l;
  
  for (e = list_begin(&cur->child_list); e != list_end(&cur->child_list); e = list_next(e))
c002b9ea:	8d 78 70             	lea    0x70(%eax),%edi
c002b9ed:	83 ec 0c             	sub    $0xc,%esp
c002b9f0:	57                   	push   %edi
c002b9f1:	e8 c4 df ff ff       	call   c00299ba <list_begin>
c002b9f6:	89 c6                	mov    %eax,%esi
c002b9f8:	83 c4 10             	add    $0x10,%esp
c002b9fb:	83 ec 0c             	sub    $0xc,%esp
c002b9fe:	57                   	push   %edi
c002b9ff:	e8 58 e0 ff ff       	call   c0029a5c <list_end>
c002ba04:	83 c4 10             	add    $0x10,%esp
c002ba07:	39 f0                	cmp    %esi,%eax
c002ba09:	74 5d                	je     c002ba68 <process_wait+0x99>
  {
    l = list_entry(e, struct child_message, elem);
    if (l->tid == child_tid)
c002ba0b:	39 6e ec             	cmp    %ebp,-0x14(%esi)
c002ba0e:	74 10                	je     c002ba20 <process_wait+0x51>
  for (e = list_begin(&cur->child_list); e != list_end(&cur->child_list); e = list_next(e))
c002ba10:	83 ec 0c             	sub    $0xc,%esp
c002ba13:	56                   	push   %esi
c002ba14:	e8 e6 df ff ff       	call   c00299ff <list_next>
c002ba19:	89 c6                	mov    %eax,%esi
c002ba1b:	83 c4 10             	add    $0x10,%esp
c002ba1e:	eb db                	jmp    c002b9fb <process_wait+0x2c>
    {
      if (!l->terminated)
c002ba20:	80 7e f1 00          	cmpb   $0x0,-0xf(%esi)
c002ba24:	74 32                	je     c002ba58 <process_wait+0x89>
      {
        sema_down(l->sema_finished);
      }
      int ret = l->exited ? l->return_value : -1;
c002ba26:	bf ff ff ff ff       	mov    $0xffffffff,%edi
c002ba2b:	80 7e f0 00          	cmpb   $0x0,-0x10(%esi)
c002ba2f:	74 03                	je     c002ba34 <process_wait+0x65>
c002ba31:	8b 7e f4             	mov    -0xc(%esi),%edi
      list_remove(e);
c002ba34:	83 ec 0c             	sub    $0xc,%esp
c002ba37:	56                   	push   %esi
c002ba38:	e8 28 e5 ff ff       	call   c0029f65 <list_remove>
      list_remove(&l->allelem);
c002ba3d:	8d 6e e8             	lea    -0x18(%esi),%ebp
c002ba40:	83 c6 08             	add    $0x8,%esi
c002ba43:	89 34 24             	mov    %esi,(%esp)
c002ba46:	e8 1a e5 ff ff       	call   c0029f65 <list_remove>
      palloc_free_page(l);
c002ba4b:	89 2c 24             	mov    %ebp,(%esp)
c002ba4e:	e8 ea 85 ff ff       	call   c002403d <palloc_free_page>
      return ret;
c002ba53:	83 c4 10             	add    $0x10,%esp
c002ba56:	eb 15                	jmp    c002ba6d <process_wait+0x9e>
        sema_down(l->sema_finished);
c002ba58:	83 ec 0c             	sub    $0xc,%esp
c002ba5b:	ff 76 f8             	pushl  -0x8(%esi)
c002ba5e:	e8 b1 77 ff ff       	call   c0023214 <sema_down>
c002ba63:	83 c4 10             	add    $0x10,%esp
c002ba66:	eb be                	jmp    c002ba26 <process_wait+0x57>
    }
  }

  return -1;
c002ba68:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
c002ba6d:	89 f8                	mov    %edi,%eax
c002ba6f:	83 c4 0c             	add    $0xc,%esp
c002ba72:	5b                   	pop    %ebx
c002ba73:	5e                   	pop    %esi
c002ba74:	5f                   	pop    %edi
c002ba75:	5d                   	pop    %ebp
c002ba76:	c3                   	ret    

c002ba77 <process_activate>:

/* Sets up the CPU for running user code in the current
   thread.
   This function is called on every context switch. */
void process_activate(void)
{
c002ba77:	53                   	push   %ebx
c002ba78:	83 ec 08             	sub    $0x8,%esp
c002ba7b:	e8 66 6a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ba80:	81 c3 bc 51 01 00    	add    $0x151bc,%ebx
  struct thread *t = thread_current();
c002ba86:	e8 ba 55 ff ff       	call   c0021045 <thread_current>

  /* Activate thread's page tables. */
  pagedir_activate(t->pagedir);
c002ba8b:	83 ec 0c             	sub    $0xc,%esp
c002ba8e:	ff 70 30             	pushl  0x30(%eax)
c002ba91:	e8 da 0d 00 00       	call   c002c870 <pagedir_activate>

  /* Set thread's kernel stack for use in processing
     interrupts. */
  tss_update();
c002ba96:	e8 5f 27 00 00       	call   c002e1fa <tss_update>
}
c002ba9b:	83 c4 18             	add    $0x18,%esp
c002ba9e:	5b                   	pop    %ebx
c002ba9f:	c3                   	ret    

c002baa0 <start_process>:
{
c002baa0:	55                   	push   %ebp
c002baa1:	57                   	push   %edi
c002baa2:	56                   	push   %esi
c002baa3:	53                   	push   %ebx
c002baa4:	81 ec 30 01 00 00    	sub    $0x130,%esp
c002baaa:	e8 37 6a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002baaf:	81 c3 8d 51 01 00    	add    $0x1518d,%ebx
  char *text = strtok_r(file_name, " ", &save_ptr);
c002bab5:	8d 84 24 d0 00 00 00 	lea    0xd0(%esp),%eax
c002babc:	50                   	push   %eax
c002babd:	8d 83 da 46 ff ff    	lea    -0xb926(%ebx),%eax
c002bac3:	50                   	push   %eax
c002bac4:	ff b4 24 4c 01 00 00 	pushl  0x14c(%esp)
c002bacb:	e8 10 d2 ff ff       	call   c0028ce0 <strtok_r>
c002bad0:	89 c5                	mov    %eax,%ebp
  memset(&if_, 0, sizeof if_);
c002bad2:	8d 94 24 e0 00 00 00 	lea    0xe0(%esp),%edx
c002bad9:	b9 14 00 00 00       	mov    $0x14,%ecx
c002bade:	b8 00 00 00 00       	mov    $0x0,%eax
c002bae3:	89 d7                	mov    %edx,%edi
c002bae5:	f3 ab                	rep stos %eax,%es:(%edi)
  if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
c002bae7:	66 c7 84 24 2c 01 00 	movw   $0x23,0x12c(%esp)
c002baee:	00 23 00 
c002baf1:	66 c7 84 24 0c 01 00 	movw   $0x23,0x10c(%esp)
c002baf8:	00 23 00 
c002bafb:	66 c7 84 24 08 01 00 	movw   $0x23,0x108(%esp)
c002bb02:	00 23 00 
c002bb05:	66 c7 84 24 04 01 00 	movw   $0x23,0x104(%esp)
c002bb0c:	00 23 00 
c002bb0f:	66 c7 84 24 00 01 00 	movw   $0x23,0x100(%esp)
c002bb16:	00 23 00 
  if_.cs = SEL_UCSEG;
c002bb19:	66 c7 84 24 20 01 00 	movw   $0x1b,0x120(%esp)
c002bb20:	00 1b 00 
  if_.eflags = FLAG_IF | FLAG_MBS;
c002bb23:	c7 84 24 24 01 00 00 	movl   $0x202,0x124(%esp)
c002bb2a:	02 02 00 00 
   Stores the executable's entry point into *EIP
   and its initial stack pointer into *ESP.
   Returns true if successful, false otherwise. */
bool load(const char *file_name, void (**eip)(void), void **esp)
{
  struct thread *t = thread_current();
c002bb2e:	e8 12 55 ff ff       	call   c0021045 <thread_current>
c002bb33:	89 c7                	mov    %eax,%edi
  off_t file_ofs;
  bool success = false;
  int i;

#ifdef VM
    t->page_table = page_create();
c002bb35:	e8 c8 62 00 00       	call   c0031e02 <page_create>
c002bb3a:	89 87 b8 00 00 00    	mov    %eax,0xb8(%edi)
    if(t->page_table == NULL)
c002bb40:	83 c4 10             	add    $0x10,%esp
c002bb43:	85 c0                	test   %eax,%eax
c002bb45:	0f 84 80 00 00 00    	je     c002bbcb <start_process+0x12b>
        goto done;
#endif

  /* Allocate and activate page directory. */
  t->pagedir = pagedir_create();
c002bb4b:	e8 ac 08 00 00       	call   c002c3fc <pagedir_create>
c002bb50:	89 47 30             	mov    %eax,0x30(%edi)
  if (t->pagedir == NULL)
c002bb53:	85 c0                	test   %eax,%eax
c002bb55:	74 74                	je     c002bbcb <start_process+0x12b>
    goto done;
  process_activate();
c002bb57:	e8 1b ff ff ff       	call   c002ba77 <process_activate>

  /* Open executable file. */
  file = filesys_open(file_name);
c002bb5c:	83 ec 0c             	sub    $0xc,%esp
c002bb5f:	55                   	push   %ebp
c002bb60:	e8 b0 2a 00 00       	call   c002e615 <filesys_open>
c002bb65:	89 c6                	mov    %eax,%esi
  if (file == NULL)
c002bb67:	83 c4 10             	add    $0x10,%esp
c002bb6a:	85 c0                	test   %eax,%eax
c002bb6c:	0f 84 b6 00 00 00    	je     c002bc28 <start_process+0x188>
    printf("load: %s: open failed\n", file_name);
    goto done;
  }

  /* Read and verify executable header. */
  if (file_read(file, &ehdr, sizeof ehdr) != sizeof ehdr || memcmp(ehdr.e_ident, "\177ELF\1\1\1", 7) || ehdr.e_type != 2 || ehdr.e_machine != 3 || ehdr.e_version != 1 || ehdr.e_phentsize != sizeof(struct Elf32_Phdr) || ehdr.e_phnum > 1024)
c002bb72:	83 ec 04             	sub    $0x4,%esp
c002bb75:	6a 34                	push   $0x34
c002bb77:	8d 44 24 54          	lea    0x54(%esp),%eax
c002bb7b:	50                   	push   %eax
c002bb7c:	56                   	push   %esi
c002bb7d:	e8 69 2e 00 00       	call   c002e9eb <file_read>
c002bb82:	83 c4 10             	add    $0x10,%esp
c002bb85:	83 f8 34             	cmp    $0x34,%eax
c002bb88:	75 2e                	jne    c002bbb8 <start_process+0x118>
c002bb8a:	83 ec 04             	sub    $0x4,%esp
c002bb8d:	6a 07                	push   $0x7
c002bb8f:	8d 83 6f 4c ff ff    	lea    -0xb391(%ebx),%eax
c002bb95:	50                   	push   %eax
c002bb96:	8d 44 24 58          	lea    0x58(%esp),%eax
c002bb9a:	50                   	push   %eax
c002bb9b:	e8 68 cf ff ff       	call   c0028b08 <memcmp>
c002bba0:	83 c4 10             	add    $0x10,%esp
c002bba3:	89 04 24             	mov    %eax,(%esp)
c002bba6:	85 c0                	test   %eax,%eax
c002bba8:	75 0e                	jne    c002bbb8 <start_process+0x118>
c002bbaa:	81 7c 24 5c 02 00 03 	cmpl   $0x30002,0x5c(%esp)
c002bbb1:	00 
c002bbb2:	0f 84 85 00 00 00    	je     c002bc3d <start_process+0x19d>
  {
    printf("load: %s: error loading executable\n", file_name);
c002bbb8:	83 ec 08             	sub    $0x8,%esp
c002bbbb:	55                   	push   %ebp
c002bbbc:	8d 83 a0 4c ff ff    	lea    -0xb360(%ebx),%eax
c002bbc2:	50                   	push   %eax
c002bbc3:	e8 36 bf ff ff       	call   c0027afe <printf>
c002bbc8:	83 c4 10             	add    $0x10,%esp
  palloc_free_page(file_name);
c002bbcb:	83 ec 0c             	sub    $0xc,%esp
c002bbce:	ff b4 24 4c 01 00 00 	pushl  0x14c(%esp)
c002bbd5:	e8 63 84 ff ff       	call   c002403d <palloc_free_page>
c002bbda:	83 c4 10             	add    $0x10,%esp
    thread_current()->message_to_grandpa->load_failed = true;
c002bbdd:	e8 63 54 ff ff       	call   c0021045 <thread_current>
c002bbe2:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
c002bbe8:	c6 40 0a 01          	movb   $0x1,0xa(%eax)
    thread_current()->message_to_grandpa->return_value = -1;
c002bbec:	e8 54 54 ff ff       	call   c0021045 <thread_current>
c002bbf1:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
c002bbf7:	c7 40 0c ff ff ff ff 	movl   $0xffffffff,0xc(%eax)
    thread_current()->return_value = -1;
c002bbfe:	e8 42 54 ff ff       	call   c0021045 <thread_current>
c002bc03:	c7 80 b4 00 00 00 ff 	movl   $0xffffffff,0xb4(%eax)
c002bc0a:	ff ff ff 
  sema_up(thread_current()->message_to_grandpa->sema_started);
c002bc0d:	e8 33 54 ff ff       	call   c0021045 <thread_current>
c002bc12:	83 ec 0c             	sub    $0xc,%esp
c002bc15:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
c002bc1b:	ff 70 14             	pushl  0x14(%eax)
c002bc1e:	e8 0e 77 ff ff       	call   c0023331 <sema_up>
    thread_exit();
c002bc23:	e8 52 5a ff ff       	call   c002167a <thread_exit>
    printf("load: %s: open failed\n", file_name);
c002bc28:	83 ec 08             	sub    $0x8,%esp
c002bc2b:	55                   	push   %ebp
c002bc2c:	8d 83 58 4c ff ff    	lea    -0xb3a8(%ebx),%eax
c002bc32:	50                   	push   %eax
c002bc33:	e8 c6 be ff ff       	call   c0027afe <printf>
c002bc38:	83 c4 10             	add    $0x10,%esp
c002bc3b:	eb 8e                	jmp    c002bbcb <start_process+0x12b>
  if (file_read(file, &ehdr, sizeof ehdr) != sizeof ehdr || memcmp(ehdr.e_ident, "\177ELF\1\1\1", 7) || ehdr.e_type != 2 || ehdr.e_machine != 3 || ehdr.e_version != 1 || ehdr.e_phentsize != sizeof(struct Elf32_Phdr) || ehdr.e_phnum > 1024)
c002bc3d:	83 7c 24 60 01       	cmpl   $0x1,0x60(%esp)
c002bc42:	0f 85 70 ff ff ff    	jne    c002bbb8 <start_process+0x118>
c002bc48:	66 83 7c 24 76 20    	cmpw   $0x20,0x76(%esp)
c002bc4e:	0f 85 64 ff ff ff    	jne    c002bbb8 <start_process+0x118>
c002bc54:	66 81 7c 24 78 00 04 	cmpw   $0x400,0x78(%esp)
c002bc5b:	0f 87 57 ff ff ff    	ja     c002bbb8 <start_process+0x118>
    goto done;
  }

  /* Read program headers. */
  file_ofs = ehdr.e_phoff;
c002bc61:	8b 4c 24 68          	mov    0x68(%esp),%ecx
  for (i = 0; i < ehdr.e_phnum; i++)
c002bc65:	89 44 24 04          	mov    %eax,0x4(%esp)

    if (file_ofs < 0 || file_ofs > file_length(file))
      goto done;
    file_seek(file, file_ofs);

    if (file_read(file, &phdr, sizeof phdr) != sizeof phdr)
c002bc69:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002bc6d:	89 44 24 14          	mov    %eax,0x14(%esp)
c002bc71:	89 6c 24 18          	mov    %ebp,0x18(%esp)
c002bc75:	89 7c 24 1c          	mov    %edi,0x1c(%esp)
c002bc79:	89 cf                	mov    %ecx,%edi
c002bc7b:	e9 91 00 00 00       	jmp    c002bd11 <start_process+0x271>
      goto done;
    file_ofs += sizeof phdr;
    switch (phdr.p_type)
c002bc80:	83 f8 05             	cmp    $0x5,%eax
c002bc83:	0f 84 42 ff ff ff    	je     c002bbcb <start_process+0x12b>
c002bc89:	eb 7e                	jmp    c002bd09 <start_process+0x269>
    case PT_SHLIB:
      goto done;
    case PT_LOAD:
      if (validate_segment(&phdr, file))
      {
        bool writable = (phdr.p_flags & PF_W) != 0;
c002bc8b:	8b 4c 24 44          	mov    0x44(%esp),%ecx
c002bc8f:	d1 e9                	shr    %ecx
c002bc91:	83 e1 01             	and    $0x1,%ecx
c002bc94:	88 4c 24 08          	mov    %cl,0x8(%esp)
        uint32_t file_page = phdr.p_offset & ~PGMASK;
c002bc98:	8b 44 24 30          	mov    0x30(%esp),%eax
c002bc9c:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002bca1:	89 44 24 0c          	mov    %eax,0xc(%esp)
        uint32_t mem_page = phdr.p_vaddr & ~PGMASK;
c002bca5:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002bca9:	89 c8                	mov    %ecx,%eax
c002bcab:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002bcb0:	89 44 24 10          	mov    %eax,0x10(%esp)
        uint32_t page_offset = phdr.p_vaddr & PGMASK;
c002bcb4:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
c002bcba:	89 c8                	mov    %ecx,%eax
        uint32_t read_bytes, zero_bytes;
        if (phdr.p_filesz > 0)
c002bcbc:	85 ed                	test   %ebp,%ebp
c002bcbe:	0f 84 43 01 00 00    	je     c002be07 <start_process+0x367>
        {
          /* Normal segment.
               Read initial part from disk and zero the rest. */
          read_bytes = page_offset + phdr.p_filesz;
c002bcc4:	8d 0c 29             	lea    (%ecx,%ebp,1),%ecx
          zero_bytes = (ROUND_UP(page_offset + phdr.p_memsz, PGSIZE) - read_bytes);
c002bcc7:	8d ac 10 ff 0f 00 00 	lea    0xfff(%eax,%edx,1),%ebp
c002bcce:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp
c002bcd4:	29 cd                	sub    %ecx,%ebp
          /* Entirely zero.
               Don't read anything from disk. */
          read_bytes = 0;
          zero_bytes = ROUND_UP(page_offset + phdr.p_memsz, PGSIZE);
        }
        if (!load_segment(file, file_page, (void *)mem_page,
c002bcd6:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
   or disk read error occurs. */
static bool
load_segment(struct file *file, off_t ofs, uint8_t *upage,
             uint32_t read_bytes, uint32_t zero_bytes, bool writable)
{
  ASSERT((read_bytes + zero_bytes) % PGSIZE == 0);
c002bcdb:	8d 14 29             	lea    (%ecx,%ebp,1),%edx
c002bcde:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
c002bce4:	0f 85 34 01 00 00    	jne    c002be1e <start_process+0x37e>
  ASSERT(pg_ofs(upage) == 0);
  ASSERT(ofs % PGSIZE == 0);
#ifdef VM
  return mmap_load_segment(file, ofs, upage, read_bytes, zero_bytes, writable);
c002bcea:	83 ec 08             	sub    $0x8,%esp
c002bced:	50                   	push   %eax
c002bcee:	55                   	push   %ebp
c002bcef:	51                   	push   %ecx
c002bcf0:	ff 74 24 24          	pushl  0x24(%esp)
c002bcf4:	ff 74 24 24          	pushl  0x24(%esp)
c002bcf8:	56                   	push   %esi
c002bcf9:	e8 d9 22 00 00       	call   c002dfd7 <mmap_load_segment>
        if (!load_segment(file, file_page, (void *)mem_page,
c002bcfe:	83 c4 20             	add    $0x20,%esp
c002bd01:	84 c0                	test   %al,%al
c002bd03:	0f 84 c2 fe ff ff    	je     c002bbcb <start_process+0x12b>
c002bd09:	83 c7 20             	add    $0x20,%edi
  for (i = 0; i < ehdr.e_phnum; i++)
c002bd0c:	83 44 24 04 01       	addl   $0x1,0x4(%esp)
c002bd11:	0f b7 44 24 78       	movzwl 0x78(%esp),%eax
c002bd16:	39 44 24 04          	cmp    %eax,0x4(%esp)
c002bd1a:	0f 8d 27 01 00 00    	jge    c002be47 <start_process+0x3a7>
    if (file_ofs < 0 || file_ofs > file_length(file))
c002bd20:	85 ff                	test   %edi,%edi
c002bd22:	0f 88 a3 fe ff ff    	js     c002bbcb <start_process+0x12b>
c002bd28:	83 ec 0c             	sub    $0xc,%esp
c002bd2b:	56                   	push   %esi
c002bd2c:	e8 63 2e 00 00       	call   c002eb94 <file_length>
c002bd31:	83 c4 10             	add    $0x10,%esp
c002bd34:	39 c7                	cmp    %eax,%edi
c002bd36:	0f 8f 8f fe ff ff    	jg     c002bbcb <start_process+0x12b>
    file_seek(file, file_ofs);
c002bd3c:	83 ec 08             	sub    $0x8,%esp
c002bd3f:	57                   	push   %edi
c002bd40:	56                   	push   %esi
c002bd41:	e8 9d 2e 00 00       	call   c002ebe3 <file_seek>
    if (file_read(file, &phdr, sizeof phdr) != sizeof phdr)
c002bd46:	83 c4 0c             	add    $0xc,%esp
c002bd49:	6a 20                	push   $0x20
c002bd4b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002bd4f:	56                   	push   %esi
c002bd50:	e8 96 2c 00 00       	call   c002e9eb <file_read>
c002bd55:	83 c4 10             	add    $0x10,%esp
c002bd58:	83 f8 20             	cmp    $0x20,%eax
c002bd5b:	0f 85 6a fe ff ff    	jne    c002bbcb <start_process+0x12b>
    switch (phdr.p_type)
c002bd61:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002bd65:	83 f8 03             	cmp    $0x3,%eax
c002bd68:	0f 87 12 ff ff ff    	ja     c002bc80 <start_process+0x1e0>
c002bd6e:	83 f8 02             	cmp    $0x2,%eax
c002bd71:	0f 83 54 fe ff ff    	jae    c002bbcb <start_process+0x12b>
c002bd77:	83 f8 01             	cmp    $0x1,%eax
c002bd7a:	75 8d                	jne    c002bd09 <start_process+0x269>
  if ((phdr->p_offset & PGMASK) != (phdr->p_vaddr & PGMASK))
c002bd7c:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c002bd80:	89 e8                	mov    %ebp,%eax
c002bd82:	33 44 24 34          	xor    0x34(%esp),%eax
c002bd86:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002bd8b:	0f 85 3a fe ff ff    	jne    c002bbcb <start_process+0x12b>
  if (phdr->p_offset > (Elf32_Off)file_length(file))
c002bd91:	83 ec 0c             	sub    $0xc,%esp
c002bd94:	56                   	push   %esi
c002bd95:	e8 fa 2d 00 00       	call   c002eb94 <file_length>
c002bd9a:	83 c4 10             	add    $0x10,%esp
c002bd9d:	39 c5                	cmp    %eax,%ebp
c002bd9f:	0f 87 26 fe ff ff    	ja     c002bbcb <start_process+0x12b>
  if (phdr->p_memsz < phdr->p_filesz)
c002bda5:	8b 54 24 40          	mov    0x40(%esp),%edx
c002bda9:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
  if (phdr->p_memsz == 0)
c002bdad:	85 d2                	test   %edx,%edx
c002bdaf:	0f 84 16 fe ff ff    	je     c002bbcb <start_process+0x12b>
c002bdb5:	39 ea                	cmp    %ebp,%edx
c002bdb7:	0f 82 0e fe ff ff    	jb     c002bbcb <start_process+0x12b>
  if (!is_user_vaddr((void *)phdr->p_vaddr))
c002bdbd:	8b 4c 24 34          	mov    0x34(%esp),%ecx
c002bdc1:	81 f9 ff ff ff bf    	cmp    $0xbfffffff,%ecx
c002bdc7:	0f 87 fe fd ff ff    	ja     c002bbcb <start_process+0x12b>
  if (phdr->p_vaddr < PGSIZE)
c002bdcd:	81 f9 ff 0f 00 00    	cmp    $0xfff,%ecx
c002bdd3:	0f 96 44 24 0c       	setbe  0xc(%esp)
  if (phdr->p_vaddr + phdr->p_memsz < phdr->p_vaddr)
c002bdd8:	89 d0                	mov    %edx,%eax
c002bdda:	89 4c 24 10          	mov    %ecx,0x10(%esp)
c002bdde:	01 c8                	add    %ecx,%eax
c002bde0:	89 44 24 08          	mov    %eax,0x8(%esp)
c002bde4:	0f 92 c1             	setb   %cl
      if (validate_segment(&phdr, file))
c002bde7:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c002bdec:	08 c8                	or     %cl,%al
c002bdee:	0f 85 d7 fd ff ff    	jne    c002bbcb <start_process+0x12b>
c002bdf4:	81 7c 24 08 ff ff ff 	cmpl   $0xbfffffff,0x8(%esp)
c002bdfb:	bf 
c002bdfc:	0f 86 89 fe ff ff    	jbe    c002bc8b <start_process+0x1eb>
c002be02:	e9 c4 fd ff ff       	jmp    c002bbcb <start_process+0x12b>
          zero_bytes = ROUND_UP(page_offset + phdr.p_memsz, PGSIZE);
c002be07:	8d ac 11 ff 0f 00 00 	lea    0xfff(%ecx,%edx,1),%ebp
c002be0e:	81 e5 00 f0 ff ff    	and    $0xfffff000,%ebp
          read_bytes = 0;
c002be14:	b9 00 00 00 00       	mov    $0x0,%ecx
c002be19:	e9 b8 fe ff ff       	jmp    c002bcd6 <start_process+0x236>
  ASSERT((read_bytes + zero_bytes) % PGSIZE == 0);
c002be1e:	83 ec 0c             	sub    $0xc,%esp
c002be21:	8d 83 c4 4c ff ff    	lea    -0xb33c(%ebx),%eax
c002be27:	50                   	push   %eax
c002be28:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002be2e:	50                   	push   %eax
c002be2f:	8d 83 20 28 ff ff    	lea    -0xd7e0(%ebx),%eax
c002be35:	50                   	push   %eax
c002be36:	68 fa 01 00 00       	push   $0x1fa
c002be3b:	8d 83 77 4c ff ff    	lea    -0xb389(%ebx),%eax
c002be41:	50                   	push   %eax
c002be42:	e8 4e da ff ff       	call   c0029895 <debug_panic>
c002be47:	8b 6c 24 18          	mov    0x18(%esp),%ebp
c002be4b:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
setup_stack(void **esp)
{
  uint8_t *kpage;
  bool success = false;
#ifdef VM
    kpage = frame_apply(PAL_USER | PAL_ZERO, ((uint8_t *) PHYS_BASE) - PGSIZE);
c002be4f:	83 ec 08             	sub    $0x8,%esp
c002be52:	68 00 f0 ff bf       	push   $0xbffff000
c002be57:	6a 06                	push   $0x6
c002be59:	e8 12 59 00 00       	call   c0031770 <frame_apply>
#else
  kpage = palloc_get_page(PAL_USER | PAL_ZERO);
#endif
  if (kpage != NULL)
c002be5e:	83 c4 10             	add    $0x10,%esp
c002be61:	85 c0                	test   %eax,%eax
c002be63:	0f 84 81 01 00 00    	je     c002bfea <start_process+0x54a>
   if memory allocation fails. */
static bool
install_page(void *upage, void *kpage, bool writable)
{
#ifdef VM
    return page_set_frame(upage, kpage, writable);
c002be69:	83 ec 04             	sub    $0x4,%esp
c002be6c:	6a 01                	push   $0x1
c002be6e:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002be72:	50                   	push   %eax
c002be73:	68 00 f0 ff bf       	push   $0xbffff000
c002be78:	e8 d2 62 00 00       	call   c003214f <page_set_frame>
    if (success)
c002be7d:	83 c4 10             	add    $0x10,%esp
c002be80:	84 c0                	test   %al,%al
c002be82:	0f 84 4e 01 00 00    	je     c002bfd6 <start_process+0x536>
      *esp = PHYS_BASE;
c002be88:	c7 84 24 18 01 00 00 	movl   $0xc0000000,0x118(%esp)
c002be8f:	00 00 00 c0 
        frame_reset(kpage);
c002be93:	83 ec 0c             	sub    $0xc,%esp
c002be96:	ff 74 24 10          	pushl  0x10(%esp)
c002be9a:	e8 05 55 00 00       	call   c00313a4 <frame_reset>
  *eip = (void (*)(void))ehdr.e_entry;
c002be9f:	8b 44 24 74          	mov    0x74(%esp),%eax
c002bea3:	89 84 24 1c 01 00 00 	mov    %eax,0x11c(%esp)
    t->exec_file = file;
c002beaa:	89 77 34             	mov    %esi,0x34(%edi)
    t->current_dir = get_file_dir(file);
c002bead:	89 34 24             	mov    %esi,(%esp)
c002beb0:	e8 fb 2d 00 00       	call   c002ecb0 <get_file_dir>
c002beb5:	89 87 b0 00 00 00    	mov    %eax,0xb0(%edi)
    file_deny_write(file);
c002bebb:	89 34 24             	mov    %esi,(%esp)
c002bebe:	e8 dc 2b 00 00       	call   c002ea9f <file_deny_write>
    char *esp = if_.esp;
c002bec3:	8b b4 24 28 01 00 00 	mov    0x128(%esp),%esi
    for (arg = text; arg != NULL; arg = strtok_r(NULL, " ", &save_ptr))
c002beca:	83 c4 10             	add    $0x10,%esp
c002becd:	85 ed                	test   %ebp,%ebp
c002becf:	74 4e                	je     c002bf1f <start_process+0x47f>
c002bed1:	89 ea                	mov    %ebp,%edx
c002bed3:	8b 2c 24             	mov    (%esp),%ebp
      int l = strlen(arg);
c002bed6:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002bedb:	89 d7                	mov    %edx,%edi
c002bedd:	b8 00 00 00 00       	mov    $0x0,%eax
c002bee2:	f2 ae                	repnz scas %es:(%edi),%al
c002bee4:	f7 d1                	not    %ecx
      esp -= l + 1;
c002bee6:	29 ce                	sub    %ecx,%esi
      strlcpy(esp, arg, l + 1);
c002bee8:	83 ec 04             	sub    $0x4,%esp
c002beeb:	51                   	push   %ecx
c002beec:	52                   	push   %edx
c002beed:	56                   	push   %esi
c002beee:	e8 f7 cf ff ff       	call   c0028eea <strlcpy>
      args[top] = esp, top++;
c002bef3:	89 74 ac 5c          	mov    %esi,0x5c(%esp,%ebp,4)
c002bef7:	83 c5 01             	add    $0x1,%ebp
    for (arg = text; arg != NULL; arg = strtok_r(NULL, " ", &save_ptr))
c002befa:	83 c4 0c             	add    $0xc,%esp
c002befd:	8d 84 24 d0 00 00 00 	lea    0xd0(%esp),%eax
c002bf04:	50                   	push   %eax
c002bf05:	8d 83 da 46 ff ff    	lea    -0xb926(%ebx),%eax
c002bf0b:	50                   	push   %eax
c002bf0c:	6a 00                	push   $0x0
c002bf0e:	e8 cd cd ff ff       	call   c0028ce0 <strtok_r>
c002bf13:	89 c2                	mov    %eax,%edx
c002bf15:	83 c4 10             	add    $0x10,%esp
c002bf18:	85 c0                	test   %eax,%eax
c002bf1a:	75 ba                	jne    c002bed6 <start_process+0x436>
c002bf1c:	89 2c 24             	mov    %ebp,(%esp)
    while (((char *)if_.esp - esp) % 4 != 0)
c002bf1f:	8b 84 24 18 01 00 00 	mov    0x118(%esp),%eax
c002bf26:	89 c2                	mov    %eax,%edx
c002bf28:	29 f2                	sub    %esi,%edx
c002bf2a:	f6 c2 03             	test   $0x3,%dl
c002bf2d:	74 14                	je     c002bf43 <start_process+0x4a3>
c002bf2f:	8d 56 ff             	lea    -0x1(%esi),%edx
c002bf32:	29 d0                	sub    %edx,%eax
      esp--;
c002bf34:	83 ee 01             	sub    $0x1,%esi
    while (((char *)if_.esp - esp) % 4 != 0)
c002bf37:	89 c2                	mov    %eax,%edx
c002bf39:	83 e2 03             	and    $0x3,%edx
c002bf3c:	83 c0 01             	add    $0x1,%eax
c002bf3f:	85 d2                	test   %edx,%edx
c002bf41:	75 f1                	jne    c002bf34 <start_process+0x494>
    esp -= 4;
c002bf43:	8d 56 fc             	lea    -0x4(%esi),%edx
    *((int *)esp) = 0; /* alignment */
c002bf46:	c7 46 fc 00 00 00 00 	movl   $0x0,-0x4(%esi)
    while (top > 0)
c002bf4d:	8b 04 24             	mov    (%esp),%eax
c002bf50:	85 c0                	test   %eax,%eax
c002bf52:	7e 16                	jle    c002bf6a <start_process+0x4ca>
c002bf54:	6b c8 fc             	imul   $0xfffffffc,%eax,%ecx
c002bf57:	01 ce                	add    %ecx,%esi
      --top, *((char **)esp) = args[top];
c002bf59:	83 e8 01             	sub    $0x1,%eax
c002bf5c:	8b 7c 84 4c          	mov    0x4c(%esp,%eax,4),%edi
c002bf60:	89 7c 86 fc          	mov    %edi,-0x4(%esi,%eax,4)
    while (top > 0)
c002bf64:	85 c0                	test   %eax,%eax
c002bf66:	75 f1                	jne    c002bf59 <start_process+0x4b9>
c002bf68:	01 ca                	add    %ecx,%edx
    *((char ***)esp) = argv;
c002bf6a:	89 52 fc             	mov    %edx,-0x4(%edx)
    *((int *)esp) = argc;
c002bf6d:	8b 04 24             	mov    (%esp),%eax
c002bf70:	89 42 f8             	mov    %eax,-0x8(%edx)
    *((int *)esp) = 0;
c002bf73:	c7 42 f4 00 00 00 00 	movl   $0x0,-0xc(%edx)
    esp -= 4;
c002bf7a:	83 ea 0c             	sub    $0xc,%edx
c002bf7d:	89 94 24 18 01 00 00 	mov    %edx,0x118(%esp)
  palloc_free_page(file_name);
c002bf84:	83 ec 0c             	sub    $0xc,%esp
c002bf87:	ff b4 24 4c 01 00 00 	pushl  0x14c(%esp)
c002bf8e:	e8 aa 80 ff ff       	call   c002403d <palloc_free_page>
  sema_up(thread_current()->message_to_grandpa->sema_started);
c002bf93:	e8 ad 50 ff ff       	call   c0021045 <thread_current>
c002bf98:	83 c4 04             	add    $0x4,%esp
c002bf9b:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
c002bfa1:	ff 70 14             	pushl  0x14(%eax)
c002bfa4:	e8 88 73 ff ff       	call   c0023331 <sema_up>
  asm volatile("movl %0, %%esp; jmp intr_exit"
c002bfa9:	8d 84 24 e0 00 00 00 	lea    0xe0(%esp),%eax
c002bfb0:	89 c4                	mov    %eax,%esp
c002bfb2:	e9 98 65 ff ff       	jmp    c002254f <intr_exit>
  NOT_REACHED();
c002bfb7:	8d 83 60 34 ff ff    	lea    -0xcba0(%ebx),%eax
c002bfbd:	50                   	push   %eax
c002bfbe:	8d 83 30 28 ff ff    	lea    -0xd7d0(%ebx),%eax
c002bfc4:	50                   	push   %eax
c002bfc5:	68 91 00 00 00       	push   $0x91
c002bfca:	8d 83 77 4c ff ff    	lea    -0xb389(%ebx),%eax
c002bfd0:	50                   	push   %eax
c002bfd1:	e8 bf d8 ff ff       	call   c0029895 <debug_panic>
    frame_free(kpage);
c002bfd6:	83 ec 0c             	sub    $0xc,%esp
c002bfd9:	ff 74 24 10          	pushl  0x10(%esp)
c002bfdd:	e8 34 59 00 00       	call   c0031916 <frame_free>
c002bfe2:	83 c4 10             	add    $0x10,%esp
c002bfe5:	e9 e1 fb ff ff       	jmp    c002bbcb <start_process+0x12b>
  palloc_free_page(file_name);
c002bfea:	83 ec 0c             	sub    $0xc,%esp
c002bfed:	ff b4 24 4c 01 00 00 	pushl  0x14c(%esp)
c002bff4:	e8 44 80 ff ff       	call   c002403d <palloc_free_page>
c002bff9:	83 c4 10             	add    $0x10,%esp
c002bffc:	e9 dc fb ff ff       	jmp    c002bbdd <start_process+0x13d>

c002c001 <process_get_mmap_handler>:
     address, then map our page there. */
  return (pagedir_get_page(t->pagedir, upage) == NULL && pagedir_set_page(t->pagedir, upage, kpage, writable));
#endif
}

struct mmap_handler* process_get_mmap_handler(mapid_t mapid) {
c002c001:	55                   	push   %ebp
c002c002:	57                   	push   %edi
c002c003:	56                   	push   %esi
c002c004:	53                   	push   %ebx
c002c005:	83 ec 0c             	sub    $0xc,%esp
c002c008:	e8 d9 64 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002c00d:	81 c3 2f 4c 01 00    	add    $0x14c2f,%ebx
c002c013:	8b 6c 24 20          	mov    0x20(%esp),%ebp
#ifdef VM
    struct list_elem* e;
    struct mmap_handler* mh;
    struct thread* curT = thread_current();
c002c017:	e8 29 50 ff ff       	call   c0021045 <thread_current>
    if (!list_empty(&curT->mmap_list)){
c002c01c:	8d b8 c0 00 00 00    	lea    0xc0(%eax),%edi
c002c022:	83 ec 0c             	sub    $0xc,%esp
c002c025:	57                   	push   %edi
c002c026:	e8 dc df ff ff       	call   c002a007 <list_empty>
c002c02b:	83 c4 10             	add    $0x10,%esp
c002c02e:	84 c0                	test   %al,%al
c002c030:	75 45                	jne    c002c077 <process_get_mmap_handler+0x76>
        for(e = list_begin(&curT->mmap_list); e != list_end(&curT->mmap_list); e = list_next(e)){
c002c032:	83 ec 0c             	sub    $0xc,%esp
c002c035:	57                   	push   %edi
c002c036:	e8 7f d9 ff ff       	call   c00299ba <list_begin>
c002c03b:	89 c6                	mov    %eax,%esi
c002c03d:	83 c4 10             	add    $0x10,%esp
c002c040:	83 ec 0c             	sub    $0xc,%esp
c002c043:	57                   	push   %edi
c002c044:	e8 13 da ff ff       	call   c0029a5c <list_end>
c002c049:	83 c4 10             	add    $0x10,%esp
c002c04c:	39 f0                	cmp    %esi,%eax
c002c04e:	74 1a                	je     c002c06a <process_get_mmap_handler+0x69>
            mh = list_entry(e, struct mmap_handler, elem);
            if (mh->mapid == mapid)
c002c050:	39 6e e8             	cmp    %ebp,-0x18(%esi)
c002c053:	74 10                	je     c002c065 <process_get_mmap_handler+0x64>
        for(e = list_begin(&curT->mmap_list); e != list_end(&curT->mmap_list); e = list_next(e)){
c002c055:	83 ec 0c             	sub    $0xc,%esp
c002c058:	56                   	push   %esi
c002c059:	e8 a1 d9 ff ff       	call   c00299ff <list_next>
c002c05e:	89 c6                	mov    %eax,%esi
c002c060:	83 c4 10             	add    $0x10,%esp
c002c063:	eb db                	jmp    c002c040 <process_get_mmap_handler+0x3f>
            mh = list_entry(e, struct mmap_handler, elem);
c002c065:	8d 46 e8             	lea    -0x18(%esi),%eax
c002c068:	eb 05                	jmp    c002c06f <process_get_mmap_handler+0x6e>
                return mh;
        }
    }
    return NULL;
c002c06a:	b8 00 00 00 00       	mov    $0x0,%eax
#endif
}
c002c06f:	83 c4 0c             	add    $0xc,%esp
c002c072:	5b                   	pop    %ebx
c002c073:	5e                   	pop    %esi
c002c074:	5f                   	pop    %edi
c002c075:	5d                   	pop    %ebp
c002c076:	c3                   	ret    
    return NULL;
c002c077:	b8 00 00 00 00       	mov    $0x0,%eax
c002c07c:	eb f1                	jmp    c002c06f <process_get_mmap_handler+0x6e>

c002c07e <process_delete_mmap_handler>:

bool process_delete_mmap_handler(struct mmap_handler *mh) {
c002c07e:	55                   	push   %ebp
c002c07f:	57                   	push   %edi
c002c080:	56                   	push   %esi
c002c081:	53                   	push   %ebx
c002c082:	83 ec 1c             	sub    $0x1c,%esp
c002c085:	e8 5c 64 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002c08a:	81 c3 b2 4b 01 00    	add    $0x14bb2,%ebx
#ifdef VM
    struct list_elem* e;
    struct mmap_handler* tmp;
    struct thread* curT = thread_current();
c002c090:	e8 b0 4f ff ff       	call   c0021045 <thread_current>
    if (!list_empty(&curT->mmap_list)) {
c002c095:	8d b8 c0 00 00 00    	lea    0xc0(%eax),%edi
c002c09b:	83 ec 0c             	sub    $0xc,%esp
c002c09e:	57                   	push   %edi
c002c09f:	e8 63 df ff ff       	call   c002a007 <list_empty>
c002c0a4:	88 44 24 1f          	mov    %al,0x1f(%esp)
c002c0a8:	83 c4 10             	add    $0x10,%esp
c002c0ab:	84 c0                	test   %al,%al
c002c0ad:	74 12                	je     c002c0c1 <process_delete_mmap_handler+0x43>
                free(mh);
                return true;
            }
        }
    }
    return false;
c002c0af:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
#endif
}
c002c0b4:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
c002c0b9:	83 c4 1c             	add    $0x1c,%esp
c002c0bc:	5b                   	pop    %ebx
c002c0bd:	5e                   	pop    %esi
c002c0be:	5f                   	pop    %edi
c002c0bf:	5d                   	pop    %ebp
c002c0c0:	c3                   	ret    
        for(e = list_begin(&curT->mmap_list); e != list_end(&curT->mmap_list); e = list_next(e)) {
c002c0c1:	83 ec 0c             	sub    $0xc,%esp
c002c0c4:	57                   	push   %edi
c002c0c5:	e8 f0 d8 ff ff       	call   c00299ba <list_begin>
c002c0ca:	89 c6                	mov    %eax,%esi
c002c0cc:	83 c4 10             	add    $0x10,%esp
c002c0cf:	83 ec 0c             	sub    $0xc,%esp
c002c0d2:	57                   	push   %edi
c002c0d3:	e8 84 d9 ff ff       	call   c0029a5c <list_end>
c002c0d8:	83 c4 10             	add    $0x10,%esp
c002c0db:	39 f0                	cmp    %esi,%eax
c002c0dd:	74 d5                	je     c002c0b4 <process_delete_mmap_handler+0x36>
            tmp = list_entry(e, struct mmap_handler, elem);
c002c0df:	8d 6e e8             	lea    -0x18(%esi),%ebp
            if (tmp == mh) {
c002c0e2:	3b 6c 24 30          	cmp    0x30(%esp),%ebp
c002c0e6:	74 10                	je     c002c0f8 <process_delete_mmap_handler+0x7a>
        for(e = list_begin(&curT->mmap_list); e != list_end(&curT->mmap_list); e = list_next(e)) {
c002c0e8:	83 ec 0c             	sub    $0xc,%esp
c002c0eb:	56                   	push   %esi
c002c0ec:	e8 0e d9 ff ff       	call   c00299ff <list_next>
c002c0f1:	89 c6                	mov    %eax,%esi
c002c0f3:	83 c4 10             	add    $0x10,%esp
c002c0f6:	eb d7                	jmp    c002c0cf <process_delete_mmap_handler+0x51>
                list_remove(e);
c002c0f8:	83 ec 0c             	sub    $0xc,%esp
c002c0fb:	56                   	push   %esi
c002c0fc:	e8 64 de ff ff       	call   c0029f65 <list_remove>
                syscall_file_close(mh->fd);
c002c101:	83 c4 04             	add    $0x4,%esp
c002c104:	ff 76 f0             	pushl  -0x10(%esi)
c002c107:	e8 c6 0c 00 00       	call   c002cdd2 <syscall_file_close>
                free(mh);
c002c10c:	89 2c 24             	mov    %ebp,(%esp)
c002c10f:	e8 86 83 ff ff       	call   c002449a <free>
                return true;
c002c114:	83 c4 10             	add    $0x10,%esp
c002c117:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
c002c11c:	eb 96                	jmp    c002c0b4 <process_delete_mmap_handler+0x36>

c002c11e <process_exit>:
{
c002c11e:	55                   	push   %ebp
c002c11f:	57                   	push   %edi
c002c120:	56                   	push   %esi
c002c121:	53                   	push   %ebx
c002c122:	83 ec 1c             	sub    $0x1c,%esp
c002c125:	e8 bc 63 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002c12a:	81 c3 12 4b 01 00    	add    $0x14b12,%ebx
  struct thread *cur = thread_current();
c002c130:	e8 10 4f ff ff       	call   c0021045 <thread_current>
c002c135:	89 c6                	mov    %eax,%esi
    struct list* mmap_list = &cur->mmap_list;
c002c137:	8d 80 c0 00 00 00    	lea    0xc0(%eax),%eax
c002c13d:	89 44 24 08          	mov    %eax,0x8(%esp)
    if (!list_empty(mmap_list)){
c002c141:	83 ec 0c             	sub    $0xc,%esp
c002c144:	50                   	push   %eax
c002c145:	e8 bd de ff ff       	call   c002a007 <list_empty>
c002c14a:	83 c4 10             	add    $0x10,%esp
c002c14d:	84 c0                	test   %al,%al
c002c14f:	74 17                	je     c002c168 <process_exit+0x4a>
  while (!list_empty(&cur->child_list))
c002c151:	8d 6e 70             	lea    0x70(%esi),%ebp
c002c154:	e9 9f 00 00 00       	jmp    c002c1f8 <process_exit+0xda>
            process_delete_mmap_handler(mh);
c002c159:	83 ec 0c             	sub    $0xc,%esp
c002c15c:	ff 74 24 18          	pushl  0x18(%esp)
c002c160:	e8 19 ff ff ff       	call   c002c07e <process_delete_mmap_handler>
c002c165:	83 c4 10             	add    $0x10,%esp
        while (!list_empty(mmap_list)){
c002c168:	83 ec 0c             	sub    $0xc,%esp
c002c16b:	ff 74 24 14          	pushl  0x14(%esp)
c002c16f:	e8 93 de ff ff       	call   c002a007 <list_empty>
c002c174:	83 c4 10             	add    $0x10,%esp
c002c177:	84 c0                	test   %al,%al
c002c179:	75 d6                	jne    c002c151 <process_exit+0x33>
            mh = list_entry(list_pop_front (mmap_list), struct mmap_handler, elem);
c002c17b:	83 ec 0c             	sub    $0xc,%esp
c002c17e:	ff 74 24 14          	pushl  0x14(%esp)
c002c182:	e8 f7 de ff ff       	call   c002a07e <list_pop_front>
c002c187:	89 c5                	mov    %eax,%ebp
c002c189:	8d 40 e8             	lea    -0x18(%eax),%eax
c002c18c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
            for (int i = 0; i < mh->num_page_with_segment; i++)
c002c190:	83 c4 10             	add    $0x10,%esp
c002c193:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002c197:	7e c0                	jle    c002c159 <process_exit+0x3b>
c002c199:	bf 00 00 00 00       	mov    $0x0,%edi
                page_unmap(cur->page_table, mh->va + i * PGSIZE);
c002c19e:	83 ec 08             	sub    $0x8,%esp
c002c1a1:	89 f8                	mov    %edi,%eax
c002c1a3:	c1 e0 0c             	shl    $0xc,%eax
c002c1a6:	03 45 ec             	add    -0x14(%ebp),%eax
c002c1a9:	50                   	push   %eax
c002c1aa:	ff b6 b8 00 00 00    	pushl  0xb8(%esi)
c002c1b0:	e8 2e 61 00 00       	call   c00322e3 <page_unmap>
            for (int i = 0; i < mh->num_page_with_segment; i++)
c002c1b5:	83 c7 01             	add    $0x1,%edi
c002c1b8:	83 c4 10             	add    $0x10,%esp
c002c1bb:	39 7d 0c             	cmp    %edi,0xc(%ebp)
c002c1be:	7f de                	jg     c002c19e <process_exit+0x80>
c002c1c0:	eb 97                	jmp    c002c159 <process_exit+0x3b>
    l = list_entry(list_pop_front(&cur->child_list), struct child_message, elem);
c002c1c2:	83 ec 0c             	sub    $0xc,%esp
c002c1c5:	55                   	push   %ebp
c002c1c6:	e8 b3 de ff ff       	call   c002a07e <list_pop_front>
c002c1cb:	89 c7                	mov    %eax,%edi
    list_remove(&l->allelem);
c002c1cd:	8d 40 e8             	lea    -0x18(%eax),%eax
c002c1d0:	89 44 24 18          	mov    %eax,0x18(%esp)
c002c1d4:	8d 47 08             	lea    0x8(%edi),%eax
c002c1d7:	89 04 24             	mov    %eax,(%esp)
c002c1da:	e8 86 dd ff ff       	call   c0029f65 <list_remove>
    l->tchild->grandpa_died = true;
c002c1df:	8b 47 e8             	mov    -0x18(%edi),%eax
c002c1e2:	c6 80 a8 00 00 00 01 	movb   $0x1,0xa8(%eax)
    palloc_free_page(l);
c002c1e9:	83 c4 04             	add    $0x4,%esp
c002c1ec:	ff 74 24 14          	pushl  0x14(%esp)
c002c1f0:	e8 48 7e ff ff       	call   c002403d <palloc_free_page>
c002c1f5:	83 c4 10             	add    $0x10,%esp
  while (!list_empty(&cur->child_list))
c002c1f8:	83 ec 0c             	sub    $0xc,%esp
c002c1fb:	55                   	push   %ebp
c002c1fc:	e8 06 de ff ff       	call   c002a007 <list_empty>
c002c201:	83 c4 10             	add    $0x10,%esp
c002c204:	84 c0                	test   %al,%al
c002c206:	74 ba                	je     c002c1c2 <process_exit+0xa4>
    page_free(cur->page_table);
c002c208:	83 ec 0c             	sub    $0xc,%esp
c002c20b:	ff b6 b8 00 00 00    	pushl  0xb8(%esi)
c002c211:	e8 44 5c 00 00       	call   c0031e5a <page_free>
  pd = cur->pagedir;
c002c216:	8b 7e 30             	mov    0x30(%esi),%edi
  if (pd != NULL)
c002c219:	83 c4 10             	add    $0x10,%esp
c002c21c:	85 ff                	test   %edi,%edi
c002c21e:	74 35                	je     c002c255 <process_exit+0x137>
    cur->pagedir = NULL;
c002c220:	c7 46 30 00 00 00 00 	movl   $0x0,0x30(%esi)
    pagedir_activate(NULL);
c002c227:	83 ec 0c             	sub    $0xc,%esp
c002c22a:	6a 00                	push   $0x0
c002c22c:	e8 3f 06 00 00       	call   c002c870 <pagedir_activate>
    pagedir_destroy(pd);
c002c231:	89 3c 24             	mov    %edi,(%esp)
c002c234:	e8 15 02 00 00       	call   c002c44e <pagedir_destroy>
    printf("%s: exit(%d)\n", cur->name, cur->return_value);
c002c239:	83 c4 0c             	add    $0xc,%esp
c002c23c:	ff b6 b4 00 00 00    	pushl  0xb4(%esi)
c002c242:	8d 46 08             	lea    0x8(%esi),%eax
c002c245:	50                   	push   %eax
c002c246:	8d 83 90 4c ff ff    	lea    -0xb370(%ebx),%eax
c002c24c:	50                   	push   %eax
c002c24d:	e8 ac b8 ff ff       	call   c0027afe <printf>
c002c252:	83 c4 10             	add    $0x10,%esp
  if (!cur->grandpa_died)
c002c255:	80 be a8 00 00 00 00 	cmpb   $0x0,0xa8(%esi)
c002c25c:	75 0a                	jne    c002c268 <process_exit+0x14a>
    cur->message_to_grandpa->terminated = true;
c002c25e:	8b 86 ac 00 00 00    	mov    0xac(%esi),%eax
c002c264:	c6 40 09 01          	movb   $0x1,0x9(%eax)
}
c002c268:	83 c4 1c             	add    $0x1c,%esp
c002c26b:	5b                   	pop    %ebx
c002c26c:	5e                   	pop    %esi
c002c26d:	5f                   	pop    %edi
c002c26e:	5d                   	pop    %ebp
c002c26f:	c3                   	ret    

c002c270 <lookup_page>:
   on CREATE.  If CREATE is true, then a new page table is
   created and a pointer into it is returned.  Otherwise, a null
   pointer is returned. */
static uint32_t *
lookup_page(uint32_t *pd, const void *vaddr, bool create)
{
c002c270:	57                   	push   %edi
c002c271:	56                   	push   %esi
c002c272:	53                   	push   %ebx
c002c273:	e8 6e 62 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002c278:	81 c3 c4 49 01 00    	add    $0x149c4,%ebx
  uint32_t *pt, *pde;

  ASSERT(pd != NULL);
c002c27e:	85 c0                	test   %eax,%eax
c002c280:	0f 84 88 00 00 00    	je     c002c30e <lookup_page+0x9e>
c002c286:	89 d6                	mov    %edx,%esi

  /* Shouldn't create new kernel virtual mappings. */
  ASSERT(!create || is_user_vaddr(vaddr));
c002c288:	80 f9 01             	cmp    $0x1,%cl
c002c28b:	75 0c                	jne    c002c299 <lookup_page+0x29>
c002c28d:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002c293:	0f 87 9b 00 00 00    	ja     c002c334 <lookup_page+0xc4>
  return (uintptr_t)va >> PDSHIFT;
c002c299:	89 f2                	mov    %esi,%edx
c002c29b:	c1 ea 16             	shr    $0x16,%edx

  /* Check for a page table for VADDR.
     If one is missing, create one if requested. */
  pde = pd + pd_no(vaddr);
c002c29e:	8d 3c 90             	lea    (%eax,%edx,4),%edi
  if (*pde == 0)
c002c2a1:	83 3f 00             	cmpl   $0x0,(%edi)
c002c2a4:	75 3a                	jne    c002c2e0 <lookup_page+0x70>
  {
    if (create)
c002c2a6:	84 c9                	test   %cl,%cl
c002c2a8:	0f 84 44 01 00 00    	je     c002c3f2 <lookup_page+0x182>
    {
      pt = palloc_get_page(PAL_ZERO);
c002c2ae:	83 ec 0c             	sub    $0xc,%esp
c002c2b1:	6a 02                	push   $0x2
c002c2b3:	e8 17 7c ff ff       	call   c0023ecf <palloc_get_page>
      if (pt == NULL)
c002c2b8:	83 c4 10             	add    $0x10,%esp
c002c2bb:	85 c0                	test   %eax,%eax
c002c2bd:	74 4b                	je     c002c30a <lookup_page+0x9a>
  ASSERT(pg_ofs(pt) == 0);
c002c2bf:	a9 ff 0f 00 00       	test   $0xfff,%eax
c002c2c4:	0f 85 90 00 00 00    	jne    c002c35a <lookup_page+0xea>
  ASSERT(is_kernel_vaddr(vaddr));
c002c2ca:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002c2cf:	0f 86 ab 00 00 00    	jbe    c002c380 <lookup_page+0x110>
  return (uintptr_t)vaddr - (uintptr_t)PHYS_BASE;
c002c2d5:	8d 80 00 00 00 40    	lea    0x40000000(%eax),%eax
  return vtop(pt) | PTE_U | PTE_P | PTE_W;
c002c2db:	83 c8 07             	or     $0x7,%eax
c002c2de:	89 07                	mov    %eax,(%edi)
    else
      return NULL;
  }

  /* Return the page table entry. */
  pt = pde_get_pt(*pde);
c002c2e0:	8b 07                	mov    (%edi),%eax
  ASSERT(pde & PTE_P);
c002c2e2:	a8 01                	test   $0x1,%al
c002c2e4:	0f 84 bc 00 00 00    	je     c002c3a6 <lookup_page+0x136>
  return ptov(pde & PTE_ADDR);
c002c2ea:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  ASSERT((void *)paddr < PHYS_BASE);
c002c2ef:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002c2f4:	0f 87 d2 00 00 00    	ja     c002c3cc <lookup_page+0x15c>
  return ((uintptr_t)va & PTMASK) >> PTSHIFT;
c002c2fa:	c1 ee 0a             	shr    $0xa,%esi
  return &pt[pt_no(vaddr)];
c002c2fd:	81 e6 fc 0f 00 00    	and    $0xffc,%esi
c002c303:	8d 84 30 00 00 00 c0 	lea    -0x40000000(%eax,%esi,1),%eax
}
c002c30a:	5b                   	pop    %ebx
c002c30b:	5e                   	pop    %esi
c002c30c:	5f                   	pop    %edi
c002c30d:	c3                   	ret    
  ASSERT(pd != NULL);
c002c30e:	83 ec 0c             	sub    $0xc,%esp
c002c311:	8d 83 ec 4c ff ff    	lea    -0xb314(%ebx),%eax
c002c317:	50                   	push   %eax
c002c318:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c31e:	50                   	push   %eax
c002c31f:	8d 83 74 28 ff ff    	lea    -0xd78c(%ebx),%eax
c002c325:	50                   	push   %eax
c002c326:	6a 3c                	push   $0x3c
c002c328:	8d 83 f7 4c ff ff    	lea    -0xb309(%ebx),%eax
c002c32e:	50                   	push   %eax
c002c32f:	e8 61 d5 ff ff       	call   c0029895 <debug_panic>
  ASSERT(!create || is_user_vaddr(vaddr));
c002c334:	83 ec 0c             	sub    $0xc,%esp
c002c337:	8d 83 94 4d ff ff    	lea    -0xb26c(%ebx),%eax
c002c33d:	50                   	push   %eax
c002c33e:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c344:	50                   	push   %eax
c002c345:	8d 83 74 28 ff ff    	lea    -0xd78c(%ebx),%eax
c002c34b:	50                   	push   %eax
c002c34c:	6a 3f                	push   $0x3f
c002c34e:	8d 83 f7 4c ff ff    	lea    -0xb309(%ebx),%eax
c002c354:	50                   	push   %eax
c002c355:	e8 3b d5 ff ff       	call   c0029895 <debug_panic>
  ASSERT(pg_ofs(pt) == 0);
c002c35a:	83 ec 0c             	sub    $0xc,%esp
c002c35d:	8d 83 ec 2c ff ff    	lea    -0xd314(%ebx),%eax
c002c363:	50                   	push   %eax
c002c364:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c36a:	50                   	push   %eax
c002c36b:	8d 83 68 28 ff ff    	lea    -0xd798(%ebx),%eax
c002c371:	50                   	push   %eax
c002c372:	6a 4b                	push   $0x4b
c002c374:	8d 83 13 2d ff ff    	lea    -0xd2ed(%ebx),%eax
c002c37a:	50                   	push   %eax
c002c37b:	e8 15 d5 ff ff       	call   c0029895 <debug_panic>
  ASSERT(is_kernel_vaddr(vaddr));
c002c380:	83 ec 0c             	sub    $0xc,%esp
c002c383:	8d 83 27 2d ff ff    	lea    -0xd2d9(%ebx),%eax
c002c389:	50                   	push   %eax
c002c38a:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c390:	50                   	push   %eax
c002c391:	8d 83 80 28 ff ff    	lea    -0xd780(%ebx),%eax
c002c397:	50                   	push   %eax
c002c398:	6a 58                	push   $0x58
c002c39a:	8d 83 3e 2d ff ff    	lea    -0xd2c2(%ebx),%eax
c002c3a0:	50                   	push   %eax
c002c3a1:	e8 ef d4 ff ff       	call   c0029895 <debug_panic>
  ASSERT(pde & PTE_P);
c002c3a6:	83 ec 0c             	sub    $0xc,%esp
c002c3a9:	8d 83 10 4d ff ff    	lea    -0xb2f0(%ebx),%eax
c002c3af:	50                   	push   %eax
c002c3b0:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c3b6:	50                   	push   %eax
c002c3b7:	8d 83 a4 28 ff ff    	lea    -0xd75c(%ebx),%eax
c002c3bd:	50                   	push   %eax
c002c3be:	6a 53                	push   $0x53
c002c3c0:	8d 83 13 2d ff ff    	lea    -0xd2ed(%ebx),%eax
c002c3c6:	50                   	push   %eax
c002c3c7:	e8 c9 d4 ff ff       	call   c0029895 <debug_panic>
  ASSERT((void *)paddr < PHYS_BASE);
c002c3cc:	83 ec 0c             	sub    $0xc,%esp
c002c3cf:	8d 83 4e 39 ff ff    	lea    -0xc6b2(%ebx),%eax
c002c3d5:	50                   	push   %eax
c002c3d6:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c3dc:	50                   	push   %eax
c002c3dd:	8d 83 9c 28 ff ff    	lea    -0xd764(%ebx),%eax
c002c3e3:	50                   	push   %eax
c002c3e4:	6a 4e                	push   $0x4e
c002c3e6:	8d 83 3e 2d ff ff    	lea    -0xd2c2(%ebx),%eax
c002c3ec:	50                   	push   %eax
c002c3ed:	e8 a3 d4 ff ff       	call   c0029895 <debug_panic>
      return NULL;
c002c3f2:	b8 00 00 00 00       	mov    $0x0,%eax
c002c3f7:	e9 0e ff ff ff       	jmp    c002c30a <lookup_page+0x9a>

c002c3fc <pagedir_create>:
{
c002c3fc:	57                   	push   %edi
c002c3fd:	56                   	push   %esi
c002c3fe:	53                   	push   %ebx
c002c3ff:	e8 e2 60 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002c404:	81 c3 38 48 01 00    	add    $0x14838,%ebx
  uint32_t *pd = palloc_get_page(0);
c002c40a:	83 ec 0c             	sub    $0xc,%esp
c002c40d:	6a 00                	push   $0x0
c002c40f:	e8 bb 7a ff ff       	call   c0023ecf <palloc_get_page>
  if (pd != NULL)
c002c414:	83 c4 10             	add    $0x10,%esp
c002c417:	85 c0                	test   %eax,%eax
c002c419:	74 2f                	je     c002c44a <pagedir_create+0x4e>
    memcpy(pd, init_page_dir, PGSIZE);
c002c41b:	c7 c2 b4 b2 04 c0    	mov    $0xc004b2b4,%edx
c002c421:	8b 32                	mov    (%edx),%esi
c002c423:	8b 16                	mov    (%esi),%edx
c002c425:	89 10                	mov    %edx,(%eax)
c002c427:	8b 96 fc 0f 00 00    	mov    0xffc(%esi),%edx
c002c42d:	89 90 fc 0f 00 00    	mov    %edx,0xffc(%eax)
c002c433:	8d 78 04             	lea    0x4(%eax),%edi
c002c436:	83 e7 fc             	and    $0xfffffffc,%edi
c002c439:	89 c1                	mov    %eax,%ecx
c002c43b:	29 f9                	sub    %edi,%ecx
c002c43d:	29 ce                	sub    %ecx,%esi
c002c43f:	81 c1 00 10 00 00    	add    $0x1000,%ecx
c002c445:	c1 e9 02             	shr    $0x2,%ecx
c002c448:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
c002c44a:	5b                   	pop    %ebx
c002c44b:	5e                   	pop    %esi
c002c44c:	5f                   	pop    %edi
c002c44d:	c3                   	ret    

c002c44e <pagedir_destroy>:
{
c002c44e:	55                   	push   %ebp
c002c44f:	57                   	push   %edi
c002c450:	56                   	push   %esi
c002c451:	53                   	push   %ebx
c002c452:	83 ec 1c             	sub    $0x1c,%esp
c002c455:	e8 8c 60 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002c45a:	81 c3 e2 47 01 00    	add    $0x147e2,%ebx
  if (pd == NULL)
c002c460:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c002c465:	0f 84 24 01 00 00    	je     c002c58f <pagedir_destroy+0x141>
  ASSERT(pd != init_page_dir);
c002c46b:	c7 c0 b4 b2 04 c0    	mov    $0xc004b2b4,%eax
c002c471:	8b 54 24 30          	mov    0x30(%esp),%edx
c002c475:	39 10                	cmp    %edx,(%eax)
c002c477:	74 1c                	je     c002c495 <pagedir_destroy+0x47>
  for (pde = pd; pde < pd + pd_no(PHYS_BASE); pde++)
c002c479:	89 d0                	mov    %edx,%eax
c002c47b:	05 00 0c 00 00       	add    $0xc00,%eax
c002c480:	89 44 24 08          	mov    %eax,0x8(%esp)
c002c484:	39 c2                	cmp    %eax,%edx
c002c486:	0f 83 f4 00 00 00    	jae    c002c580 <pagedir_destroy+0x132>
c002c48c:	8b 6c 24 30          	mov    0x30(%esp),%ebp
c002c490:	e9 b6 00 00 00       	jmp    c002c54b <pagedir_destroy+0xfd>
  ASSERT(pd != init_page_dir);
c002c495:	83 ec 0c             	sub    $0xc,%esp
c002c498:	8d 83 1c 4d ff ff    	lea    -0xb2e4(%ebx),%eax
c002c49e:	50                   	push   %eax
c002c49f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c4a5:	50                   	push   %eax
c002c4a6:	8d 83 b0 28 ff ff    	lea    -0xd750(%ebx),%eax
c002c4ac:	50                   	push   %eax
c002c4ad:	6a 22                	push   $0x22
c002c4af:	8d 83 f7 4c ff ff    	lea    -0xb309(%ebx),%eax
c002c4b5:	50                   	push   %eax
c002c4b6:	e8 da d3 ff ff       	call   c0029895 <debug_panic>
c002c4bb:	83 ec 0c             	sub    $0xc,%esp
c002c4be:	8d 83 4e 39 ff ff    	lea    -0xc6b2(%ebx),%eax
c002c4c4:	50                   	push   %eax
c002c4c5:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c4cb:	50                   	push   %eax
c002c4cc:	8d 83 9c 28 ff ff    	lea    -0xd764(%ebx),%eax
c002c4d2:	50                   	push   %eax
c002c4d3:	6a 4e                	push   $0x4e
c002c4d5:	8d 83 3e 2d ff ff    	lea    -0xd2c2(%ebx),%eax
c002c4db:	50                   	push   %eax
c002c4dc:	e8 b4 d3 ff ff       	call   c0029895 <debug_panic>
c002c4e1:	83 ec 0c             	sub    $0xc,%esp
c002c4e4:	8d 83 4e 39 ff ff    	lea    -0xc6b2(%ebx),%eax
c002c4ea:	50                   	push   %eax
c002c4eb:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c4f1:	50                   	push   %eax
c002c4f2:	8d 83 9c 28 ff ff    	lea    -0xd764(%ebx),%eax
c002c4f8:	50                   	push   %eax
c002c4f9:	6a 4e                	push   $0x4e
c002c4fb:	8d 83 3e 2d ff ff    	lea    -0xd2c2(%ebx),%eax
c002c501:	50                   	push   %eax
c002c502:	e8 8e d3 ff ff       	call   c0029895 <debug_panic>
      for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002c507:	83 c6 04             	add    $0x4,%esi
c002c50a:	39 fe                	cmp    %edi,%esi
c002c50c:	74 25                	je     c002c533 <pagedir_destroy+0xe5>
        if (*pte & PTE_P)
c002c50e:	8b 06                	mov    (%esi),%eax
c002c510:	a8 01                	test   $0x1,%al
c002c512:	74 f3                	je     c002c507 <pagedir_destroy+0xb9>

/* Returns a pointer to the page that page table entry PTE points
   to. */
static inline void *pte_get_page(uint32_t pte)
{
  return ptov(pte & PTE_ADDR);
c002c514:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c002c519:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002c51e:	77 c1                	ja     c002c4e1 <pagedir_destroy+0x93>
          palloc_free_page(pte_get_page(*pte));
c002c520:	83 ec 0c             	sub    $0xc,%esp
  return (void *)(paddr + PHYS_BASE);
c002c523:	2d 00 00 00 40       	sub    $0x40000000,%eax
c002c528:	50                   	push   %eax
c002c529:	e8 0f 7b ff ff       	call   c002403d <palloc_free_page>
c002c52e:	83 c4 10             	add    $0x10,%esp
c002c531:	eb d4                	jmp    c002c507 <pagedir_destroy+0xb9>
      palloc_free_page(pt);
c002c533:	83 ec 0c             	sub    $0xc,%esp
c002c536:	ff 74 24 18          	pushl  0x18(%esp)
c002c53a:	e8 fe 7a ff ff       	call   c002403d <palloc_free_page>
c002c53f:	83 c4 10             	add    $0x10,%esp
  for (pde = pd; pde < pd + pd_no(PHYS_BASE); pde++)
c002c542:	83 c5 04             	add    $0x4,%ebp
c002c545:	3b 6c 24 08          	cmp    0x8(%esp),%ebp
c002c549:	74 35                	je     c002c580 <pagedir_destroy+0x132>
    if (*pde & PTE_P)
c002c54b:	8b 7d 00             	mov    0x0(%ebp),%edi
c002c54e:	f7 c7 01 00 00 00    	test   $0x1,%edi
c002c554:	74 ec                	je     c002c542 <pagedir_destroy+0xf4>
  return ptov(pde & PTE_ADDR);
c002c556:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
  ASSERT((void *)paddr < PHYS_BASE);
c002c55c:	81 ff ff ff ff bf    	cmp    $0xbfffffff,%edi
c002c562:	0f 87 53 ff ff ff    	ja     c002c4bb <pagedir_destroy+0x6d>
  return (void *)(paddr + PHYS_BASE);
c002c568:	8d 87 00 00 00 c0    	lea    -0x40000000(%edi),%eax
c002c56e:	89 44 24 0c          	mov    %eax,0xc(%esp)
      for (pte = pt; pte < pt + PGSIZE / sizeof *pte; pte++)
c002c572:	81 ef 00 f0 ff 3f    	sub    $0x3ffff000,%edi
c002c578:	39 f8                	cmp    %edi,%eax
c002c57a:	73 b7                	jae    c002c533 <pagedir_destroy+0xe5>
c002c57c:	89 c6                	mov    %eax,%esi
c002c57e:	eb 8e                	jmp    c002c50e <pagedir_destroy+0xc0>
  palloc_free_page(pd);
c002c580:	83 ec 0c             	sub    $0xc,%esp
c002c583:	ff 74 24 3c          	pushl  0x3c(%esp)
c002c587:	e8 b1 7a ff ff       	call   c002403d <palloc_free_page>
c002c58c:	83 c4 10             	add    $0x10,%esp
}
c002c58f:	83 c4 1c             	add    $0x1c,%esp
c002c592:	5b                   	pop    %ebx
c002c593:	5e                   	pop    %esi
c002c594:	5f                   	pop    %edi
c002c595:	5d                   	pop    %ebp
c002c596:	c3                   	ret    

c002c597 <pagedir_set_page>:
   If WRITABLE is true, the new page is read/write;
   otherwise it is read-only.
   Returns true if successful, false if memory allocation
   failed. */
bool pagedir_set_page(uint32_t *pd, void *upage, void *kpage, bool writable)
{
c002c597:	55                   	push   %ebp
c002c598:	57                   	push   %edi
c002c599:	56                   	push   %esi
c002c59a:	53                   	push   %ebx
c002c59b:	83 ec 0c             	sub    $0xc,%esp
c002c59e:	e8 43 5f 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002c5a3:	81 c3 99 46 01 00    	add    $0x14699,%ebx
c002c5a9:	8b 44 24 20          	mov    0x20(%esp),%eax
c002c5ad:	8b 54 24 24          	mov    0x24(%esp),%edx
c002c5b1:	8b 74 24 28          	mov    0x28(%esp),%esi
c002c5b5:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  uint32_t *pte;

  ASSERT(pg_ofs(upage) == 0);
c002c5b9:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
c002c5bf:	0f 85 86 00 00 00    	jne    c002c64b <pagedir_set_page+0xb4>
  ASSERT(pg_ofs(kpage) == 0);
c002c5c5:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
c002c5cb:	0f 85 a0 00 00 00    	jne    c002c671 <pagedir_set_page+0xda>
  ASSERT(is_user_vaddr(upage));
c002c5d1:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002c5d7:	0f 87 ba 00 00 00    	ja     c002c697 <pagedir_set_page+0x100>
  ASSERT(is_kernel_vaddr(vaddr));
c002c5dd:	81 fe ff ff ff bf    	cmp    $0xbfffffff,%esi
c002c5e3:	0f 86 d4 00 00 00    	jbe    c002c6bd <pagedir_set_page+0x126>
  return (uintptr_t)vaddr - (uintptr_t)PHYS_BASE;
c002c5e9:	81 c6 00 00 00 40    	add    $0x40000000,%esi
  ASSERT(vtop(kpage) >> PTSHIFT < init_ram_pages);
c002c5ef:	89 f5                	mov    %esi,%ebp
c002c5f1:	c1 ed 0c             	shr    $0xc,%ebp
c002c5f4:	c7 c1 7e 01 02 c0    	mov    $0xc002017e,%ecx
c002c5fa:	3b 29                	cmp    (%ecx),%ebp
c002c5fc:	0f 83 e1 00 00 00    	jae    c002c6e3 <pagedir_set_page+0x14c>
  ASSERT(pd != init_page_dir);
c002c602:	c7 c1 b4 b2 04 c0    	mov    $0xc004b2b4,%ecx
c002c608:	39 01                	cmp    %eax,(%ecx)
c002c60a:	0f 84 f9 00 00 00    	je     c002c709 <pagedir_set_page+0x172>

  pte = lookup_page(pd, upage, true);
c002c610:	b9 01 00 00 00       	mov    $0x1,%ecx
c002c615:	e8 56 fc ff ff       	call   c002c270 <lookup_page>

  if (pte != NULL)
c002c61a:	85 c0                	test   %eax,%eax
c002c61c:	0f 84 33 01 00 00    	je     c002c755 <pagedir_set_page+0x1be>
  {
    ASSERT((*pte & PTE_P) == 0);
c002c622:	f6 00 01             	testb  $0x1,(%eax)
c002c625:	0f 85 04 01 00 00    	jne    c002c72f <pagedir_set_page+0x198>
  return vtop(page) | PTE_P | (writable ? PTE_W : 0);
c002c62b:	89 fb                	mov    %edi,%ebx
c002c62d:	84 db                	test   %bl,%bl
c002c62f:	0f 95 c2             	setne  %dl
c002c632:	0f b6 d2             	movzbl %dl,%edx
c002c635:	01 d2                	add    %edx,%edx
  return pte_create_kernel(page, writable) | PTE_U;
c002c637:	83 ce 05             	or     $0x5,%esi
c002c63a:	09 d6                	or     %edx,%esi
c002c63c:	89 30                	mov    %esi,(%eax)
    *pte = pte_create_user(kpage, writable);
    return true;
c002c63e:	b8 01 00 00 00       	mov    $0x1,%eax
  }
  else
    return false;
}
c002c643:	83 c4 0c             	add    $0xc,%esp
c002c646:	5b                   	pop    %ebx
c002c647:	5e                   	pop    %esi
c002c648:	5f                   	pop    %edi
c002c649:	5d                   	pop    %ebp
c002c64a:	c3                   	ret    
  ASSERT(pg_ofs(upage) == 0);
c002c64b:	83 ec 0c             	sub    $0xc,%esp
c002c64e:	8d 83 30 4d ff ff    	lea    -0xb2d0(%ebx),%eax
c002c654:	50                   	push   %eax
c002c655:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c65b:	50                   	push   %eax
c002c65c:	8d 83 88 28 ff ff    	lea    -0xd778(%ebx),%eax
c002c662:	50                   	push   %eax
c002c663:	6a 65                	push   $0x65
c002c665:	8d 83 f7 4c ff ff    	lea    -0xb309(%ebx),%eax
c002c66b:	50                   	push   %eax
c002c66c:	e8 24 d2 ff ff       	call   c0029895 <debug_panic>
  ASSERT(pg_ofs(kpage) == 0);
c002c671:	83 ec 0c             	sub    $0xc,%esp
c002c674:	8d 83 43 4d ff ff    	lea    -0xb2bd(%ebx),%eax
c002c67a:	50                   	push   %eax
c002c67b:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c681:	50                   	push   %eax
c002c682:	8d 83 88 28 ff ff    	lea    -0xd778(%ebx),%eax
c002c688:	50                   	push   %eax
c002c689:	6a 66                	push   $0x66
c002c68b:	8d 83 f7 4c ff ff    	lea    -0xb309(%ebx),%eax
c002c691:	50                   	push   %eax
c002c692:	e8 fe d1 ff ff       	call   c0029895 <debug_panic>
  ASSERT(is_user_vaddr(upage));
c002c697:	83 ec 0c             	sub    $0xc,%esp
c002c69a:	8d 83 56 4d ff ff    	lea    -0xb2aa(%ebx),%eax
c002c6a0:	50                   	push   %eax
c002c6a1:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c6a7:	50                   	push   %eax
c002c6a8:	8d 83 88 28 ff ff    	lea    -0xd778(%ebx),%eax
c002c6ae:	50                   	push   %eax
c002c6af:	6a 67                	push   $0x67
c002c6b1:	8d 83 f7 4c ff ff    	lea    -0xb309(%ebx),%eax
c002c6b7:	50                   	push   %eax
c002c6b8:	e8 d8 d1 ff ff       	call   c0029895 <debug_panic>
  ASSERT(is_kernel_vaddr(vaddr));
c002c6bd:	83 ec 0c             	sub    $0xc,%esp
c002c6c0:	8d 83 27 2d ff ff    	lea    -0xd2d9(%ebx),%eax
c002c6c6:	50                   	push   %eax
c002c6c7:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c6cd:	50                   	push   %eax
c002c6ce:	8d 83 80 28 ff ff    	lea    -0xd780(%ebx),%eax
c002c6d4:	50                   	push   %eax
c002c6d5:	6a 58                	push   $0x58
c002c6d7:	8d 83 3e 2d ff ff    	lea    -0xd2c2(%ebx),%eax
c002c6dd:	50                   	push   %eax
c002c6de:	e8 b2 d1 ff ff       	call   c0029895 <debug_panic>
  ASSERT(vtop(kpage) >> PTSHIFT < init_ram_pages);
c002c6e3:	83 ec 0c             	sub    $0xc,%esp
c002c6e6:	8d 83 b4 4d ff ff    	lea    -0xb24c(%ebx),%eax
c002c6ec:	50                   	push   %eax
c002c6ed:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c6f3:	50                   	push   %eax
c002c6f4:	8d 83 88 28 ff ff    	lea    -0xd778(%ebx),%eax
c002c6fa:	50                   	push   %eax
c002c6fb:	6a 68                	push   $0x68
c002c6fd:	8d 83 f7 4c ff ff    	lea    -0xb309(%ebx),%eax
c002c703:	50                   	push   %eax
c002c704:	e8 8c d1 ff ff       	call   c0029895 <debug_panic>
  ASSERT(pd != init_page_dir);
c002c709:	83 ec 0c             	sub    $0xc,%esp
c002c70c:	8d 83 1c 4d ff ff    	lea    -0xb2e4(%ebx),%eax
c002c712:	50                   	push   %eax
c002c713:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c719:	50                   	push   %eax
c002c71a:	8d 83 88 28 ff ff    	lea    -0xd778(%ebx),%eax
c002c720:	50                   	push   %eax
c002c721:	6a 69                	push   $0x69
c002c723:	8d 83 f7 4c ff ff    	lea    -0xb309(%ebx),%eax
c002c729:	50                   	push   %eax
c002c72a:	e8 66 d1 ff ff       	call   c0029895 <debug_panic>
    ASSERT((*pte & PTE_P) == 0);
c002c72f:	83 ec 0c             	sub    $0xc,%esp
c002c732:	8d 83 6b 4d ff ff    	lea    -0xb295(%ebx),%eax
c002c738:	50                   	push   %eax
c002c739:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c73f:	50                   	push   %eax
c002c740:	8d 83 88 28 ff ff    	lea    -0xd778(%ebx),%eax
c002c746:	50                   	push   %eax
c002c747:	6a 6f                	push   $0x6f
c002c749:	8d 83 f7 4c ff ff    	lea    -0xb309(%ebx),%eax
c002c74f:	50                   	push   %eax
c002c750:	e8 40 d1 ff ff       	call   c0029895 <debug_panic>
    return false;
c002c755:	b8 00 00 00 00       	mov    $0x0,%eax
c002c75a:	e9 e4 fe ff ff       	jmp    c002c643 <pagedir_set_page+0xac>

c002c75f <pagedir_get_page>:
   address UADDR in PD.  Returns the kernel virtual address
   corresponding to that physical address, or a null pointer if
   UADDR is unmapped. */
void *
pagedir_get_page(uint32_t *pd, const void *uaddr)
{
c002c75f:	56                   	push   %esi
c002c760:	53                   	push   %ebx
c002c761:	83 ec 04             	sub    $0x4,%esp
c002c764:	e8 7d 5d 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002c769:	81 c3 d3 44 01 00    	add    $0x144d3,%ebx
c002c76f:	8b 74 24 14          	mov    0x14(%esp),%esi
  uint32_t *pte;

  ASSERT(is_user_vaddr(uaddr));
c002c773:	81 fe ff ff ff bf    	cmp    $0xbfffffff,%esi
c002c779:	77 3a                	ja     c002c7b5 <pagedir_get_page+0x56>

  pte = lookup_page(pd, uaddr, false);
c002c77b:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c780:	89 f2                	mov    %esi,%edx
c002c782:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c786:	e8 e5 fa ff ff       	call   c002c270 <lookup_page>
  if (pte != NULL && (*pte & PTE_P) != 0)
c002c78b:	85 c0                	test   %eax,%eax
c002c78d:	74 75                	je     c002c804 <pagedir_get_page+0xa5>
c002c78f:	8b 00                	mov    (%eax),%eax
c002c791:	a8 01                	test   $0x1,%al
c002c793:	74 76                	je     c002c80b <pagedir_get_page+0xac>
  return ptov(pte & PTE_ADDR);
c002c795:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  ASSERT((void *)paddr < PHYS_BASE);
c002c79a:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002c79f:	77 3d                	ja     c002c7de <pagedir_get_page+0x7f>
  return (uintptr_t)va & PGMASK;
c002c7a1:	81 e6 ff 0f 00 00    	and    $0xfff,%esi
    return pte_get_page(*pte) + pg_ofs(uaddr);
c002c7a7:	09 c6                	or     %eax,%esi
c002c7a9:	8d 86 00 00 00 c0    	lea    -0x40000000(%esi),%eax
  else
    return NULL;
}
c002c7af:	83 c4 04             	add    $0x4,%esp
c002c7b2:	5b                   	pop    %ebx
c002c7b3:	5e                   	pop    %esi
c002c7b4:	c3                   	ret    
  ASSERT(is_user_vaddr(uaddr));
c002c7b5:	83 ec 0c             	sub    $0xc,%esp
c002c7b8:	8d 83 7f 4d ff ff    	lea    -0xb281(%ebx),%eax
c002c7be:	50                   	push   %eax
c002c7bf:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c7c5:	50                   	push   %eax
c002c7c6:	8d 83 54 28 ff ff    	lea    -0xd7ac(%ebx),%eax
c002c7cc:	50                   	push   %eax
c002c7cd:	68 80 00 00 00       	push   $0x80
c002c7d2:	8d 83 f7 4c ff ff    	lea    -0xb309(%ebx),%eax
c002c7d8:	50                   	push   %eax
c002c7d9:	e8 b7 d0 ff ff       	call   c0029895 <debug_panic>
  ASSERT((void *)paddr < PHYS_BASE);
c002c7de:	83 ec 0c             	sub    $0xc,%esp
c002c7e1:	8d 83 4e 39 ff ff    	lea    -0xc6b2(%ebx),%eax
c002c7e7:	50                   	push   %eax
c002c7e8:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c7ee:	50                   	push   %eax
c002c7ef:	8d 83 9c 28 ff ff    	lea    -0xd764(%ebx),%eax
c002c7f5:	50                   	push   %eax
c002c7f6:	6a 4e                	push   $0x4e
c002c7f8:	8d 83 3e 2d ff ff    	lea    -0xd2c2(%ebx),%eax
c002c7fe:	50                   	push   %eax
c002c7ff:	e8 91 d0 ff ff       	call   c0029895 <debug_panic>
    return NULL;
c002c804:	b8 00 00 00 00       	mov    $0x0,%eax
c002c809:	eb a4                	jmp    c002c7af <pagedir_get_page+0x50>
c002c80b:	b8 00 00 00 00       	mov    $0x0,%eax
c002c810:	eb 9d                	jmp    c002c7af <pagedir_get_page+0x50>

c002c812 <pagedir_is_dirty>:
/* Returns true if the PTE for virtual page VPAGE in PD is dirty,
   that is, if the page has been modified since the PTE was
   installed.
   Returns false if PD contains no PTE for VPAGE. */
bool pagedir_is_dirty(uint32_t *pd, const void *vpage)
{
c002c812:	83 ec 0c             	sub    $0xc,%esp
  uint32_t *pte = lookup_page(pd, vpage, false);
c002c815:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c81a:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c81e:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c822:	e8 49 fa ff ff       	call   c002c270 <lookup_page>
  return pte != NULL && (*pte & PTE_D) != 0;
c002c827:	ba 00 00 00 00       	mov    $0x0,%edx
c002c82c:	85 c0                	test   %eax,%eax
c002c82e:	74 08                	je     c002c838 <pagedir_is_dirty+0x26>
c002c830:	8b 10                	mov    (%eax),%edx
c002c832:	c1 ea 06             	shr    $0x6,%edx
c002c835:	83 e2 01             	and    $0x1,%edx
c002c838:	89 d0                	mov    %edx,%eax
c002c83a:	83 e0 01             	and    $0x1,%eax
}
c002c83d:	83 c4 0c             	add    $0xc,%esp
c002c840:	c3                   	ret    

c002c841 <pagedir_is_accessed>:
/* Returns true if the PTE for virtual page VPAGE in PD has been
   accessed recently, that is, between the time the PTE was
   installed and the last time it was cleared.  Returns false if
   PD contains no PTE for VPAGE. */
bool pagedir_is_accessed(uint32_t *pd, const void *vpage)
{
c002c841:	83 ec 0c             	sub    $0xc,%esp
  uint32_t *pte = lookup_page(pd, vpage, false);
c002c844:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c849:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c84d:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c851:	e8 1a fa ff ff       	call   c002c270 <lookup_page>
  return pte != NULL && (*pte & PTE_A) != 0;
c002c856:	ba 00 00 00 00       	mov    $0x0,%edx
c002c85b:	85 c0                	test   %eax,%eax
c002c85d:	74 08                	je     c002c867 <pagedir_is_accessed+0x26>
c002c85f:	8b 10                	mov    (%eax),%edx
c002c861:	c1 ea 05             	shr    $0x5,%edx
c002c864:	83 e2 01             	and    $0x1,%edx
c002c867:	89 d0                	mov    %edx,%eax
c002c869:	83 e0 01             	and    $0x1,%eax
}
c002c86c:	83 c4 0c             	add    $0xc,%esp
c002c86f:	c3                   	ret    

c002c870 <pagedir_activate>:
}

/* Loads page directory PD into the CPU's page directory base
   register. */
void pagedir_activate(uint32_t *pd)
{
c002c870:	53                   	push   %ebx
c002c871:	83 ec 08             	sub    $0x8,%esp
c002c874:	e8 6d 5c 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002c879:	81 c3 c3 43 01 00    	add    $0x143c3,%ebx
c002c87f:	8b 44 24 10          	mov    0x10(%esp),%eax
  if (pd == NULL)
c002c883:	85 c0                	test   %eax,%eax
c002c885:	74 14                	je     c002c89b <pagedir_activate+0x2b>
  ASSERT(is_kernel_vaddr(vaddr));
c002c887:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002c88c:	76 17                	jbe    c002c8a5 <pagedir_activate+0x35>
  return (uintptr_t)vaddr - (uintptr_t)PHYS_BASE;
c002c88e:	05 00 00 00 40       	add    $0x40000000,%eax
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base
     Address of the Page Directory". */
  asm volatile("movl %0, %%cr3"
c002c893:	0f 22 d8             	mov    %eax,%cr3
               :
               : "r"(vtop(pd))
               : "memory");
}
c002c896:	83 c4 08             	add    $0x8,%esp
c002c899:	5b                   	pop    %ebx
c002c89a:	c3                   	ret    
    pd = init_page_dir;
c002c89b:	c7 c0 b4 b2 04 c0    	mov    $0xc004b2b4,%eax
c002c8a1:	8b 00                	mov    (%eax),%eax
c002c8a3:	eb e2                	jmp    c002c887 <pagedir_activate+0x17>
  ASSERT(is_kernel_vaddr(vaddr));
c002c8a5:	83 ec 0c             	sub    $0xc,%esp
c002c8a8:	8d 83 27 2d ff ff    	lea    -0xd2d9(%ebx),%eax
c002c8ae:	50                   	push   %eax
c002c8af:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c8b5:	50                   	push   %eax
c002c8b6:	8d 83 80 28 ff ff    	lea    -0xd780(%ebx),%eax
c002c8bc:	50                   	push   %eax
c002c8bd:	6a 58                	push   $0x58
c002c8bf:	8d 83 3e 2d ff ff    	lea    -0xd2c2(%ebx),%eax
c002c8c5:	50                   	push   %eax
c002c8c6:	e8 ca cf ff ff       	call   c0029895 <debug_panic>

c002c8cb <invalidate_pagedir>:
   This function invalidates the TLB if PD is the active page
   directory.  (If PD is not active then its entries are not in
   the TLB, so there is no need to invalidate anything.) */
static void
invalidate_pagedir(uint32_t *pd)
{
c002c8cb:	53                   	push   %ebx
c002c8cc:	83 ec 08             	sub    $0x8,%esp
c002c8cf:	e8 12 5c 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002c8d4:	81 c3 68 43 01 00    	add    $0x14368,%ebx
  asm volatile("movl %%cr3, %0"
c002c8da:	0f 20 da             	mov    %cr3,%edx
  ASSERT((void *)paddr < PHYS_BASE);
c002c8dd:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002c8e3:	77 0f                	ja     c002c8f4 <invalidate_pagedir+0x29>
  return (void *)(paddr + PHYS_BASE);
c002c8e5:	81 ea 00 00 00 40    	sub    $0x40000000,%edx
  if (active_pd() == pd)
c002c8eb:	39 d0                	cmp    %edx,%eax
c002c8ed:	74 2b                	je     c002c91a <invalidate_pagedir+0x4f>
  {
    /* Re-activating PD clears the TLB.  See [IA32-v3a] 3.12
         "Translation Lookaside Buffers (TLBs)". */
    pagedir_activate(pd);
  }
}
c002c8ef:	83 c4 08             	add    $0x8,%esp
c002c8f2:	5b                   	pop    %ebx
c002c8f3:	c3                   	ret    
  ASSERT((void *)paddr < PHYS_BASE);
c002c8f4:	83 ec 0c             	sub    $0xc,%esp
c002c8f7:	8d 83 4e 39 ff ff    	lea    -0xc6b2(%ebx),%eax
c002c8fd:	50                   	push   %eax
c002c8fe:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002c904:	50                   	push   %eax
c002c905:	8d 83 9c 28 ff ff    	lea    -0xd764(%ebx),%eax
c002c90b:	50                   	push   %eax
c002c90c:	6a 4e                	push   $0x4e
c002c90e:	8d 83 3e 2d ff ff    	lea    -0xd2c2(%ebx),%eax
c002c914:	50                   	push   %eax
c002c915:	e8 7b cf ff ff       	call   c0029895 <debug_panic>
    pagedir_activate(pd);
c002c91a:	83 ec 0c             	sub    $0xc,%esp
c002c91d:	50                   	push   %eax
c002c91e:	e8 4d ff ff ff       	call   c002c870 <pagedir_activate>
c002c923:	83 c4 10             	add    $0x10,%esp
}
c002c926:	eb c7                	jmp    c002c8ef <invalidate_pagedir+0x24>

c002c928 <pagedir_clear_page>:
{
c002c928:	53                   	push   %ebx
c002c929:	83 ec 08             	sub    $0x8,%esp
c002c92c:	e8 b5 5b 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002c931:	81 c3 0b 43 01 00    	add    $0x1430b,%ebx
c002c937:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT(pg_ofs(upage) == 0);
c002c93b:	f7 c2 ff 0f 00 00    	test   $0xfff,%edx
c002c941:	75 26                	jne    c002c969 <pagedir_clear_page+0x41>
  ASSERT(is_user_vaddr(upage));
c002c943:	81 fa ff ff ff bf    	cmp    $0xbfffffff,%edx
c002c949:	77 47                	ja     c002c992 <pagedir_clear_page+0x6a>
  pte = lookup_page(pd, upage, false);
c002c94b:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c950:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c954:	e8 17 f9 ff ff       	call   c002c270 <lookup_page>
  if (pte != NULL && (*pte & PTE_P) != 0)
c002c959:	85 c0                	test   %eax,%eax
c002c95b:	74 07                	je     c002c964 <pagedir_clear_page+0x3c>
c002c95d:	8b 10                	mov    (%eax),%edx
c002c95f:	f6 c2 01             	test   $0x1,%dl
c002c962:	75 57                	jne    c002c9bb <pagedir_clear_page+0x93>
}
c002c964:	83 c4 08             	add    $0x8,%esp
c002c967:	5b                   	pop    %ebx
c002c968:	c3                   	ret    
  ASSERT(pg_ofs(upage) == 0);
c002c969:	83 ec 0c             	sub    $0xc,%esp
c002c96c:	8d 93 30 4d ff ff    	lea    -0xb2d0(%ebx),%edx
c002c972:	52                   	push   %edx
c002c973:	8d 93 fc 2c ff ff    	lea    -0xd304(%ebx),%edx
c002c979:	52                   	push   %edx
c002c97a:	8d 93 40 28 ff ff    	lea    -0xd7c0(%ebx),%edx
c002c980:	52                   	push   %edx
c002c981:	68 91 00 00 00       	push   $0x91
c002c986:	8d 93 f7 4c ff ff    	lea    -0xb309(%ebx),%edx
c002c98c:	52                   	push   %edx
c002c98d:	e8 03 cf ff ff       	call   c0029895 <debug_panic>
  ASSERT(is_user_vaddr(upage));
c002c992:	83 ec 0c             	sub    $0xc,%esp
c002c995:	8d 93 56 4d ff ff    	lea    -0xb2aa(%ebx),%edx
c002c99b:	52                   	push   %edx
c002c99c:	8d 93 fc 2c ff ff    	lea    -0xd304(%ebx),%edx
c002c9a2:	52                   	push   %edx
c002c9a3:	8d 93 40 28 ff ff    	lea    -0xd7c0(%ebx),%edx
c002c9a9:	52                   	push   %edx
c002c9aa:	68 92 00 00 00       	push   $0x92
c002c9af:	8d 93 f7 4c ff ff    	lea    -0xb309(%ebx),%edx
c002c9b5:	52                   	push   %edx
c002c9b6:	e8 da ce ff ff       	call   c0029895 <debug_panic>
    *pte &= ~PTE_P;
c002c9bb:	83 e2 fe             	and    $0xfffffffe,%edx
c002c9be:	89 10                	mov    %edx,(%eax)
    invalidate_pagedir(pd);
c002c9c0:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c9c4:	e8 02 ff ff ff       	call   c002c8cb <invalidate_pagedir>
}
c002c9c9:	eb 99                	jmp    c002c964 <pagedir_clear_page+0x3c>

c002c9cb <pagedir_set_dirty>:
{
c002c9cb:	53                   	push   %ebx
c002c9cc:	83 ec 08             	sub    $0x8,%esp
c002c9cf:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  uint32_t *pte = lookup_page(pd, vpage, false);
c002c9d3:	b9 00 00 00 00       	mov    $0x0,%ecx
c002c9d8:	8b 54 24 14          	mov    0x14(%esp),%edx
c002c9dc:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c9e0:	e8 8b f8 ff ff       	call   c002c270 <lookup_page>
  if (pte != NULL)
c002c9e5:	85 c0                	test   %eax,%eax
c002c9e7:	74 07                	je     c002c9f0 <pagedir_set_dirty+0x25>
    if (dirty)
c002c9e9:	84 db                	test   %bl,%bl
c002c9eb:	74 08                	je     c002c9f5 <pagedir_set_dirty+0x2a>
      *pte |= PTE_D;
c002c9ed:	83 08 40             	orl    $0x40,(%eax)
}
c002c9f0:	83 c4 08             	add    $0x8,%esp
c002c9f3:	5b                   	pop    %ebx
c002c9f4:	c3                   	ret    
      *pte &= ~(uint32_t)PTE_D;
c002c9f5:	83 20 bf             	andl   $0xffffffbf,(%eax)
      invalidate_pagedir(pd);
c002c9f8:	8b 44 24 10          	mov    0x10(%esp),%eax
c002c9fc:	e8 ca fe ff ff       	call   c002c8cb <invalidate_pagedir>
}
c002ca01:	eb ed                	jmp    c002c9f0 <pagedir_set_dirty+0x25>

c002ca03 <pagedir_set_accessed>:
{
c002ca03:	53                   	push   %ebx
c002ca04:	83 ec 08             	sub    $0x8,%esp
c002ca07:	8b 5c 24 18          	mov    0x18(%esp),%ebx
  uint32_t *pte = lookup_page(pd, vpage, false);
c002ca0b:	b9 00 00 00 00       	mov    $0x0,%ecx
c002ca10:	8b 54 24 14          	mov    0x14(%esp),%edx
c002ca14:	8b 44 24 10          	mov    0x10(%esp),%eax
c002ca18:	e8 53 f8 ff ff       	call   c002c270 <lookup_page>
  if (pte != NULL)
c002ca1d:	85 c0                	test   %eax,%eax
c002ca1f:	74 07                	je     c002ca28 <pagedir_set_accessed+0x25>
    if (accessed)
c002ca21:	84 db                	test   %bl,%bl
c002ca23:	74 08                	je     c002ca2d <pagedir_set_accessed+0x2a>
      *pte |= PTE_A;
c002ca25:	83 08 20             	orl    $0x20,(%eax)
}
c002ca28:	83 c4 08             	add    $0x8,%esp
c002ca2b:	5b                   	pop    %ebx
c002ca2c:	c3                   	ret    
      *pte &= ~(uint32_t)PTE_A;
c002ca2d:	83 20 df             	andl   $0xffffffdf,(%eax)
      invalidate_pagedir(pd);
c002ca30:	8b 44 24 10          	mov    0x10(%esp),%eax
c002ca34:	e8 92 fe ff ff       	call   c002c8cb <invalidate_pagedir>
}
c002ca39:	eb ed                	jmp    c002ca28 <pagedir_set_accessed+0x25>

c002ca3b <kill>:
}

/* Handler for an exception (probably) caused by a user process. */
static void
kill(struct intr_frame *f)
{
c002ca3b:	55                   	push   %ebp
c002ca3c:	57                   	push   %edi
c002ca3d:	56                   	push   %esi
c002ca3e:	53                   	push   %ebx
c002ca3f:	83 ec 0c             	sub    $0xc,%esp
c002ca42:	e8 9f 5a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ca47:	81 c3 f5 41 01 00    	add    $0x141f5,%ebx
c002ca4d:	8b 74 24 20          	mov    0x20(%esp),%esi
     exceptions back to the process via signals, but we don't
     implement them. */

  /* The interrupt frame's code segment value tells us where the
     exception originated. */
  switch (f->cs)
c002ca51:	0f b7 7e 40          	movzwl 0x40(%esi),%edi
c002ca55:	66 83 ff 08          	cmp    $0x8,%di
c002ca59:	74 3a                	je     c002ca95 <kill+0x5a>
c002ca5b:	66 83 ff 1b          	cmp    $0x1b,%di
c002ca5f:	75 59                	jne    c002caba <kill+0x7f>
  {
  case SEL_UCSEG:
    /* User's code segment, so it's a user exception, as we
         expected.  Kill the user process.  */
    printf("%s: dying due to interrupt %#04x (%s).\n",
c002ca61:	83 ec 0c             	sub    $0xc,%esp
c002ca64:	0f b6 46 30          	movzbl 0x30(%esi),%eax
c002ca68:	50                   	push   %eax
c002ca69:	e8 ac 5a ff ff       	call   c002251a <intr_name>
c002ca6e:	89 c5                	mov    %eax,%ebp
c002ca70:	8b 7e 30             	mov    0x30(%esi),%edi
c002ca73:	e8 bb 46 ff ff       	call   c0021133 <thread_name>
c002ca78:	55                   	push   %ebp
c002ca79:	57                   	push   %edi
c002ca7a:	50                   	push   %eax
c002ca7b:	8d 83 dc 4d ff ff    	lea    -0xb224(%ebx),%eax
c002ca81:	50                   	push   %eax
c002ca82:	e8 77 b0 ff ff       	call   c0027afe <printf>
           thread_name(), f->vec_no, intr_name(f->vec_no));
    intr_dump_frame(f);
c002ca87:	83 c4 14             	add    $0x14,%esp
c002ca8a:	56                   	push   %esi
c002ca8b:	e8 e9 59 ff ff       	call   c0022479 <intr_dump_frame>
    thread_exit();
c002ca90:	e8 e5 4b ff ff       	call   c002167a <thread_exit>
  case SEL_KCSEG:
    /* Kernel's code segment, which indicates a kernel bug.
         Kernel code shouldn't throw exceptions.  (Page faults
         may cause kernel exceptions--but they shouldn't arrive
         here.)  Panic the kernel to make the point.  */
    intr_dump_frame(f);
c002ca95:	83 ec 0c             	sub    $0xc,%esp
c002ca98:	56                   	push   %esi
c002ca99:	e8 db 59 ff ff       	call   c0022479 <intr_dump_frame>
    PANIC("Kernel bug - unexpected interrupt in kernel");
c002ca9e:	8d 83 04 4e ff ff    	lea    -0xb1fc(%ebx),%eax
c002caa4:	50                   	push   %eax
c002caa5:	8d 83 c0 28 ff ff    	lea    -0xd740(%ebx),%eax
c002caab:	50                   	push   %eax
c002caac:	6a 67                	push   $0x67
c002caae:	8d 83 93 4e ff ff    	lea    -0xb16d(%ebx),%eax
c002cab4:	50                   	push   %eax
c002cab5:	e8 db cd ff ff       	call   c0029895 <debug_panic>

  default:
    /* Some other code segment?  Shouldn't happen.  Panic the
         kernel. */
    printf("Interrupt %#04x (%s) in unknown segment %04x\n",
c002caba:	83 ec 0c             	sub    $0xc,%esp
c002cabd:	0f b6 46 30          	movzbl 0x30(%esi),%eax
c002cac1:	50                   	push   %eax
c002cac2:	e8 53 5a ff ff       	call   c002251a <intr_name>
  switch (f->cs)
c002cac7:	0f b7 ff             	movzwl %di,%edi
    printf("Interrupt %#04x (%s) in unknown segment %04x\n",
c002caca:	57                   	push   %edi
c002cacb:	50                   	push   %eax
c002cacc:	ff 76 30             	pushl  0x30(%esi)
c002cacf:	8d 83 30 4e ff ff    	lea    -0xb1d0(%ebx),%eax
c002cad5:	50                   	push   %eax
c002cad6:	e8 23 b0 ff ff       	call   c0027afe <printf>
           f->vec_no, intr_name(f->vec_no), f->cs);
    thread_exit();
c002cadb:	83 c4 20             	add    $0x20,%esp
c002cade:	e8 97 4b ff ff       	call   c002167a <thread_exit>

c002cae3 <page_fault>:
   can find more information about both of these in the
   description of "Interrupt 14--Page Fault Exception (#PF)" in
   [IA32-v3a] section 5.15 "Exception and Interrupt Reference". */
static void
page_fault(struct intr_frame *f)
{
c002cae3:	55                   	push   %ebp
c002cae4:	57                   	push   %edi
c002cae5:	56                   	push   %esi
c002cae6:	53                   	push   %ebx
c002cae7:	83 ec 1c             	sub    $0x1c,%esp
c002caea:	e8 f7 59 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002caef:	81 c3 4d 41 01 00    	add    $0x1414d,%ebx
c002caf5:	8b 74 24 30          	mov    0x30(%esp),%esi
     data.  It is not necessarily the address of the instruction
     that caused the fault (that's f->eip).
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.15 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm("movl %%cr2, %0"
c002caf9:	0f 20 d5             	mov    %cr2,%ebp
  if (!syscall_translate_vaddr(fault_addr, false))
    thread_exit_with_return_value(f, -1);
#endif
  /* Turn interrupts back on (they were only off so that we could
     be assured of reading CR2 before it changed). */
  intr_enable();
c002cafc:	e8 61 54 ff ff       	call   c0021f62 <intr_enable>

  /* Count page faults. */
  page_fault_cnt++;
c002cb01:	83 83 bc 1d 00 00 01 	addl   $0x1,0x1dbc(%ebx)
c002cb08:	83 93 c0 1d 00 00 00 	adcl   $0x0,0x1dc0(%ebx)

  /* Determine cause. */
  not_present = (f->error_code & PF_P) == 0;
c002cb0f:	8b 46 34             	mov    0x34(%esi),%eax
  write = (f->error_code & PF_W) != 0;
c002cb12:	89 c1                	mov    %eax,%ecx
c002cb14:	83 e1 02             	and    $0x2,%ecx
c002cb17:	89 4c 24 08          	mov    %ecx,0x8(%esp)
c002cb1b:	0f 95 44 24 07       	setne  0x7(%esp)
c002cb20:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
  user = (f->error_code & PF_U) != 0;
c002cb25:	89 c7                	mov    %eax,%edi
c002cb27:	83 e7 04             	and    $0x4,%edi

#ifdef VM
    if(not_present && page_fault_handler(fault_addr, write, user ? f->esp : thread_current()->esp)) {
c002cb2a:	83 e0 01             	and    $0x1,%eax
c002cb2d:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002cb31:	75 5e                	jne    c002cb91 <page_fault+0xae>
c002cb33:	85 ff                	test   %edi,%edi
c002cb35:	74 23                	je     c002cb5a <page_fault+0x77>
c002cb37:	83 ec 04             	sub    $0x4,%esp
c002cb3a:	ff 76 48             	pushl  0x48(%esi)
c002cb3d:	0f b6 c2             	movzbl %dl,%eax
c002cb40:	50                   	push   %eax
c002cb41:	55                   	push   %ebp
c002cb42:	e8 50 53 00 00       	call   c0031e97 <page_fault_handler>
c002cb47:	83 c4 10             	add    $0x10,%esp
c002cb4a:	84 c0                	test   %al,%al
c002cb4c:	0f 84 a7 00 00 00    	je     c002cbf9 <page_fault+0x116>
         fault_addr,
         not_present ? "not present" : "rights violation",
         write ? "writing" : "reading",
         user ? "user" : "kernel");
  kill(f);
}
c002cb52:	83 c4 1c             	add    $0x1c,%esp
c002cb55:	5b                   	pop    %ebx
c002cb56:	5e                   	pop    %esi
c002cb57:	5f                   	pop    %edi
c002cb58:	5d                   	pop    %ebp
c002cb59:	c3                   	ret    
    if(not_present && page_fault_handler(fault_addr, write, user ? f->esp : thread_current()->esp)) {
c002cb5a:	e8 e6 44 ff ff       	call   c0021045 <thread_current>
c002cb5f:	83 ec 04             	sub    $0x4,%esp
c002cb62:	ff b0 bc 00 00 00    	pushl  0xbc(%eax)
c002cb68:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
c002cb6d:	50                   	push   %eax
c002cb6e:	55                   	push   %ebp
c002cb6f:	e8 23 53 00 00       	call   c0031e97 <page_fault_handler>
c002cb74:	83 c4 10             	add    $0x10,%esp
c002cb77:	84 c0                	test   %al,%al
c002cb79:	75 d7                	jne    c002cb52 <page_fault+0x6f>
        thread_exit_with_return_value(f, -1);
c002cb7b:	83 ec 08             	sub    $0x8,%esp
c002cb7e:	6a ff                	push   $0xffffffff
c002cb80:	56                   	push   %esi
c002cb81:	e8 7f 51 ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002cb86:	83 c4 10             	add    $0x10,%esp
  printf("Page fault at %p: %s error %s page in %s context.\n",
c002cb89:	8d 93 ac 3e ff ff    	lea    -0xc154(%ebx),%edx
c002cb8f:	eb 7c                	jmp    c002cc0d <page_fault+0x12a>
        thread_exit_with_return_value(f, -1);
c002cb91:	83 ec 08             	sub    $0x8,%esp
c002cb94:	6a ff                	push   $0xffffffff
c002cb96:	56                   	push   %esi
c002cb97:	e8 69 51 ff ff       	call   c0021d05 <thread_exit_with_return_value>
  printf("Page fault at %p: %s error %s page in %s context.\n",
c002cb9c:	83 c4 10             	add    $0x10,%esp
c002cb9f:	8d 93 ac 3e ff ff    	lea    -0xc154(%ebx),%edx
c002cba5:	85 ff                	test   %edi,%edi
c002cba7:	75 79                	jne    c002cc22 <page_fault+0x13f>
c002cba9:	8d 83 b6 4e ff ff    	lea    -0xb14a(%ebx),%eax
c002cbaf:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c002cbb4:	74 14                	je     c002cbca <page_fault+0xe7>
c002cbb6:	8d 83 ae 4e ff ff    	lea    -0xb152(%ebx),%eax
c002cbbc:	8d 8b ca 4e ff ff    	lea    -0xb136(%ebx),%ecx
c002cbc2:	eb 19                	jmp    c002cbdd <page_fault+0xfa>
c002cbc4:	8d 83 ae 4e ff ff    	lea    -0xb152(%ebx),%eax
c002cbca:	8d 8b be 4e ff ff    	lea    -0xb142(%ebx),%ecx
c002cbd0:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c002cbd5:	74 06                	je     c002cbdd <page_fault+0xfa>
c002cbd7:	8d 8b ca 4e ff ff    	lea    -0xb136(%ebx),%ecx
c002cbdd:	83 ec 0c             	sub    $0xc,%esp
c002cbe0:	52                   	push   %edx
c002cbe1:	50                   	push   %eax
c002cbe2:	51                   	push   %ecx
c002cbe3:	55                   	push   %ebp
c002cbe4:	8d 83 60 4e ff ff    	lea    -0xb1a0(%ebx),%eax
c002cbea:	50                   	push   %eax
c002cbeb:	e8 0e af ff ff       	call   c0027afe <printf>
  kill(f);
c002cbf0:	83 c4 14             	add    $0x14,%esp
c002cbf3:	56                   	push   %esi
c002cbf4:	e8 42 fe ff ff       	call   c002ca3b <kill>
        thread_exit_with_return_value(f, -1);
c002cbf9:	83 ec 08             	sub    $0x8,%esp
c002cbfc:	6a ff                	push   $0xffffffff
c002cbfe:	56                   	push   %esi
c002cbff:	e8 01 51 ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002cc04:	83 c4 10             	add    $0x10,%esp
  printf("Page fault at %p: %s error %s page in %s context.\n",
c002cc07:	8d 93 db 4e ff ff    	lea    -0xb125(%ebx),%edx
c002cc0d:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c002cc12:	75 b0                	jne    c002cbc4 <page_fault+0xe1>
c002cc14:	8d 83 b6 4e ff ff    	lea    -0xb14a(%ebx),%eax
c002cc1a:	8d 8b be 4e ff ff    	lea    -0xb142(%ebx),%ecx
c002cc20:	eb bb                	jmp    c002cbdd <page_fault+0xfa>
c002cc22:	8d 93 db 4e ff ff    	lea    -0xb125(%ebx),%edx
c002cc28:	e9 7c ff ff ff       	jmp    c002cba9 <page_fault+0xc6>

c002cc2d <exception_init>:
{
c002cc2d:	56                   	push   %esi
c002cc2e:	53                   	push   %ebx
c002cc2f:	83 ec 10             	sub    $0x10,%esp
c002cc32:	e8 af 58 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002cc37:	81 c3 05 40 01 00    	add    $0x14005,%ebx
  intr_register_int(3, 3, INTR_ON, kill, "#BP Breakpoint Exception");
c002cc3d:	8d 83 22 35 ff ff    	lea    -0xcade(%ebx),%eax
c002cc43:	50                   	push   %eax
c002cc44:	8d b3 ff bd fe ff    	lea    -0x14201(%ebx),%esi
c002cc4a:	56                   	push   %esi
c002cc4b:	6a 01                	push   $0x1
c002cc4d:	6a 03                	push   $0x3
c002cc4f:	6a 03                	push   $0x3
c002cc51:	e8 95 55 ff ff       	call   c00221eb <intr_register_int>
  intr_register_int(4, 3, INTR_ON, kill, "#OF Overflow Exception");
c002cc56:	83 c4 14             	add    $0x14,%esp
c002cc59:	8d 83 3b 35 ff ff    	lea    -0xcac5(%ebx),%eax
c002cc5f:	50                   	push   %eax
c002cc60:	56                   	push   %esi
c002cc61:	6a 01                	push   $0x1
c002cc63:	6a 03                	push   $0x3
c002cc65:	6a 04                	push   $0x4
c002cc67:	e8 7f 55 ff ff       	call   c00221eb <intr_register_int>
  intr_register_int(5, 3, INTR_ON, kill,
c002cc6c:	83 c4 14             	add    $0x14,%esp
c002cc6f:	8d 83 78 36 ff ff    	lea    -0xc988(%ebx),%eax
c002cc75:	50                   	push   %eax
c002cc76:	56                   	push   %esi
c002cc77:	6a 01                	push   $0x1
c002cc79:	6a 03                	push   $0x3
c002cc7b:	6a 05                	push   $0x5
c002cc7d:	e8 69 55 ff ff       	call   c00221eb <intr_register_int>
  intr_register_int(0, 0, INTR_ON, kill, "#DE Divide Error");
c002cc82:	83 c4 14             	add    $0x14,%esp
c002cc85:	8d 83 ef 34 ff ff    	lea    -0xcb11(%ebx),%eax
c002cc8b:	50                   	push   %eax
c002cc8c:	56                   	push   %esi
c002cc8d:	6a 01                	push   $0x1
c002cc8f:	6a 00                	push   $0x0
c002cc91:	6a 00                	push   $0x0
c002cc93:	e8 53 55 ff ff       	call   c00221eb <intr_register_int>
  intr_register_int(1, 0, INTR_ON, kill, "#DB Debug Exception");
c002cc98:	83 c4 14             	add    $0x14,%esp
c002cc9b:	8d 83 00 35 ff ff    	lea    -0xcb00(%ebx),%eax
c002cca1:	50                   	push   %eax
c002cca2:	56                   	push   %esi
c002cca3:	6a 01                	push   $0x1
c002cca5:	6a 00                	push   $0x0
c002cca7:	6a 01                	push   $0x1
c002cca9:	e8 3d 55 ff ff       	call   c00221eb <intr_register_int>
  intr_register_int(6, 0, INTR_ON, kill, "#UD Invalid Opcode Exception");
c002ccae:	83 c4 14             	add    $0x14,%esp
c002ccb1:	8d 83 52 35 ff ff    	lea    -0xcaae(%ebx),%eax
c002ccb7:	50                   	push   %eax
c002ccb8:	56                   	push   %esi
c002ccb9:	6a 01                	push   $0x1
c002ccbb:	6a 00                	push   $0x0
c002ccbd:	6a 06                	push   $0x6
c002ccbf:	e8 27 55 ff ff       	call   c00221eb <intr_register_int>
  intr_register_int(7, 0, INTR_ON, kill,
c002ccc4:	83 c4 14             	add    $0x14,%esp
c002ccc7:	8d 83 9c 36 ff ff    	lea    -0xc964(%ebx),%eax
c002cccd:	50                   	push   %eax
c002ccce:	56                   	push   %esi
c002cccf:	6a 01                	push   $0x1
c002ccd1:	6a 00                	push   $0x0
c002ccd3:	6a 07                	push   $0x7
c002ccd5:	e8 11 55 ff ff       	call   c00221eb <intr_register_int>
  intr_register_int(11, 0, INTR_ON, kill, "#NP Segment Not Present");
c002ccda:	83 c4 14             	add    $0x14,%esp
c002ccdd:	8d 83 c0 35 ff ff    	lea    -0xca40(%ebx),%eax
c002cce3:	50                   	push   %eax
c002cce4:	56                   	push   %esi
c002cce5:	6a 01                	push   $0x1
c002cce7:	6a 00                	push   $0x0
c002cce9:	6a 0b                	push   $0xb
c002cceb:	e8 fb 54 ff ff       	call   c00221eb <intr_register_int>
  intr_register_int(12, 0, INTR_ON, kill, "#SS Stack Fault Exception");
c002ccf0:	83 c4 14             	add    $0x14,%esp
c002ccf3:	8d 83 d8 35 ff ff    	lea    -0xca28(%ebx),%eax
c002ccf9:	50                   	push   %eax
c002ccfa:	56                   	push   %esi
c002ccfb:	6a 01                	push   $0x1
c002ccfd:	6a 00                	push   $0x0
c002ccff:	6a 0c                	push   $0xc
c002cd01:	e8 e5 54 ff ff       	call   c00221eb <intr_register_int>
  intr_register_int(13, 0, INTR_ON, kill, "#GP General Protection Exception");
c002cd06:	83 c4 14             	add    $0x14,%esp
c002cd09:	8d 83 c0 36 ff ff    	lea    -0xc940(%ebx),%eax
c002cd0f:	50                   	push   %eax
c002cd10:	56                   	push   %esi
c002cd11:	6a 01                	push   $0x1
c002cd13:	6a 00                	push   $0x0
c002cd15:	6a 0d                	push   $0xd
c002cd17:	e8 cf 54 ff ff       	call   c00221eb <intr_register_int>
  intr_register_int(16, 0, INTR_ON, kill, "#MF x87 FPU Floating-Point Error");
c002cd1c:	83 c4 14             	add    $0x14,%esp
c002cd1f:	8d 83 e4 36 ff ff    	lea    -0xc91c(%ebx),%eax
c002cd25:	50                   	push   %eax
c002cd26:	56                   	push   %esi
c002cd27:	6a 01                	push   $0x1
c002cd29:	6a 00                	push   $0x0
c002cd2b:	6a 10                	push   $0x10
c002cd2d:	e8 b9 54 ff ff       	call   c00221eb <intr_register_int>
  intr_register_int(19, 0, INTR_ON, kill,
c002cd32:	83 c4 14             	add    $0x14,%esp
c002cd35:	8d 83 08 37 ff ff    	lea    -0xc8f8(%ebx),%eax
c002cd3b:	50                   	push   %eax
c002cd3c:	56                   	push   %esi
c002cd3d:	6a 01                	push   $0x1
c002cd3f:	6a 00                	push   $0x0
c002cd41:	6a 13                	push   $0x13
c002cd43:	e8 a3 54 ff ff       	call   c00221eb <intr_register_int>
  intr_register_int(14, 0, INTR_OFF, page_fault, "#PF Page-Fault Exception");
c002cd48:	83 c4 14             	add    $0x14,%esp
c002cd4b:	8d 83 f2 35 ff ff    	lea    -0xca0e(%ebx),%eax
c002cd51:	50                   	push   %eax
c002cd52:	8d 83 a7 be fe ff    	lea    -0x14159(%ebx),%eax
c002cd58:	50                   	push   %eax
c002cd59:	6a 00                	push   $0x0
c002cd5b:	6a 00                	push   $0x0
c002cd5d:	6a 0e                	push   $0xe
c002cd5f:	e8 87 54 ff ff       	call   c00221eb <intr_register_int>
}
c002cd64:	83 c4 24             	add    $0x24,%esp
c002cd67:	5b                   	pop    %ebx
c002cd68:	5e                   	pop    %esi
c002cd69:	c3                   	ret    

c002cd6a <exception_print_stats>:
{
c002cd6a:	53                   	push   %ebx
c002cd6b:	83 ec 0c             	sub    $0xc,%esp
c002cd6e:	e8 73 57 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002cd73:	81 c3 c9 3e 01 00    	add    $0x13ec9,%ebx
  printf("Exception: %lld page faults\n", page_fault_cnt);
c002cd79:	ff b3 c0 1d 00 00    	pushl  0x1dc0(%ebx)
c002cd7f:	ff b3 bc 1d 00 00    	pushl  0x1dbc(%ebx)
c002cd85:	8d 83 e0 4e ff ff    	lea    -0xb120(%ebx),%eax
c002cd8b:	50                   	push   %eax
c002cd8c:	e8 6d ad ff ff       	call   c0027afe <printf>
}
c002cd91:	83 c4 18             	add    $0x18,%esp
c002cd94:	5b                   	pop    %ebx
c002cd95:	c3                   	ret    

c002cd96 <syscall_init>:
static void syscall_isdir(struct intr_frame *f, int fd);
static void syscall_inumber(struct intr_frame *f, int fd);
#endif

void syscall_init(void)
{
c002cd96:	53                   	push   %ebx
c002cd97:	83 ec 14             	sub    $0x14,%esp
c002cd9a:	e8 47 57 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002cd9f:	81 c3 9d 3e 01 00    	add    $0x13e9d,%ebx
  intr_register_int(0x30, 3, INTR_ON, syscall_handler, "syscall");
c002cda5:	8d 83 fd 4e ff ff    	lea    -0xb103(%ebx),%eax
c002cdab:	50                   	push   %eax
c002cdac:	8d 83 87 c6 fe ff    	lea    -0x13979(%ebx),%eax
c002cdb2:	50                   	push   %eax
c002cdb3:	6a 01                	push   $0x1
c002cdb5:	6a 03                	push   $0x3
c002cdb7:	6a 30                	push   $0x30
c002cdb9:	e8 2d 54 ff ff       	call   c00221eb <intr_register_int>
  lock_init(&filesys_lock);
c002cdbe:	83 c4 14             	add    $0x14,%esp
c002cdc1:	8d 83 c4 1d 00 00    	lea    0x1dc4(%ebx),%eax
c002cdc7:	50                   	push   %eax
c002cdc8:	e8 35 67 ff ff       	call   c0023502 <lock_init>
}
c002cdcd:	83 c4 18             	add    $0x18,%esp
c002cdd0:	5b                   	pop    %ebx
c002cdd1:	c3                   	ret    

c002cdd2 <syscall_file_close>:

void syscall_file_close(struct file *file)
{
c002cdd2:	56                   	push   %esi
c002cdd3:	53                   	push   %ebx
c002cdd4:	83 ec 10             	sub    $0x10,%esp
c002cdd7:	e8 0a 57 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002cddc:	81 c3 60 3e 01 00    	add    $0x13e60,%ebx
  lock_acquire(&filesys_lock);
c002cde2:	8d b3 c4 1d 00 00    	lea    0x1dc4(%ebx),%esi
c002cde8:	56                   	push   %esi
c002cde9:	e8 d4 67 ff ff       	call   c00235c2 <lock_acquire>
  file_close(file);
c002cdee:	83 c4 04             	add    $0x4,%esp
c002cdf1:	ff 74 24 1c          	pushl  0x1c(%esp)
c002cdf5:	e8 5e 1d 00 00       	call   c002eb58 <file_close>
  lock_release(&filesys_lock);
c002cdfa:	89 34 24             	mov    %esi,(%esp)
c002cdfd:	e8 94 69 ff ff       	call   c0023796 <lock_release>
}
c002ce02:	83 c4 14             	add    $0x14,%esp
c002ce05:	5b                   	pop    %ebx
c002ce06:	5e                   	pop    %esi
c002ce07:	c3                   	ret    

c002ce08 <syscall_file_open>:

struct file *syscall_file_open(const char *name)
{
c002ce08:	57                   	push   %edi
c002ce09:	56                   	push   %esi
c002ce0a:	53                   	push   %ebx
c002ce0b:	e8 d6 56 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ce10:	81 c3 2c 3e 01 00    	add    $0x13e2c,%ebx
  lock_acquire(&filesys_lock);
c002ce16:	83 ec 0c             	sub    $0xc,%esp
c002ce19:	8d b3 c4 1d 00 00    	lea    0x1dc4(%ebx),%esi
c002ce1f:	56                   	push   %esi
c002ce20:	e8 9d 67 ff ff       	call   c00235c2 <lock_acquire>
  struct file *tmp = filesys_open(name);
c002ce25:	83 c4 04             	add    $0x4,%esp
c002ce28:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ce2c:	e8 e4 17 00 00       	call   c002e615 <filesys_open>
c002ce31:	89 c7                	mov    %eax,%edi
  lock_release(&filesys_lock);
c002ce33:	89 34 24             	mov    %esi,(%esp)
c002ce36:	e8 5b 69 ff ff       	call   c0023796 <lock_release>
  return tmp;
c002ce3b:	83 c4 10             	add    $0x10,%esp
}
c002ce3e:	89 f8                	mov    %edi,%eax
c002ce40:	5b                   	pop    %ebx
c002ce41:	5e                   	pop    %esi
c002ce42:	5f                   	pop    %edi
c002ce43:	c3                   	ret    

c002ce44 <syscall_translate_vaddr>:

/* Transfer user Vaddr to kernel vaddr
 * Return NULL if user Vaddr is invalid
 * */
bool syscall_translate_vaddr(const void *vaddr, bool write)
{
c002ce44:	57                   	push   %edi
c002ce45:	56                   	push   %esi
c002ce46:	53                   	push   %ebx
c002ce47:	e8 9a 56 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ce4c:	81 c3 f0 3d 01 00    	add    $0x13df0,%ebx
c002ce52:	8b 7c 24 10          	mov    0x10(%esp),%edi
c002ce56:	8b 74 24 14          	mov    0x14(%esp),%esi
  if (vaddr == NULL || !is_user_vaddr(vaddr))
c002ce5a:	8d 57 ff             	lea    -0x1(%edi),%edx
    return false;
c002ce5d:	b8 00 00 00 00       	mov    $0x0,%eax
  if (vaddr == NULL || !is_user_vaddr(vaddr))
c002ce62:	81 fa fe ff ff bf    	cmp    $0xbffffffe,%edx
c002ce68:	76 04                	jbe    c002ce6e <syscall_translate_vaddr+0x2a>
        return !(write && !(pte->dirty));
#else
  ASSERT(vaddr != NULL);
  return pagedir_get_page(thread_current()->pagedir, vaddr) != NULL;
#endif
}
c002ce6a:	5b                   	pop    %ebx
c002ce6b:	5e                   	pop    %esi
c002ce6c:	5f                   	pop    %edi
c002ce6d:	c3                   	ret    
    struct page_table_entry* pte = page_find_entry_with_lock(thread_current()->page_table, pg_round_down(vaddr));
c002ce6e:	e8 d2 41 ff ff       	call   c0021045 <thread_current>
c002ce73:	83 ec 08             	sub    $0x8,%esp
  return (void *)((uintptr_t)va & ~PGMASK);
c002ce76:	89 fa                	mov    %edi,%edx
c002ce78:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c002ce7e:	52                   	push   %edx
c002ce7f:	ff b0 b8 00 00 00    	pushl  0xb8(%eax)
c002ce85:	e8 38 4f 00 00       	call   c0031dc2 <page_find_entry_with_lock>
    if (pte == NULL) {
c002ce8a:	83 c4 10             	add    $0x10,%esp
c002ce8d:	85 c0                	test   %eax,%eax
c002ce8f:	74 16                	je     c002cea7 <syscall_translate_vaddr+0x63>
        return !(write && !(pte->dirty));
c002ce91:	ba 01 00 00 00       	mov    $0x1,%edx
c002ce96:	89 f1                	mov    %esi,%ecx
c002ce98:	84 c9                	test   %cl,%cl
c002ce9a:	74 04                	je     c002cea0 <syscall_translate_vaddr+0x5c>
c002ce9c:	0f b6 50 10          	movzbl 0x10(%eax),%edx
c002cea0:	89 d0                	mov    %edx,%eax
c002cea2:	83 e0 01             	and    $0x1,%eax
c002cea5:	eb c3                	jmp    c002ce6a <syscall_translate_vaddr+0x26>
        return page_fault_handler(vaddr, write, thread_current()->esp);
c002cea7:	e8 99 41 ff ff       	call   c0021045 <thread_current>
c002ceac:	83 ec 04             	sub    $0x4,%esp
c002ceaf:	ff b0 bc 00 00 00    	pushl  0xbc(%eax)
c002ceb5:	89 f0                	mov    %esi,%eax
c002ceb7:	0f b6 f0             	movzbl %al,%esi
c002ceba:	56                   	push   %esi
c002cebb:	57                   	push   %edi
c002cebc:	e8 d6 4f 00 00       	call   c0031e97 <page_fault_handler>
c002cec1:	83 c4 10             	add    $0x10,%esp
c002cec4:	eb a4                	jmp    c002ce6a <syscall_translate_vaddr+0x26>

c002cec6 <syscall_check_user_string>:
{
c002cec6:	55                   	push   %ebp
c002cec7:	57                   	push   %edi
c002cec8:	56                   	push   %esi
c002cec9:	53                   	push   %ebx
c002ceca:	83 ec 14             	sub    $0x14,%esp
c002cecd:	e8 2c 56 00 00       	call   c00324fe <__x86.get_pc_thunk.bp>
c002ced2:	81 c5 6a 3d 01 00    	add    $0x13d6a,%ebp
c002ced8:	8b 74 24 28          	mov    0x28(%esp),%esi
  if (!syscall_translate_vaddr(ustr, false))
c002cedc:	6a 00                	push   $0x0
c002cede:	56                   	push   %esi
c002cedf:	e8 60 ff ff ff       	call   c002ce44 <syscall_translate_vaddr>
c002cee4:	89 c3                	mov    %eax,%ebx
c002cee6:	83 c4 10             	add    $0x10,%esp
c002cee9:	8d be ff 0f 00 00    	lea    0xfff(%esi),%edi
c002ceef:	84 c0                	test   %al,%al
c002cef1:	74 28                	je     c002cf1b <syscall_check_user_string+0x55>
  while (*ustr != '\0')
c002cef3:	80 3e 00             	cmpb   $0x0,(%esi)
c002cef6:	74 23                	je     c002cf1b <syscall_check_user_string+0x55>
    if (cnt == 4095)
c002cef8:	39 fe                	cmp    %edi,%esi
c002cefa:	74 29                	je     c002cf25 <syscall_check_user_string+0x5f>
    ustr++;
c002cefc:	83 c6 01             	add    $0x1,%esi
    if (((int)ustr & PGMASK) == 0)
c002ceff:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
c002cf05:	75 ec                	jne    c002cef3 <syscall_check_user_string+0x2d>
      if (!syscall_translate_vaddr(ustr, false))
c002cf07:	83 ec 08             	sub    $0x8,%esp
c002cf0a:	6a 00                	push   $0x0
c002cf0c:	56                   	push   %esi
c002cf0d:	e8 32 ff ff ff       	call   c002ce44 <syscall_translate_vaddr>
c002cf12:	83 c4 10             	add    $0x10,%esp
c002cf15:	84 c0                	test   %al,%al
c002cf17:	75 da                	jne    c002cef3 <syscall_check_user_string+0x2d>
        return false;
c002cf19:	89 c3                	mov    %eax,%ebx
}
c002cf1b:	89 d8                	mov    %ebx,%eax
c002cf1d:	83 c4 0c             	add    $0xc,%esp
c002cf20:	5b                   	pop    %ebx
c002cf21:	5e                   	pop    %esi
c002cf22:	5f                   	pop    %edi
c002cf23:	5d                   	pop    %ebp
c002cf24:	c3                   	ret    
      puts("String to long, please make sure it is no longer than 4096 Bytes!\n");
c002cf25:	83 ec 0c             	sub    $0xc,%esp
c002cf28:	8d 85 44 4f ff ff    	lea    -0xb0bc(%ebp),%eax
c002cf2e:	50                   	push   %eax
c002cf2f:	89 eb                	mov    %ebp,%ebx
c002cf31:	e8 38 e9 ff ff       	call   c002b86e <puts>
      return false;
c002cf36:	83 c4 10             	add    $0x10,%esp
c002cf39:	bb 00 00 00 00       	mov    $0x0,%ebx
c002cf3e:	eb db                	jmp    c002cf1b <syscall_check_user_string+0x55>

c002cf40 <syscall_check_user_buffer>:
{
c002cf40:	57                   	push   %edi
c002cf41:	56                   	push   %esi
c002cf42:	53                   	push   %ebx
c002cf43:	8b 74 24 10          	mov    0x10(%esp),%esi
c002cf47:	8b 5c 24 14          	mov    0x14(%esp),%ebx
  if (!syscall_translate_vaddr(ustr + size - 1, write))
c002cf4b:	0f b6 7c 24 18       	movzbl 0x18(%esp),%edi
c002cf50:	83 ec 08             	sub    $0x8,%esp
c002cf53:	57                   	push   %edi
c002cf54:	8d 44 1e ff          	lea    -0x1(%esi,%ebx,1),%eax
c002cf58:	50                   	push   %eax
c002cf59:	e8 e6 fe ff ff       	call   c002ce44 <syscall_translate_vaddr>
c002cf5e:	83 c4 10             	add    $0x10,%esp
c002cf61:	84 c0                	test   %al,%al
c002cf63:	74 22                	je     c002cf87 <syscall_check_user_buffer+0x47>
  size >>= 12;
c002cf65:	c1 fb 0c             	sar    $0xc,%ebx
    if (!syscall_translate_vaddr(ustr, write))
c002cf68:	83 ec 08             	sub    $0x8,%esp
c002cf6b:	57                   	push   %edi
c002cf6c:	56                   	push   %esi
c002cf6d:	e8 d2 fe ff ff       	call   c002ce44 <syscall_translate_vaddr>
c002cf72:	83 c4 10             	add    $0x10,%esp
c002cf75:	84 c0                	test   %al,%al
c002cf77:	74 0e                	je     c002cf87 <syscall_check_user_buffer+0x47>
    ustr += 1 << 12;
c002cf79:	81 c6 00 10 00 00    	add    $0x1000,%esi
  } while (size--);
c002cf7f:	83 eb 01             	sub    $0x1,%ebx
c002cf82:	83 fb ff             	cmp    $0xffffffff,%ebx
c002cf85:	75 e1                	jne    c002cf68 <syscall_check_user_buffer+0x28>
}
c002cf87:	5b                   	pop    %ebx
c002cf88:	5e                   	pop    %esi
c002cf89:	5f                   	pop    %edi
c002cf8a:	c3                   	ret    

c002cf8b <mmap_read>:
    f->eax = -1;
}

#endif

void mmap_read(struct mmap_handler* mh, void* va, void* pa){
c002cf8b:	55                   	push   %ebp
c002cf8c:	57                   	push   %edi
c002cf8d:	56                   	push   %esi
c002cf8e:	53                   	push   %ebx
c002cf8f:	83 ec 0c             	sub    $0xc,%esp
c002cf92:	e8 4f 55 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002cf97:	81 c3 a5 3c 01 00    	add    $0x13ca5,%ebx
c002cf9d:	8b 74 24 20          	mov    0x20(%esp),%esi
c002cfa1:	8b 6c 24 28          	mov    0x28(%esp),%ebp
#ifdef VM
    if (mh->is_segment){
c002cfa5:	80 7e 22 00          	cmpb   $0x0,0x22(%esi)
c002cfa9:	0f 84 ab 00 00 00    	je     c002d05a <mmap_read+0xcf>
        void* addr = mh->va + mh->page_cnt * PGSIZE + mh->last_page_size;
c002cfaf:	8b 4e 04             	mov    0x4(%esi),%ecx
c002cfb2:	8b 56 14             	mov    0x14(%esi),%edx
c002cfb5:	8b 46 10             	mov    0x10(%esi),%eax
c002cfb8:	c1 e0 0c             	shl    $0xc,%eax
c002cfbb:	01 d0                	add    %edx,%eax
c002cfbd:	01 c8                	add    %ecx,%eax
        if (mh->last_page_size != 0)
            addr -= PGSIZE;
c002cfbf:	8d b8 00 f0 ff ff    	lea    -0x1000(%eax),%edi
c002cfc5:	85 d2                	test   %edx,%edx
c002cfc7:	0f 45 c7             	cmovne %edi,%eax
        if (addr > va){
c002cfca:	3b 44 24 24          	cmp    0x24(%esp),%eax
c002cfce:	76 5f                	jbe    c002d02f <mmap_read+0xa4>
            if (addr - va < PGSIZE){
c002cfd0:	2b 44 24 24          	sub    0x24(%esp),%eax
c002cfd4:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002cfd9:	7f 37                	jg     c002d012 <mmap_read+0x87>
                file_read_at(mh->fd, pa, mh->last_page_size, va - mh->va + mh->fa);
c002cfdb:	8b 44 24 24          	mov    0x24(%esp),%eax
c002cfdf:	29 c8                	sub    %ecx,%eax
c002cfe1:	03 46 0c             	add    0xc(%esi),%eax
c002cfe4:	50                   	push   %eax
c002cfe5:	52                   	push   %edx
c002cfe6:	55                   	push   %ebp
c002cfe7:	ff 76 08             	pushl  0x8(%esi)
c002cfea:	e8 2b 1a 00 00       	call   c002ea1a <file_read_at>
                memset(pa + mh->last_page_size, 0, PGSIZE - mh->last_page_size);
c002cfef:	8b 46 14             	mov    0x14(%esi),%eax
c002cff2:	ba 00 10 00 00       	mov    $0x1000,%edx
c002cff7:	29 c2                	sub    %eax,%edx
c002cff9:	01 c5                	add    %eax,%ebp
c002cffb:	83 c4 0c             	add    $0xc,%esp
c002cffe:	52                   	push   %edx
c002cfff:	6a 00                	push   $0x0
c002d001:	55                   	push   %ebp
c002d002:	e8 0d be ff ff       	call   c0028e14 <memset>
c002d007:	83 c4 10             	add    $0x10,%esp
        }
        else
            file_read_at(mh->fd, pa, PGSIZE, va - mh->va + mh->fa);
    }
#endif
}
c002d00a:	83 c4 0c             	add    $0xc,%esp
c002d00d:	5b                   	pop    %ebx
c002d00e:	5e                   	pop    %esi
c002d00f:	5f                   	pop    %edi
c002d010:	5d                   	pop    %ebp
c002d011:	c3                   	ret    
                file_read_at(mh->fd, pa, PGSIZE, va - mh->va + mh->fa);
c002d012:	8b 44 24 24          	mov    0x24(%esp),%eax
c002d016:	29 c8                	sub    %ecx,%eax
c002d018:	03 46 0c             	add    0xc(%esi),%eax
c002d01b:	50                   	push   %eax
c002d01c:	68 00 10 00 00       	push   $0x1000
c002d021:	55                   	push   %ebp
c002d022:	ff 76 08             	pushl  0x8(%esi)
c002d025:	e8 f0 19 00 00       	call   c002ea1a <file_read_at>
c002d02a:	83 c4 10             	add    $0x10,%esp
c002d02d:	eb db                	jmp    c002d00a <mmap_read+0x7f>
            memset(pa, 0, PGSIZE);
c002d02f:	c7 45 00 00 00 00 00 	movl   $0x0,0x0(%ebp)
c002d036:	c7 85 fc 0f 00 00 00 	movl   $0x0,0xffc(%ebp)
c002d03d:	00 00 00 
c002d040:	8d 7d 04             	lea    0x4(%ebp),%edi
c002d043:	83 e7 fc             	and    $0xfffffffc,%edi
c002d046:	29 fd                	sub    %edi,%ebp
c002d048:	8d 8d 00 10 00 00    	lea    0x1000(%ebp),%ecx
c002d04e:	c1 e9 02             	shr    $0x2,%ecx
c002d051:	b8 00 00 00 00       	mov    $0x0,%eax
c002d056:	f3 ab                	rep stos %eax,%es:(%edi)
c002d058:	eb b0                	jmp    c002d00a <mmap_read+0x7f>
        if (mh->va + file_length(mh->fd) - va < PGSIZE){
c002d05a:	8b 7e 04             	mov    0x4(%esi),%edi
c002d05d:	83 ec 0c             	sub    $0xc,%esp
c002d060:	ff 76 08             	pushl  0x8(%esi)
c002d063:	e8 2c 1b 00 00       	call   c002eb94 <file_length>
c002d068:	01 c7                	add    %eax,%edi
c002d06a:	2b 7c 24 34          	sub    0x34(%esp),%edi
c002d06e:	83 c4 10             	add    $0x10,%esp
c002d071:	81 ff ff 0f 00 00    	cmp    $0xfff,%edi
c002d077:	7e 21                	jle    c002d09a <mmap_read+0x10f>
            file_read_at(mh->fd, pa, PGSIZE, va - mh->va + mh->fa);
c002d079:	8b 44 24 24          	mov    0x24(%esp),%eax
c002d07d:	2b 46 04             	sub    0x4(%esi),%eax
c002d080:	03 46 0c             	add    0xc(%esi),%eax
c002d083:	50                   	push   %eax
c002d084:	68 00 10 00 00       	push   $0x1000
c002d089:	55                   	push   %ebp
c002d08a:	ff 76 08             	pushl  0x8(%esi)
c002d08d:	e8 88 19 00 00       	call   c002ea1a <file_read_at>
c002d092:	83 c4 10             	add    $0x10,%esp
}
c002d095:	e9 70 ff ff ff       	jmp    c002d00a <mmap_read+0x7f>
            file_read_at(mh->fd, pa, mh->last_page_size, va - mh->va + mh->fa);
c002d09a:	8b 44 24 24          	mov    0x24(%esp),%eax
c002d09e:	2b 46 04             	sub    0x4(%esi),%eax
c002d0a1:	03 46 0c             	add    0xc(%esi),%eax
c002d0a4:	50                   	push   %eax
c002d0a5:	ff 76 14             	pushl  0x14(%esi)
c002d0a8:	55                   	push   %ebp
c002d0a9:	ff 76 08             	pushl  0x8(%esi)
c002d0ac:	e8 69 19 00 00       	call   c002ea1a <file_read_at>
            memset(pa + mh->last_page_size, 0, PGSIZE - mh->last_page_size);
c002d0b1:	8b 46 14             	mov    0x14(%esi),%eax
c002d0b4:	ba 00 10 00 00       	mov    $0x1000,%edx
c002d0b9:	29 c2                	sub    %eax,%edx
c002d0bb:	01 c5                	add    %eax,%ebp
c002d0bd:	83 c4 0c             	add    $0xc,%esp
c002d0c0:	52                   	push   %edx
c002d0c1:	6a 00                	push   $0x0
c002d0c3:	55                   	push   %ebp
c002d0c4:	e8 4b bd ff ff       	call   c0028e14 <memset>
c002d0c9:	83 c4 10             	add    $0x10,%esp
c002d0cc:	e9 39 ff ff ff       	jmp    c002d00a <mmap_read+0x7f>

c002d0d1 <mmap_write>:

void mmap_write(struct mmap_handler* mh, void* va, void* pa){
c002d0d1:	57                   	push   %edi
c002d0d2:	56                   	push   %esi
c002d0d3:	53                   	push   %ebx
c002d0d4:	e8 0d 54 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002d0d9:	81 c3 63 3b 01 00    	add    $0x13b63,%ebx
c002d0df:	8b 74 24 10          	mov    0x10(%esp),%esi
#ifdef VM
    if (mh->dirty){
c002d0e3:	80 7e 20 00          	cmpb   $0x0,0x20(%esi)
c002d0e7:	74 41                	je     c002d12a <mmap_write+0x59>
        if (mh->is_segment){
c002d0e9:	80 7e 22 00          	cmpb   $0x0,0x22(%esi)
c002d0ed:	74 5f                	je     c002d14e <mmap_write+0x7d>
            void* addr = mh->va + mh->page_cnt * PGSIZE + mh->last_page_size;
c002d0ef:	8b 56 04             	mov    0x4(%esi),%edx
c002d0f2:	8b 4e 14             	mov    0x14(%esi),%ecx
c002d0f5:	8b 46 10             	mov    0x10(%esi),%eax
c002d0f8:	c1 e0 0c             	shl    $0xc,%eax
c002d0fb:	01 c8                	add    %ecx,%eax
c002d0fd:	01 d0                	add    %edx,%eax
            if (addr > va){
c002d0ff:	39 44 24 14          	cmp    %eax,0x14(%esp)
c002d103:	73 25                	jae    c002d12a <mmap_write+0x59>
                if (addr - va < PGSIZE)
c002d105:	2b 44 24 14          	sub    0x14(%esp),%eax
c002d109:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c002d10e:	7f 1e                	jg     c002d12e <mmap_write+0x5d>
                    file_write_at(mh->fd, pa, mh->last_page_size, va - mh->va + mh->fa);
c002d110:	8b 44 24 14          	mov    0x14(%esp),%eax
c002d114:	29 d0                	sub    %edx,%eax
c002d116:	03 46 0c             	add    0xc(%esi),%eax
c002d119:	50                   	push   %eax
c002d11a:	51                   	push   %ecx
c002d11b:	ff 74 24 20          	pushl  0x20(%esp)
c002d11f:	ff 76 08             	pushl  0x8(%esi)
c002d122:	e8 4d 19 00 00       	call   c002ea74 <file_write_at>
c002d127:	83 c4 10             	add    $0x10,%esp
            else
                file_write_at(mh->fd, pa, PGSIZE, va - mh->va + mh->fa);
        }
    }
#endif
}
c002d12a:	5b                   	pop    %ebx
c002d12b:	5e                   	pop    %esi
c002d12c:	5f                   	pop    %edi
c002d12d:	c3                   	ret    
                    file_write_at(mh->fd, pa, PGSIZE, va - mh->va + mh->fa);
c002d12e:	8b 44 24 14          	mov    0x14(%esp),%eax
c002d132:	29 d0                	sub    %edx,%eax
c002d134:	03 46 0c             	add    0xc(%esi),%eax
c002d137:	50                   	push   %eax
c002d138:	68 00 10 00 00       	push   $0x1000
c002d13d:	ff 74 24 20          	pushl  0x20(%esp)
c002d141:	ff 76 08             	pushl  0x8(%esi)
c002d144:	e8 2b 19 00 00       	call   c002ea74 <file_write_at>
c002d149:	83 c4 10             	add    $0x10,%esp
c002d14c:	eb dc                	jmp    c002d12a <mmap_write+0x59>
            if (mh->va + file_length(mh->fd) - va < PGSIZE)
c002d14e:	8b 7e 04             	mov    0x4(%esi),%edi
c002d151:	83 ec 0c             	sub    $0xc,%esp
c002d154:	ff 76 08             	pushl  0x8(%esi)
c002d157:	e8 38 1a 00 00       	call   c002eb94 <file_length>
c002d15c:	01 c7                	add    %eax,%edi
c002d15e:	2b 7c 24 24          	sub    0x24(%esp),%edi
c002d162:	83 c4 10             	add    $0x10,%esp
c002d165:	81 ff ff 0f 00 00    	cmp    $0xfff,%edi
c002d16b:	7e 21                	jle    c002d18e <mmap_write+0xbd>
                file_write_at(mh->fd, pa, PGSIZE, va - mh->va + mh->fa);
c002d16d:	8b 44 24 14          	mov    0x14(%esp),%eax
c002d171:	2b 46 04             	sub    0x4(%esi),%eax
c002d174:	03 46 0c             	add    0xc(%esi),%eax
c002d177:	50                   	push   %eax
c002d178:	68 00 10 00 00       	push   $0x1000
c002d17d:	ff 74 24 20          	pushl  0x20(%esp)
c002d181:	ff 76 08             	pushl  0x8(%esi)
c002d184:	e8 eb 18 00 00       	call   c002ea74 <file_write_at>
c002d189:	83 c4 10             	add    $0x10,%esp
}
c002d18c:	eb 9c                	jmp    c002d12a <mmap_write+0x59>
                file_write_at(mh->fd, pa, mh->last_page_size, va - mh->va + mh->fa);
c002d18e:	8b 44 24 14          	mov    0x14(%esp),%eax
c002d192:	2b 46 04             	sub    0x4(%esi),%eax
c002d195:	03 46 0c             	add    0xc(%esi),%eax
c002d198:	50                   	push   %eax
c002d199:	ff 76 14             	pushl  0x14(%esi)
c002d19c:	ff 74 24 20          	pushl  0x20(%esp)
c002d1a0:	ff 76 08             	pushl  0x8(%esi)
c002d1a3:	e8 cc 18 00 00       	call   c002ea74 <file_write_at>
c002d1a8:	83 c4 10             	add    $0x10,%esp
c002d1ab:	e9 7a ff ff ff       	jmp    c002d12a <mmap_write+0x59>

c002d1b0 <mmap_check_va>:
        return;
    }
#endif
}

bool mmap_check_va(struct thread* curT, const void* va, int page_cnt){
c002d1b0:	55                   	push   %ebp
c002d1b1:	57                   	push   %edi
c002d1b2:	56                   	push   %esi
c002d1b3:	53                   	push   %ebx
c002d1b4:	83 ec 0c             	sub    $0xc,%esp
c002d1b7:	e8 2a 53 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002d1bc:	81 c3 80 3a 01 00    	add    $0x13a80,%ebx
c002d1c2:	8b 44 24 24          	mov    0x24(%esp),%eax
c002d1c6:	8b 6c 24 28          	mov    0x28(%esp),%ebp
#ifdef VM
    bool flag = true;
    for (int i = 0; i < page_cnt; i++){
c002d1ca:	85 ed                	test   %ebp,%ebp
c002d1cc:	7e 3b                	jle    c002d209 <mmap_check_va+0x59>
c002d1ce:	89 c6                	mov    %eax,%esi
c002d1d0:	c1 e5 0c             	shl    $0xc,%ebp
c002d1d3:	01 c5                	add    %eax,%ebp
    bool flag = true;
c002d1d5:	bf 01 00 00 00       	mov    $0x1,%edi
        if (!page_available(curT->page_table, va + i * PGSIZE))
c002d1da:	83 ec 08             	sub    $0x8,%esp
c002d1dd:	56                   	push   %esi
c002d1de:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002d1e2:	ff b0 b8 00 00 00    	pushl  0xb8(%eax)
c002d1e8:	e8 c4 52 00 00       	call   c00324b1 <page_available>
c002d1ed:	83 c4 10             	add    $0x10,%esp
c002d1f0:	84 c0                	test   %al,%al
            flag = false;
c002d1f2:	0f 44 f8             	cmove  %eax,%edi
c002d1f5:	81 c6 00 10 00 00    	add    $0x1000,%esi
    for (int i = 0; i < page_cnt; i++){
c002d1fb:	39 ee                	cmp    %ebp,%esi
c002d1fd:	75 db                	jne    c002d1da <mmap_check_va+0x2a>
    }
    return flag;
#endif
}
c002d1ff:	89 f8                	mov    %edi,%eax
c002d201:	83 c4 0c             	add    $0xc,%esp
c002d204:	5b                   	pop    %ebx
c002d205:	5e                   	pop    %esi
c002d206:	5f                   	pop    %edi
c002d207:	5d                   	pop    %ebp
c002d208:	c3                   	ret    
    bool flag = true;
c002d209:	bf 01 00 00 00       	mov    $0x1,%edi
    return flag;
c002d20e:	eb ef                	jmp    c002d1ff <mmap_check_va+0x4f>

c002d210 <mmap_install_page>:

bool mmap_install_page(struct thread* curT, struct mmap_handler* mh){
c002d210:	55                   	push   %ebp
c002d211:	57                   	push   %edi
c002d212:	56                   	push   %esi
c002d213:	53                   	push   %ebx
c002d214:	83 ec 1c             	sub    $0x1c,%esp
c002d217:	e8 ca 52 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002d21c:	81 c3 20 3a 01 00    	add    $0x13a20,%ebx
c002d222:	8b 74 24 34          	mov    0x34(%esp),%esi
#ifdef VM
    bool flag = true;
    for (int i = 0; i < mh->page_cnt; i++){
c002d226:	8b 7e 10             	mov    0x10(%esi),%edi
c002d229:	85 ff                	test   %edi,%edi
c002d22b:	0f 8e 8b 00 00 00    	jle    c002d2bc <mmap_install_page+0xac>
c002d231:	b8 00 00 00 00       	mov    $0x0,%eax
    bool flag = true;
c002d236:	bd 01 00 00 00       	mov    $0x1,%ebp
        if (!page_mmap(curT->page_table, mh, mh->va + i * PGSIZE))
c002d23b:	83 ec 04             	sub    $0x4,%esp
c002d23e:	89 c7                	mov    %eax,%edi
c002d240:	c1 e0 0c             	shl    $0xc,%eax
c002d243:	03 46 04             	add    0x4(%esi),%eax
c002d246:	50                   	push   %eax
c002d247:	56                   	push   %esi
c002d248:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002d24c:	ff b0 b8 00 00 00    	pushl  0xb8(%eax)
c002d252:	e8 ec 4f 00 00       	call   c0032243 <page_mmap>
c002d257:	83 c4 10             	add    $0x10,%esp
            flag = false;
c002d25a:	84 c0                	test   %al,%al
c002d25c:	0f 44 e8             	cmove  %eax,%ebp
    for (int i = 0; i < mh->page_cnt; i++){
c002d25f:	83 c7 01             	add    $0x1,%edi
c002d262:	89 f8                	mov    %edi,%eax
c002d264:	8b 7e 10             	mov    0x10(%esi),%edi
c002d267:	39 c7                	cmp    %eax,%edi
c002d269:	7f d0                	jg     c002d23b <mmap_install_page+0x2b>
    }
    if (mh->is_segment){
c002d26b:	80 7e 22 00          	cmpb   $0x0,0x22(%esi)
c002d26f:	74 41                	je     c002d2b2 <mmap_install_page+0xa2>
        for (int i = mh->page_cnt; i < mh->num_page_with_segment; i++){
c002d271:	39 7e 24             	cmp    %edi,0x24(%esi)
c002d274:	7e 3c                	jle    c002d2b2 <mmap_install_page+0xa2>
c002d276:	89 f8                	mov    %edi,%eax
c002d278:	c1 e0 0c             	shl    $0xc,%eax
c002d27b:	89 44 24 0c          	mov    %eax,0xc(%esp)
            if (!page_mmap(curT->page_table, mh, mh->va + i * PGSIZE))
c002d27f:	83 ec 04             	sub    $0x4,%esp
c002d282:	8b 44 24 10          	mov    0x10(%esp),%eax
c002d286:	03 46 04             	add    0x4(%esi),%eax
c002d289:	50                   	push   %eax
c002d28a:	56                   	push   %esi
c002d28b:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c002d28f:	ff b2 b8 00 00 00    	pushl  0xb8(%edx)
c002d295:	e8 a9 4f 00 00       	call   c0032243 <page_mmap>
c002d29a:	83 c4 10             	add    $0x10,%esp
                flag = false;
c002d29d:	84 c0                	test   %al,%al
c002d29f:	0f 44 e8             	cmove  %eax,%ebp
        for (int i = mh->page_cnt; i < mh->num_page_with_segment; i++){
c002d2a2:	83 c7 01             	add    $0x1,%edi
c002d2a5:	81 44 24 0c 00 10 00 	addl   $0x1000,0xc(%esp)
c002d2ac:	00 
c002d2ad:	39 7e 24             	cmp    %edi,0x24(%esi)
c002d2b0:	7f cd                	jg     c002d27f <mmap_install_page+0x6f>
        }
    }
    return flag;
#endif
c002d2b2:	89 e8                	mov    %ebp,%eax
c002d2b4:	83 c4 1c             	add    $0x1c,%esp
c002d2b7:	5b                   	pop    %ebx
c002d2b8:	5e                   	pop    %esi
c002d2b9:	5f                   	pop    %edi
c002d2ba:	5d                   	pop    %ebp
c002d2bb:	c3                   	ret    
    bool flag = true;
c002d2bc:	bd 01 00 00 00       	mov    $0x1,%ebp
c002d2c1:	eb a8                	jmp    c002d26b <mmap_install_page+0x5b>

c002d2c3 <syscall_handler>:
{
c002d2c3:	55                   	push   %ebp
c002d2c4:	57                   	push   %edi
c002d2c5:	56                   	push   %esi
c002d2c6:	53                   	push   %ebx
c002d2c7:	83 ec 2c             	sub    $0x2c,%esp
c002d2ca:	e8 17 52 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002d2cf:	81 c3 6d 39 01 00    	add    $0x1396d,%ebx
c002d2d5:	8b 6c 24 40          	mov    0x40(%esp),%ebp
    thread_current()->esp = f->esp;
c002d2d9:	e8 67 3d ff ff       	call   c0021045 <thread_current>
c002d2de:	8b 55 48             	mov    0x48(%ebp),%edx
c002d2e1:	89 90 bc 00 00 00    	mov    %edx,0xbc(%eax)
  if (!syscall_check_user_buffer(f->esp, 4, false))
c002d2e7:	83 ec 04             	sub    $0x4,%esp
c002d2ea:	6a 00                	push   $0x0
c002d2ec:	6a 04                	push   $0x4
c002d2ee:	ff 75 48             	pushl  0x48(%ebp)
c002d2f1:	e8 4a fc ff ff       	call   c002cf40 <syscall_check_user_buffer>
c002d2f6:	83 c4 10             	add    $0x10,%esp
c002d2f9:	84 c0                	test   %al,%al
c002d2fb:	74 18                	je     c002d315 <syscall_handler+0x52>
  int call_num = *((int *)f->esp);
c002d2fd:	8b 75 48             	mov    0x48(%ebp),%esi
c002d300:	8b 3e                	mov    (%esi),%edi
  void *arg1 = f->esp + 4, *arg2 = f->esp + 8, *arg3 = f->esp + 12;
c002d302:	8d 46 04             	lea    0x4(%esi),%eax
  switch (call_num)
c002d305:	83 ff 13             	cmp    $0x13,%edi
c002d308:	77 2f                	ja     c002d339 <.L66>
c002d30a:	89 da                	mov    %ebx,%edx
c002d30c:	03 94 bb c8 28 ff ff 	add    -0xd738(%ebx,%edi,4),%edx
c002d313:	ff e2                	jmp    *%edx
    thread_exit_with_return_value(f, -1);
c002d315:	83 ec 08             	sub    $0x8,%esp
c002d318:	6a ff                	push   $0xffffffff
c002d31a:	55                   	push   %ebp
c002d31b:	e8 e5 49 ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002d320:	83 c4 10             	add    $0x10,%esp
c002d323:	eb d8                	jmp    c002d2fd <syscall_handler+0x3a>

c002d325 <.L67>:
    if (!syscall_check_user_buffer(arg1, 4, false))
c002d325:	83 ec 04             	sub    $0x4,%esp
c002d328:	6a 00                	push   $0x0
c002d32a:	6a 04                	push   $0x4
c002d32c:	50                   	push   %eax
c002d32d:	e8 0e fc ff ff       	call   c002cf40 <syscall_check_user_buffer>
c002d332:	83 c4 10             	add    $0x10,%esp
c002d335:	84 c0                	test   %al,%al
c002d337:	74 14                	je     c002d34d <.L66+0x14>

c002d339 <.L66>:
  switch (call_num)
c002d339:	83 ff 13             	cmp    $0x13,%edi
c002d33c:	0f 87 82 0c 00 00    	ja     c002dfc4 <.L82+0xd6>
c002d342:	89 d8                	mov    %ebx,%eax
c002d344:	03 84 bb 18 29 ff ff 	add    -0xd6e8(%ebx,%edi,4),%eax
c002d34b:	ff e0                	jmp    *%eax
      thread_exit_with_return_value(f, -1);
c002d34d:	83 ec 08             	sub    $0x8,%esp
c002d350:	6a ff                	push   $0xffffffff
c002d352:	55                   	push   %ebp
c002d353:	e8 ad 49 ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002d358:	83 c4 10             	add    $0x10,%esp
c002d35b:	eb dc                	jmp    c002d339 <.L66>

c002d35d <.L69>:
    if (!syscall_check_user_buffer(arg1, 8, false))
c002d35d:	83 ec 04             	sub    $0x4,%esp
c002d360:	6a 00                	push   $0x0
c002d362:	6a 08                	push   $0x8
c002d364:	50                   	push   %eax
c002d365:	e8 d6 fb ff ff       	call   c002cf40 <syscall_check_user_buffer>
c002d36a:	83 c4 10             	add    $0x10,%esp
c002d36d:	84 c0                	test   %al,%al
c002d36f:	75 c8                	jne    c002d339 <.L66>
      thread_exit_with_return_value(f, -1);
c002d371:	83 ec 08             	sub    $0x8,%esp
c002d374:	6a ff                	push   $0xffffffff
c002d376:	55                   	push   %ebp
c002d377:	e8 89 49 ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002d37c:	83 c4 10             	add    $0x10,%esp
c002d37f:	eb b8                	jmp    c002d339 <.L66>

c002d381 <.L70>:
        if (!syscall_check_user_buffer(arg1, 12, false))
c002d381:	83 ec 04             	sub    $0x4,%esp
c002d384:	6a 00                	push   $0x0
c002d386:	6a 0c                	push   $0xc
c002d388:	50                   	push   %eax
c002d389:	e8 b2 fb ff ff       	call   c002cf40 <syscall_check_user_buffer>
c002d38e:	83 c4 10             	add    $0x10,%esp
c002d391:	84 c0                	test   %al,%al
c002d393:	75 a4                	jne    c002d339 <.L66>
        thread_exit_with_return_value(f, -1);
c002d395:	83 ec 08             	sub    $0x8,%esp
c002d398:	6a ff                	push   $0xffffffff
c002d39a:	55                   	push   %ebp
c002d39b:	e8 65 49 ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002d3a0:	83 c4 10             	add    $0x10,%esp
c002d3a3:	eb 94                	jmp    c002d339 <.L66>

c002d3a5 <.L72>:
  shutdown_power_off();
c002d3a5:	e8 a9 9f ff ff       	call   c0027353 <shutdown_power_off>

c002d3aa <.L74>:
    syscall_exit(f, *((int *)arg1));
c002d3aa:	8b 76 04             	mov    0x4(%esi),%esi
  struct thread *cur = thread_current();
c002d3ad:	e8 93 3c ff ff       	call   c0021045 <thread_current>
  if (!cur->grandpa_died)
c002d3b2:	80 b8 a8 00 00 00 00 	cmpb   $0x0,0xa8(%eax)
c002d3b9:	75 13                	jne    c002d3ce <.L74+0x24>
    cur->message_to_grandpa->exited = true;
c002d3bb:	8b 90 ac 00 00 00    	mov    0xac(%eax),%edx
c002d3c1:	c6 42 08 01          	movb   $0x1,0x8(%edx)
    cur->message_to_grandpa->return_value = return_value;
c002d3c5:	8b 80 ac 00 00 00    	mov    0xac(%eax),%eax
c002d3cb:	89 70 0c             	mov    %esi,0xc(%eax)
  thread_exit_with_return_value(f, return_value);
c002d3ce:	83 ec 08             	sub    $0x8,%esp
c002d3d1:	56                   	push   %esi
c002d3d2:	55                   	push   %ebp
c002d3d3:	e8 2d 49 ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002d3d8:	83 c4 10             	add    $0x10,%esp
}
c002d3db:	83 c4 2c             	add    $0x2c,%esp
c002d3de:	5b                   	pop    %ebx
c002d3df:	5e                   	pop    %esi
c002d3e0:	5f                   	pop    %edi
c002d3e1:	5d                   	pop    %ebp
c002d3e2:	c3                   	ret    

c002d3e3 <.L75>:
    syscall_exec(f, *((void **)arg1));
c002d3e3:	8b 7e 04             	mov    0x4(%esi),%edi
  if (!syscall_check_user_string(cmd_line))
c002d3e6:	83 ec 0c             	sub    $0xc,%esp
c002d3e9:	57                   	push   %edi
c002d3ea:	e8 d7 fa ff ff       	call   c002cec6 <syscall_check_user_string>
c002d3ef:	83 c4 10             	add    $0x10,%esp
c002d3f2:	84 c0                	test   %al,%al
c002d3f4:	74 5f                	je     c002d455 <.L75+0x72>
  lock_acquire(&filesys_lock);
c002d3f6:	83 ec 0c             	sub    $0xc,%esp
c002d3f9:	8d b3 c4 1d 00 00    	lea    0x1dc4(%ebx),%esi
c002d3ff:	56                   	push   %esi
c002d400:	e8 bd 61 ff ff       	call   c00235c2 <lock_acquire>
  f->eax = (uint32_t)process_execute(cmd_line);
c002d405:	89 3c 24             	mov    %edi,(%esp)
c002d408:	e8 f4 e4 ff ff       	call   c002b901 <process_execute>
c002d40d:	89 45 1c             	mov    %eax,0x1c(%ebp)
  lock_release(&filesys_lock);
c002d410:	89 34 24             	mov    %esi,(%esp)
c002d413:	e8 7e 63 ff ff       	call   c0023796 <lock_release>
  struct thread *cur = thread_current();
c002d418:	e8 28 3c ff ff       	call   c0021045 <thread_current>
  for (e = list_begin(&cur->child_list); e != list_end(&cur->child_list); e = list_next(e))
c002d41d:	8d 78 70             	lea    0x70(%eax),%edi
c002d420:	89 3c 24             	mov    %edi,(%esp)
c002d423:	e8 92 c5 ff ff       	call   c00299ba <list_begin>
c002d428:	89 c6                	mov    %eax,%esi
c002d42a:	83 c4 10             	add    $0x10,%esp
c002d42d:	83 ec 0c             	sub    $0xc,%esp
c002d430:	57                   	push   %edi
c002d431:	e8 26 c6 ff ff       	call   c0029a5c <list_end>
c002d436:	83 c4 10             	add    $0x10,%esp
c002d439:	39 c6                	cmp    %eax,%esi
c002d43b:	74 9e                	je     c002d3db <.L74+0x31>
    if (l->tid == f->eax)
c002d43d:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002d440:	39 46 ec             	cmp    %eax,-0x14(%esi)
c002d443:	74 20                	je     c002d465 <.L75+0x82>
  for (e = list_begin(&cur->child_list); e != list_end(&cur->child_list); e = list_next(e))
c002d445:	83 ec 0c             	sub    $0xc,%esp
c002d448:	56                   	push   %esi
c002d449:	e8 b1 c5 ff ff       	call   c00299ff <list_next>
c002d44e:	89 c6                	mov    %eax,%esi
c002d450:	83 c4 10             	add    $0x10,%esp
c002d453:	eb d8                	jmp    c002d42d <.L75+0x4a>
    thread_exit_with_return_value(f, -1);
c002d455:	83 ec 08             	sub    $0x8,%esp
c002d458:	6a ff                	push   $0xffffffff
c002d45a:	55                   	push   %ebp
c002d45b:	e8 a5 48 ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002d460:	83 c4 10             	add    $0x10,%esp
c002d463:	eb 91                	jmp    c002d3f6 <.L75+0x13>
      sema_down(l->sema_started);
c002d465:	83 ec 0c             	sub    $0xc,%esp
c002d468:	ff 76 fc             	pushl  -0x4(%esi)
c002d46b:	e8 a4 5d ff ff       	call   c0023214 <sema_down>
      if (l->load_failed)
c002d470:	83 c4 10             	add    $0x10,%esp
c002d473:	80 7e f2 00          	cmpb   $0x0,-0xe(%esi)
c002d477:	0f 84 5e ff ff ff    	je     c002d3db <.L74+0x31>
        f->eax = (uint32_t)-1;
c002d47d:	c7 45 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebp)
c002d484:	e9 52 ff ff ff       	jmp    c002d3db <.L74+0x31>

c002d489 <.L76>:
  f->eax = (uint32_t)process_wait(pid);
c002d489:	83 ec 0c             	sub    $0xc,%esp
c002d48c:	ff 76 04             	pushl  0x4(%esi)
c002d48f:	e8 3b e5 ff ff       	call   c002b9cf <process_wait>
c002d494:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002d497:	83 c4 10             	add    $0x10,%esp
c002d49a:	e9 3c ff ff ff       	jmp    c002d3db <.L74+0x31>

c002d49f <.L84>:
  struct file_handle *t = syscall_get_file_handle(fd);
c002d49f:	83 ec 0c             	sub    $0xc,%esp
c002d4a2:	ff 76 04             	pushl  0x4(%esi)
c002d4a5:	e8 a2 48 ff ff       	call   c0021d4c <syscall_get_file_handle>
c002d4aa:	89 c6                	mov    %eax,%esi
  if (t != NULL && !inode_isdir(file_get_inode(t->opened_file)))
c002d4ac:	83 c4 10             	add    $0x10,%esp
c002d4af:	85 c0                	test   %eax,%eax
c002d4b1:	74 1a                	je     c002d4cd <.L84+0x2e>
c002d4b3:	83 ec 0c             	sub    $0xc,%esp
c002d4b6:	ff 70 04             	pushl  0x4(%eax)
c002d4b9:	e8 26 15 00 00       	call   c002e9e4 <file_get_inode>
c002d4be:	89 04 24             	mov    %eax,(%esp)
c002d4c1:	e8 ba 32 00 00       	call   c0030780 <inode_isdir>
c002d4c6:	83 c4 10             	add    $0x10,%esp
c002d4c9:	85 c0                	test   %eax,%eax
c002d4cb:	74 13                	je     c002d4e0 <.L84+0x41>
    thread_exit_with_return_value(f, -1);
c002d4cd:	83 ec 08             	sub    $0x8,%esp
c002d4d0:	6a ff                	push   $0xffffffff
c002d4d2:	55                   	push   %ebp
c002d4d3:	e8 2d 48 ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002d4d8:	83 c4 10             	add    $0x10,%esp
c002d4db:	e9 fb fe ff ff       	jmp    c002d3db <.L74+0x31>
    lock_acquire(&filesys_lock);
c002d4e0:	83 ec 0c             	sub    $0xc,%esp
c002d4e3:	8d bb c4 1d 00 00    	lea    0x1dc4(%ebx),%edi
c002d4e9:	57                   	push   %edi
c002d4ea:	e8 d3 60 ff ff       	call   c00235c2 <lock_acquire>
    f->eax = (uint32_t)file_tell(t->opened_file);
c002d4ef:	83 c4 04             	add    $0x4,%esp
c002d4f2:	ff 76 04             	pushl  0x4(%esi)
c002d4f5:	e8 62 17 00 00       	call   c002ec5c <file_tell>
c002d4fa:	89 45 1c             	mov    %eax,0x1c(%ebp)
    lock_release(&filesys_lock);
c002d4fd:	89 3c 24             	mov    %edi,(%esp)
c002d500:	e8 91 62 ff ff       	call   c0023796 <lock_release>
c002d505:	83 c4 10             	add    $0x10,%esp
c002d508:	e9 ce fe ff ff       	jmp    c002d3db <.L74+0x31>

c002d50d <.L85>:
  struct file_handle *t = syscall_get_file_handle(fd);
c002d50d:	83 ec 0c             	sub    $0xc,%esp
c002d510:	ff 76 04             	pushl  0x4(%esi)
c002d513:	e8 34 48 ff ff       	call   c0021d4c <syscall_get_file_handle>
c002d518:	89 c6                	mov    %eax,%esi
  if (t != NULL)
c002d51a:	83 c4 10             	add    $0x10,%esp
c002d51d:	85 c0                	test   %eax,%eax
c002d51f:	74 6d                	je     c002d58e <.L85+0x81>
    lock_acquire(&filesys_lock);
c002d521:	83 ec 0c             	sub    $0xc,%esp
c002d524:	8d 83 c4 1d 00 00    	lea    0x1dc4(%ebx),%eax
c002d52a:	50                   	push   %eax
c002d52b:	e8 92 60 ff ff       	call   c00235c2 <lock_acquire>
    if (inode_isdir(file_get_inode(t->opened_file)))
c002d530:	83 c4 04             	add    $0x4,%esp
c002d533:	ff 76 04             	pushl  0x4(%esi)
c002d536:	e8 a9 14 00 00       	call   c002e9e4 <file_get_inode>
c002d53b:	89 04 24             	mov    %eax,(%esp)
c002d53e:	e8 3d 32 00 00       	call   c0030780 <inode_isdir>
c002d543:	83 c4 10             	add    $0x10,%esp
c002d546:	85 c0                	test   %eax,%eax
c002d548:	75 34                	jne    c002d57e <.L85+0x71>
    file_close(t->opened_file);
c002d54a:	83 ec 0c             	sub    $0xc,%esp
c002d54d:	ff 76 04             	pushl  0x4(%esi)
c002d550:	e8 03 16 00 00       	call   c002eb58 <file_close>
    lock_release(&filesys_lock);
c002d555:	8d 83 c4 1d 00 00    	lea    0x1dc4(%ebx),%eax
c002d55b:	89 04 24             	mov    %eax,(%esp)
c002d55e:	e8 33 62 ff ff       	call   c0023796 <lock_release>
    list_remove(&t->elem);
c002d563:	8d 46 10             	lea    0x10(%esi),%eax
c002d566:	89 04 24             	mov    %eax,(%esp)
c002d569:	e8 f7 c9 ff ff       	call   c0029f65 <list_remove>
    free(t);
c002d56e:	89 34 24             	mov    %esi,(%esp)
c002d571:	e8 24 6f ff ff       	call   c002449a <free>
c002d576:	83 c4 10             	add    $0x10,%esp
c002d579:	e9 5d fe ff ff       	jmp    c002d3db <.L74+0x31>
      dir_close(t->opened_dir);
c002d57e:	83 ec 0c             	sub    $0xc,%esp
c002d581:	ff 76 0c             	pushl  0xc(%esi)
c002d584:	e8 18 19 00 00       	call   c002eea1 <dir_close>
c002d589:	83 c4 10             	add    $0x10,%esp
c002d58c:	eb bc                	jmp    c002d54a <.L85+0x3d>
    thread_exit_with_return_value(f, -1);
c002d58e:	83 ec 08             	sub    $0x8,%esp
c002d591:	6a ff                	push   $0xffffffff
c002d593:	55                   	push   %ebp
c002d594:	e8 6c 47 ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002d599:	83 c4 10             	add    $0x10,%esp
c002d59c:	e9 3a fe ff ff       	jmp    c002d3db <.L74+0x31>

c002d5a1 <.L78>:
    syscall_remove(f, *((void **)arg1));
c002d5a1:	8b 7e 04             	mov    0x4(%esi),%edi
  if (!syscall_check_user_string(name))
c002d5a4:	83 ec 0c             	sub    $0xc,%esp
c002d5a7:	57                   	push   %edi
c002d5a8:	e8 19 f9 ff ff       	call   c002cec6 <syscall_check_user_string>
c002d5ad:	83 c4 10             	add    $0x10,%esp
c002d5b0:	84 c0                	test   %al,%al
c002d5b2:	74 2d                	je     c002d5e1 <.L78+0x40>
  lock_acquire(&filesys_lock);
c002d5b4:	83 ec 0c             	sub    $0xc,%esp
c002d5b7:	8d b3 c4 1d 00 00    	lea    0x1dc4(%ebx),%esi
c002d5bd:	56                   	push   %esi
c002d5be:	e8 ff 5f ff ff       	call   c00235c2 <lock_acquire>
  f->eax = (uint32_t)filesys_remove(name);
c002d5c3:	89 3c 24             	mov    %edi,(%esp)
c002d5c6:	e8 9d 10 00 00       	call   c002e668 <filesys_remove>
c002d5cb:	0f b6 c0             	movzbl %al,%eax
c002d5ce:	89 45 1c             	mov    %eax,0x1c(%ebp)
  lock_release(&filesys_lock);
c002d5d1:	89 34 24             	mov    %esi,(%esp)
c002d5d4:	e8 bd 61 ff ff       	call   c0023796 <lock_release>
c002d5d9:	83 c4 10             	add    $0x10,%esp
c002d5dc:	e9 fa fd ff ff       	jmp    c002d3db <.L74+0x31>
    thread_exit_with_return_value(f, -1);
c002d5e1:	83 ec 08             	sub    $0x8,%esp
c002d5e4:	6a ff                	push   $0xffffffff
c002d5e6:	55                   	push   %ebp
c002d5e7:	e8 19 47 ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002d5ec:	83 c4 10             	add    $0x10,%esp
c002d5ef:	eb c3                	jmp    c002d5b4 <.L78+0x13>

c002d5f1 <.L79>:
    syscall_open(f, *((void **)arg1));
c002d5f1:	8b 7e 04             	mov    0x4(%esi),%edi
  if (!syscall_check_user_string(name))
c002d5f4:	83 ec 0c             	sub    $0xc,%esp
c002d5f7:	57                   	push   %edi
c002d5f8:	e8 c9 f8 ff ff       	call   c002cec6 <syscall_check_user_string>
c002d5fd:	83 c4 10             	add    $0x10,%esp
c002d600:	84 c0                	test   %al,%al
c002d602:	74 7d                	je     c002d681 <.L79+0x90>
  lock_acquire(&filesys_lock);
c002d604:	83 ec 0c             	sub    $0xc,%esp
c002d607:	8d b3 c4 1d 00 00    	lea    0x1dc4(%ebx),%esi
c002d60d:	56                   	push   %esi
c002d60e:	e8 af 5f ff ff       	call   c00235c2 <lock_acquire>
  struct file *tmp_file = filesys_open(name);
c002d613:	89 3c 24             	mov    %edi,(%esp)
c002d616:	e8 fa 0f 00 00       	call   c002e615 <filesys_open>
c002d61b:	89 c7                	mov    %eax,%edi
  lock_release(&filesys_lock);
c002d61d:	89 34 24             	mov    %esi,(%esp)
c002d620:	e8 71 61 ff ff       	call   c0023796 <lock_release>
  if (tmp_file == NULL)
c002d625:	83 c4 10             	add    $0x10,%esp
c002d628:	85 ff                	test   %edi,%edi
c002d62a:	74 68                	je     c002d694 <.L79+0xa3>
  struct file_handle *handle = malloc(sizeof(struct file_handle));
c002d62c:	83 ec 0c             	sub    $0xc,%esp
c002d62f:	6a 18                	push   $0x18
c002d631:	e8 ae 6c ff ff       	call   c00242e4 <malloc>
c002d636:	89 c6                	mov    %eax,%esi
  handle->opened_file = tmp_file;
c002d638:	89 78 04             	mov    %edi,0x4(%eax)
  handle->owned_thread = thread_current();
c002d63b:	e8 05 3a ff ff       	call   c0021045 <thread_current>
c002d640:	89 46 08             	mov    %eax,0x8(%esi)
  handle->fd = fd_next++;
c002d643:	8b 83 c0 ff ff ff    	mov    -0x40(%ebx),%eax
c002d649:	8d 50 01             	lea    0x1(%eax),%edx
c002d64c:	89 93 c0 ff ff ff    	mov    %edx,-0x40(%ebx)
c002d652:	89 06                	mov    %eax,(%esi)
  if (inode_isdir(file_get_inode(tmp_file)))
c002d654:	89 3c 24             	mov    %edi,(%esp)
c002d657:	e8 88 13 00 00       	call   c002e9e4 <file_get_inode>
c002d65c:	89 04 24             	mov    %eax,(%esp)
c002d65f:	e8 1c 31 00 00       	call   c0030780 <inode_isdir>
c002d664:	83 c4 10             	add    $0x10,%esp
c002d667:	85 c0                	test   %eax,%eax
c002d669:	75 35                	jne    c002d6a0 <.L79+0xaf>
  thread_file_list_inster(handle);
c002d66b:	83 ec 0c             	sub    $0xc,%esp
c002d66e:	56                   	push   %esi
c002d66f:	e8 b0 46 ff ff       	call   c0021d24 <thread_file_list_inster>
  f->eax = (uint32_t)handle->fd;
c002d674:	8b 06                	mov    (%esi),%eax
c002d676:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002d679:	83 c4 10             	add    $0x10,%esp
c002d67c:	e9 5a fd ff ff       	jmp    c002d3db <.L74+0x31>
    thread_exit_with_return_value(f, -1);
c002d681:	83 ec 08             	sub    $0x8,%esp
c002d684:	6a ff                	push   $0xffffffff
c002d686:	55                   	push   %ebp
c002d687:	e8 79 46 ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002d68c:	83 c4 10             	add    $0x10,%esp
c002d68f:	e9 70 ff ff ff       	jmp    c002d604 <.L79+0x13>
    f->eax = (uint32_t)-1;
c002d694:	c7 45 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebp)
c002d69b:	e9 3b fd ff ff       	jmp    c002d3db <.L74+0x31>
    handle->opened_dir = dir_open(inode_reopen(file_get_inode(tmp_file)));
c002d6a0:	83 ec 0c             	sub    $0xc,%esp
c002d6a3:	57                   	push   %edi
c002d6a4:	e8 3b 13 00 00       	call   c002e9e4 <file_get_inode>
c002d6a9:	89 04 24             	mov    %eax,(%esp)
c002d6ac:	e8 b8 2a 00 00       	call   c0030169 <inode_reopen>
c002d6b1:	89 04 24             	mov    %eax,(%esp)
c002d6b4:	e8 13 17 00 00       	call   c002edcc <dir_open>
c002d6b9:	89 46 0c             	mov    %eax,0xc(%esi)
c002d6bc:	83 c4 10             	add    $0x10,%esp
c002d6bf:	eb aa                	jmp    c002d66b <.L79+0x7a>

c002d6c1 <.L80>:
  struct file_handle *t = syscall_get_file_handle(fd);
c002d6c1:	83 ec 0c             	sub    $0xc,%esp
c002d6c4:	ff 76 04             	pushl  0x4(%esi)
c002d6c7:	e8 80 46 ff ff       	call   c0021d4c <syscall_get_file_handle>
c002d6cc:	89 c6                	mov    %eax,%esi
  if (t != NULL)
c002d6ce:	83 c4 10             	add    $0x10,%esp
c002d6d1:	85 c0                	test   %eax,%eax
c002d6d3:	74 2d                	je     c002d702 <.L80+0x41>
    lock_acquire(&filesys_lock);
c002d6d5:	83 ec 0c             	sub    $0xc,%esp
c002d6d8:	8d bb c4 1d 00 00    	lea    0x1dc4(%ebx),%edi
c002d6de:	57                   	push   %edi
c002d6df:	e8 de 5e ff ff       	call   c00235c2 <lock_acquire>
    f->eax = (uint32_t)file_length(t->opened_file);
c002d6e4:	83 c4 04             	add    $0x4,%esp
c002d6e7:	ff 76 04             	pushl  0x4(%esi)
c002d6ea:	e8 a5 14 00 00       	call   c002eb94 <file_length>
c002d6ef:	89 45 1c             	mov    %eax,0x1c(%ebp)
    lock_release(&filesys_lock);
c002d6f2:	89 3c 24             	mov    %edi,(%esp)
c002d6f5:	e8 9c 60 ff ff       	call   c0023796 <lock_release>
c002d6fa:	83 c4 10             	add    $0x10,%esp
c002d6fd:	e9 d9 fc ff ff       	jmp    c002d3db <.L74+0x31>
    thread_exit_with_return_value(f, -1);
c002d702:	83 ec 08             	sub    $0x8,%esp
c002d705:	6a ff                	push   $0xffffffff
c002d707:	55                   	push   %ebp
c002d708:	e8 f8 45 ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002d70d:	83 c4 10             	add    $0x10,%esp
c002d710:	e9 c6 fc ff ff       	jmp    c002d3db <.L74+0x31>

c002d715 <.L87>:
          syscall_munmap(f, *((mapid_t *) arg1));
c002d715:	8b 76 04             	mov    0x4(%esi),%esi
    struct thread *cur = thread_current();
c002d718:	e8 28 39 ff ff       	call   c0021045 <thread_current>
c002d71d:	89 04 24             	mov    %eax,(%esp)
    if (list_empty(&cur->mmap_list)){
c002d720:	83 ec 0c             	sub    $0xc,%esp
c002d723:	05 c0 00 00 00       	add    $0xc0,%eax
c002d728:	50                   	push   %eax
c002d729:	e8 d9 c8 ff ff       	call   c002a007 <list_empty>
c002d72e:	83 c4 10             	add    $0x10,%esp
c002d731:	84 c0                	test   %al,%al
c002d733:	74 0c                	je     c002d741 <.L87+0x2c>
        f->eax = MAP_FAILED;
c002d735:	c7 45 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebp)
c002d73c:	e9 9a fc ff ff       	jmp    c002d3db <.L74+0x31>
    struct mmap_handler* mh = process_get_mmap_handler(mapid);
c002d741:	83 ec 0c             	sub    $0xc,%esp
c002d744:	56                   	push   %esi
c002d745:	e8 b7 e8 ff ff       	call   c002c001 <process_get_mmap_handler>
c002d74a:	89 c7                	mov    %eax,%edi
    if (mh == NULL){
c002d74c:	83 c4 10             	add    $0x10,%esp
c002d74f:	85 c0                	test   %eax,%eax
c002d751:	74 5c                	je     c002d7af <.L87+0x9a>
    for (int i = 0; i < mh->page_cnt; i++){
c002d753:	be 00 00 00 00       	mov    $0x0,%esi
c002d758:	83 78 10 00          	cmpl   $0x0,0x10(%eax)
c002d75c:	7e 31                	jle    c002d78f <.L87+0x7a>
c002d75e:	89 6c 24 40          	mov    %ebp,0x40(%esp)
c002d762:	8b 2c 24             	mov    (%esp),%ebp
        if (!page_unmap(cur->page_table, mh->va + i * PGSIZE)){
c002d765:	83 ec 08             	sub    $0x8,%esp
c002d768:	89 f0                	mov    %esi,%eax
c002d76a:	c1 e0 0c             	shl    $0xc,%eax
c002d76d:	03 47 04             	add    0x4(%edi),%eax
c002d770:	50                   	push   %eax
c002d771:	ff b5 b8 00 00 00    	pushl  0xb8(%ebp)
c002d777:	e8 67 4b 00 00       	call   c00322e3 <page_unmap>
c002d77c:	83 c4 10             	add    $0x10,%esp
c002d77f:	84 c0                	test   %al,%al
c002d781:	74 38                	je     c002d7bb <.L87+0xa6>
    for (int i = 0; i < mh->page_cnt; i++){
c002d783:	83 c6 01             	add    $0x1,%esi
c002d786:	3b 77 10             	cmp    0x10(%edi),%esi
c002d789:	7c da                	jl     c002d765 <.L87+0x50>
c002d78b:	8b 6c 24 40          	mov    0x40(%esp),%ebp
    if (!process_delete_mmap_handler(mh)){
c002d78f:	83 ec 0c             	sub    $0xc,%esp
c002d792:	57                   	push   %edi
c002d793:	e8 e6 e8 ff ff       	call   c002c07e <process_delete_mmap_handler>
c002d798:	83 c4 10             	add    $0x10,%esp
c002d79b:	84 c0                	test   %al,%al
c002d79d:	0f 85 38 fc ff ff    	jne    c002d3db <.L74+0x31>
        f->eax = MAP_FAILED;
c002d7a3:	c7 45 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebp)
c002d7aa:	e9 2c fc ff ff       	jmp    c002d3db <.L74+0x31>
        f->eax = MAP_FAILED;
c002d7af:	c7 45 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebp)
c002d7b6:	e9 20 fc ff ff       	jmp    c002d3db <.L74+0x31>
c002d7bb:	8b 6c 24 40          	mov    0x40(%esp),%ebp
            process_delete_mmap_handler(mh);
c002d7bf:	83 ec 0c             	sub    $0xc,%esp
c002d7c2:	57                   	push   %edi
c002d7c3:	e8 b6 e8 ff ff       	call   c002c07e <process_delete_mmap_handler>
            f->eax = MAP_FAILED;
c002d7c8:	c7 45 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebp)
c002d7cf:	83 c4 10             	add    $0x10,%esp
c002d7d2:	e9 04 fc ff ff       	jmp    c002d3db <.L74+0x31>

c002d7d7 <.L86>:
          syscall_mmap(f, *((int *) arg1), *((void **) arg2));
c002d7d7:	8b 7e 04             	mov    0x4(%esi),%edi
    if (fd == 0 || fd == 1){
c002d7da:	83 ff 01             	cmp    $0x1,%edi
c002d7dd:	76 1b                	jbe    c002d7fa <.L86+0x23>
          syscall_mmap(f, *((int *) arg1), *((void **) arg2));
c002d7df:	8b 76 08             	mov    0x8(%esi),%esi
    if (obj_va == NULL || ((uint32_t) obj_va % (uint32_t)PGSIZE != 0)){
c002d7e2:	85 f6                	test   %esi,%esi
c002d7e4:	74 08                	je     c002d7ee <.L86+0x17>
c002d7e6:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
c002d7ec:	74 18                	je     c002d806 <.L86+0x2f>
        f->eax = MAP_FAILED;
c002d7ee:	c7 45 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebp)
c002d7f5:	e9 e1 fb ff ff       	jmp    c002d3db <.L74+0x31>
        f->eax = MAP_FAILED;
c002d7fa:	c7 45 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebp)
c002d801:	e9 d5 fb ff ff       	jmp    c002d3db <.L74+0x31>
    struct thread *cur = thread_current();
c002d806:	e8 3a 38 ff ff       	call   c0021045 <thread_current>
c002d80b:	89 04 24             	mov    %eax,(%esp)
    struct file_handle *fh = syscall_get_file_handle(fd);
c002d80e:	83 ec 0c             	sub    $0xc,%esp
c002d811:	57                   	push   %edi
c002d812:	e8 35 45 ff ff       	call   c0021d4c <syscall_get_file_handle>
    if (fh != NULL){
c002d817:	83 c4 10             	add    $0x10,%esp
c002d81a:	89 44 24 04          	mov    %eax,0x4(%esp)
c002d81e:	85 c0                	test   %eax,%eax
c002d820:	0f 84 f3 00 00 00    	je     c002d919 <.L86+0x142>
        mapid_t mapid = cur->next_mapid++;
c002d826:	8b 0c 24             	mov    (%esp),%ecx
c002d829:	8b 81 d0 00 00 00    	mov    0xd0(%ecx),%eax
c002d82f:	89 44 24 08          	mov    %eax,0x8(%esp)
c002d833:	83 c0 01             	add    $0x1,%eax
c002d836:	89 81 d0 00 00 00    	mov    %eax,0xd0(%ecx)
        struct mmap_handler *mh = malloc(sizeof(struct mmap_handler));
c002d83c:	83 ec 0c             	sub    $0xc,%esp
c002d83f:	6a 28                	push   $0x28
c002d841:	e8 9e 6a ff ff       	call   c00242e4 <malloc>
c002d846:	89 c7                	mov    %eax,%edi
        mh->mapid = mapid;
c002d848:	8b 44 24 18          	mov    0x18(%esp),%eax
c002d84c:	89 07                	mov    %eax,(%edi)
        mh->fd = file_reopen(fh->opened_file);
c002d84e:	83 c4 04             	add    $0x4,%esp
c002d851:	8b 54 24 10          	mov    0x10(%esp),%edx
c002d855:	ff 72 04             	pushl  0x4(%edx)
c002d858:	e8 60 11 00 00       	call   c002e9bd <file_reopen>
c002d85d:	89 47 08             	mov    %eax,0x8(%edi)
        mh->dirty = true;
c002d860:	c6 47 20 01          	movb   $0x1,0x20(%edi)
        mh->is_segment = false;
c002d864:	c6 47 22 00          	movb   $0x0,0x22(%edi)
        mh->is_static = false;
c002d868:	c6 47 21 00          	movb   $0x0,0x21(%edi)
        mh->fa = 0;
c002d86c:	c7 47 0c 00 00 00 00 	movl   $0x0,0xc(%edi)
        off_t file_size = file_length(mh->fd);
c002d873:	89 04 24             	mov    %eax,(%esp)
c002d876:	e8 19 13 00 00       	call   c002eb94 <file_length>
        int num_page = file_size / PGSIZE;
c002d87b:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
c002d881:	83 c4 0c             	add    $0xc,%esp
c002d884:	85 c0                	test   %eax,%eax
c002d886:	0f 49 d0             	cmovns %eax,%edx
c002d889:	c1 fa 0c             	sar    $0xc,%edx
        int last_page_used = file_size % PGSIZE;
c002d88c:	89 c1                	mov    %eax,%ecx
c002d88e:	c1 f9 1f             	sar    $0x1f,%ecx
c002d891:	c1 e9 14             	shr    $0x14,%ecx
c002d894:	01 c8                	add    %ecx,%eax
c002d896:	25 ff 0f 00 00       	and    $0xfff,%eax
        if (last_page_used != 0)
c002d89b:	29 c8                	sub    %ecx,%eax
c002d89d:	89 c1                	mov    %eax,%ecx
c002d89f:	89 44 24 10          	mov    %eax,0x10(%esp)
            num_page++;
c002d8a3:	8d 42 01             	lea    0x1(%edx),%eax
c002d8a6:	85 c9                	test   %ecx,%ecx
c002d8a8:	0f 45 d0             	cmovne %eax,%edx
c002d8ab:	89 54 24 08          	mov    %edx,0x8(%esp)
        if (!mmap_check_va(cur, obj_va, num_page)){
c002d8af:	52                   	push   %edx
c002d8b0:	56                   	push   %esi
c002d8b1:	ff 74 24 0c          	pushl  0xc(%esp)
c002d8b5:	e8 f6 f8 ff ff       	call   c002d1b0 <mmap_check_va>
c002d8ba:	83 c4 10             	add    $0x10,%esp
c002d8bd:	84 c0                	test   %al,%al
c002d8bf:	75 0c                	jne    c002d8cd <.L86+0xf6>
            f->eax = MAP_FAILED;
c002d8c1:	c7 45 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebp)
c002d8c8:	e9 0e fb ff ff       	jmp    c002d3db <.L74+0x31>
        mh->va = obj_va;
c002d8cd:	89 77 04             	mov    %esi,0x4(%edi)
        mh->page_cnt = num_page;
c002d8d0:	8b 44 24 04          	mov    0x4(%esp),%eax
c002d8d4:	89 47 10             	mov    %eax,0x10(%edi)
        mh->num_page_with_segment = num_page;
c002d8d7:	89 47 24             	mov    %eax,0x24(%edi)
        mh->last_page_size = last_page_used;
c002d8da:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002d8de:	89 47 14             	mov    %eax,0x14(%edi)
        list_push_back(&(cur->mmap_list), &(mh->elem));
c002d8e1:	83 ec 08             	sub    $0x8,%esp
c002d8e4:	8d 47 18             	lea    0x18(%edi),%eax
c002d8e7:	50                   	push   %eax
c002d8e8:	8b 74 24 0c          	mov    0xc(%esp),%esi
c002d8ec:	8d 86 c0 00 00 00    	lea    0xc0(%esi),%eax
c002d8f2:	50                   	push   %eax
c002d8f3:	e8 50 c6 ff ff       	call   c0029f48 <list_push_back>
        if(!mmap_install_page(cur, mh)){
c002d8f8:	83 c4 08             	add    $0x8,%esp
c002d8fb:	57                   	push   %edi
c002d8fc:	56                   	push   %esi
c002d8fd:	e8 0e f9 ff ff       	call   c002d210 <mmap_install_page>
c002d902:	83 c4 10             	add    $0x10,%esp
            f->eax = MAP_FAILED;
c002d905:	84 c0                	test   %al,%al
c002d907:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002d90c:	0f 45 44 24 08       	cmovne 0x8(%esp),%eax
c002d911:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002d914:	e9 c2 fa ff ff       	jmp    c002d3db <.L74+0x31>
        f->eax = MAP_FAILED;
c002d919:	c7 45 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebp)
c002d920:	e9 b6 fa ff ff       	jmp    c002d3db <.L74+0x31>

c002d925 <.L88>:
    syscall_chdir(f, *((char **)arg1));
c002d925:	8b 76 04             	mov    0x4(%esi),%esi
  if (!syscall_check_user_string(dir) || strlen(dir) == 0)
c002d928:	83 ec 0c             	sub    $0xc,%esp
c002d92b:	56                   	push   %esi
c002d92c:	e8 95 f5 ff ff       	call   c002cec6 <syscall_check_user_string>
c002d931:	83 c4 10             	add    $0x10,%esp
c002d934:	84 c0                	test   %al,%al
c002d936:	74 05                	je     c002d93d <.L88+0x18>
c002d938:	80 3e 00             	cmpb   $0x0,(%esi)
c002d93b:	75 0c                	jne    c002d949 <.L88+0x24>
    f->eax = false;
c002d93d:	c7 45 1c 00 00 00 00 	movl   $0x0,0x1c(%ebp)
c002d944:	e9 92 fa ff ff       	jmp    c002d3db <.L74+0x31>
  struct thread *cur = thread_current();
c002d949:	e8 f7 36 ff ff       	call   c0021045 <thread_current>
c002d94e:	89 c7                	mov    %eax,%edi
  char *pure_name = malloc(READDIR_MAX_LEN + 1);
c002d950:	83 ec 0c             	sub    $0xc,%esp
c002d953:	6a 0f                	push   $0xf
c002d955:	e8 8a 69 ff ff       	call   c00242e4 <malloc>
c002d95a:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  ASSERT(dir != NULL)
c002d95e:	83 c4 10             	add    $0x10,%esp
c002d961:	85 f6                	test   %esi,%esi
c002d963:	74 4c                	je     c002d9b1 <.L88+0x8c>
  ASSERT(pure_name != NULL)
c002d965:	85 c0                	test   %eax,%eax
c002d967:	74 71                	je     c002d9da <.L88+0xb5>
  if (is_rootpath(dir))
c002d969:	83 ec 0c             	sub    $0xc,%esp
c002d96c:	56                   	push   %esi
c002d96d:	e8 10 09 00 00       	call   c002e282 <is_rootpath>
c002d972:	83 c4 10             	add    $0x10,%esp
c002d975:	84 c0                	test   %al,%al
c002d977:	0f 84 86 00 00 00    	je     c002da03 <.L88+0xde>
    dir_close(cur->current_dir);
c002d97d:	83 ec 0c             	sub    $0xc,%esp
c002d980:	ff b7 b0 00 00 00    	pushl  0xb0(%edi)
c002d986:	e8 16 15 00 00       	call   c002eea1 <dir_close>
    cur->current_dir = dir_open_root();
c002d98b:	e8 c7 14 00 00       	call   c002ee57 <dir_open_root>
c002d990:	89 87 b0 00 00 00    	mov    %eax,0xb0(%edi)
    f->eax = true;
c002d996:	c7 45 1c 01 00 00 00 	movl   $0x1,0x1c(%ebp)
    free(pure_name);
c002d99d:	83 c4 04             	add    $0x4,%esp
c002d9a0:	ff 74 24 28          	pushl  0x28(%esp)
c002d9a4:	e8 f1 6a ff ff       	call   c002449a <free>
c002d9a9:	83 c4 10             	add    $0x10,%esp
c002d9ac:	e9 2a fa ff ff       	jmp    c002d3db <.L74+0x31>
  ASSERT(dir != NULL)
c002d9b1:	83 ec 0c             	sub    $0xc,%esp
c002d9b4:	8d 83 37 4f ff ff    	lea    -0xb0c9(%ebx),%eax
c002d9ba:	50                   	push   %eax
c002d9bb:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002d9c1:	50                   	push   %eax
c002d9c2:	8d 83 8c 29 ff ff    	lea    -0xd674(%ebx),%eax
c002d9c8:	50                   	push   %eax
c002d9c9:	68 05 02 00 00       	push   $0x205
c002d9ce:	8d 83 05 4f ff ff    	lea    -0xb0fb(%ebx),%eax
c002d9d4:	50                   	push   %eax
c002d9d5:	e8 bb be ff ff       	call   c0029895 <debug_panic>
  ASSERT(pure_name != NULL)
c002d9da:	83 ec 0c             	sub    $0xc,%esp
c002d9dd:	8d 83 1e 4f ff ff    	lea    -0xb0e2(%ebx),%eax
c002d9e3:	50                   	push   %eax
c002d9e4:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002d9ea:	50                   	push   %eax
c002d9eb:	8d 83 8c 29 ff ff    	lea    -0xd674(%ebx),%eax
c002d9f1:	50                   	push   %eax
c002d9f2:	68 06 02 00 00       	push   $0x206
c002d9f7:	8d 83 05 4f ff ff    	lea    -0xb0fb(%ebx),%eax
c002d9fd:	50                   	push   %eax
c002d9fe:	e8 92 be ff ff       	call   c0029895 <debug_panic>
    if (path_paser(dir, &target_dir, &pure_name, &is_dir))
c002da03:	8d 44 24 17          	lea    0x17(%esp),%eax
c002da07:	50                   	push   %eax
c002da08:	8d 44 24 20          	lea    0x20(%esp),%eax
c002da0c:	50                   	push   %eax
c002da0d:	8d 44 24 20          	lea    0x20(%esp),%eax
c002da11:	50                   	push   %eax
c002da12:	56                   	push   %esi
c002da13:	e8 87 08 00 00       	call   c002e29f <path_paser>
c002da18:	83 c4 10             	add    $0x10,%esp
c002da1b:	84 c0                	test   %al,%al
c002da1d:	0f 84 c7 00 00 00    	je     c002daea <.L88+0x1c5>
      ASSERT(target_dir != NULL)
c002da23:	8b 44 24 18          	mov    0x18(%esp),%eax
c002da27:	85 c0                	test   %eax,%eax
c002da29:	74 64                	je     c002da8f <.L88+0x16a>
      ASSERT(pure_name != NULL)
c002da2b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c002da2f:	85 d2                	test   %edx,%edx
c002da31:	0f 84 81 00 00 00    	je     c002dab8 <.L88+0x193>
      struct dir *res = subdir_lookup(target_dir, pure_name);
c002da37:	83 ec 08             	sub    $0x8,%esp
c002da3a:	52                   	push   %edx
c002da3b:	50                   	push   %eax
c002da3c:	e8 7c 1b 00 00       	call   c002f5bd <subdir_lookup>
c002da41:	89 c6                	mov    %eax,%esi
      if (res != NULL)
c002da43:	83 c4 10             	add    $0x10,%esp
c002da46:	85 c0                	test   %eax,%eax
c002da48:	0f 84 93 00 00 00    	je     c002dae1 <.L88+0x1bc>
        dir_close(cur->current_dir);
c002da4e:	83 ec 0c             	sub    $0xc,%esp
c002da51:	ff b7 b0 00 00 00    	pushl  0xb0(%edi)
c002da57:	e8 45 14 00 00       	call   c002eea1 <dir_close>
        cur->current_dir = res;
c002da5c:	89 b7 b0 00 00 00    	mov    %esi,0xb0(%edi)
        f->eax = true;
c002da62:	c7 45 1c 01 00 00 00 	movl   $0x1,0x1c(%ebp)
c002da69:	83 c4 10             	add    $0x10,%esp
      dir_close(target_dir);
c002da6c:	83 ec 0c             	sub    $0xc,%esp
c002da6f:	ff 74 24 24          	pushl  0x24(%esp)
c002da73:	e8 29 14 00 00       	call   c002eea1 <dir_close>
c002da78:	83 c4 10             	add    $0x10,%esp
    free(pure_name);
c002da7b:	83 ec 0c             	sub    $0xc,%esp
c002da7e:	ff 74 24 28          	pushl  0x28(%esp)
c002da82:	e8 13 6a ff ff       	call   c002449a <free>
c002da87:	83 c4 10             	add    $0x10,%esp
c002da8a:	e9 4c f9 ff ff       	jmp    c002d3db <.L74+0x31>
      ASSERT(target_dir != NULL)
c002da8f:	83 ec 0c             	sub    $0xc,%esp
c002da92:	8d 83 30 4f ff ff    	lea    -0xb0d0(%ebx),%eax
c002da98:	50                   	push   %eax
c002da99:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002da9f:	50                   	push   %eax
c002daa0:	8d 83 8c 29 ff ff    	lea    -0xd674(%ebx),%eax
c002daa6:	50                   	push   %eax
c002daa7:	68 12 02 00 00       	push   $0x212
c002daac:	8d 83 05 4f ff ff    	lea    -0xb0fb(%ebx),%eax
c002dab2:	50                   	push   %eax
c002dab3:	e8 dd bd ff ff       	call   c0029895 <debug_panic>
      ASSERT(pure_name != NULL)
c002dab8:	83 ec 0c             	sub    $0xc,%esp
c002dabb:	8d 83 1e 4f ff ff    	lea    -0xb0e2(%ebx),%eax
c002dac1:	50                   	push   %eax
c002dac2:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002dac8:	50                   	push   %eax
c002dac9:	8d 83 8c 29 ff ff    	lea    -0xd674(%ebx),%eax
c002dacf:	50                   	push   %eax
c002dad0:	68 13 02 00 00       	push   $0x213
c002dad5:	8d 83 05 4f ff ff    	lea    -0xb0fb(%ebx),%eax
c002dadb:	50                   	push   %eax
c002dadc:	e8 b4 bd ff ff       	call   c0029895 <debug_panic>
        f->eax = false;
c002dae1:	c7 45 1c 00 00 00 00 	movl   $0x0,0x1c(%ebp)
c002dae8:	eb 82                	jmp    c002da6c <.L88+0x147>
      f->eax = false;
c002daea:	c7 45 1c 00 00 00 00 	movl   $0x0,0x1c(%ebp)
c002daf1:	eb 88                	jmp    c002da7b <.L88+0x156>

c002daf3 <.L89>:
    syscall_mkdir(f, *((char **)arg1));
c002daf3:	8b 76 04             	mov    0x4(%esi),%esi
  if (!syscall_check_user_string(dir) || strlen(dir) == 0)
c002daf6:	83 ec 0c             	sub    $0xc,%esp
c002daf9:	56                   	push   %esi
c002dafa:	e8 c7 f3 ff ff       	call   c002cec6 <syscall_check_user_string>
c002daff:	83 c4 10             	add    $0x10,%esp
c002db02:	84 c0                	test   %al,%al
c002db04:	74 05                	je     c002db0b <.L89+0x18>
c002db06:	80 3e 00             	cmpb   $0x0,(%esi)
c002db09:	75 0c                	jne    c002db17 <.L89+0x24>
    f->eax = false;
c002db0b:	c7 45 1c 00 00 00 00 	movl   $0x0,0x1c(%ebp)
c002db12:	e9 c4 f8 ff ff       	jmp    c002d3db <.L74+0x31>
  char *pure_name = malloc(READDIR_MAX_LEN + 1);
c002db17:	83 ec 0c             	sub    $0xc,%esp
c002db1a:	6a 0f                	push   $0xf
c002db1c:	e8 c3 67 ff ff       	call   c00242e4 <malloc>
c002db21:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  ASSERT(dir != NULL)
c002db25:	83 c4 10             	add    $0x10,%esp
c002db28:	85 f6                	test   %esi,%esi
c002db2a:	74 2f                	je     c002db5b <.L89+0x68>
  ASSERT(pure_name != NULL)
c002db2c:	85 c0                	test   %eax,%eax
c002db2e:	74 54                	je     c002db84 <.L89+0x91>
  if (!is_rootpath(dir) && path_paser(dir, &target_dir, &pure_name, &is_dir))
c002db30:	83 ec 0c             	sub    $0xc,%esp
c002db33:	56                   	push   %esi
c002db34:	e8 49 07 00 00       	call   c002e282 <is_rootpath>
c002db39:	83 c4 10             	add    $0x10,%esp
c002db3c:	84 c0                	test   %al,%al
c002db3e:	74 6d                	je     c002dbad <.L89+0xba>
    f->eax = false;
c002db40:	c7 45 1c 00 00 00 00 	movl   $0x0,0x1c(%ebp)
  free(pure_name);
c002db47:	83 ec 0c             	sub    $0xc,%esp
c002db4a:	ff 74 24 28          	pushl  0x28(%esp)
c002db4e:	e8 47 69 ff ff       	call   c002449a <free>
c002db53:	83 c4 10             	add    $0x10,%esp
c002db56:	e9 80 f8 ff ff       	jmp    c002d3db <.L74+0x31>
  ASSERT(dir != NULL)
c002db5b:	83 ec 0c             	sub    $0xc,%esp
c002db5e:	8d 83 37 4f ff ff    	lea    -0xb0c9(%ebx),%eax
c002db64:	50                   	push   %eax
c002db65:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002db6b:	50                   	push   %eax
c002db6c:	8d 83 7c 29 ff ff    	lea    -0xd684(%ebx),%eax
c002db72:	50                   	push   %eax
c002db73:	68 30 02 00 00       	push   $0x230
c002db78:	8d 83 05 4f ff ff    	lea    -0xb0fb(%ebx),%eax
c002db7e:	50                   	push   %eax
c002db7f:	e8 11 bd ff ff       	call   c0029895 <debug_panic>
  ASSERT(pure_name != NULL)
c002db84:	83 ec 0c             	sub    $0xc,%esp
c002db87:	8d 83 1e 4f ff ff    	lea    -0xb0e2(%ebx),%eax
c002db8d:	50                   	push   %eax
c002db8e:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002db94:	50                   	push   %eax
c002db95:	8d 83 7c 29 ff ff    	lea    -0xd684(%ebx),%eax
c002db9b:	50                   	push   %eax
c002db9c:	68 31 02 00 00       	push   $0x231
c002dba1:	8d 83 05 4f ff ff    	lea    -0xb0fb(%ebx),%eax
c002dba7:	50                   	push   %eax
c002dba8:	e8 e8 bc ff ff       	call   c0029895 <debug_panic>
  if (!is_rootpath(dir) && path_paser(dir, &target_dir, &pure_name, &is_dir))
c002dbad:	8d 44 24 17          	lea    0x17(%esp),%eax
c002dbb1:	50                   	push   %eax
c002dbb2:	8d 44 24 20          	lea    0x20(%esp),%eax
c002dbb6:	50                   	push   %eax
c002dbb7:	8d 44 24 20          	lea    0x20(%esp),%eax
c002dbbb:	50                   	push   %eax
c002dbbc:	56                   	push   %esi
c002dbbd:	e8 dd 06 00 00       	call   c002e29f <path_paser>
c002dbc2:	83 c4 10             	add    $0x10,%esp
c002dbc5:	84 c0                	test   %al,%al
c002dbc7:	0f 84 73 ff ff ff    	je     c002db40 <.L89+0x4d>
    ASSERT(target_dir != NULL)
c002dbcd:	8b 44 24 18          	mov    0x18(%esp),%eax
c002dbd1:	85 c0                	test   %eax,%eax
c002dbd3:	74 30                	je     c002dc05 <.L89+0x112>
    ASSERT(pure_name != NULL)
c002dbd5:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c002dbd9:	85 d2                	test   %edx,%edx
c002dbdb:	74 51                	je     c002dc2e <.L89+0x13b>
    bool res = subdir_create(target_dir, pure_name);
c002dbdd:	83 ec 08             	sub    $0x8,%esp
c002dbe0:	52                   	push   %edx
c002dbe1:	50                   	push   %eax
c002dbe2:	e8 da 18 00 00       	call   c002f4c1 <subdir_create>
c002dbe7:	89 c6                	mov    %eax,%esi
    dir_close(target_dir);
c002dbe9:	83 c4 04             	add    $0x4,%esp
c002dbec:	ff 74 24 24          	pushl  0x24(%esp)
c002dbf0:	e8 ac 12 00 00       	call   c002eea1 <dir_close>
    f->eax = res;
c002dbf5:	89 f0                	mov    %esi,%eax
c002dbf7:	0f b6 f0             	movzbl %al,%esi
c002dbfa:	89 75 1c             	mov    %esi,0x1c(%ebp)
c002dbfd:	83 c4 10             	add    $0x10,%esp
c002dc00:	e9 42 ff ff ff       	jmp    c002db47 <.L89+0x54>
    ASSERT(target_dir != NULL)
c002dc05:	83 ec 0c             	sub    $0xc,%esp
c002dc08:	8d 83 30 4f ff ff    	lea    -0xb0d0(%ebx),%eax
c002dc0e:	50                   	push   %eax
c002dc0f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002dc15:	50                   	push   %eax
c002dc16:	8d 83 7c 29 ff ff    	lea    -0xd684(%ebx),%eax
c002dc1c:	50                   	push   %eax
c002dc1d:	68 34 02 00 00       	push   $0x234
c002dc22:	8d 83 05 4f ff ff    	lea    -0xb0fb(%ebx),%eax
c002dc28:	50                   	push   %eax
c002dc29:	e8 67 bc ff ff       	call   c0029895 <debug_panic>
    ASSERT(pure_name != NULL)
c002dc2e:	83 ec 0c             	sub    $0xc,%esp
c002dc31:	8d 83 1e 4f ff ff    	lea    -0xb0e2(%ebx),%eax
c002dc37:	50                   	push   %eax
c002dc38:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002dc3e:	50                   	push   %eax
c002dc3f:	8d 83 7c 29 ff ff    	lea    -0xd684(%ebx),%eax
c002dc45:	50                   	push   %eax
c002dc46:	68 35 02 00 00       	push   $0x235
c002dc4b:	8d 83 05 4f ff ff    	lea    -0xb0fb(%ebx),%eax
c002dc51:	50                   	push   %eax
c002dc52:	e8 3e bc ff ff       	call   c0029895 <debug_panic>

c002dc57 <.L90>:
    syscall_readdir(f, *((int *)arg1), *((char **)arg2));
c002dc57:	8b 7e 04             	mov    0x4(%esi),%edi
  if (fd == 0 || fd == 1 || !syscall_check_user_buffer(name, READDIR_MAX_LEN + 1, false))
c002dc5a:	83 ff 01             	cmp    $0x1,%edi
c002dc5d:	76 17                	jbe    c002dc76 <.L90+0x1f>
    syscall_readdir(f, *((int *)arg1), *((char **)arg2));
c002dc5f:	8b 76 08             	mov    0x8(%esi),%esi
  if (fd == 0 || fd == 1 || !syscall_check_user_buffer(name, READDIR_MAX_LEN + 1, false))
c002dc62:	83 ec 04             	sub    $0x4,%esp
c002dc65:	6a 00                	push   $0x0
c002dc67:	6a 0f                	push   $0xf
c002dc69:	56                   	push   %esi
c002dc6a:	e8 d1 f2 ff ff       	call   c002cf40 <syscall_check_user_buffer>
c002dc6f:	83 c4 10             	add    $0x10,%esp
c002dc72:	84 c0                	test   %al,%al
c002dc74:	75 0c                	jne    c002dc82 <.L90+0x2b>
    f->eax = false;
c002dc76:	c7 45 1c 00 00 00 00 	movl   $0x0,0x1c(%ebp)
c002dc7d:	e9 59 f7 ff ff       	jmp    c002d3db <.L74+0x31>
  struct file_handle *fh = syscall_get_file_handle(fd);
c002dc82:	83 ec 0c             	sub    $0xc,%esp
c002dc85:	57                   	push   %edi
c002dc86:	e8 c1 40 ff ff       	call   c0021d4c <syscall_get_file_handle>
c002dc8b:	89 c7                	mov    %eax,%edi
  if (fh != NULL && is_dirfile(fh))
c002dc8d:	83 c4 10             	add    $0x10,%esp
c002dc90:	85 c0                	test   %eax,%eax
c002dc92:	74 10                	je     c002dca4 <.L90+0x4d>
c002dc94:	83 ec 0c             	sub    $0xc,%esp
c002dc97:	50                   	push   %eax
c002dc98:	e8 f9 1e 00 00       	call   c002fb96 <is_dirfile>
c002dc9d:	83 c4 10             	add    $0x10,%esp
c002dca0:	84 c0                	test   %al,%al
c002dca2:	75 0c                	jne    c002dcb0 <.L90+0x59>
    f->eax = false;
c002dca4:	c7 45 1c 00 00 00 00 	movl   $0x0,0x1c(%ebp)
c002dcab:	e9 2b f7 ff ff       	jmp    c002d3db <.L74+0x31>
    f->eax = dir_readdir(fh->opened_dir, name);
c002dcb0:	83 ec 08             	sub    $0x8,%esp
c002dcb3:	56                   	push   %esi
c002dcb4:	ff 77 0c             	pushl  0xc(%edi)
c002dcb7:	e8 a0 17 00 00       	call   c002f45c <dir_readdir>
c002dcbc:	0f b6 c0             	movzbl %al,%eax
c002dcbf:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002dcc2:	83 c4 10             	add    $0x10,%esp
c002dcc5:	e9 11 f7 ff ff       	jmp    c002d3db <.L74+0x31>

c002dcca <.L91>:
    syscall_isdir(f, *((int *)arg1));
c002dcca:	8b 46 04             	mov    0x4(%esi),%eax
  if (fd == 0 || fd == 1)
c002dccd:	83 f8 01             	cmp    $0x1,%eax
c002dcd0:	76 2c                	jbe    c002dcfe <.L91+0x34>
  struct file_handle *fh = syscall_get_file_handle(fd);
c002dcd2:	83 ec 0c             	sub    $0xc,%esp
c002dcd5:	50                   	push   %eax
c002dcd6:	e8 71 40 ff ff       	call   c0021d4c <syscall_get_file_handle>
  f->eax = fh != NULL && is_dirfile(fh);
c002dcdb:	83 c4 10             	add    $0x10,%esp
c002dcde:	ba 00 00 00 00       	mov    $0x0,%edx
c002dce3:	85 c0                	test   %eax,%eax
c002dce5:	74 0f                	je     c002dcf6 <.L91+0x2c>
c002dce7:	83 ec 0c             	sub    $0xc,%esp
c002dcea:	50                   	push   %eax
c002dceb:	e8 a6 1e 00 00       	call   c002fb96 <is_dirfile>
c002dcf0:	0f b6 d0             	movzbl %al,%edx
c002dcf3:	83 c4 10             	add    $0x10,%esp
c002dcf6:	89 55 1c             	mov    %edx,0x1c(%ebp)
c002dcf9:	e9 dd f6 ff ff       	jmp    c002d3db <.L74+0x31>
    f->eax = false;
c002dcfe:	c7 45 1c 00 00 00 00 	movl   $0x0,0x1c(%ebp)
c002dd05:	e9 d1 f6 ff ff       	jmp    c002d3db <.L74+0x31>

c002dd0a <.L92>:
    syscall_inumber(f, *((int *)arg1));
c002dd0a:	8b 76 04             	mov    0x4(%esi),%esi
  if (fd == 0 || fd == 1)
c002dd0d:	83 fe 01             	cmp    $0x1,%esi
c002dd10:	76 1c                	jbe    c002dd2e <.L92+0x24>
  struct file_handle *fh = syscall_get_file_handle(fd);
c002dd12:	83 ec 0c             	sub    $0xc,%esp
c002dd15:	56                   	push   %esi
c002dd16:	e8 31 40 ff ff       	call   c0021d4c <syscall_get_file_handle>
  if (fh != NULL)
c002dd1b:	83 c4 10             	add    $0x10,%esp
c002dd1e:	85 c0                	test   %eax,%eax
c002dd20:	75 1c                	jne    c002dd3e <.L92+0x34>
    f->eax = -1;
c002dd22:	c7 45 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebp)
c002dd29:	e9 ad f6 ff ff       	jmp    c002d3db <.L74+0x31>
    thread_exit_with_return_value(f, -1);
c002dd2e:	83 ec 08             	sub    $0x8,%esp
c002dd31:	6a ff                	push   $0xffffffff
c002dd33:	55                   	push   %ebp
c002dd34:	e8 cc 3f ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002dd39:	83 c4 10             	add    $0x10,%esp
c002dd3c:	eb d4                	jmp    c002dd12 <.L92+0x8>
    f->eax = inode_get_inumber(file_get_inode(fh->opened_file));
c002dd3e:	83 ec 0c             	sub    $0xc,%esp
c002dd41:	ff 70 04             	pushl  0x4(%eax)
c002dd44:	e8 9b 0c 00 00       	call   c002e9e4 <file_get_inode>
c002dd49:	89 04 24             	mov    %eax,(%esp)
c002dd4c:	e8 db 24 00 00       	call   c003022c <inode_get_inumber>
c002dd51:	89 45 1c             	mov    %eax,0x1c(%ebp)
c002dd54:	83 c4 10             	add    $0x10,%esp
c002dd57:	e9 7f f6 ff ff       	jmp    c002d3db <.L74+0x31>

c002dd5c <.L77>:
    syscall_create(f, *((void **)arg1), *((unsigned *)arg2));
c002dd5c:	8b 46 08             	mov    0x8(%esi),%eax
c002dd5f:	89 04 24             	mov    %eax,(%esp)
c002dd62:	8b 7e 04             	mov    0x4(%esi),%edi
  if (!syscall_check_user_string(name))
c002dd65:	83 ec 0c             	sub    $0xc,%esp
c002dd68:	57                   	push   %edi
c002dd69:	e8 58 f1 ff ff       	call   c002cec6 <syscall_check_user_string>
c002dd6e:	83 c4 10             	add    $0x10,%esp
c002dd71:	84 c0                	test   %al,%al
c002dd73:	74 32                	je     c002dda7 <.L77+0x4b>
  lock_acquire(&filesys_lock);
c002dd75:	83 ec 0c             	sub    $0xc,%esp
c002dd78:	8d b3 c4 1d 00 00    	lea    0x1dc4(%ebx),%esi
c002dd7e:	56                   	push   %esi
c002dd7f:	e8 3e 58 ff ff       	call   c00235c2 <lock_acquire>
  f->eax = (uint32_t)filesys_create(name, initial_size);
c002dd84:	83 c4 08             	add    $0x8,%esp
c002dd87:	ff 74 24 08          	pushl  0x8(%esp)
c002dd8b:	57                   	push   %edi
c002dd8c:	e8 e8 07 00 00       	call   c002e579 <filesys_create>
c002dd91:	0f b6 c0             	movzbl %al,%eax
c002dd94:	89 45 1c             	mov    %eax,0x1c(%ebp)
  lock_release(&filesys_lock);
c002dd97:	89 34 24             	mov    %esi,(%esp)
c002dd9a:	e8 f7 59 ff ff       	call   c0023796 <lock_release>
c002dd9f:	83 c4 10             	add    $0x10,%esp
c002dda2:	e9 34 f6 ff ff       	jmp    c002d3db <.L74+0x31>
    thread_exit_with_return_value(f, -1);
c002dda7:	83 ec 08             	sub    $0x8,%esp
c002ddaa:	6a ff                	push   $0xffffffff
c002ddac:	55                   	push   %ebp
c002ddad:	e8 53 3f ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002ddb2:	83 c4 10             	add    $0x10,%esp
c002ddb5:	eb be                	jmp    c002dd75 <.L77+0x19>

c002ddb7 <.L83>:
    syscall_seek(f, *((int *)arg1), *((unsigned *)arg2));
c002ddb7:	8b 7e 08             	mov    0x8(%esi),%edi
  struct file_handle *t = syscall_get_file_handle(fd);
c002ddba:	83 ec 0c             	sub    $0xc,%esp
c002ddbd:	ff 76 04             	pushl  0x4(%esi)
c002ddc0:	e8 87 3f ff ff       	call   c0021d4c <syscall_get_file_handle>
c002ddc5:	89 c6                	mov    %eax,%esi
  if (t != NULL)
c002ddc7:	83 c4 10             	add    $0x10,%esp
c002ddca:	85 c0                	test   %eax,%eax
c002ddcc:	74 2b                	je     c002ddf9 <.L83+0x42>
    lock_acquire(&filesys_lock);
c002ddce:	83 ec 0c             	sub    $0xc,%esp
c002ddd1:	8d ab c4 1d 00 00    	lea    0x1dc4(%ebx),%ebp
c002ddd7:	55                   	push   %ebp
c002ddd8:	e8 e5 57 ff ff       	call   c00235c2 <lock_acquire>
    file_seek(t->opened_file, position);
c002dddd:	83 c4 08             	add    $0x8,%esp
c002dde0:	57                   	push   %edi
c002dde1:	ff 76 04             	pushl  0x4(%esi)
c002dde4:	e8 fa 0d 00 00       	call   c002ebe3 <file_seek>
    lock_release(&filesys_lock);
c002dde9:	89 2c 24             	mov    %ebp,(%esp)
c002ddec:	e8 a5 59 ff ff       	call   c0023796 <lock_release>
c002ddf1:	83 c4 10             	add    $0x10,%esp
c002ddf4:	e9 e2 f5 ff ff       	jmp    c002d3db <.L74+0x31>
    thread_exit_with_return_value(f, -1);
c002ddf9:	83 ec 08             	sub    $0x8,%esp
c002ddfc:	6a ff                	push   $0xffffffff
c002ddfe:	55                   	push   %ebp
c002ddff:	e8 01 3f ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002de04:	83 c4 10             	add    $0x10,%esp
c002de07:	e9 cf f5 ff ff       	jmp    c002d3db <.L74+0x31>

c002de0c <.L81>:
    syscall_read(f, *((int *)arg1), *((void **)arg2), *((unsigned *)arg3));
c002de0c:	8b 46 0c             	mov    0xc(%esi),%eax
c002de0f:	89 04 24             	mov    %eax,(%esp)
c002de12:	8b 7e 08             	mov    0x8(%esi),%edi
c002de15:	8b 76 04             	mov    0x4(%esi),%esi
  if (!syscall_check_user_buffer(buffer, size, true))
c002de18:	83 ec 04             	sub    $0x4,%esp
c002de1b:	6a 01                	push   $0x1
c002de1d:	50                   	push   %eax
c002de1e:	57                   	push   %edi
c002de1f:	e8 1c f1 ff ff       	call   c002cf40 <syscall_check_user_buffer>
c002de24:	83 c4 10             	add    $0x10,%esp
c002de27:	84 c0                	test   %al,%al
c002de29:	74 2c                	je     c002de57 <.L81+0x4b>
  if (fd == STDOUT_FILENO)
c002de2b:	83 fe 01             	cmp    $0x1,%esi
c002de2e:	74 37                	je     c002de67 <.L81+0x5b>
  if (fd == STDIN_FILENO)
c002de30:	85 f6                	test   %esi,%esi
c002de32:	75 41                	jne    c002de75 <.L81+0x69>
    while (size-- != 0)
c002de34:	8b 04 24             	mov    (%esp),%eax
c002de37:	85 c0                	test   %eax,%eax
c002de39:	0f 84 9c f5 ff ff    	je     c002d3db <.L74+0x31>
c002de3f:	01 f8                	add    %edi,%eax
c002de41:	89 c5                	mov    %eax,%ebp
      *(char *)str++ = input_getc();
c002de43:	e8 6d 8d ff ff       	call   c0026bb5 <input_getc>
c002de48:	83 c7 01             	add    $0x1,%edi
c002de4b:	88 47 ff             	mov    %al,-0x1(%edi)
    while (size-- != 0)
c002de4e:	39 fd                	cmp    %edi,%ebp
c002de50:	75 f1                	jne    c002de43 <.L81+0x37>
c002de52:	e9 84 f5 ff ff       	jmp    c002d3db <.L74+0x31>
    thread_exit_with_return_value(f, -1);
c002de57:	83 ec 08             	sub    $0x8,%esp
c002de5a:	6a ff                	push   $0xffffffff
c002de5c:	55                   	push   %ebp
c002de5d:	e8 a3 3e ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002de62:	83 c4 10             	add    $0x10,%esp
c002de65:	eb c4                	jmp    c002de2b <.L81+0x1f>
    thread_exit_with_return_value(f, -1);
c002de67:	83 ec 08             	sub    $0x8,%esp
c002de6a:	6a ff                	push   $0xffffffff
c002de6c:	55                   	push   %ebp
c002de6d:	e8 93 3e ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002de72:	83 c4 10             	add    $0x10,%esp
    struct file_handle *t = syscall_get_file_handle(fd);
c002de75:	83 ec 0c             	sub    $0xc,%esp
c002de78:	56                   	push   %esi
c002de79:	e8 ce 3e ff ff       	call   c0021d4c <syscall_get_file_handle>
c002de7e:	89 c6                	mov    %eax,%esi
    if (t != NULL && !inode_isdir(file_get_inode(t->opened_file)))
c002de80:	83 c4 10             	add    $0x10,%esp
c002de83:	85 c0                	test   %eax,%eax
c002de85:	74 1a                	je     c002dea1 <.L81+0x95>
c002de87:	83 ec 0c             	sub    $0xc,%esp
c002de8a:	ff 70 04             	pushl  0x4(%eax)
c002de8d:	e8 52 0b 00 00       	call   c002e9e4 <file_get_inode>
c002de92:	89 04 24             	mov    %eax,(%esp)
c002de95:	e8 e6 28 00 00       	call   c0030780 <inode_isdir>
c002de9a:	83 c4 10             	add    $0x10,%esp
c002de9d:	85 c0                	test   %eax,%eax
c002de9f:	74 13                	je     c002deb4 <.L81+0xa8>
      thread_exit_with_return_value(f, -1);
c002dea1:	83 ec 08             	sub    $0x8,%esp
c002dea4:	6a ff                	push   $0xffffffff
c002dea6:	55                   	push   %ebp
c002dea7:	e8 59 3e ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002deac:	83 c4 10             	add    $0x10,%esp
c002deaf:	e9 27 f5 ff ff       	jmp    c002d3db <.L74+0x31>
      lock_acquire(&filesys_lock);
c002deb4:	83 ec 0c             	sub    $0xc,%esp
c002deb7:	8d 83 c4 1d 00 00    	lea    0x1dc4(%ebx),%eax
c002debd:	89 44 24 10          	mov    %eax,0x10(%esp)
c002dec1:	50                   	push   %eax
c002dec2:	e8 fb 56 ff ff       	call   c00235c2 <lock_acquire>
      f->eax = (uint32_t)file_read(t->opened_file, (void *)buffer, size);
c002dec7:	83 c4 0c             	add    $0xc,%esp
c002deca:	ff 74 24 04          	pushl  0x4(%esp)
c002dece:	57                   	push   %edi
c002decf:	ff 76 04             	pushl  0x4(%esi)
c002ded2:	e8 14 0b 00 00       	call   c002e9eb <file_read>
c002ded7:	89 45 1c             	mov    %eax,0x1c(%ebp)
      lock_release(&filesys_lock);
c002deda:	83 c4 04             	add    $0x4,%esp
c002dedd:	ff 74 24 10          	pushl  0x10(%esp)
c002dee1:	e8 b0 58 ff ff       	call   c0023796 <lock_release>
c002dee6:	83 c4 10             	add    $0x10,%esp
c002dee9:	e9 ed f4 ff ff       	jmp    c002d3db <.L74+0x31>

c002deee <.L82>:
    syscall_write(f, *((int *)arg1), *((void **)arg2),
c002deee:	8b 46 0c             	mov    0xc(%esi),%eax
c002def1:	89 04 24             	mov    %eax,(%esp)
c002def4:	8b 7e 08             	mov    0x8(%esi),%edi
c002def7:	8b 76 04             	mov    0x4(%esi),%esi
  if (!syscall_check_user_buffer(buffer, size, false))
c002defa:	83 ec 04             	sub    $0x4,%esp
c002defd:	6a 00                	push   $0x0
c002deff:	50                   	push   %eax
c002df00:	57                   	push   %edi
c002df01:	e8 3a f0 ff ff       	call   c002cf40 <syscall_check_user_buffer>
c002df06:	83 c4 10             	add    $0x10,%esp
c002df09:	84 c0                	test   %al,%al
c002df0b:	74 48                	je     c002df55 <.L82+0x67>
  if (fd == STDIN_FILENO)
c002df0d:	85 f6                	test   %esi,%esi
c002df0f:	74 54                	je     c002df65 <.L82+0x77>
  if (fd == STDOUT_FILENO)
c002df11:	83 fe 01             	cmp    $0x1,%esi
c002df14:	74 5f                	je     c002df75 <.L82+0x87>
    struct file_handle *t = syscall_get_file_handle(fd);
c002df16:	83 ec 0c             	sub    $0xc,%esp
c002df19:	56                   	push   %esi
c002df1a:	e8 2d 3e ff ff       	call   c0021d4c <syscall_get_file_handle>
c002df1f:	89 c6                	mov    %eax,%esi
    if (t != NULL && !inode_isdir(file_get_inode(t->opened_file)))
c002df21:	83 c4 10             	add    $0x10,%esp
c002df24:	85 c0                	test   %eax,%eax
c002df26:	74 1a                	je     c002df42 <.L82+0x54>
c002df28:	83 ec 0c             	sub    $0xc,%esp
c002df2b:	ff 70 04             	pushl  0x4(%eax)
c002df2e:	e8 b1 0a 00 00       	call   c002e9e4 <file_get_inode>
c002df33:	89 04 24             	mov    %eax,(%esp)
c002df36:	e8 45 28 00 00       	call   c0030780 <inode_isdir>
c002df3b:	83 c4 10             	add    $0x10,%esp
c002df3e:	85 c0                	test   %eax,%eax
c002df40:	74 48                	je     c002df8a <.L82+0x9c>
      thread_exit_with_return_value(f, -1);
c002df42:	83 ec 08             	sub    $0x8,%esp
c002df45:	6a ff                	push   $0xffffffff
c002df47:	55                   	push   %ebp
c002df48:	e8 b8 3d ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002df4d:	83 c4 10             	add    $0x10,%esp
c002df50:	e9 86 f4 ff ff       	jmp    c002d3db <.L74+0x31>
    thread_exit_with_return_value(f, -1);
c002df55:	83 ec 08             	sub    $0x8,%esp
c002df58:	6a ff                	push   $0xffffffff
c002df5a:	55                   	push   %ebp
c002df5b:	e8 a5 3d ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002df60:	83 c4 10             	add    $0x10,%esp
c002df63:	eb a8                	jmp    c002df0d <.L82+0x1f>
    thread_exit_with_return_value(f, -1);
c002df65:	83 ec 08             	sub    $0x8,%esp
c002df68:	6a ff                	push   $0xffffffff
c002df6a:	55                   	push   %ebp
c002df6b:	e8 95 3d ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002df70:	83 c4 10             	add    $0x10,%esp
c002df73:	eb a1                	jmp    c002df16 <.L82+0x28>
    putbuf(buffer, size);
c002df75:	83 ec 08             	sub    $0x8,%esp
c002df78:	ff 74 24 08          	pushl  0x8(%esp)
c002df7c:	57                   	push   %edi
c002df7d:	e8 2b d9 ff ff       	call   c002b8ad <putbuf>
c002df82:	83 c4 10             	add    $0x10,%esp
c002df85:	e9 51 f4 ff ff       	jmp    c002d3db <.L74+0x31>
      lock_acquire(&filesys_lock);
c002df8a:	83 ec 0c             	sub    $0xc,%esp
c002df8d:	8d 83 c4 1d 00 00    	lea    0x1dc4(%ebx),%eax
c002df93:	89 44 24 10          	mov    %eax,0x10(%esp)
c002df97:	50                   	push   %eax
c002df98:	e8 25 56 ff ff       	call   c00235c2 <lock_acquire>
      f->eax = (uint32_t)file_write(t->opened_file, (void *)buffer, size);
c002df9d:	83 c4 0c             	add    $0xc,%esp
c002dfa0:	ff 74 24 04          	pushl  0x4(%esp)
c002dfa4:	57                   	push   %edi
c002dfa5:	ff 76 04             	pushl  0x4(%esi)
c002dfa8:	e8 98 0a 00 00       	call   c002ea45 <file_write>
c002dfad:	89 45 1c             	mov    %eax,0x1c(%ebp)
      lock_release(&filesys_lock);
c002dfb0:	83 c4 04             	add    $0x4,%esp
c002dfb3:	ff 74 24 10          	pushl  0x10(%esp)
c002dfb7:	e8 da 57 ff ff       	call   c0023796 <lock_release>
c002dfbc:	83 c4 10             	add    $0x10,%esp
c002dfbf:	e9 17 f4 ff ff       	jmp    c002d3db <.L74+0x31>
    thread_exit_with_return_value(f, -1);
c002dfc4:	83 ec 08             	sub    $0x8,%esp
c002dfc7:	6a ff                	push   $0xffffffff
c002dfc9:	55                   	push   %ebp
c002dfca:	e8 36 3d ff ff       	call   c0021d05 <thread_exit_with_return_value>
c002dfcf:	83 c4 10             	add    $0x10,%esp
}
c002dfd2:	e9 04 f4 ff ff       	jmp    c002d3db <.L74+0x31>

c002dfd7 <mmap_load_segment>:
bool mmap_load_segment(struct file *file, off_t ofs, uint8_t *upage, uint32_t read_bytes, uint32_t zero_bytes, bool writable){
c002dfd7:	55                   	push   %ebp
c002dfd8:	57                   	push   %edi
c002dfd9:	56                   	push   %esi
c002dfda:	53                   	push   %ebx
c002dfdb:	83 ec 1c             	sub    $0x1c,%esp
c002dfde:	e8 03 45 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002dfe3:	81 c3 59 2c 01 00    	add    $0x12c59,%ebx
c002dfe9:	8b 44 24 44          	mov    0x44(%esp),%eax
c002dfed:	89 44 24 0c          	mov    %eax,0xc(%esp)
    ASSERT(!((read_bytes + zero_bytes) & PGMASK))
c002dff1:	8b 7c 24 3c          	mov    0x3c(%esp),%edi
c002dff5:	03 7c 24 40          	add    0x40(%esp),%edi
c002dff9:	f7 c7 ff 0f 00 00    	test   $0xfff,%edi
c002dfff:	75 76                	jne    c002e077 <mmap_load_segment+0xa0>
    struct thread* cur = thread_current();
c002e001:	e8 3f 30 ff ff       	call   c0021045 <thread_current>
c002e006:	89 c2                	mov    %eax,%edx
    mapid_t mapid = cur->next_mapid++;
c002e008:	8b a8 d0 00 00 00    	mov    0xd0(%eax),%ebp
c002e00e:	8d 45 01             	lea    0x1(%ebp),%eax
c002e011:	89 54 24 08          	mov    %edx,0x8(%esp)
c002e015:	89 82 d0 00 00 00    	mov    %eax,0xd0(%edx)
    struct mmap_handler *mh = malloc(sizeof(struct mmap_handler));
c002e01b:	83 ec 0c             	sub    $0xc,%esp
c002e01e:	6a 28                	push   $0x28
c002e020:	e8 bf 62 ff ff       	call   c00242e4 <malloc>
c002e025:	89 c6                	mov    %eax,%esi
    mh->mapid = mapid;
c002e027:	89 28                	mov    %ebp,(%eax)
    mh->fd = file;
c002e029:	8b 44 24 40          	mov    0x40(%esp),%eax
c002e02d:	89 46 08             	mov    %eax,0x8(%esi)
    mh->dirty = writable;
c002e030:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c002e034:	88 4e 20             	mov    %cl,0x20(%esi)
    mh->is_static = writable;
c002e037:	88 4e 21             	mov    %cl,0x21(%esi)
    int num_page = read_bytes / PGSIZE;
c002e03a:	8b 6c 24 4c          	mov    0x4c(%esp),%ebp
c002e03e:	c1 ed 0c             	shr    $0xc,%ebp
    int total_num_page = ((read_bytes + zero_bytes) / PGSIZE);
c002e041:	c1 ef 0c             	shr    $0xc,%edi
    if (last_page_used != 0)
c002e044:	83 c4 0c             	add    $0xc,%esp
c002e047:	8b 44 24 40          	mov    0x40(%esp),%eax
c002e04b:	25 ff 0f 00 00       	and    $0xfff,%eax
c002e050:	89 44 24 10          	mov    %eax,0x10(%esp)
        num_page++;
c002e054:	83 f8 01             	cmp    $0x1,%eax
c002e057:	83 dd ff             	sbb    $0xffffffff,%ebp
    if (!mmap_check_va(cur, upage, total_num_page))
c002e05a:	57                   	push   %edi
c002e05b:	ff 74 24 40          	pushl  0x40(%esp)
c002e05f:	ff 74 24 14          	pushl  0x14(%esp)
c002e063:	e8 48 f1 ff ff       	call   c002d1b0 <mmap_check_va>
c002e068:	83 c4 10             	add    $0x10,%esp
c002e06b:	84 c0                	test   %al,%al
c002e06d:	75 31                	jne    c002e0a0 <mmap_load_segment+0xc9>
}
c002e06f:	83 c4 1c             	add    $0x1c,%esp
c002e072:	5b                   	pop    %ebx
c002e073:	5e                   	pop    %esi
c002e074:	5f                   	pop    %edi
c002e075:	5d                   	pop    %ebp
c002e076:	c3                   	ret    
    ASSERT(!((read_bytes + zero_bytes) & PGMASK))
c002e077:	83 ec 0c             	sub    $0xc,%esp
c002e07a:	8d 83 88 4f ff ff    	lea    -0xb078(%ebx),%eax
c002e080:	50                   	push   %eax
c002e081:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002e087:	50                   	push   %eax
c002e088:	8d 83 68 29 ff ff    	lea    -0xd698(%ebx),%eax
c002e08e:	50                   	push   %eax
c002e08f:	68 a3 02 00 00       	push   $0x2a3
c002e094:	8d 83 05 4f ff ff    	lea    -0xb0fb(%ebx),%eax
c002e09a:	50                   	push   %eax
c002e09b:	e8 f5 b7 ff ff       	call   c0029895 <debug_panic>
    mh->va = upage;
c002e0a0:	8b 44 24 38          	mov    0x38(%esp),%eax
c002e0a4:	89 46 04             	mov    %eax,0x4(%esi)
    mh ->fa = ofs;
c002e0a7:	8b 44 24 34          	mov    0x34(%esp),%eax
c002e0ab:	89 46 0c             	mov    %eax,0xc(%esi)
    mh->page_cnt = num_page;
c002e0ae:	89 6e 10             	mov    %ebp,0x10(%esi)
    mh->last_page_size = last_page_used;
c002e0b1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002e0b5:	89 46 14             	mov    %eax,0x14(%esi)
    mh->num_page_with_segment = total_num_page;
c002e0b8:	89 7e 24             	mov    %edi,0x24(%esi)
    mh->is_segment = true;
c002e0bb:	c6 46 22 01          	movb   $0x1,0x22(%esi)
    list_push_back(&(cur->mmap_list), &(mh->elem));
c002e0bf:	83 ec 08             	sub    $0x8,%esp
c002e0c2:	8d 46 18             	lea    0x18(%esi),%eax
c002e0c5:	50                   	push   %eax
c002e0c6:	8b 7c 24 14          	mov    0x14(%esp),%edi
c002e0ca:	8d 87 c0 00 00 00    	lea    0xc0(%edi),%eax
c002e0d0:	50                   	push   %eax
c002e0d1:	e8 72 be ff ff       	call   c0029f48 <list_push_back>
    if(!mmap_install_page(cur, mh))
c002e0d6:	83 c4 08             	add    $0x8,%esp
c002e0d9:	56                   	push   %esi
c002e0da:	57                   	push   %edi
c002e0db:	e8 30 f1 ff ff       	call   c002d210 <mmap_install_page>
c002e0e0:	83 c4 10             	add    $0x10,%esp
c002e0e3:	eb 8a                	jmp    c002e06f <mmap_load_segment+0x98>

c002e0e5 <gdt_init>:
static uint64_t make_gdtr_operand(uint16_t limit, void *base);

/* Sets up a proper GDT.  The bootstrap loader's GDT didn't
   include user-mode selectors or a TSS, but we need both now. */
void gdt_init(void)
{
c002e0e5:	53                   	push   %ebx
c002e0e6:	83 ec 18             	sub    $0x18,%esp
c002e0e9:	e8 f8 43 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e0ee:	81 c3 4e 2b 01 00    	add    $0x12b4e,%ebx
  uint64_t gdtr_operand;

  /* Initialize GDT. */
  gdt[SEL_NULL / sizeof *gdt] = 0;
c002e0f4:	c7 83 04 1e 00 00 00 	movl   $0x0,0x1e04(%ebx)
c002e0fb:	00 00 00 
c002e0fe:	c7 83 08 1e 00 00 00 	movl   $0x0,0x1e08(%ebx)
c002e105:	00 00 00 
  gdt[SEL_KCSEG / sizeof *gdt] = make_code_desc(0);
c002e108:	c7 83 0c 1e 00 00 ff 	movl   $0xffff,0x1e0c(%ebx)
c002e10f:	ff 00 00 
c002e112:	c7 83 10 1e 00 00 00 	movl   $0xcf9a00,0x1e10(%ebx)
c002e119:	9a cf 00 
  gdt[SEL_KDSEG / sizeof *gdt] = make_data_desc(0);
c002e11c:	c7 83 14 1e 00 00 ff 	movl   $0xffff,0x1e14(%ebx)
c002e123:	ff 00 00 
c002e126:	c7 83 18 1e 00 00 00 	movl   $0xcf9200,0x1e18(%ebx)
c002e12d:	92 cf 00 
  gdt[SEL_UCSEG / sizeof *gdt] = make_code_desc(3);
c002e130:	c7 83 1c 1e 00 00 ff 	movl   $0xffff,0x1e1c(%ebx)
c002e137:	ff 00 00 
c002e13a:	c7 83 20 1e 00 00 00 	movl   $0xcffa00,0x1e20(%ebx)
c002e141:	fa cf 00 
  gdt[SEL_UDSEG / sizeof *gdt] = make_data_desc(3);
c002e144:	c7 83 24 1e 00 00 ff 	movl   $0xffff,0x1e24(%ebx)
c002e14b:	ff 00 00 
c002e14e:	c7 83 28 1e 00 00 00 	movl   $0xcff200,0x1e28(%ebx)
c002e155:	f2 cf 00 
  gdt[SEL_TSS / sizeof *gdt] = make_tss_desc(tss_get());
c002e158:	e8 59 00 00 00       	call   c002e1b6 <tss_get>
  ASSERT(granularity == GRAN_BYTE || granularity == GRAN_PAGE);

  e0 = ((limit & 0xffff) /* Limit 15:0. */
        | (base << 16)); /* Base 15:0. */

  e1 = (((base >> 16) & 0xff)   /* Base 23:16. */
c002e15d:	89 c2                	mov    %eax,%edx
c002e15f:	c1 ea 10             	shr    $0x10,%edx
c002e162:	0f b6 d2             	movzbl %dl,%edx
        | (dpl << 13)           /* Descriptor privilege. */
        | (1 << 15)             /* Present. */
        | (limit & 0xf0000)     /* Limit 16:19. */
        | (1 << 22)             /* 32-bit segment. */
        | (granularity << 23)   /* Byte/page granularity. */
        | (base & 0xff000000)); /* Base 31:24. */
c002e165:	89 c1                	mov    %eax,%ecx
c002e167:	81 e1 00 00 00 ff    	and    $0xff000000,%ecx
  e1 = (((base >> 16) & 0xff)   /* Base 23:16. */
c002e16d:	81 c9 00 89 40 00    	or     $0x408900,%ecx
c002e173:	09 ca                	or     %ecx,%edx
        | (base << 16)); /* Base 15:0. */
c002e175:	c1 e0 10             	shl    $0x10,%eax
  e0 = ((limit & 0xffff) /* Limit 15:0. */
c002e178:	83 c8 67             	or     $0x67,%eax

  return e0 | ((uint64_t)e1 << 32);
c002e17b:	89 83 2c 1e 00 00    	mov    %eax,0x1e2c(%ebx)
c002e181:	89 93 30 1e 00 00    	mov    %edx,0x1e30(%ebx)
/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LGDT instruction. */
static uint64_t
make_gdtr_operand(uint16_t limit, void *base)
{
  return limit | ((uint64_t)(uint32_t)base << 16);
c002e187:	8d 83 04 1e 00 00    	lea    0x1e04(%ebx),%eax
c002e18d:	ba 00 00 00 00       	mov    $0x0,%edx
c002e192:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c002e196:	c1 e0 10             	shl    $0x10,%eax
c002e199:	83 c8 2f             	or     $0x2f,%eax
c002e19c:	89 44 24 08          	mov    %eax,0x8(%esp)
c002e1a0:	89 54 24 0c          	mov    %edx,0xc(%esp)
  asm volatile("lgdt %0"
c002e1a4:	0f 01 54 24 08       	lgdtl  0x8(%esp)
  asm volatile("ltr %w0"
c002e1a9:	b8 28 00 00 00       	mov    $0x28,%eax
c002e1ae:	0f 00 d8             	ltr    %ax
}
c002e1b1:	83 c4 18             	add    $0x18,%esp
c002e1b4:	5b                   	pop    %ebx
c002e1b5:	c3                   	ret    

c002e1b6 <tss_get>:
}

/* Returns the kernel TSS. */
struct tss *
tss_get(void)
{
c002e1b6:	53                   	push   %ebx
c002e1b7:	83 ec 08             	sub    $0x8,%esp
c002e1ba:	e8 27 43 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e1bf:	81 c3 7d 2a 01 00    	add    $0x12a7d,%ebx
  ASSERT(tss != NULL);
c002e1c5:	8b 83 34 1e 00 00    	mov    0x1e34(%ebx),%eax
c002e1cb:	85 c0                	test   %eax,%eax
c002e1cd:	74 05                	je     c002e1d4 <tss_get+0x1e>
  return tss;
}
c002e1cf:	83 c4 08             	add    $0x8,%esp
c002e1d2:	5b                   	pop    %ebx
c002e1d3:	c3                   	ret    
  ASSERT(tss != NULL);
c002e1d4:	83 ec 0c             	sub    $0xc,%esp
c002e1d7:	8d 83 ae 4f ff ff    	lea    -0xb052(%ebx),%eax
c002e1dd:	50                   	push   %eax
c002e1de:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002e1e4:	50                   	push   %eax
c002e1e5:	8d 83 a8 29 ff ff    	lea    -0xd658(%ebx),%eax
c002e1eb:	50                   	push   %eax
c002e1ec:	6a 5e                	push   $0x5e
c002e1ee:	8d 83 ba 4f ff ff    	lea    -0xb046(%ebx),%eax
c002e1f4:	50                   	push   %eax
c002e1f5:	e8 9b b6 ff ff       	call   c0029895 <debug_panic>

c002e1fa <tss_update>:

/* Sets the ring 0 stack pointer in the TSS to point to the end
   of the thread stack. */
void tss_update(void)
{
c002e1fa:	53                   	push   %ebx
c002e1fb:	83 ec 08             	sub    $0x8,%esp
c002e1fe:	e8 e3 42 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e203:	81 c3 39 2a 01 00    	add    $0x12a39,%ebx
  ASSERT(tss != NULL);
c002e209:	83 bb 34 1e 00 00 00 	cmpl   $0x0,0x1e34(%ebx)
c002e210:	74 18                	je     c002e22a <tss_update+0x30>
  tss->esp0 = (uint8_t *)thread_current() + PGSIZE;
c002e212:	e8 2e 2e ff ff       	call   c0021045 <thread_current>
c002e217:	8b 93 34 1e 00 00    	mov    0x1e34(%ebx),%edx
c002e21d:	05 00 10 00 00       	add    $0x1000,%eax
c002e222:	89 42 04             	mov    %eax,0x4(%edx)
}
c002e225:	83 c4 08             	add    $0x8,%esp
c002e228:	5b                   	pop    %ebx
c002e229:	c3                   	ret    
  ASSERT(tss != NULL);
c002e22a:	83 ec 0c             	sub    $0xc,%esp
c002e22d:	8d 83 ae 4f ff ff    	lea    -0xb052(%ebx),%eax
c002e233:	50                   	push   %eax
c002e234:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002e23a:	50                   	push   %eax
c002e23b:	8d 83 9c 29 ff ff    	lea    -0xd664(%ebx),%eax
c002e241:	50                   	push   %eax
c002e242:	6a 66                	push   $0x66
c002e244:	8d 83 ba 4f ff ff    	lea    -0xb046(%ebx),%eax
c002e24a:	50                   	push   %eax
c002e24b:	e8 45 b6 ff ff       	call   c0029895 <debug_panic>

c002e250 <tss_init>:
{
c002e250:	53                   	push   %ebx
c002e251:	83 ec 14             	sub    $0x14,%esp
c002e254:	e8 8d 42 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e259:	81 c3 e3 29 01 00    	add    $0x129e3,%ebx
  tss = palloc_get_page(PAL_ASSERT | PAL_ZERO);
c002e25f:	6a 03                	push   $0x3
c002e261:	e8 69 5c ff ff       	call   c0023ecf <palloc_get_page>
c002e266:	89 83 34 1e 00 00    	mov    %eax,0x1e34(%ebx)
  tss->ss0 = SEL_KDSEG;
c002e26c:	66 c7 40 08 10 00    	movw   $0x10,0x8(%eax)
  tss->bitmap = 0xdfff;
c002e272:	66 c7 40 66 ff df    	movw   $0xdfff,0x66(%eax)
  tss_update();
c002e278:	e8 7d ff ff ff       	call   c002e1fa <tss_update>
}
c002e27d:	83 c4 18             	add    $0x18,%esp
c002e280:	5b                   	pop    %ebx
c002e281:	c3                   	ret    

c002e282 <is_rootpath>:

/*
 * Check whether the name is '/'.
 * */
bool is_rootpath(const char *name)
{
c002e282:	8b 54 24 04          	mov    0x4(%esp),%edx
  if (name == NULL)
    return false;
c002e286:	b8 00 00 00 00       	mov    $0x0,%eax
  if (name == NULL)
c002e28b:	85 d2                	test   %edx,%edx
c002e28d:	74 05                	je     c002e294 <is_rootpath+0x12>
  if (name[0] == '/' && name[1] == '\0')
c002e28f:	80 3a 2f             	cmpb   $0x2f,(%edx)
c002e292:	74 02                	je     c002e296 <is_rootpath+0x14>
    return true;
  return false;
}
c002e294:	f3 c3                	repz ret 
  if (name[0] == '/' && name[1] == '\0')
c002e296:	80 7a 01 00          	cmpb   $0x0,0x1(%edx)
c002e29a:	0f 94 c0             	sete   %al
c002e29d:	eb f5                	jmp    c002e294 <is_rootpath+0x12>

c002e29f <path_paser>:
 * previous directory + target file/dir name
 * is_dir is true if it's surely a dir, false if unknown.
 * if return true, prev_dir MUST be closed after use this function
 * */
bool path_paser(const char *target_path, struct dir **prev_dir, char **pure_name, bool *is_dir)
{
c002e29f:	55                   	push   %ebp
c002e2a0:	57                   	push   %edi
c002e2a1:	56                   	push   %esi
c002e2a2:	53                   	push   %ebx
c002e2a3:	83 ec 2c             	sub    $0x2c,%esp
c002e2a6:	e8 3b 42 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e2ab:	81 c3 91 29 01 00    	add    $0x12991,%ebx
c002e2b1:	8b 6c 24 44          	mov    0x44(%esp),%ebp
  *is_dir = false; // init it to false;
c002e2b5:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c002e2b9:	c6 00 00             	movb   $0x0,(%eax)
                   //  printf("%s\n", target_path);
  // copy the full path
  int length = strlen(target_path);
c002e2bc:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002e2c1:	b8 00 00 00 00       	mov    $0x0,%eax
c002e2c6:	8b 7c 24 40          	mov    0x40(%esp),%edi
c002e2ca:	f2 ae                	repnz scas %es:(%edi),%al
c002e2cc:	89 ce                	mov    %ecx,%esi
c002e2ce:	f7 d6                	not    %esi
c002e2d0:	89 f1                	mov    %esi,%ecx
  if (length == 0)
c002e2d2:	83 e9 01             	sub    $0x1,%ecx
c002e2d5:	0f 84 2f 01 00 00    	je     c002e40a <path_paser+0x16b>
c002e2db:	89 ce                	mov    %ecx,%esi
    return false;
  char *path_copy = malloc(length + 1);
c002e2dd:	8d 79 01             	lea    0x1(%ecx),%edi
c002e2e0:	83 ec 0c             	sub    $0xc,%esp
c002e2e3:	57                   	push   %edi
c002e2e4:	e8 fb 5f ff ff       	call   c00242e4 <malloc>
c002e2e9:	89 44 24 14          	mov    %eax,0x14(%esp)
  strlcpy(path_copy, target_path, length + 1);
c002e2ed:	83 c4 0c             	add    $0xc,%esp
c002e2f0:	57                   	push   %edi
c002e2f1:	ff 74 24 48          	pushl  0x48(%esp)
c002e2f5:	89 c7                	mov    %eax,%edi
c002e2f7:	50                   	push   %eax
c002e2f8:	e8 ed ab ff ff       	call   c0028eea <strlcpy>

  // check the tail to check whether it is surely a dir.
  if (length > 0 && path_copy[length - 1] == '/')
c002e2fd:	83 c4 10             	add    $0x10,%esp
c002e300:	85 f6                	test   %esi,%esi
c002e302:	7e 09                	jle    c002e30d <path_paser+0x6e>
c002e304:	8d 44 37 ff          	lea    -0x1(%edi,%esi,1),%eax
c002e308:	80 38 2f             	cmpb   $0x2f,(%eax)
c002e30b:	74 5c                	je     c002e369 <path_paser+0xca>
  {
    free(path_copy);
    return false;
  }

  if (path_copy[0] == '/')
c002e30d:	8b 44 24 04          	mov    0x4(%esp),%eax
c002e311:	80 38 2f             	cmpb   $0x2f,(%eax)
c002e314:	0f 84 88 00 00 00    	je     c002e3a2 <path_paser+0x103>
    *prev_dir = dir_open_root();
  else
    *prev_dir = dir_reopen(thread_current()->current_dir);
c002e31a:	e8 26 2d ff ff       	call   c0021045 <thread_current>
c002e31f:	83 ec 0c             	sub    $0xc,%esp
c002e322:	ff b0 b0 00 00 00    	pushl  0xb0(%eax)
c002e328:	e8 4d 0b 00 00       	call   c002ee7a <dir_reopen>
c002e32d:	89 45 00             	mov    %eax,0x0(%ebp)
c002e330:	83 c4 10             	add    $0x10,%esp

  //split token by '/'
  char *token, *save_ptr, *next_token;
  for (token = strtok_r(path_copy, "/", &save_ptr);; token = next_token)
c002e333:	83 ec 04             	sub    $0x4,%esp
c002e336:	8d 44 24 20          	lea    0x20(%esp),%eax
c002e33a:	50                   	push   %eax
c002e33b:	8d 83 07 3c ff ff    	lea    -0xc3f9(%ebx),%eax
c002e341:	50                   	push   %eax
c002e342:	ff 74 24 10          	pushl  0x10(%esp)
c002e346:	e8 95 a9 ff ff       	call   c0028ce0 <strtok_r>
c002e34b:	89 c6                	mov    %eax,%esi
c002e34d:	83 c4 10             	add    $0x10,%esp
      free(path_copy);
      dir_close(*prev_dir);
      return false;
    }
    ASSERT(token != NULL);
    next_token = strtok_r(NULL, "/", &save_ptr);
c002e350:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002e354:	89 44 24 08          	mov    %eax,0x8(%esp)
c002e358:	8d 83 07 3c ff ff    	lea    -0xc3f9(%ebx),%eax
c002e35e:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002e362:	89 ef                	mov    %ebp,%edi
c002e364:	e9 f8 00 00 00       	jmp    c002e461 <path_paser+0x1c2>
    *is_dir = true;
c002e369:	8b 7c 24 4c          	mov    0x4c(%esp),%edi
c002e36d:	c6 07 01             	movb   $0x1,(%edi)
    length--;
c002e370:	83 ee 01             	sub    $0x1,%esi
    ASSERT(length > 0); // non-root dir, length shouldn't be 0 here.
c002e373:	85 f6                	test   %esi,%esi
c002e375:	7e 05                	jle    c002e37c <path_paser+0xdd>
    path_copy[length] = '\0';
c002e377:	c6 00 00             	movb   $0x0,(%eax)
c002e37a:	eb 91                	jmp    c002e30d <path_paser+0x6e>
    ASSERT(length > 0); // non-root dir, length shouldn't be 0 here.
c002e37c:	83 ec 0c             	sub    $0xc,%esp
c002e37f:	8d 83 cf 4f ff ff    	lea    -0xb031(%ebx),%eax
c002e385:	50                   	push   %eax
c002e386:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002e38c:	50                   	push   %eax
c002e38d:	8d 83 cc 29 ff ff    	lea    -0xd634(%ebx),%eax
c002e393:	50                   	push   %eax
c002e394:	6a 49                	push   $0x49
c002e396:	8d 83 da 4f ff ff    	lea    -0xb026(%ebx),%eax
c002e39c:	50                   	push   %eax
c002e39d:	e8 f3 b4 ff ff       	call   c0029895 <debug_panic>
    *prev_dir = dir_open_root();
c002e3a2:	e8 b0 0a 00 00       	call   c002ee57 <dir_open_root>
c002e3a7:	89 45 00             	mov    %eax,0x0(%ebp)
c002e3aa:	eb 87                	jmp    c002e333 <path_paser+0x94>
    if (next_token == NULL) // token is the purename in path
    {
      strlcpy(*pure_name, token, READDIR_MAX_LEN + 1);
c002e3ac:	83 ec 04             	sub    $0x4,%esp
c002e3af:	6a 0f                	push   $0xf
c002e3b1:	56                   	push   %esi
c002e3b2:	8b 44 24 54          	mov    0x54(%esp),%eax
c002e3b6:	ff 30                	pushl  (%eax)
c002e3b8:	e8 2d ab ff ff       	call   c0028eea <strlcpy>
        free(path_copy);
        return false;
      }
    }
  }
  free(path_copy);
c002e3bd:	83 c4 04             	add    $0x4,%esp
c002e3c0:	ff 74 24 10          	pushl  0x10(%esp)
c002e3c4:	e8 d1 60 ff ff       	call   c002449a <free>
  return true;
c002e3c9:	83 c4 10             	add    $0x10,%esp
c002e3cc:	b8 01 00 00 00       	mov    $0x1,%eax
c002e3d1:	eb 37                	jmp    c002e40a <path_paser+0x16b>
        free(path_copy);
c002e3d3:	83 ec 0c             	sub    $0xc,%esp
c002e3d6:	ff 74 24 10          	pushl  0x10(%esp)
c002e3da:	e8 bb 60 ff ff       	call   c002449a <free>
        return false;
c002e3df:	83 c4 10             	add    $0x10,%esp
c002e3e2:	b8 00 00 00 00       	mov    $0x0,%eax
c002e3e7:	eb 21                	jmp    c002e40a <path_paser+0x16b>
c002e3e9:	89 fd                	mov    %edi,%ebp
      free(path_copy);
c002e3eb:	83 ec 0c             	sub    $0xc,%esp
c002e3ee:	ff 74 24 10          	pushl  0x10(%esp)
c002e3f2:	e8 a3 60 ff ff       	call   c002449a <free>
      dir_close(*prev_dir);
c002e3f7:	83 c4 04             	add    $0x4,%esp
c002e3fa:	ff 75 00             	pushl  0x0(%ebp)
c002e3fd:	e8 9f 0a 00 00       	call   c002eea1 <dir_close>
      return false;
c002e402:	83 c4 10             	add    $0x10,%esp
c002e405:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002e40a:	83 c4 2c             	add    $0x2c,%esp
c002e40d:	5b                   	pop    %ebx
c002e40e:	5e                   	pop    %esi
c002e40f:	5f                   	pop    %edi
c002e410:	5d                   	pop    %ebp
c002e411:	c3                   	ret    
c002e412:	89 fd                	mov    %edi,%ebp
c002e414:	eb d5                	jmp    c002e3eb <path_paser+0x14c>
c002e416:	89 fd                	mov    %edi,%ebp
c002e418:	eb d1                	jmp    c002e3eb <path_paser+0x14c>
    next_token = strtok_r(NULL, "/", &save_ptr);
c002e41a:	83 ec 04             	sub    $0x4,%esp
c002e41d:	ff 74 24 0c          	pushl  0xc(%esp)
c002e421:	ff 74 24 14          	pushl  0x14(%esp)
c002e425:	6a 00                	push   $0x0
c002e427:	e8 b4 a8 ff ff       	call   c0028ce0 <strtok_r>
c002e42c:	89 44 24 10          	mov    %eax,0x10(%esp)
    if (next_token == NULL) // token is the purename in path
c002e430:	83 c4 10             	add    $0x10,%esp
c002e433:	85 c0                	test   %eax,%eax
c002e435:	0f 84 71 ff ff ff    	je     c002e3ac <path_paser+0x10d>
      struct dir *tmp_dir = *prev_dir;
c002e43b:	8b 2f                	mov    (%edi),%ebp
      *prev_dir = subdir_lookup(*prev_dir, token);
c002e43d:	83 ec 08             	sub    $0x8,%esp
c002e440:	56                   	push   %esi
c002e441:	55                   	push   %ebp
c002e442:	e8 76 11 00 00       	call   c002f5bd <subdir_lookup>
c002e447:	89 07                	mov    %eax,(%edi)
      dir_close(tmp_dir);
c002e449:	89 2c 24             	mov    %ebp,(%esp)
c002e44c:	e8 50 0a 00 00       	call   c002eea1 <dir_close>
  for (token = strtok_r(path_copy, "/", &save_ptr);; token = next_token)
c002e451:	8b 74 24 10          	mov    0x10(%esp),%esi
      if (*prev_dir == NULL)
c002e455:	83 c4 10             	add    $0x10,%esp
c002e458:	83 3f 00             	cmpl   $0x0,(%edi)
c002e45b:	0f 84 72 ff ff ff    	je     c002e3d3 <path_paser+0x134>
  if (name == NULL)
c002e461:	85 f6                	test   %esi,%esi
c002e463:	74 84                	je     c002e3e9 <path_paser+0x14a>
    if (name[i] == '/')
c002e465:	0f b6 06             	movzbl (%esi),%eax
c002e468:	3c 2f                	cmp    $0x2f,%al
c002e46a:	74 a6                	je     c002e412 <path_paser+0x173>
    if (name[i] == '\0')
c002e46c:	84 c0                	test   %al,%al
c002e46e:	74 aa                	je     c002e41a <path_paser+0x17b>
c002e470:	8d 46 01             	lea    0x1(%esi),%eax
c002e473:	8d 4e 0f             	lea    0xf(%esi),%ecx
    if (name[i] == '/')
c002e476:	0f b6 10             	movzbl (%eax),%edx
c002e479:	80 fa 2f             	cmp    $0x2f,%dl
c002e47c:	74 98                	je     c002e416 <path_paser+0x177>
    if (name[i] == '\0')
c002e47e:	84 d2                	test   %dl,%dl
c002e480:	74 98                	je     c002e41a <path_paser+0x17b>
c002e482:	83 c0 01             	add    $0x1,%eax
  for (int i = 0; i < READDIR_MAX_LEN + 1; i++)
c002e485:	39 c1                	cmp    %eax,%ecx
c002e487:	75 ed                	jne    c002e476 <path_paser+0x1d7>
c002e489:	89 fd                	mov    %edi,%ebp
c002e48b:	e9 5b ff ff ff       	jmp    c002e3eb <path_paser+0x14c>

c002e490 <filesys_init>:


/* Initializes the file system module.
   If FORMAT is true, reformats the file system. */
void filesys_init(bool format)
{
c002e490:	56                   	push   %esi
c002e491:	53                   	push   %ebx
c002e492:	83 ec 04             	sub    $0x4,%esp
c002e495:	e8 4c 40 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e49a:	81 c3 a2 27 01 00    	add    $0x127a2,%ebx
c002e4a0:	8b 74 24 10          	mov    0x10(%esp),%esi
  cache_init();
c002e4a4:	e8 ff 2a 00 00       	call   c0030fa8 <cache_init>

  fs_device = block_get_role(BLOCK_FILESYS);
c002e4a9:	83 ec 0c             	sub    $0xc,%esp
c002e4ac:	6a 01                	push   $0x1
c002e4ae:	e8 1a 72 ff ff       	call   c00256cd <block_get_role>
c002e4b3:	c7 c2 b8 b2 04 c0    	mov    $0xc004b2b8,%edx
c002e4b9:	89 02                	mov    %eax,(%edx)
  if (fs_device == NULL)
c002e4bb:	83 c4 10             	add    $0x10,%esp
c002e4be:	85 c0                	test   %eax,%eax
c002e4c0:	74 1b                	je     c002e4dd <filesys_init+0x4d>
    PANIC("No file system device found, can't initialize file system.");

  inode_init();
c002e4c2:	e8 ec 19 00 00       	call   c002feb3 <inode_init>
  free_map_init();
c002e4c7:	e8 e2 01 00 00       	call   c002e6ae <free_map_init>

  if (format)
c002e4cc:	89 f0                	mov    %esi,%eax
c002e4ce:	84 c0                	test   %al,%al
c002e4d0:	75 2a                	jne    c002e4fc <filesys_init+0x6c>
    do_format();

  free_map_open();
c002e4d2:	e8 36 03 00 00       	call   c002e80d <free_map_open>
}
c002e4d7:	83 c4 04             	add    $0x4,%esp
c002e4da:	5b                   	pop    %ebx
c002e4db:	5e                   	pop    %esi
c002e4dc:	c3                   	ret    
    PANIC("No file system device found, can't initialize file system.");
c002e4dd:	8d 83 0c 50 ff ff    	lea    -0xaff4(%ebx),%eax
c002e4e3:	50                   	push   %eax
c002e4e4:	8d 83 bc 29 ff ff    	lea    -0xd644(%ebx),%eax
c002e4ea:	50                   	push   %eax
c002e4eb:	68 83 00 00 00       	push   $0x83
c002e4f0:	8d 83 da 4f ff ff    	lea    -0xb026(%ebx),%eax
c002e4f6:	50                   	push   %eax
c002e4f7:	e8 99 b3 ff ff       	call   c0029895 <debug_panic>

/* Formats the file system. */
static void
do_format(void)
{
  printf("Formatting file system...");
c002e4fc:	83 ec 0c             	sub    $0xc,%esp
c002e4ff:	8d 83 f2 4f ff ff    	lea    -0xb00e(%ebx),%eax
c002e505:	50                   	push   %eax
c002e506:	e8 f3 95 ff ff       	call   c0027afe <printf>
  free_map_create();
c002e50b:	e8 9a 03 00 00       	call   c002e8aa <free_map_create>
  if (!dir_create(ROOT_DIR_SECTOR, 16))
c002e510:	83 c4 08             	add    $0x8,%esp
c002e513:	6a 10                	push   $0x10
c002e515:	6a 01                	push   $0x1
c002e517:	e8 fb 0c 00 00       	call   c002f217 <dir_create>
c002e51c:	83 c4 10             	add    $0x10,%esp
c002e51f:	84 c0                	test   %al,%al
c002e521:	74 19                	je     c002e53c <filesys_init+0xac>
    PANIC("root directory creation failed");
  free_map_close();
c002e523:	e8 63 03 00 00       	call   c002e88b <free_map_close>
  printf("done.\n");
c002e528:	83 ec 0c             	sub    $0xc,%esp
c002e52b:	8d 83 6d 38 ff ff    	lea    -0xc793(%ebx),%eax
c002e531:	50                   	push   %eax
c002e532:	e8 37 d3 ff ff       	call   c002b86e <puts>
c002e537:	83 c4 10             	add    $0x10,%esp
c002e53a:	eb 96                	jmp    c002e4d2 <filesys_init+0x42>
    PANIC("root directory creation failed");
c002e53c:	8d 83 48 50 ff ff    	lea    -0xafb8(%ebx),%eax
c002e542:	50                   	push   %eax
c002e543:	8d 83 b0 29 ff ff    	lea    -0xd650(%ebx),%eax
c002e549:	50                   	push   %eax
c002e54a:	68 cc 00 00 00       	push   $0xcc
c002e54f:	8d 83 da 4f ff ff    	lea    -0xb026(%ebx),%eax
c002e555:	50                   	push   %eax
c002e556:	e8 3a b3 ff ff       	call   c0029895 <debug_panic>

c002e55b <filesys_done>:
{
c002e55b:	53                   	push   %ebx
c002e55c:	83 ec 08             	sub    $0x8,%esp
c002e55f:	e8 82 3f 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e564:	81 c3 d8 26 01 00    	add    $0x126d8,%ebx
  free_map_close();
c002e56a:	e8 1c 03 00 00       	call   c002e88b <free_map_close>
  cache_finish();
c002e56f:	e8 c9 2a 00 00       	call   c003103d <cache_finish>
}
c002e574:	83 c4 08             	add    $0x8,%esp
c002e577:	5b                   	pop    %ebx
c002e578:	c3                   	ret    

c002e579 <filesys_create>:
{
c002e579:	57                   	push   %edi
c002e57a:	56                   	push   %esi
c002e57b:	53                   	push   %ebx
c002e57c:	83 ec 10             	sub    $0x10,%esp
c002e57f:	e8 62 3f 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e584:	81 c3 b8 26 01 00    	add    $0x126b8,%ebx
  block_sector_t inode_sector = 0;
c002e58a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002e591:	00 
  struct dir *dir = dir_open_root();
c002e592:	e8 c0 08 00 00       	call   c002ee57 <dir_open_root>
c002e597:	89 c6                	mov    %eax,%esi
  bool success = (dir != NULL && free_map_allocate(1, &inode_sector) && inode_create(inode_sector, initial_size) && dir_add(dir, name, inode_sector));
c002e599:	85 c0                	test   %eax,%eax
c002e59b:	74 16                	je     c002e5b3 <filesys_create+0x3a>
c002e59d:	83 ec 08             	sub    $0x8,%esp
c002e5a0:	8d 44 24 14          	lea    0x14(%esp),%eax
c002e5a4:	50                   	push   %eax
c002e5a5:	6a 01                	push   $0x1
c002e5a7:	e8 6f 01 00 00       	call   c002e71b <free_map_allocate>
c002e5ac:	83 c4 10             	add    $0x10,%esp
c002e5af:	84 c0                	test   %al,%al
c002e5b1:	75 1f                	jne    c002e5d2 <filesys_create+0x59>
  if (!success && inode_sector != 0)
c002e5b3:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002e5b7:	bf 00 00 00 00       	mov    $0x0,%edi
c002e5bc:	85 c0                	test   %eax,%eax
c002e5be:	75 45                	jne    c002e605 <filesys_create+0x8c>
  dir_close(dir);
c002e5c0:	83 ec 0c             	sub    $0xc,%esp
c002e5c3:	56                   	push   %esi
c002e5c4:	e8 d8 08 00 00       	call   c002eea1 <dir_close>
}
c002e5c9:	89 f8                	mov    %edi,%eax
c002e5cb:	83 c4 20             	add    $0x20,%esp
c002e5ce:	5b                   	pop    %ebx
c002e5cf:	5e                   	pop    %esi
c002e5d0:	5f                   	pop    %edi
c002e5d1:	c3                   	ret    
  bool success = (dir != NULL && free_map_allocate(1, &inode_sector) && inode_create(inode_sector, initial_size) && dir_add(dir, name, inode_sector));
c002e5d2:	83 ec 08             	sub    $0x8,%esp
c002e5d5:	ff 74 24 2c          	pushl  0x2c(%esp)
c002e5d9:	ff 74 24 18          	pushl  0x18(%esp)
c002e5dd:	e8 07 19 00 00       	call   c002fee9 <inode_create>
c002e5e2:	83 c4 10             	add    $0x10,%esp
c002e5e5:	84 c0                	test   %al,%al
c002e5e7:	74 ca                	je     c002e5b3 <filesys_create+0x3a>
c002e5e9:	83 ec 04             	sub    $0x4,%esp
c002e5ec:	ff 74 24 10          	pushl  0x10(%esp)
c002e5f0:	ff 74 24 28          	pushl  0x28(%esp)
c002e5f4:	56                   	push   %esi
c002e5f5:	e8 8e 09 00 00       	call   c002ef88 <dir_add>
c002e5fa:	89 c7                	mov    %eax,%edi
  if (!success && inode_sector != 0)
c002e5fc:	83 c4 10             	add    $0x10,%esp
c002e5ff:	84 c0                	test   %al,%al
c002e601:	75 bd                	jne    c002e5c0 <filesys_create+0x47>
c002e603:	eb ae                	jmp    c002e5b3 <filesys_create+0x3a>
    free_map_release(inode_sector, 1);
c002e605:	83 ec 08             	sub    $0x8,%esp
c002e608:	6a 01                	push   $0x1
c002e60a:	50                   	push   %eax
c002e60b:	e8 80 01 00 00       	call   c002e790 <free_map_release>
c002e610:	83 c4 10             	add    $0x10,%esp
c002e613:	eb ab                	jmp    c002e5c0 <filesys_create+0x47>

c002e615 <filesys_open>:
{
c002e615:	56                   	push   %esi
c002e616:	53                   	push   %ebx
c002e617:	83 ec 14             	sub    $0x14,%esp
c002e61a:	e8 c7 3e 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e61f:	81 c3 1d 26 01 00    	add    $0x1261d,%ebx
  struct dir *dir = dir_open_root();
c002e625:	e8 2d 08 00 00       	call   c002ee57 <dir_open_root>
c002e62a:	89 c6                	mov    %eax,%esi
  struct inode *inode = NULL;
c002e62c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002e633:	00 
  if (dir != NULL)
c002e634:	85 c0                	test   %eax,%eax
c002e636:	74 15                	je     c002e64d <filesys_open+0x38>
    dir_lookup(dir, name, &inode);
c002e638:	83 ec 04             	sub    $0x4,%esp
c002e63b:	8d 44 24 10          	lea    0x10(%esp),%eax
c002e63f:	50                   	push   %eax
c002e640:	ff 74 24 28          	pushl  0x28(%esp)
c002e644:	56                   	push   %esi
c002e645:	e8 91 08 00 00       	call   c002eedb <dir_lookup>
c002e64a:	83 c4 10             	add    $0x10,%esp
  dir_close(dir);
c002e64d:	83 ec 0c             	sub    $0xc,%esp
c002e650:	56                   	push   %esi
c002e651:	e8 4b 08 00 00       	call   c002eea1 <dir_close>
  return file_open(inode);
c002e656:	83 c4 04             	add    $0x4,%esp
c002e659:	ff 74 24 18          	pushl  0x18(%esp)
c002e65d:	e8 02 03 00 00       	call   c002e964 <file_open>
}
c002e662:	83 c4 24             	add    $0x24,%esp
c002e665:	5b                   	pop    %ebx
c002e666:	5e                   	pop    %esi
c002e667:	c3                   	ret    

c002e668 <filesys_remove>:
{
c002e668:	57                   	push   %edi
c002e669:	56                   	push   %esi
c002e66a:	53                   	push   %ebx
c002e66b:	e8 76 3e 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e670:	81 c3 cc 25 01 00    	add    $0x125cc,%ebx
  struct dir *dir = dir_open_root();
c002e676:	e8 dc 07 00 00       	call   c002ee57 <dir_open_root>
c002e67b:	89 c7                	mov    %eax,%edi
  bool success = dir != NULL && dir_remove(dir, name);
c002e67d:	be 00 00 00 00       	mov    $0x0,%esi
c002e682:	85 c0                	test   %eax,%eax
c002e684:	74 13                	je     c002e699 <filesys_remove+0x31>
c002e686:	83 ec 08             	sub    $0x8,%esp
c002e689:	ff 74 24 18          	pushl  0x18(%esp)
c002e68d:	50                   	push   %eax
c002e68e:	e8 c8 0c 00 00       	call   c002f35b <dir_remove>
c002e693:	0f b6 f0             	movzbl %al,%esi
c002e696:	83 c4 10             	add    $0x10,%esp
  dir_close(dir);
c002e699:	83 ec 0c             	sub    $0xc,%esp
c002e69c:	57                   	push   %edi
c002e69d:	e8 ff 07 00 00       	call   c002eea1 <dir_close>
  bool success = dir != NULL && dir_remove(dir, name);
c002e6a2:	89 f0                	mov    %esi,%eax
c002e6a4:	83 e0 01             	and    $0x1,%eax
  return success;
c002e6a7:	83 c4 10             	add    $0x10,%esp
}
c002e6aa:	5b                   	pop    %ebx
c002e6ab:	5e                   	pop    %esi
c002e6ac:	5f                   	pop    %edi
c002e6ad:	c3                   	ret    

c002e6ae <free_map_init>:
static struct file *free_map_file; /* Free map file. */
static struct bitmap *free_map;    /* Free map, one bit per sector. */

/* Initializes the free map. */
void free_map_init(void)
{
c002e6ae:	53                   	push   %ebx
c002e6af:	83 ec 14             	sub    $0x14,%esp
c002e6b2:	e8 2f 3e 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e6b7:	81 c3 85 25 01 00    	add    $0x12585,%ebx
  free_map = bitmap_create(block_size(fs_device));
c002e6bd:	c7 c0 b8 b2 04 c0    	mov    $0xc004b2b8,%eax
c002e6c3:	ff 30                	pushl  (%eax)
c002e6c5:	e8 22 72 ff ff       	call   c00258ec <block_size>
c002e6ca:	89 04 24             	mov    %eax,(%esp)
c002e6cd:	e8 69 c3 ff ff       	call   c002aa3b <bitmap_create>
c002e6d2:	89 83 38 1e 00 00    	mov    %eax,0x1e38(%ebx)
  if (free_map == NULL)
c002e6d8:	83 c4 10             	add    $0x10,%esp
c002e6db:	85 c0                	test   %eax,%eax
c002e6dd:	74 20                	je     c002e6ff <free_map_init+0x51>
    PANIC("bitmap creation failed--file system device is too large");
  bitmap_mark(free_map, FREE_MAP_SECTOR);
c002e6df:	83 ec 08             	sub    $0x8,%esp
c002e6e2:	6a 00                	push   $0x0
c002e6e4:	50                   	push   %eax
c002e6e5:	e8 a3 c0 ff ff       	call   c002a78d <bitmap_mark>
  bitmap_mark(free_map, ROOT_DIR_SECTOR);
c002e6ea:	83 c4 08             	add    $0x8,%esp
c002e6ed:	6a 01                	push   $0x1
c002e6ef:	ff b3 38 1e 00 00    	pushl  0x1e38(%ebx)
c002e6f5:	e8 93 c0 ff ff       	call   c002a78d <bitmap_mark>
}
c002e6fa:	83 c4 18             	add    $0x18,%esp
c002e6fd:	5b                   	pop    %ebx
c002e6fe:	c3                   	ret    
    PANIC("bitmap creation failed--file system device is too large");
c002e6ff:	8d 83 68 50 ff ff    	lea    -0xaf98(%ebx),%eax
c002e705:	50                   	push   %eax
c002e706:	8d 83 0c 2a ff ff    	lea    -0xd5f4(%ebx),%eax
c002e70c:	50                   	push   %eax
c002e70d:	6a 10                	push   $0x10
c002e70f:	8d 83 c2 50 ff ff    	lea    -0xaf3e(%ebx),%eax
c002e715:	50                   	push   %eax
c002e716:	e8 7a b1 ff ff       	call   c0029895 <debug_panic>

c002e71b <free_map_allocate>:
   the first into *SECTORP.
   Returns true if successful, false if not enough consecutive
   sectors were available or if the free_map file could not be
   written. */
bool free_map_allocate(size_t cnt, block_sector_t *sectorp)
{
c002e71b:	57                   	push   %edi
c002e71c:	56                   	push   %esi
c002e71d:	53                   	push   %ebx
c002e71e:	e8 c3 3d 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e723:	81 c3 19 25 01 00    	add    $0x12519,%ebx
c002e729:	8b 7c 24 10          	mov    0x10(%esp),%edi
  block_sector_t sector = bitmap_scan_and_flip(free_map, 0, cnt, false);
c002e72d:	6a 00                	push   $0x0
c002e72f:	57                   	push   %edi
c002e730:	6a 00                	push   $0x0
c002e732:	ff b3 38 1e 00 00    	pushl  0x1e38(%ebx)
c002e738:	e8 d9 c6 ff ff       	call   c002ae16 <bitmap_scan_and_flip>
c002e73d:	89 c6                	mov    %eax,%esi
  if (sector != BITMAP_ERROR && free_map_file != NULL && !bitmap_write(free_map, free_map_file))
c002e73f:	83 c4 10             	add    $0x10,%esp
c002e742:	83 f8 ff             	cmp    $0xffffffff,%eax
c002e745:	74 26                	je     c002e76d <free_map_allocate+0x52>
c002e747:	8b 83 3c 1e 00 00    	mov    0x1e3c(%ebx),%eax
c002e74d:	85 c0                	test   %eax,%eax
c002e74f:	74 16                	je     c002e767 <free_map_allocate+0x4c>
c002e751:	83 ec 08             	sub    $0x8,%esp
c002e754:	50                   	push   %eax
c002e755:	ff b3 38 1e 00 00    	pushl  0x1e38(%ebx)
c002e75b:	e8 7a c7 ff ff       	call   c002aeda <bitmap_write>
c002e760:	83 c4 10             	add    $0x10,%esp
c002e763:	84 c0                	test   %al,%al
c002e765:	74 10                	je     c002e777 <free_map_allocate+0x5c>
  {
    bitmap_set_multiple(free_map, sector, cnt, false);
    sector = BITMAP_ERROR;
  }
  if (sector != BITMAP_ERROR)
    *sectorp = sector;
c002e767:	8b 44 24 14          	mov    0x14(%esp),%eax
c002e76b:	89 30                	mov    %esi,(%eax)
  return sector != BITMAP_ERROR;
c002e76d:	83 fe ff             	cmp    $0xffffffff,%esi
c002e770:	0f 95 c0             	setne  %al
}
c002e773:	5b                   	pop    %ebx
c002e774:	5e                   	pop    %esi
c002e775:	5f                   	pop    %edi
c002e776:	c3                   	ret    
    bitmap_set_multiple(free_map, sector, cnt, false);
c002e777:	6a 00                	push   $0x0
c002e779:	57                   	push   %edi
c002e77a:	56                   	push   %esi
c002e77b:	ff b3 38 1e 00 00    	pushl  0x1e38(%ebx)
c002e781:	e8 85 c1 ff ff       	call   c002a90b <bitmap_set_multiple>
c002e786:	83 c4 10             	add    $0x10,%esp
    sector = BITMAP_ERROR;
c002e789:	be ff ff ff ff       	mov    $0xffffffff,%esi
c002e78e:	eb dd                	jmp    c002e76d <free_map_allocate+0x52>

c002e790 <free_map_release>:

/* Makes CNT sectors starting at SECTOR available for use. */
void free_map_release(block_sector_t sector, size_t cnt)
{
c002e790:	57                   	push   %edi
c002e791:	56                   	push   %esi
c002e792:	53                   	push   %ebx
c002e793:	e8 4e 3d 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e798:	81 c3 a4 24 01 00    	add    $0x124a4,%ebx
c002e79e:	8b 74 24 10          	mov    0x10(%esp),%esi
c002e7a2:	8b 7c 24 14          	mov    0x14(%esp),%edi
  ASSERT(bitmap_all(free_map, sector, cnt));
c002e7a6:	83 ec 04             	sub    $0x4,%esp
c002e7a9:	57                   	push   %edi
c002e7aa:	56                   	push   %esi
c002e7ab:	ff b3 38 1e 00 00    	pushl  0x1e38(%ebx)
c002e7b1:	e8 73 c5 ff ff       	call   c002ad29 <bitmap_all>
c002e7b6:	83 c4 10             	add    $0x10,%esp
c002e7b9:	84 c0                	test   %al,%al
c002e7bb:	74 2a                	je     c002e7e7 <free_map_release+0x57>
  bitmap_set_multiple(free_map, sector, cnt, false);
c002e7bd:	6a 00                	push   $0x0
c002e7bf:	57                   	push   %edi
c002e7c0:	56                   	push   %esi
c002e7c1:	ff b3 38 1e 00 00    	pushl  0x1e38(%ebx)
c002e7c7:	e8 3f c1 ff ff       	call   c002a90b <bitmap_set_multiple>
  bitmap_write(free_map, free_map_file);
c002e7cc:	83 c4 08             	add    $0x8,%esp
c002e7cf:	ff b3 3c 1e 00 00    	pushl  0x1e3c(%ebx)
c002e7d5:	ff b3 38 1e 00 00    	pushl  0x1e38(%ebx)
c002e7db:	e8 fa c6 ff ff       	call   c002aeda <bitmap_write>
}
c002e7e0:	83 c4 10             	add    $0x10,%esp
c002e7e3:	5b                   	pop    %ebx
c002e7e4:	5e                   	pop    %esi
c002e7e5:	5f                   	pop    %edi
c002e7e6:	c3                   	ret    
  ASSERT(bitmap_all(free_map, sector, cnt));
c002e7e7:	83 ec 0c             	sub    $0xc,%esp
c002e7ea:	8d 83 a0 50 ff ff    	lea    -0xaf60(%ebx),%eax
c002e7f0:	50                   	push   %eax
c002e7f1:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002e7f7:	50                   	push   %eax
c002e7f8:	8d 83 f8 29 ff ff    	lea    -0xd608(%ebx),%eax
c002e7fe:	50                   	push   %eax
c002e7ff:	6a 2a                	push   $0x2a
c002e801:	8d 83 c2 50 ff ff    	lea    -0xaf3e(%ebx),%eax
c002e807:	50                   	push   %eax
c002e808:	e8 88 b0 ff ff       	call   c0029895 <debug_panic>

c002e80d <free_map_open>:

/* Opens the free map file and reads it from disk. */
void free_map_open(void)
{
c002e80d:	53                   	push   %ebx
c002e80e:	83 ec 14             	sub    $0x14,%esp
c002e811:	e8 d0 3c 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e816:	81 c3 26 24 01 00    	add    $0x12426,%ebx
  free_map_file = file_open(inode_open(FREE_MAP_SECTOR));
c002e81c:	6a 00                	push   $0x0
c002e81e:	e8 54 19 00 00       	call   c0030177 <inode_open>
c002e823:	89 04 24             	mov    %eax,(%esp)
c002e826:	e8 39 01 00 00       	call   c002e964 <file_open>
c002e82b:	89 83 3c 1e 00 00    	mov    %eax,0x1e3c(%ebx)
  if (free_map_file == NULL)
c002e831:	83 c4 10             	add    $0x10,%esp
c002e834:	85 c0                	test   %eax,%eax
c002e836:	74 1b                	je     c002e853 <free_map_open+0x46>
    PANIC("can't open free map");
  if (!bitmap_read(free_map, free_map_file))
c002e838:	83 ec 08             	sub    $0x8,%esp
c002e83b:	50                   	push   %eax
c002e83c:	ff b3 38 1e 00 00    	pushl  0x1e38(%ebx)
c002e842:	e8 27 c6 ff ff       	call   c002ae6e <bitmap_read>
c002e847:	83 c4 10             	add    $0x10,%esp
c002e84a:	84 c0                	test   %al,%al
c002e84c:	74 21                	je     c002e86f <free_map_open+0x62>
    PANIC("can't read free map");
}
c002e84e:	83 c4 08             	add    $0x8,%esp
c002e851:	5b                   	pop    %ebx
c002e852:	c3                   	ret    
    PANIC("can't open free map");
c002e853:	8d 83 db 50 ff ff    	lea    -0xaf25(%ebx),%eax
c002e859:	50                   	push   %eax
c002e85a:	8d 83 e8 29 ff ff    	lea    -0xd618(%ebx),%eax
c002e860:	50                   	push   %eax
c002e861:	6a 34                	push   $0x34
c002e863:	8d 83 c2 50 ff ff    	lea    -0xaf3e(%ebx),%eax
c002e869:	50                   	push   %eax
c002e86a:	e8 26 b0 ff ff       	call   c0029895 <debug_panic>
    PANIC("can't read free map");
c002e86f:	8d 83 ef 50 ff ff    	lea    -0xaf11(%ebx),%eax
c002e875:	50                   	push   %eax
c002e876:	8d 83 e8 29 ff ff    	lea    -0xd618(%ebx),%eax
c002e87c:	50                   	push   %eax
c002e87d:	6a 36                	push   $0x36
c002e87f:	8d 83 c2 50 ff ff    	lea    -0xaf3e(%ebx),%eax
c002e885:	50                   	push   %eax
c002e886:	e8 0a b0 ff ff       	call   c0029895 <debug_panic>

c002e88b <free_map_close>:

/* Writes the free map to disk and closes the free map file. */
void free_map_close(void)
{
c002e88b:	53                   	push   %ebx
c002e88c:	83 ec 14             	sub    $0x14,%esp
c002e88f:	e8 52 3c 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e894:	81 c3 a8 23 01 00    	add    $0x123a8,%ebx
  file_close(free_map_file);
c002e89a:	ff b3 3c 1e 00 00    	pushl  0x1e3c(%ebx)
c002e8a0:	e8 b3 02 00 00       	call   c002eb58 <file_close>
}
c002e8a5:	83 c4 18             	add    $0x18,%esp
c002e8a8:	5b                   	pop    %ebx
c002e8a9:	c3                   	ret    

c002e8aa <free_map_create>:

/* Creates a new free map file on disk and writes the free map to
   it. */
void free_map_create(void)
{
c002e8aa:	53                   	push   %ebx
c002e8ab:	83 ec 14             	sub    $0x14,%esp
c002e8ae:	e8 33 3c 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e8b3:	81 c3 89 23 01 00    	add    $0x12389,%ebx
  /* Create inode. */
  if (!inode_create(FREE_MAP_SECTOR, bitmap_file_size(free_map)))
c002e8b9:	ff b3 38 1e 00 00    	pushl  0x1e38(%ebx)
c002e8bf:	e8 9a c5 ff ff       	call   c002ae5e <bitmap_file_size>
c002e8c4:	83 c4 08             	add    $0x8,%esp
c002e8c7:	50                   	push   %eax
c002e8c8:	6a 00                	push   $0x0
c002e8ca:	e8 1a 16 00 00       	call   c002fee9 <inode_create>
c002e8cf:	83 c4 10             	add    $0x10,%esp
c002e8d2:	84 c0                	test   %al,%al
c002e8d4:	74 3a                	je     c002e910 <free_map_create+0x66>
    PANIC("free map creation failed");

  /* Write bitmap to file. */
  free_map_file = file_open(inode_open(FREE_MAP_SECTOR));
c002e8d6:	83 ec 0c             	sub    $0xc,%esp
c002e8d9:	6a 00                	push   $0x0
c002e8db:	e8 97 18 00 00       	call   c0030177 <inode_open>
c002e8e0:	89 04 24             	mov    %eax,(%esp)
c002e8e3:	e8 7c 00 00 00       	call   c002e964 <file_open>
c002e8e8:	89 83 3c 1e 00 00    	mov    %eax,0x1e3c(%ebx)
  if (free_map_file == NULL)
c002e8ee:	83 c4 10             	add    $0x10,%esp
c002e8f1:	85 c0                	test   %eax,%eax
c002e8f3:	74 37                	je     c002e92c <free_map_create+0x82>
    PANIC("can't open free map");
  if (!bitmap_write(free_map, free_map_file))
c002e8f5:	83 ec 08             	sub    $0x8,%esp
c002e8f8:	50                   	push   %eax
c002e8f9:	ff b3 38 1e 00 00    	pushl  0x1e38(%ebx)
c002e8ff:	e8 d6 c5 ff ff       	call   c002aeda <bitmap_write>
c002e904:	83 c4 10             	add    $0x10,%esp
c002e907:	84 c0                	test   %al,%al
c002e909:	74 3d                	je     c002e948 <free_map_create+0x9e>
    PANIC("can't write free map");
}
c002e90b:	83 c4 08             	add    $0x8,%esp
c002e90e:	5b                   	pop    %ebx
c002e90f:	c3                   	ret    
    PANIC("free map creation failed");
c002e910:	8d 83 03 51 ff ff    	lea    -0xaefd(%ebx),%eax
c002e916:	50                   	push   %eax
c002e917:	8d 83 d8 29 ff ff    	lea    -0xd628(%ebx),%eax
c002e91d:	50                   	push   %eax
c002e91e:	6a 45                	push   $0x45
c002e920:	8d 83 c2 50 ff ff    	lea    -0xaf3e(%ebx),%eax
c002e926:	50                   	push   %eax
c002e927:	e8 69 af ff ff       	call   c0029895 <debug_panic>
    PANIC("can't open free map");
c002e92c:	8d 83 db 50 ff ff    	lea    -0xaf25(%ebx),%eax
c002e932:	50                   	push   %eax
c002e933:	8d 83 d8 29 ff ff    	lea    -0xd628(%ebx),%eax
c002e939:	50                   	push   %eax
c002e93a:	6a 4a                	push   $0x4a
c002e93c:	8d 83 c2 50 ff ff    	lea    -0xaf3e(%ebx),%eax
c002e942:	50                   	push   %eax
c002e943:	e8 4d af ff ff       	call   c0029895 <debug_panic>
    PANIC("can't write free map");
c002e948:	8d 83 1c 51 ff ff    	lea    -0xaee4(%ebx),%eax
c002e94e:	50                   	push   %eax
c002e94f:	8d 83 d8 29 ff ff    	lea    -0xd628(%ebx),%eax
c002e955:	50                   	push   %eax
c002e956:	6a 4c                	push   $0x4c
c002e958:	8d 83 c2 50 ff ff    	lea    -0xaf3e(%ebx),%eax
c002e95e:	50                   	push   %eax
c002e95f:	e8 31 af ff ff       	call   c0029895 <debug_panic>

c002e964 <file_open>:
/* Opens a file for the given INODE, of which it takes ownership,
   and returns the new file.  Returns a null pointer if an
   allocation fails or if INODE is null. */
struct file *
file_open(struct inode *inode)
{
c002e964:	57                   	push   %edi
c002e965:	56                   	push   %esi
c002e966:	53                   	push   %ebx
c002e967:	e8 7a 3b 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e96c:	81 c3 d0 22 01 00    	add    $0x122d0,%ebx
c002e972:	8b 7c 24 10          	mov    0x10(%esp),%edi
  struct file *file = calloc(1, sizeof *file);
c002e976:	83 ec 08             	sub    $0x8,%esp
c002e979:	6a 10                	push   $0x10
c002e97b:	6a 01                	push   $0x1
c002e97d:	e8 c7 5a ff ff       	call   c0024449 <calloc>
c002e982:	89 c6                	mov    %eax,%esi
  if (inode != NULL && file != NULL)
c002e984:	83 c4 10             	add    $0x10,%esp
c002e987:	85 ff                	test   %edi,%edi
c002e989:	74 17                	je     c002e9a2 <file_open+0x3e>
c002e98b:	85 c0                	test   %eax,%eax
c002e98d:	74 13                	je     c002e9a2 <file_open+0x3e>
  {
    file->inode = inode;
c002e98f:	89 38                	mov    %edi,(%eax)
    file->pos = 0;
c002e991:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    file->deny_write = false;
c002e998:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  {
    inode_close(inode);
    free(file);
    return NULL;
  }
}
c002e99c:	89 f0                	mov    %esi,%eax
c002e99e:	5b                   	pop    %ebx
c002e99f:	5e                   	pop    %esi
c002e9a0:	5f                   	pop    %edi
c002e9a1:	c3                   	ret    
    inode_close(inode);
c002e9a2:	83 ec 0c             	sub    $0xc,%esp
c002e9a5:	57                   	push   %edi
c002e9a6:	e8 89 18 00 00       	call   c0030234 <inode_close>
    free(file);
c002e9ab:	89 34 24             	mov    %esi,(%esp)
c002e9ae:	e8 e7 5a ff ff       	call   c002449a <free>
    return NULL;
c002e9b3:	83 c4 10             	add    $0x10,%esp
c002e9b6:	be 00 00 00 00       	mov    $0x0,%esi
c002e9bb:	eb df                	jmp    c002e99c <file_open+0x38>

c002e9bd <file_reopen>:

/* Opens and returns a new file for the same inode as FILE.
   Returns a null pointer if unsuccessful. */
struct file *
file_reopen(struct file *file)
{
c002e9bd:	53                   	push   %ebx
c002e9be:	83 ec 14             	sub    $0x14,%esp
c002e9c1:	e8 20 3b 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e9c6:	81 c3 76 22 01 00    	add    $0x12276,%ebx
  return file_open(inode_reopen(file->inode));
c002e9cc:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002e9d0:	ff 30                	pushl  (%eax)
c002e9d2:	e8 92 17 00 00       	call   c0030169 <inode_reopen>
c002e9d7:	89 04 24             	mov    %eax,(%esp)
c002e9da:	e8 85 ff ff ff       	call   c002e964 <file_open>
}
c002e9df:	83 c4 18             	add    $0x18,%esp
c002e9e2:	5b                   	pop    %ebx
c002e9e3:	c3                   	ret    

c002e9e4 <file_get_inode>:

/* Returns the inode encapsulated by FILE. */
struct inode *
file_get_inode(struct file *file)
{
  return file->inode;
c002e9e4:	8b 44 24 04          	mov    0x4(%esp),%eax
c002e9e8:	8b 00                	mov    (%eax),%eax
}
c002e9ea:	c3                   	ret    

c002e9eb <file_read>:
   starting at the file's current position.
   Returns the number of bytes actually read,
   which may be less than SIZE if end of file is reached.
   Advances FILE's position by the number of bytes read. */
off_t file_read(struct file *file, void *buffer, off_t size)
{
c002e9eb:	56                   	push   %esi
c002e9ec:	53                   	push   %ebx
c002e9ed:	83 ec 04             	sub    $0x4,%esp
c002e9f0:	e8 f1 3a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002e9f5:	81 c3 47 22 01 00    	add    $0x12247,%ebx
c002e9fb:	8b 74 24 10          	mov    0x10(%esp),%esi
  off_t bytes_read = inode_read_at(file->inode, buffer, size, file->pos);
c002e9ff:	ff 76 04             	pushl  0x4(%esi)
c002ea02:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ea06:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ea0a:	ff 36                	pushl  (%esi)
c002ea0c:	e8 cf 19 00 00       	call   c00303e0 <inode_read_at>
  file->pos += bytes_read;
c002ea11:	01 46 04             	add    %eax,0x4(%esi)
  return bytes_read;
}
c002ea14:	83 c4 14             	add    $0x14,%esp
c002ea17:	5b                   	pop    %ebx
c002ea18:	5e                   	pop    %esi
c002ea19:	c3                   	ret    

c002ea1a <file_read_at>:
   starting at offset FILE_OFS in the file.
   Returns the number of bytes actually read,
   which may be less than SIZE if end of file is reached.
   The file's current position is unaffected. */
off_t file_read_at(struct file *file, void *buffer, off_t size, off_t file_ofs)
{
c002ea1a:	53                   	push   %ebx
c002ea1b:	83 ec 08             	sub    $0x8,%esp
c002ea1e:	e8 c3 3a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ea23:	81 c3 19 22 01 00    	add    $0x12219,%ebx
  return inode_read_at(file->inode, buffer, size, file_ofs);
c002ea29:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ea2d:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ea31:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ea35:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002ea39:	ff 30                	pushl  (%eax)
c002ea3b:	e8 a0 19 00 00       	call   c00303e0 <inode_read_at>
}
c002ea40:	83 c4 18             	add    $0x18,%esp
c002ea43:	5b                   	pop    %ebx
c002ea44:	c3                   	ret    

c002ea45 <file_write>:
   which may be less than SIZE if end of file is reached.
   (Normally we'd grow the file in that case, but file growth is
   not yet implemented.)
   Advances FILE's position by the number of bytes read. */
off_t file_write(struct file *file, const void *buffer, off_t size)
{
c002ea45:	56                   	push   %esi
c002ea46:	53                   	push   %ebx
c002ea47:	83 ec 04             	sub    $0x4,%esp
c002ea4a:	e8 97 3a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ea4f:	81 c3 ed 21 01 00    	add    $0x121ed,%ebx
c002ea55:	8b 74 24 10          	mov    0x10(%esp),%esi
  off_t bytes_written = inode_write_at(file->inode, buffer, size, file->pos);
c002ea59:	ff 76 04             	pushl  0x4(%esi)
c002ea5c:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ea60:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ea64:	ff 36                	pushl  (%esi)
c002ea66:	e8 b5 1a 00 00       	call   c0030520 <inode_write_at>
  file->pos += bytes_written;
c002ea6b:	01 46 04             	add    %eax,0x4(%esi)
  return bytes_written;
}
c002ea6e:	83 c4 14             	add    $0x14,%esp
c002ea71:	5b                   	pop    %ebx
c002ea72:	5e                   	pop    %esi
c002ea73:	c3                   	ret    

c002ea74 <file_write_at>:
   (Normally we'd grow the file in that case, but file growth is
   not yet implemented.)
   The file's current position is unaffected. */
off_t file_write_at(struct file *file, const void *buffer, off_t size,
                    off_t file_ofs)
{
c002ea74:	53                   	push   %ebx
c002ea75:	83 ec 08             	sub    $0x8,%esp
c002ea78:	e8 69 3a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ea7d:	81 c3 bf 21 01 00    	add    $0x121bf,%ebx
  return inode_write_at(file->inode, buffer, size, file_ofs);
c002ea83:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ea87:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ea8b:	ff 74 24 1c          	pushl  0x1c(%esp)
c002ea8f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002ea93:	ff 30                	pushl  (%eax)
c002ea95:	e8 86 1a 00 00       	call   c0030520 <inode_write_at>
}
c002ea9a:	83 c4 18             	add    $0x18,%esp
c002ea9d:	5b                   	pop    %ebx
c002ea9e:	c3                   	ret    

c002ea9f <file_deny_write>:

/* Prevents write operations on FILE's underlying inode
   until file_allow_write() is called or FILE is closed. */
void file_deny_write(struct file *file)
{
c002ea9f:	53                   	push   %ebx
c002eaa0:	83 ec 08             	sub    $0x8,%esp
c002eaa3:	e8 3e 3a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002eaa8:	81 c3 94 21 01 00    	add    $0x12194,%ebx
c002eaae:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(file != NULL);
c002eab2:	85 c0                	test   %eax,%eax
c002eab4:	74 0b                	je     c002eac1 <file_deny_write+0x22>
  if (!file->deny_write)
c002eab6:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
c002eaba:	74 2b                	je     c002eae7 <file_deny_write+0x48>
  {
    file->deny_write = true;
    inode_deny_write(file->inode);
  }
}
c002eabc:	83 c4 08             	add    $0x8,%esp
c002eabf:	5b                   	pop    %ebx
c002eac0:	c3                   	ret    
  ASSERT(file != NULL);
c002eac1:	83 ec 0c             	sub    $0xc,%esp
c002eac4:	8d 83 31 51 ff ff    	lea    -0xaecf(%ebx),%eax
c002eaca:	50                   	push   %eax
c002eacb:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002ead1:	50                   	push   %eax
c002ead2:	8d 83 54 2a ff ff    	lea    -0xd5ac(%ebx),%eax
c002ead8:	50                   	push   %eax
c002ead9:	6a 75                	push   $0x75
c002eadb:	8d 83 3e 51 ff ff    	lea    -0xaec2(%ebx),%eax
c002eae1:	50                   	push   %eax
c002eae2:	e8 ae ad ff ff       	call   c0029895 <debug_panic>
    file->deny_write = true;
c002eae7:	c6 40 08 01          	movb   $0x1,0x8(%eax)
    inode_deny_write(file->inode);
c002eaeb:	83 ec 0c             	sub    $0xc,%esp
c002eaee:	ff 30                	pushl  (%eax)
c002eaf0:	e8 b8 1b 00 00       	call   c00306ad <inode_deny_write>
c002eaf5:	83 c4 10             	add    $0x10,%esp
}
c002eaf8:	eb c2                	jmp    c002eabc <file_deny_write+0x1d>

c002eafa <file_allow_write>:

/* Re-enables write operations on FILE's underlying inode.
   (Writes might still be denied by some other file that has the
   same inode open.) */
void file_allow_write(struct file *file)
{
c002eafa:	53                   	push   %ebx
c002eafb:	83 ec 08             	sub    $0x8,%esp
c002eafe:	e8 e3 39 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002eb03:	81 c3 39 21 01 00    	add    $0x12139,%ebx
c002eb09:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(file != NULL);
c002eb0d:	85 c0                	test   %eax,%eax
c002eb0f:	74 0b                	je     c002eb1c <file_allow_write+0x22>
  if (file->deny_write)
c002eb11:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
c002eb15:	75 2e                	jne    c002eb45 <file_allow_write+0x4b>
  {
    file->deny_write = false;
    inode_allow_write(file->inode);
  }
}
c002eb17:	83 c4 08             	add    $0x8,%esp
c002eb1a:	5b                   	pop    %ebx
c002eb1b:	c3                   	ret    
  ASSERT(file != NULL);
c002eb1c:	83 ec 0c             	sub    $0xc,%esp
c002eb1f:	8d 83 31 51 ff ff    	lea    -0xaecf(%ebx),%eax
c002eb25:	50                   	push   %eax
c002eb26:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002eb2c:	50                   	push   %eax
c002eb2d:	8d 83 40 2a ff ff    	lea    -0xd5c0(%ebx),%eax
c002eb33:	50                   	push   %eax
c002eb34:	68 82 00 00 00       	push   $0x82
c002eb39:	8d 83 3e 51 ff ff    	lea    -0xaec2(%ebx),%eax
c002eb3f:	50                   	push   %eax
c002eb40:	e8 50 ad ff ff       	call   c0029895 <debug_panic>
    file->deny_write = false;
c002eb45:	c6 40 08 00          	movb   $0x0,0x8(%eax)
    inode_allow_write(file->inode);
c002eb49:	83 ec 0c             	sub    $0xc,%esp
c002eb4c:	ff 30                	pushl  (%eax)
c002eb4e:	e8 a9 1b 00 00       	call   c00306fc <inode_allow_write>
c002eb53:	83 c4 10             	add    $0x10,%esp
}
c002eb56:	eb bf                	jmp    c002eb17 <file_allow_write+0x1d>

c002eb58 <file_close>:
{
c002eb58:	56                   	push   %esi
c002eb59:	53                   	push   %ebx
c002eb5a:	83 ec 04             	sub    $0x4,%esp
c002eb5d:	e8 84 39 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002eb62:	81 c3 da 20 01 00    	add    $0x120da,%ebx
c002eb68:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (file != NULL)
c002eb6c:	85 f6                	test   %esi,%esi
c002eb6e:	74 1e                	je     c002eb8e <file_close+0x36>
    file_allow_write(file);
c002eb70:	83 ec 0c             	sub    $0xc,%esp
c002eb73:	56                   	push   %esi
c002eb74:	e8 81 ff ff ff       	call   c002eafa <file_allow_write>
    inode_close(file->inode);
c002eb79:	83 c4 04             	add    $0x4,%esp
c002eb7c:	ff 36                	pushl  (%esi)
c002eb7e:	e8 b1 16 00 00       	call   c0030234 <inode_close>
    free(file);
c002eb83:	89 34 24             	mov    %esi,(%esp)
c002eb86:	e8 0f 59 ff ff       	call   c002449a <free>
c002eb8b:	83 c4 10             	add    $0x10,%esp
}
c002eb8e:	83 c4 04             	add    $0x4,%esp
c002eb91:	5b                   	pop    %ebx
c002eb92:	5e                   	pop    %esi
c002eb93:	c3                   	ret    

c002eb94 <file_length>:

/* Returns the size of FILE in bytes. */
off_t file_length(struct file *file)
{
c002eb94:	53                   	push   %ebx
c002eb95:	83 ec 08             	sub    $0x8,%esp
c002eb98:	e8 49 39 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002eb9d:	81 c3 9f 20 01 00    	add    $0x1209f,%ebx
c002eba3:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(file != NULL);
c002eba7:	85 c0                	test   %eax,%eax
c002eba9:	74 0f                	je     c002ebba <file_length+0x26>
  return inode_length(file->inode);
c002ebab:	83 ec 0c             	sub    $0xc,%esp
c002ebae:	ff 30                	pushl  (%eax)
c002ebb0:	e8 c3 1b 00 00       	call   c0030778 <inode_length>
}
c002ebb5:	83 c4 18             	add    $0x18,%esp
c002ebb8:	5b                   	pop    %ebx
c002ebb9:	c3                   	ret    
  ASSERT(file != NULL);
c002ebba:	83 ec 0c             	sub    $0xc,%esp
c002ebbd:	8d 83 31 51 ff ff    	lea    -0xaecf(%ebx),%eax
c002ebc3:	50                   	push   %eax
c002ebc4:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002ebca:	50                   	push   %eax
c002ebcb:	8d 83 34 2a ff ff    	lea    -0xd5cc(%ebx),%eax
c002ebd1:	50                   	push   %eax
c002ebd2:	68 8d 00 00 00       	push   $0x8d
c002ebd7:	8d 83 3e 51 ff ff    	lea    -0xaec2(%ebx),%eax
c002ebdd:	50                   	push   %eax
c002ebde:	e8 b2 ac ff ff       	call   c0029895 <debug_panic>

c002ebe3 <file_seek>:

/* Sets the current position in FILE to NEW_POS bytes from the
   start of the file. */
void file_seek(struct file *file, off_t new_pos)
{
c002ebe3:	53                   	push   %ebx
c002ebe4:	83 ec 08             	sub    $0x8,%esp
c002ebe7:	e8 fa 38 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ebec:	81 c3 50 20 01 00    	add    $0x12050,%ebx
c002ebf2:	8b 44 24 10          	mov    0x10(%esp),%eax
c002ebf6:	8b 54 24 14          	mov    0x14(%esp),%edx
  ASSERT(file != NULL);
c002ebfa:	85 c0                	test   %eax,%eax
c002ebfc:	74 0c                	je     c002ec0a <file_seek+0x27>
  ASSERT(new_pos >= 0);
c002ebfe:	85 d2                	test   %edx,%edx
c002ec00:	78 31                	js     c002ec33 <file_seek+0x50>
  file->pos = new_pos;
c002ec02:	89 50 04             	mov    %edx,0x4(%eax)
}
c002ec05:	83 c4 08             	add    $0x8,%esp
c002ec08:	5b                   	pop    %ebx
c002ec09:	c3                   	ret    
  ASSERT(file != NULL);
c002ec0a:	83 ec 0c             	sub    $0xc,%esp
c002ec0d:	8d 83 31 51 ff ff    	lea    -0xaecf(%ebx),%eax
c002ec13:	50                   	push   %eax
c002ec14:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002ec1a:	50                   	push   %eax
c002ec1b:	8d 83 28 2a ff ff    	lea    -0xd5d8(%ebx),%eax
c002ec21:	50                   	push   %eax
c002ec22:	68 95 00 00 00       	push   $0x95
c002ec27:	8d 83 3e 51 ff ff    	lea    -0xaec2(%ebx),%eax
c002ec2d:	50                   	push   %eax
c002ec2e:	e8 62 ac ff ff       	call   c0029895 <debug_panic>
  ASSERT(new_pos >= 0);
c002ec33:	83 ec 0c             	sub    $0xc,%esp
c002ec36:	8d 83 53 51 ff ff    	lea    -0xaead(%ebx),%eax
c002ec3c:	50                   	push   %eax
c002ec3d:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002ec43:	50                   	push   %eax
c002ec44:	8d 83 28 2a ff ff    	lea    -0xd5d8(%ebx),%eax
c002ec4a:	50                   	push   %eax
c002ec4b:	68 96 00 00 00       	push   $0x96
c002ec50:	8d 83 3e 51 ff ff    	lea    -0xaec2(%ebx),%eax
c002ec56:	50                   	push   %eax
c002ec57:	e8 39 ac ff ff       	call   c0029895 <debug_panic>

c002ec5c <file_tell>:

/* Returns the current position in FILE as a byte offset from the
   start of the file. */
off_t file_tell(struct file *file)
{
c002ec5c:	53                   	push   %ebx
c002ec5d:	83 ec 08             	sub    $0x8,%esp
c002ec60:	e8 81 38 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ec65:	81 c3 d7 1f 01 00    	add    $0x11fd7,%ebx
c002ec6b:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(file != NULL);
c002ec6f:	85 c0                	test   %eax,%eax
c002ec71:	74 08                	je     c002ec7b <file_tell+0x1f>
  return file->pos;
c002ec73:	8b 40 04             	mov    0x4(%eax),%eax
}
c002ec76:	83 c4 08             	add    $0x8,%esp
c002ec79:	5b                   	pop    %ebx
c002ec7a:	c3                   	ret    
  ASSERT(file != NULL);
c002ec7b:	83 ec 0c             	sub    $0xc,%esp
c002ec7e:	8d 83 31 51 ff ff    	lea    -0xaecf(%ebx),%eax
c002ec84:	50                   	push   %eax
c002ec85:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002ec8b:	50                   	push   %eax
c002ec8c:	8d 83 1c 2a ff ff    	lea    -0xd5e4(%ebx),%eax
c002ec92:	50                   	push   %eax
c002ec93:	68 9e 00 00 00       	push   $0x9e
c002ec98:	8d 83 3e 51 ff ff    	lea    -0xaec2(%ebx),%eax
c002ec9e:	50                   	push   %eax
c002ec9f:	e8 f1 ab ff ff       	call   c0029895 <debug_panic>

c002eca4 <set_file_dir>:


void set_file_dir(struct file *file, struct dir *dir)
{
  file->dir = dir;
c002eca4:	8b 44 24 04          	mov    0x4(%esp),%eax
c002eca8:	8b 54 24 08          	mov    0x8(%esp),%edx
c002ecac:	89 50 0c             	mov    %edx,0xc(%eax)
}
c002ecaf:	c3                   	ret    

c002ecb0 <get_file_dir>:

struct dir *
get_file_dir(struct file *file)
{
  return file->dir;
c002ecb0:	8b 44 24 04          	mov    0x4(%esp),%eax
c002ecb4:	8b 40 0c             	mov    0xc(%eax),%eax
c002ecb7:	c3                   	ret    

c002ecb8 <lookup>:
   directory entry if OFSP is non-null.
   otherwise, returns false and ignores EP and OFSP. */
static bool
lookup(const struct dir *dir, const char *name,
       struct dir_entry *ep, off_t *ofsp)
{
c002ecb8:	55                   	push   %ebp
c002ecb9:	57                   	push   %edi
c002ecba:	56                   	push   %esi
c002ecbb:	53                   	push   %ebx
c002ecbc:	83 ec 4c             	sub    $0x4c,%esp
c002ecbf:	e8 22 38 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ecc4:	81 c3 78 1f 01 00    	add    $0x11f78,%ebx
c002ecca:	89 54 24 14          	mov    %edx,0x14(%esp)
c002ecce:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
  struct dir_entry e;
  size_t ofs;

  ASSERT(dir != NULL);
c002ecd2:	85 c0                	test   %eax,%eax
c002ecd4:	74 1c                	je     c002ecf2 <lookup+0x3a>
c002ecd6:	89 c5                	mov    %eax,%ebp
  ASSERT(name != NULL);
c002ecd8:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c002ecdd:	74 39                	je     c002ed18 <lookup+0x60>

  for (ofs = 0; inode_read_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
c002ecdf:	be 00 00 00 00       	mov    $0x0,%esi
c002ece4:	8d 7c 24 2c          	lea    0x2c(%esp),%edi
       ofs += sizeof e)
    if (e.in_use && !strcmp(name, e.name))
c002ece8:	8d 44 24 30          	lea    0x30(%esp),%eax
c002ecec:	89 44 24 18          	mov    %eax,0x18(%esp)
c002ecf0:	eb 4f                	jmp    c002ed41 <lookup+0x89>
  ASSERT(dir != NULL);
c002ecf2:	83 ec 0c             	sub    $0xc,%esp
c002ecf5:	8d 83 37 4f ff ff    	lea    -0xb0c9(%ebx),%eax
c002ecfb:	50                   	push   %eax
c002ecfc:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002ed02:	50                   	push   %eax
c002ed03:	8d 83 d8 2a ff ff    	lea    -0xd528(%ebx),%eax
c002ed09:	50                   	push   %eax
c002ed0a:	6a 66                	push   $0x66
c002ed0c:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002ed12:	50                   	push   %eax
c002ed13:	e8 7d ab ff ff       	call   c0029895 <debug_panic>
  ASSERT(name != NULL);
c002ed18:	83 ec 0c             	sub    $0xc,%esp
c002ed1b:	8d 83 0c 52 ff ff    	lea    -0xadf4(%ebx),%eax
c002ed21:	50                   	push   %eax
c002ed22:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002ed28:	50                   	push   %eax
c002ed29:	8d 83 d8 2a ff ff    	lea    -0xd528(%ebx),%eax
c002ed2f:	50                   	push   %eax
c002ed30:	6a 67                	push   $0x67
c002ed32:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002ed38:	50                   	push   %eax
c002ed39:	e8 57 ab ff ff       	call   c0029895 <debug_panic>
       ofs += sizeof e)
c002ed3e:	83 c6 14             	add    $0x14,%esi
  for (ofs = 0; inode_read_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
c002ed41:	89 74 24 10          	mov    %esi,0x10(%esp)
c002ed45:	56                   	push   %esi
c002ed46:	6a 14                	push   $0x14
c002ed48:	57                   	push   %edi
c002ed49:	ff 75 00             	pushl  0x0(%ebp)
c002ed4c:	e8 8f 16 00 00       	call   c00303e0 <inode_read_at>
c002ed51:	83 c4 10             	add    $0x10,%esp
c002ed54:	83 f8 14             	cmp    $0x14,%eax
c002ed57:	75 61                	jne    c002edba <lookup+0x102>
    if (e.in_use && !strcmp(name, e.name))
c002ed59:	0f b6 44 24 3f       	movzbl 0x3f(%esp),%eax
c002ed5e:	88 44 24 0f          	mov    %al,0xf(%esp)
c002ed62:	84 c0                	test   %al,%al
c002ed64:	74 d8                	je     c002ed3e <lookup+0x86>
c002ed66:	83 ec 08             	sub    $0x8,%esp
c002ed69:	ff 74 24 20          	pushl  0x20(%esp)
c002ed6d:	ff 74 24 20          	pushl  0x20(%esp)
c002ed71:	e8 e4 9d ff ff       	call   c0028b5a <strcmp>
c002ed76:	83 c4 10             	add    $0x10,%esp
c002ed79:	85 c0                	test   %eax,%eax
c002ed7b:	75 c1                	jne    c002ed3e <lookup+0x86>
    {
      if (ep != NULL)
c002ed7d:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c002ed81:	85 d2                	test   %edx,%edx
c002ed83:	74 22                	je     c002eda7 <lookup+0xef>
        *ep = e;
c002ed85:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c002ed89:	89 02                	mov    %eax,(%edx)
c002ed8b:	8b 44 24 30          	mov    0x30(%esp),%eax
c002ed8f:	89 42 04             	mov    %eax,0x4(%edx)
c002ed92:	8b 44 24 34          	mov    0x34(%esp),%eax
c002ed96:	89 42 08             	mov    %eax,0x8(%edx)
c002ed99:	8b 44 24 38          	mov    0x38(%esp),%eax
c002ed9d:	89 42 0c             	mov    %eax,0xc(%edx)
c002eda0:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002eda4:	89 42 10             	mov    %eax,0x10(%edx)
      if (ofsp != NULL)
c002eda7:	83 7c 24 60 00       	cmpl   $0x0,0x60(%esp)
c002edac:	74 11                	je     c002edbf <lookup+0x107>
        *ofsp = ofs;
c002edae:	8b 44 24 60          	mov    0x60(%esp),%eax
c002edb2:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c002edb6:	89 08                	mov    %ecx,(%eax)
c002edb8:	eb 05                	jmp    c002edbf <lookup+0x107>
      return true;
    }
  return false;
c002edba:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
}
c002edbf:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
c002edc4:	83 c4 4c             	add    $0x4c,%esp
c002edc7:	5b                   	pop    %ebx
c002edc8:	5e                   	pop    %esi
c002edc9:	5f                   	pop    %edi
c002edca:	5d                   	pop    %ebp
c002edcb:	c3                   	ret    

c002edcc <dir_open>:
{
c002edcc:	57                   	push   %edi
c002edcd:	56                   	push   %esi
c002edce:	53                   	push   %ebx
c002edcf:	e8 12 37 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002edd4:	81 c3 68 1e 01 00    	add    $0x11e68,%ebx
c002edda:	8b 7c 24 10          	mov    0x10(%esp),%edi
  struct dir *dir = calloc(1, sizeof *dir);
c002edde:	83 ec 08             	sub    $0x8,%esp
c002ede1:	6a 08                	push   $0x8
c002ede3:	6a 01                	push   $0x1
c002ede5:	e8 5f 56 ff ff       	call   c0024449 <calloc>
c002edea:	89 c6                	mov    %eax,%esi
  if (inode != NULL && dir != NULL)
c002edec:	83 c4 10             	add    $0x10,%esp
c002edef:	85 ff                	test   %edi,%edi
c002edf1:	74 49                	je     c002ee3c <dir_open+0x70>
c002edf3:	85 c0                	test   %eax,%eax
c002edf5:	74 45                	je     c002ee3c <dir_open+0x70>
    ASSERT(inode_isdir(inode));
c002edf7:	83 ec 0c             	sub    $0xc,%esp
c002edfa:	57                   	push   %edi
c002edfb:	e8 80 19 00 00       	call   c0030780 <inode_isdir>
c002ee00:	83 c4 10             	add    $0x10,%esp
c002ee03:	84 c0                	test   %al,%al
c002ee05:	74 0f                	je     c002ee16 <dir_open+0x4a>
    dir->inode = inode;
c002ee07:	89 3e                	mov    %edi,(%esi)
    dir->pos = DIR_BASE_ENTRY * sizeof(struct dir_entry);
c002ee09:	c7 46 04 28 00 00 00 	movl   $0x28,0x4(%esi)
}
c002ee10:	89 f0                	mov    %esi,%eax
c002ee12:	5b                   	pop    %ebx
c002ee13:	5e                   	pop    %esi
c002ee14:	5f                   	pop    %edi
c002ee15:	c3                   	ret    
    ASSERT(inode_isdir(inode));
c002ee16:	83 ec 0c             	sub    $0xc,%esp
c002ee19:	8d 83 7a 51 ff ff    	lea    -0xae86(%ebx),%eax
c002ee1f:	50                   	push   %eax
c002ee20:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002ee26:	50                   	push   %eax
c002ee27:	8d 83 ec 2a ff ff    	lea    -0xd514(%ebx),%eax
c002ee2d:	50                   	push   %eax
c002ee2e:	6a 2b                	push   $0x2b
c002ee30:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002ee36:	50                   	push   %eax
c002ee37:	e8 59 aa ff ff       	call   c0029895 <debug_panic>
    inode_close(inode);
c002ee3c:	83 ec 0c             	sub    $0xc,%esp
c002ee3f:	57                   	push   %edi
c002ee40:	e8 ef 13 00 00       	call   c0030234 <inode_close>
    free(dir);
c002ee45:	89 34 24             	mov    %esi,(%esp)
c002ee48:	e8 4d 56 ff ff       	call   c002449a <free>
    return NULL;
c002ee4d:	83 c4 10             	add    $0x10,%esp
c002ee50:	be 00 00 00 00       	mov    $0x0,%esi
c002ee55:	eb b9                	jmp    c002ee10 <dir_open+0x44>

c002ee57 <dir_open_root>:
{
c002ee57:	53                   	push   %ebx
c002ee58:	83 ec 14             	sub    $0x14,%esp
c002ee5b:	e8 86 36 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ee60:	81 c3 dc 1d 01 00    	add    $0x11ddc,%ebx
  return dir_open(inode_open(ROOT_DIR_SECTOR));
c002ee66:	6a 01                	push   $0x1
c002ee68:	e8 0a 13 00 00       	call   c0030177 <inode_open>
c002ee6d:	89 04 24             	mov    %eax,(%esp)
c002ee70:	e8 57 ff ff ff       	call   c002edcc <dir_open>
}
c002ee75:	83 c4 18             	add    $0x18,%esp
c002ee78:	5b                   	pop    %ebx
c002ee79:	c3                   	ret    

c002ee7a <dir_reopen>:
{
c002ee7a:	53                   	push   %ebx
c002ee7b:	83 ec 14             	sub    $0x14,%esp
c002ee7e:	e8 63 36 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ee83:	81 c3 b9 1d 01 00    	add    $0x11db9,%ebx
  return dir_open(inode_reopen(dir->inode));
c002ee89:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002ee8d:	ff 30                	pushl  (%eax)
c002ee8f:	e8 d5 12 00 00       	call   c0030169 <inode_reopen>
c002ee94:	89 04 24             	mov    %eax,(%esp)
c002ee97:	e8 30 ff ff ff       	call   c002edcc <dir_open>
}
c002ee9c:	83 c4 18             	add    $0x18,%esp
c002ee9f:	5b                   	pop    %ebx
c002eea0:	c3                   	ret    

c002eea1 <dir_close>:
{
c002eea1:	56                   	push   %esi
c002eea2:	53                   	push   %ebx
c002eea3:	83 ec 04             	sub    $0x4,%esp
c002eea6:	e8 3b 36 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002eeab:	81 c3 91 1d 01 00    	add    $0x11d91,%ebx
c002eeb1:	8b 74 24 10          	mov    0x10(%esp),%esi
  if (dir != NULL)
c002eeb5:	85 f6                	test   %esi,%esi
c002eeb7:	74 15                	je     c002eece <dir_close+0x2d>
    inode_close(dir->inode);
c002eeb9:	83 ec 0c             	sub    $0xc,%esp
c002eebc:	ff 36                	pushl  (%esi)
c002eebe:	e8 71 13 00 00       	call   c0030234 <inode_close>
    free(dir);
c002eec3:	89 34 24             	mov    %esi,(%esp)
c002eec6:	e8 cf 55 ff ff       	call   c002449a <free>
c002eecb:	83 c4 10             	add    $0x10,%esp
}
c002eece:	83 c4 04             	add    $0x4,%esp
c002eed1:	5b                   	pop    %ebx
c002eed2:	5e                   	pop    %esi
c002eed3:	c3                   	ret    

c002eed4 <dir_get_inode>:
  return dir->inode;
c002eed4:	8b 44 24 04          	mov    0x4(%esp),%eax
c002eed8:	8b 00                	mov    (%eax),%eax
}
c002eeda:	c3                   	ret    

c002eedb <dir_lookup>:
   and returns true if one exists, false otherwise.
   On success, sets *INODE to an inode for the file, otherwise to
   a null pointer.  The caller must close *INODE. */
bool dir_lookup(const struct dir *dir, const char *name,
                struct inode **inode)
{
c002eedb:	56                   	push   %esi
c002eedc:	53                   	push   %ebx
c002eedd:	83 ec 24             	sub    $0x24,%esp
c002eee0:	e8 01 36 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002eee5:	81 c3 57 1d 01 00    	add    $0x11d57,%ebx
c002eeeb:	8b 44 24 30          	mov    0x30(%esp),%eax
c002eeef:	8b 54 24 34          	mov    0x34(%esp),%edx
c002eef3:	8b 74 24 38          	mov    0x38(%esp),%esi
  struct dir_entry e;

  ASSERT(dir != NULL);
c002eef7:	85 c0                	test   %eax,%eax
c002eef9:	74 2b                	je     c002ef26 <dir_lookup+0x4b>
  ASSERT(name != NULL);
c002eefb:	85 d2                	test   %edx,%edx
c002eefd:	74 4d                	je     c002ef4c <dir_lookup+0x71>

  if (lookup(dir, name, &e, NULL))
c002eeff:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c002ef03:	83 ec 0c             	sub    $0xc,%esp
c002ef06:	6a 00                	push   $0x0
c002ef08:	e8 ab fd ff ff       	call   c002ecb8 <lookup>
c002ef0d:	83 c4 10             	add    $0x10,%esp
c002ef10:	84 c0                	test   %al,%al
c002ef12:	75 61                	jne    c002ef75 <dir_lookup+0x9a>
    *inode = inode_open(e.inode_sector);
  else
    *inode = NULL;
c002ef14:	c7 06 00 00 00 00    	movl   $0x0,(%esi)

  return *inode != NULL;
c002ef1a:	83 3e 00             	cmpl   $0x0,(%esi)
c002ef1d:	0f 95 c0             	setne  %al
}
c002ef20:	83 c4 24             	add    $0x24,%esp
c002ef23:	5b                   	pop    %ebx
c002ef24:	5e                   	pop    %esi
c002ef25:	c3                   	ret    
  ASSERT(dir != NULL);
c002ef26:	83 ec 0c             	sub    $0xc,%esp
c002ef29:	8d 83 37 4f ff ff    	lea    -0xb0c9(%ebx),%eax
c002ef2f:	50                   	push   %eax
c002ef30:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002ef36:	50                   	push   %eax
c002ef37:	8d 83 e0 2a ff ff    	lea    -0xd520(%ebx),%eax
c002ef3d:	50                   	push   %eax
c002ef3e:	6a 7f                	push   $0x7f
c002ef40:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002ef46:	50                   	push   %eax
c002ef47:	e8 49 a9 ff ff       	call   c0029895 <debug_panic>
  ASSERT(name != NULL);
c002ef4c:	83 ec 0c             	sub    $0xc,%esp
c002ef4f:	8d 83 0c 52 ff ff    	lea    -0xadf4(%ebx),%eax
c002ef55:	50                   	push   %eax
c002ef56:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002ef5c:	50                   	push   %eax
c002ef5d:	8d 83 e0 2a ff ff    	lea    -0xd520(%ebx),%eax
c002ef63:	50                   	push   %eax
c002ef64:	68 80 00 00 00       	push   $0x80
c002ef69:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002ef6f:	50                   	push   %eax
c002ef70:	e8 20 a9 ff ff       	call   c0029895 <debug_panic>
    *inode = inode_open(e.inode_sector);
c002ef75:	83 ec 0c             	sub    $0xc,%esp
c002ef78:	ff 74 24 18          	pushl  0x18(%esp)
c002ef7c:	e8 f6 11 00 00       	call   c0030177 <inode_open>
c002ef81:	89 06                	mov    %eax,(%esi)
c002ef83:	83 c4 10             	add    $0x10,%esp
c002ef86:	eb 92                	jmp    c002ef1a <dir_lookup+0x3f>

c002ef88 <dir_add>:
   INODE_SECTOR.
   Returns true if successful, false on failure.
   Fails if NAME is invalid (i.e. too long) or a disk or memory
   error occurs. */
bool dir_add(struct dir *dir, const char *name, block_sector_t inode_sector)
{
c002ef88:	55                   	push   %ebp
c002ef89:	57                   	push   %edi
c002ef8a:	56                   	push   %esi
c002ef8b:	53                   	push   %ebx
c002ef8c:	83 ec 3c             	sub    $0x3c,%esp
c002ef8f:	e8 52 35 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002ef94:	81 c3 a8 1c 01 00    	add    $0x11ca8,%ebx
c002ef9a:	8b 6c 24 50          	mov    0x50(%esp),%ebp
c002ef9e:	8b 74 24 54          	mov    0x54(%esp),%esi
  struct dir_entry e;
  off_t ofs;
  bool success = false;

  ASSERT(dir != NULL);
c002efa2:	85 ed                	test   %ebp,%ebp
c002efa4:	0f 84 8c 00 00 00    	je     c002f036 <dir_add+0xae>
  ASSERT(name != NULL);
c002efaa:	85 f6                	test   %esi,%esi
c002efac:	0f 84 ad 00 00 00    	je     c002f05f <dir_add+0xd7>

  /* Check NAME for validity. */
  if (*name == '\0' || strlen(name) > NAME_MAX)
c002efb2:	80 3e 00             	cmpb   $0x0,(%esi)
c002efb5:	0f 84 3f 02 00 00    	je     c002f1fa <dir_add+0x272>
c002efbb:	b9 ff ff ff ff       	mov    $0xffffffff,%ecx
c002efc0:	b8 00 00 00 00       	mov    $0x0,%eax
c002efc5:	89 f7                	mov    %esi,%edi
c002efc7:	f2 ae                	repnz scas %es:(%edi),%al
c002efc9:	89 c8                	mov    %ecx,%eax
c002efcb:	f7 d0                	not    %eax
c002efcd:	83 e8 01             	sub    $0x1,%eax
    return false;
c002efd0:	bf 00 00 00 00       	mov    $0x0,%edi
  if (*name == '\0' || strlen(name) > NAME_MAX)
c002efd5:	83 f8 0e             	cmp    $0xe,%eax
c002efd8:	0f 87 21 02 00 00    	ja     c002f1ff <dir_add+0x277>

  /* Check that NAME is not in use. */
  if (lookup(dir, name, NULL, NULL))
c002efde:	83 ec 0c             	sub    $0xc,%esp
c002efe1:	6a 00                	push   $0x0
c002efe3:	b9 00 00 00 00       	mov    $0x0,%ecx
c002efe8:	89 f2                	mov    %esi,%edx
c002efea:	89 e8                	mov    %ebp,%eax
c002efec:	e8 c7 fc ff ff       	call   c002ecb8 <lookup>
c002eff1:	89 c7                	mov    %eax,%edi
c002eff3:	83 c4 10             	add    $0x10,%esp
c002eff6:	84 c0                	test   %al,%al
c002eff8:	0f 85 0b 02 00 00    	jne    c002f209 <dir_add+0x281>
     current end-of-file.
     
     inode_read_at() will only return a short read at end of file.
     Otherwise, we'd need to verify that we didn't get a short
     read due to something intermittent such as low memory. */
  for (ofs = 0; inode_read_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
c002effe:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c002f005:	00 
c002f006:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c002f00a:	89 44 24 0c          	mov    %eax,0xc(%esp)
c002f00e:	ff 74 24 18          	pushl  0x18(%esp)
c002f012:	6a 14                	push   $0x14
c002f014:	ff 74 24 14          	pushl  0x14(%esp)
c002f018:	ff 75 00             	pushl  0x0(%ebp)
c002f01b:	e8 c0 13 00 00       	call   c00303e0 <inode_read_at>
c002f020:	83 c4 10             	add    $0x10,%esp
c002f023:	83 f8 14             	cmp    $0x14,%eax
c002f026:	75 60                	jne    c002f088 <dir_add+0x100>
       ofs += sizeof e)
    if (!e.in_use)
c002f028:	80 7c 24 2f 00       	cmpb   $0x0,0x2f(%esp)
c002f02d:	74 59                	je     c002f088 <dir_add+0x100>
       ofs += sizeof e)
c002f02f:	83 44 24 18 14       	addl   $0x14,0x18(%esp)
c002f034:	eb d8                	jmp    c002f00e <dir_add+0x86>
  ASSERT(dir != NULL);
c002f036:	83 ec 0c             	sub    $0xc,%esp
c002f039:	8d 83 37 4f ff ff    	lea    -0xb0c9(%ebx),%eax
c002f03f:	50                   	push   %eax
c002f040:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f046:	50                   	push   %eax
c002f047:	8d 83 d0 2a ff ff    	lea    -0xd530(%ebx),%eax
c002f04d:	50                   	push   %eax
c002f04e:	68 96 00 00 00       	push   $0x96
c002f053:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f059:	50                   	push   %eax
c002f05a:	e8 36 a8 ff ff       	call   c0029895 <debug_panic>
  ASSERT(name != NULL);
c002f05f:	83 ec 0c             	sub    $0xc,%esp
c002f062:	8d 83 0c 52 ff ff    	lea    -0xadf4(%ebx),%eax
c002f068:	50                   	push   %eax
c002f069:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f06f:	50                   	push   %eax
c002f070:	8d 83 d0 2a ff ff    	lea    -0xd530(%ebx),%eax
c002f076:	50                   	push   %eax
c002f077:	68 97 00 00 00       	push   $0x97
c002f07c:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f082:	50                   	push   %eax
c002f083:	e8 0d a8 ff ff       	call   c0029895 <debug_panic>
      break;

  /* Write slot. */
  e.in_use = true;
c002f088:	c6 44 24 2f 01       	movb   $0x1,0x2f(%esp)
  strlcpy(e.name, name, sizeof e.name);
c002f08d:	83 ec 04             	sub    $0x4,%esp
c002f090:	6a 0f                	push   $0xf
c002f092:	56                   	push   %esi
c002f093:	8d 74 24 28          	lea    0x28(%esp),%esi
c002f097:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c002f09b:	50                   	push   %eax
c002f09c:	e8 49 9e ff ff       	call   c0028eea <strlcpy>
  e.inode_sector = inode_sector;
c002f0a1:	8b 44 24 68          	mov    0x68(%esp),%eax
c002f0a5:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  success = inode_write_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
c002f0a9:	ff 74 24 28          	pushl  0x28(%esp)
c002f0ad:	6a 14                	push   $0x14
c002f0af:	56                   	push   %esi
c002f0b0:	ff 75 00             	pushl  0x0(%ebp)
c002f0b3:	e8 68 14 00 00       	call   c0030520 <inode_write_at>

  if (success && inode_sector != inode_get_inumber(dir->inode))
c002f0b8:	83 c4 20             	add    $0x20,%esp
c002f0bb:	83 f8 14             	cmp    $0x14,%eax
c002f0be:	0f 85 3b 01 00 00    	jne    c002f1ff <dir_add+0x277>
c002f0c4:	83 ec 0c             	sub    $0xc,%esp
c002f0c7:	ff 75 00             	pushl  0x0(%ebp)
c002f0ca:	e8 5d 11 00 00       	call   c003022c <inode_get_inumber>
c002f0cf:	83 c4 10             	add    $0x10,%esp
c002f0d2:	3b 44 24 58          	cmp    0x58(%esp),%eax
c002f0d6:	0f 84 34 01 00 00    	je     c002f210 <dir_add+0x288>
  {
    struct inode *inode;
    inode = inode_open(inode_sector);
c002f0dc:	83 ec 0c             	sub    $0xc,%esp
c002f0df:	ff 74 24 64          	pushl  0x64(%esp)
c002f0e3:	e8 8f 10 00 00       	call   c0030177 <inode_open>
c002f0e8:	89 c6                	mov    %eax,%esi
    ASSERT(inode != NULL);
c002f0ea:	83 c4 10             	add    $0x10,%esp
c002f0ed:	85 c0                	test   %eax,%eax
c002f0ef:	74 7b                	je     c002f16c <dir_add+0x1e4>

    if (inode_isdir(inode))
c002f0f1:	83 ec 0c             	sub    $0xc,%esp
c002f0f4:	50                   	push   %eax
c002f0f5:	e8 86 16 00 00       	call   c0030780 <inode_isdir>
c002f0fa:	83 c4 10             	add    $0x10,%esp
c002f0fd:	84 c0                	test   %al,%al
c002f0ff:	0f 84 e2 00 00 00    	je     c002f1e7 <dir_add+0x25f>
    {
      struct dir *subdir = dir_open(inode);
c002f105:	83 ec 0c             	sub    $0xc,%esp
c002f108:	56                   	push   %esi
c002f109:	e8 be fc ff ff       	call   c002edcc <dir_open>
c002f10e:	89 c6                	mov    %eax,%esi
      ASSERT(lookup(subdir, "..", &e, &ofs));
c002f110:	8d 4c 24 2c          	lea    0x2c(%esp),%ecx
c002f114:	83 c4 04             	add    $0x4,%esp
c002f117:	8d 44 24 24          	lea    0x24(%esp),%eax
c002f11b:	50                   	push   %eax
c002f11c:	8d 93 82 41 ff ff    	lea    -0xbe7e(%ebx),%edx
c002f122:	89 f0                	mov    %esi,%eax
c002f124:	e8 8f fb ff ff       	call   c002ecb8 <lookup>
c002f129:	89 c7                	mov    %eax,%edi
c002f12b:	83 c4 10             	add    $0x10,%esp
c002f12e:	84 c0                	test   %al,%al
c002f130:	74 63                	je     c002f195 <dir_add+0x20d>
      e.inode_sector = inode_get_inumber(dir->inode);
c002f132:	83 ec 0c             	sub    $0xc,%esp
c002f135:	ff 75 00             	pushl  0x0(%ebp)
c002f138:	e8 ef 10 00 00       	call   c003022c <inode_get_inumber>
c002f13d:	89 44 24 2c          	mov    %eax,0x2c(%esp)
      ASSERT(inode_write_at(subdir->inode, &e, sizeof e, ofs) == sizeof e);
c002f141:	ff 74 24 28          	pushl  0x28(%esp)
c002f145:	6a 14                	push   $0x14
c002f147:	8d 44 24 34          	lea    0x34(%esp),%eax
c002f14b:	50                   	push   %eax
c002f14c:	ff 36                	pushl  (%esi)
c002f14e:	e8 cd 13 00 00       	call   c0030520 <inode_write_at>
c002f153:	83 c4 20             	add    $0x20,%esp
c002f156:	83 f8 14             	cmp    $0x14,%eax
c002f159:	75 63                	jne    c002f1be <dir_add+0x236>
      dir_close(subdir);
c002f15b:	83 ec 0c             	sub    $0xc,%esp
c002f15e:	56                   	push   %esi
c002f15f:	e8 3d fd ff ff       	call   c002eea1 <dir_close>
c002f164:	83 c4 10             	add    $0x10,%esp
c002f167:	e9 93 00 00 00       	jmp    c002f1ff <dir_add+0x277>
    ASSERT(inode != NULL);
c002f16c:	83 ec 0c             	sub    $0xc,%esp
c002f16f:	8d 83 8d 51 ff ff    	lea    -0xae73(%ebx),%eax
c002f175:	50                   	push   %eax
c002f176:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f17c:	50                   	push   %eax
c002f17d:	8d 83 d0 2a ff ff    	lea    -0xd530(%ebx),%eax
c002f183:	50                   	push   %eax
c002f184:	68 b7 00 00 00       	push   $0xb7
c002f189:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f18f:	50                   	push   %eax
c002f190:	e8 00 a7 ff ff       	call   c0029895 <debug_panic>
      ASSERT(lookup(subdir, "..", &e, &ofs));
c002f195:	83 ec 0c             	sub    $0xc,%esp
c002f198:	8d 83 1c 52 ff ff    	lea    -0xade4(%ebx),%eax
c002f19e:	50                   	push   %eax
c002f19f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f1a5:	50                   	push   %eax
c002f1a6:	8d 83 d0 2a ff ff    	lea    -0xd530(%ebx),%eax
c002f1ac:	50                   	push   %eax
c002f1ad:	68 bc 00 00 00       	push   $0xbc
c002f1b2:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f1b8:	50                   	push   %eax
c002f1b9:	e8 d7 a6 ff ff       	call   c0029895 <debug_panic>
      ASSERT(inode_write_at(subdir->inode, &e, sizeof e, ofs) == sizeof e);
c002f1be:	83 ec 0c             	sub    $0xc,%esp
c002f1c1:	8d 83 3c 52 ff ff    	lea    -0xadc4(%ebx),%eax
c002f1c7:	50                   	push   %eax
c002f1c8:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f1ce:	50                   	push   %eax
c002f1cf:	8d 83 d0 2a ff ff    	lea    -0xd530(%ebx),%eax
c002f1d5:	50                   	push   %eax
c002f1d6:	68 be 00 00 00       	push   $0xbe
c002f1db:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f1e1:	50                   	push   %eax
c002f1e2:	e8 ae a6 ff ff       	call   c0029895 <debug_panic>
    }
    else
    {
      inode_close(inode);
c002f1e7:	83 ec 0c             	sub    $0xc,%esp
c002f1ea:	56                   	push   %esi
c002f1eb:	e8 44 10 00 00       	call   c0030234 <inode_close>
c002f1f0:	83 c4 10             	add    $0x10,%esp
  success = inode_write_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
c002f1f3:	bf 01 00 00 00       	mov    $0x1,%edi
c002f1f8:	eb 05                	jmp    c002f1ff <dir_add+0x277>
    return false;
c002f1fa:	bf 00 00 00 00       	mov    $0x0,%edi
    }
  }
  
done:
  return success;
}
c002f1ff:	89 f8                	mov    %edi,%eax
c002f201:	83 c4 3c             	add    $0x3c,%esp
c002f204:	5b                   	pop    %ebx
c002f205:	5e                   	pop    %esi
c002f206:	5f                   	pop    %edi
c002f207:	5d                   	pop    %ebp
c002f208:	c3                   	ret    
  bool success = false;
c002f209:	bf 00 00 00 00       	mov    $0x0,%edi
c002f20e:	eb ef                	jmp    c002f1ff <dir_add+0x277>
  success = inode_write_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
c002f210:	bf 01 00 00 00       	mov    $0x1,%edi
c002f215:	eb e8                	jmp    c002f1ff <dir_add+0x277>

c002f217 <dir_create>:
{
c002f217:	55                   	push   %ebp
c002f218:	57                   	push   %edi
c002f219:	56                   	push   %esi
c002f21a:	53                   	push   %ebx
c002f21b:	83 ec 14             	sub    $0x14,%esp
c002f21e:	e8 c3 32 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002f223:	81 c3 19 1a 01 00    	add    $0x11a19,%ebx
c002f229:	8b 74 24 28          	mov    0x28(%esp),%esi
c002f22d:	8b 44 24 2c          	mov    0x2c(%esp),%eax
  bool suc = inode_create(sector, (DIR_BASE_ENTRY + entry_cnt) * sizeof(struct dir_entry));
c002f231:	8d 04 80             	lea    (%eax,%eax,4),%eax
c002f234:	8d 04 85 28 00 00 00 	lea    0x28(,%eax,4),%eax
c002f23b:	50                   	push   %eax
c002f23c:	56                   	push   %esi
c002f23d:	e8 a7 0c 00 00       	call   c002fee9 <inode_create>
c002f242:	89 c7                	mov    %eax,%edi
  if (suc)
c002f244:	83 c4 10             	add    $0x10,%esp
c002f247:	84 c0                	test   %al,%al
c002f249:	75 0a                	jne    c002f255 <dir_create+0x3e>
}
c002f24b:	89 f8                	mov    %edi,%eax
c002f24d:	83 c4 0c             	add    $0xc,%esp
c002f250:	5b                   	pop    %ebx
c002f251:	5e                   	pop    %esi
c002f252:	5f                   	pop    %edi
c002f253:	5d                   	pop    %ebp
c002f254:	c3                   	ret    
    struct inode *inode = inode_open(sector);
c002f255:	83 ec 0c             	sub    $0xc,%esp
c002f258:	56                   	push   %esi
c002f259:	e8 19 0f 00 00       	call   c0030177 <inode_open>
c002f25e:	89 c5                	mov    %eax,%ebp
    ASSERT(inode != NULL);
c002f260:	83 c4 10             	add    $0x10,%esp
c002f263:	85 c0                	test   %eax,%eax
c002f265:	74 5c                	je     c002f2c3 <dir_create+0xac>
    inode_set_dir(inode);
c002f267:	83 ec 0c             	sub    $0xc,%esp
c002f26a:	50                   	push   %eax
c002f26b:	e8 1c 15 00 00       	call   c003078c <inode_set_dir>
    struct dir *dir = dir_open(inode);
c002f270:	89 2c 24             	mov    %ebp,(%esp)
c002f273:	e8 54 fb ff ff       	call   c002edcc <dir_open>
c002f278:	89 c5                	mov    %eax,%ebp
    ASSERT(dir != NULL);
c002f27a:	83 c4 10             	add    $0x10,%esp
c002f27d:	85 c0                	test   %eax,%eax
c002f27f:	74 68                	je     c002f2e9 <dir_create+0xd2>
    ASSERT(dir_add(dir, ".", sector));
c002f281:	83 ec 04             	sub    $0x4,%esp
c002f284:	56                   	push   %esi
c002f285:	8d 83 83 41 ff ff    	lea    -0xbe7d(%ebx),%eax
c002f28b:	50                   	push   %eax
c002f28c:	55                   	push   %ebp
c002f28d:	e8 f6 fc ff ff       	call   c002ef88 <dir_add>
c002f292:	83 c4 10             	add    $0x10,%esp
c002f295:	84 c0                	test   %al,%al
c002f297:	74 76                	je     c002f30f <dir_create+0xf8>
    ASSERT(dir_add(dir, "..", sector));
c002f299:	83 ec 04             	sub    $0x4,%esp
c002f29c:	56                   	push   %esi
c002f29d:	8d 83 82 41 ff ff    	lea    -0xbe7e(%ebx),%eax
c002f2a3:	50                   	push   %eax
c002f2a4:	55                   	push   %ebp
c002f2a5:	e8 de fc ff ff       	call   c002ef88 <dir_add>
c002f2aa:	83 c4 10             	add    $0x10,%esp
c002f2ad:	84 c0                	test   %al,%al
c002f2af:	0f 84 80 00 00 00    	je     c002f335 <dir_create+0x11e>
    dir_close(dir);
c002f2b5:	83 ec 0c             	sub    $0xc,%esp
c002f2b8:	55                   	push   %ebp
c002f2b9:	e8 e3 fb ff ff       	call   c002eea1 <dir_close>
c002f2be:	83 c4 10             	add    $0x10,%esp
  return suc;
c002f2c1:	eb 88                	jmp    c002f24b <dir_create+0x34>
    ASSERT(inode != NULL);
c002f2c3:	83 ec 0c             	sub    $0xc,%esp
c002f2c6:	8d 83 8d 51 ff ff    	lea    -0xae73(%ebx),%eax
c002f2cc:	50                   	push   %eax
c002f2cd:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f2d3:	50                   	push   %eax
c002f2d4:	8d 83 f8 2a ff ff    	lea    -0xd508(%ebx),%eax
c002f2da:	50                   	push   %eax
c002f2db:	6a 14                	push   $0x14
c002f2dd:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f2e3:	50                   	push   %eax
c002f2e4:	e8 ac a5 ff ff       	call   c0029895 <debug_panic>
    ASSERT(dir != NULL);
c002f2e9:	83 ec 0c             	sub    $0xc,%esp
c002f2ec:	8d 83 37 4f ff ff    	lea    -0xb0c9(%ebx),%eax
c002f2f2:	50                   	push   %eax
c002f2f3:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f2f9:	50                   	push   %eax
c002f2fa:	8d 83 f8 2a ff ff    	lea    -0xd508(%ebx),%eax
c002f300:	50                   	push   %eax
c002f301:	6a 19                	push   $0x19
c002f303:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f309:	50                   	push   %eax
c002f30a:	e8 86 a5 ff ff       	call   c0029895 <debug_panic>
    ASSERT(dir_add(dir, ".", sector));
c002f30f:	83 ec 0c             	sub    $0xc,%esp
c002f312:	8d 83 9b 51 ff ff    	lea    -0xae65(%ebx),%eax
c002f318:	50                   	push   %eax
c002f319:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f31f:	50                   	push   %eax
c002f320:	8d 83 f8 2a ff ff    	lea    -0xd508(%ebx),%eax
c002f326:	50                   	push   %eax
c002f327:	6a 1a                	push   $0x1a
c002f329:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f32f:	50                   	push   %eax
c002f330:	e8 60 a5 ff ff       	call   c0029895 <debug_panic>
    ASSERT(dir_add(dir, "..", sector));
c002f335:	83 ec 0c             	sub    $0xc,%esp
c002f338:	8d 83 b5 51 ff ff    	lea    -0xae4b(%ebx),%eax
c002f33e:	50                   	push   %eax
c002f33f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f345:	50                   	push   %eax
c002f346:	8d 83 f8 2a ff ff    	lea    -0xd508(%ebx),%eax
c002f34c:	50                   	push   %eax
c002f34d:	6a 1b                	push   $0x1b
c002f34f:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f355:	50                   	push   %eax
c002f356:	e8 3a a5 ff ff       	call   c0029895 <debug_panic>

c002f35b <dir_remove>:

/* Removes any entry for NAME in DIR.
   Returns true if successful, false on failure,
   which occurs only if there is no file with the given NAME. */
bool dir_remove(struct dir *dir, const char *name)
{
c002f35b:	55                   	push   %ebp
c002f35c:	57                   	push   %edi
c002f35d:	56                   	push   %esi
c002f35e:	53                   	push   %ebx
c002f35f:	83 ec 2c             	sub    $0x2c,%esp
c002f362:	e8 7f 31 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002f367:	81 c3 d5 18 01 00    	add    $0x118d5,%ebx
c002f36d:	8b 7c 24 40          	mov    0x40(%esp),%edi
c002f371:	8b 54 24 44          	mov    0x44(%esp),%edx
  struct dir_entry e;
  struct inode *inode = NULL;
  bool success = false;
  off_t ofs;

  ASSERT(dir != NULL);
c002f375:	85 ff                	test   %edi,%edi
c002f377:	74 38                	je     c002f3b1 <dir_remove+0x56>
  ASSERT(name != NULL);
c002f379:	85 d2                	test   %edx,%edx
c002f37b:	74 5d                	je     c002f3da <dir_remove+0x7f>

  /* Find directory entry. */
  if (!lookup(dir, name, &e, &ofs))
c002f37d:	8d 4c 24 0c          	lea    0xc(%esp),%ecx
c002f381:	83 ec 0c             	sub    $0xc,%esp
c002f384:	8d 44 24 14          	lea    0x14(%esp),%eax
c002f388:	50                   	push   %eax
c002f389:	89 f8                	mov    %edi,%eax
c002f38b:	e8 28 f9 ff ff       	call   c002ecb8 <lookup>
c002f390:	89 c6                	mov    %eax,%esi
c002f392:	83 c4 10             	add    $0x10,%esp
  struct inode *inode = NULL;
c002f395:	bd 00 00 00 00       	mov    $0x0,%ebp
  if (!lookup(dir, name, &e, &ofs))
c002f39a:	84 c0                	test   %al,%al
c002f39c:	75 65                	jne    c002f403 <dir_remove+0xa8>
  /* Remove inode. */
  inode_remove(inode);
  success = true;

done:
  inode_close(inode);
c002f39e:	83 ec 0c             	sub    $0xc,%esp
c002f3a1:	55                   	push   %ebp
c002f3a2:	e8 8d 0e 00 00       	call   c0030234 <inode_close>
  return success;
}
c002f3a7:	89 f0                	mov    %esi,%eax
c002f3a9:	83 c4 3c             	add    $0x3c,%esp
c002f3ac:	5b                   	pop    %ebx
c002f3ad:	5e                   	pop    %esi
c002f3ae:	5f                   	pop    %edi
c002f3af:	5d                   	pop    %ebp
c002f3b0:	c3                   	ret    
  ASSERT(dir != NULL);
c002f3b1:	83 ec 0c             	sub    $0xc,%esp
c002f3b4:	8d 83 37 4f ff ff    	lea    -0xb0c9(%ebx),%eax
c002f3ba:	50                   	push   %eax
c002f3bb:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f3c1:	50                   	push   %eax
c002f3c2:	8d 83 c4 2a ff ff    	lea    -0xd53c(%ebx),%eax
c002f3c8:	50                   	push   %eax
c002f3c9:	68 d5 00 00 00       	push   $0xd5
c002f3ce:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f3d4:	50                   	push   %eax
c002f3d5:	e8 bb a4 ff ff       	call   c0029895 <debug_panic>
  ASSERT(name != NULL);
c002f3da:	83 ec 0c             	sub    $0xc,%esp
c002f3dd:	8d 83 0c 52 ff ff    	lea    -0xadf4(%ebx),%eax
c002f3e3:	50                   	push   %eax
c002f3e4:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f3ea:	50                   	push   %eax
c002f3eb:	8d 83 c4 2a ff ff    	lea    -0xd53c(%ebx),%eax
c002f3f1:	50                   	push   %eax
c002f3f2:	68 d6 00 00 00       	push   $0xd6
c002f3f7:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f3fd:	50                   	push   %eax
c002f3fe:	e8 92 a4 ff ff       	call   c0029895 <debug_panic>
  inode = inode_open(e.inode_sector);
c002f403:	83 ec 0c             	sub    $0xc,%esp
c002f406:	ff 74 24 18          	pushl  0x18(%esp)
c002f40a:	e8 68 0d 00 00       	call   c0030177 <inode_open>
c002f40f:	89 c5                	mov    %eax,%ebp
  if (inode == NULL)
c002f411:	83 c4 10             	add    $0x10,%esp
c002f414:	85 c0                	test   %eax,%eax
c002f416:	74 3a                	je     c002f452 <dir_remove+0xf7>
  e.in_use = false;
c002f418:	c6 44 24 1f 00       	movb   $0x0,0x1f(%esp)
  if (inode_write_at(dir->inode, &e, sizeof e, ofs) != sizeof e)
c002f41d:	ff 74 24 08          	pushl  0x8(%esp)
c002f421:	6a 14                	push   $0x14
c002f423:	8d 44 24 14          	lea    0x14(%esp),%eax
c002f427:	50                   	push   %eax
c002f428:	ff 37                	pushl  (%edi)
c002f42a:	e8 f1 10 00 00       	call   c0030520 <inode_write_at>
c002f42f:	83 c4 10             	add    $0x10,%esp
c002f432:	83 f8 14             	cmp    $0x14,%eax
c002f435:	74 0a                	je     c002f441 <dir_remove+0xe6>
  bool success = false;
c002f437:	be 00 00 00 00       	mov    $0x0,%esi
c002f43c:	e9 5d ff ff ff       	jmp    c002f39e <dir_remove+0x43>
  inode_remove(inode);
c002f441:	83 ec 0c             	sub    $0xc,%esp
c002f444:	55                   	push   %ebp
c002f445:	e8 4d 0f 00 00       	call   c0030397 <inode_remove>
c002f44a:	83 c4 10             	add    $0x10,%esp
c002f44d:	e9 4c ff ff ff       	jmp    c002f39e <dir_remove+0x43>
  bool success = false;
c002f452:	be 00 00 00 00       	mov    $0x0,%esi
c002f457:	e9 42 ff ff ff       	jmp    c002f39e <dir_remove+0x43>

c002f45c <dir_readdir>:

/* Reads the next directory entry in DIR and stores the name in
   NAME.  Returns true if successful, false if the directory
   contains no more entries. */
bool dir_readdir(struct dir *dir, char name[NAME_MAX + 1])
{
c002f45c:	55                   	push   %ebp
c002f45d:	57                   	push   %edi
c002f45e:	56                   	push   %esi
c002f45f:	53                   	push   %ebx
c002f460:	83 ec 2c             	sub    $0x2c,%esp
c002f463:	e8 7e 30 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002f468:	81 c3 d4 17 01 00    	add    $0x117d4,%ebx
c002f46e:	8b 74 24 40          	mov    0x40(%esp),%esi
  struct dir_entry e;

  while (inode_read_at(dir->inode, &e, sizeof e, dir->pos) == sizeof e)
c002f472:	8d 6c 24 0c          	lea    0xc(%esp),%ebp
c002f476:	ff 76 04             	pushl  0x4(%esi)
c002f479:	6a 14                	push   $0x14
c002f47b:	55                   	push   %ebp
c002f47c:	ff 36                	pushl  (%esi)
c002f47e:	e8 5d 0f 00 00       	call   c00303e0 <inode_read_at>
c002f483:	83 c4 10             	add    $0x10,%esp
c002f486:	83 f8 14             	cmp    $0x14,%eax
c002f489:	75 27                	jne    c002f4b2 <dir_readdir+0x56>
  {
    dir->pos += sizeof e;
c002f48b:	83 46 04 14          	addl   $0x14,0x4(%esi)
    if (e.in_use)
c002f48f:	0f b6 7c 24 1f       	movzbl 0x1f(%esp),%edi
c002f494:	89 f8                	mov    %edi,%eax
c002f496:	84 c0                	test   %al,%al
c002f498:	74 dc                	je     c002f476 <dir_readdir+0x1a>
    {
      strlcpy(name, e.name, NAME_MAX + 1);
c002f49a:	83 ec 04             	sub    $0x4,%esp
c002f49d:	6a 0f                	push   $0xf
c002f49f:	8d 44 24 18          	lea    0x18(%esp),%eax
c002f4a3:	50                   	push   %eax
c002f4a4:	ff 74 24 50          	pushl  0x50(%esp)
c002f4a8:	e8 3d 9a ff ff       	call   c0028eea <strlcpy>
      return true;
c002f4ad:	83 c4 10             	add    $0x10,%esp
c002f4b0:	eb 05                	jmp    c002f4b7 <dir_readdir+0x5b>
    }
  }
  return false;
c002f4b2:	bf 00 00 00 00       	mov    $0x0,%edi
}
c002f4b7:	89 f8                	mov    %edi,%eax
c002f4b9:	83 c4 2c             	add    $0x2c,%esp
c002f4bc:	5b                   	pop    %ebx
c002f4bd:	5e                   	pop    %esi
c002f4be:	5f                   	pop    %edi
c002f4bf:	5d                   	pop    %ebp
c002f4c0:	c3                   	ret    

c002f4c1 <subdir_create>:


bool subdir_create(struct dir *current_dir, char *subdir_name)
{
c002f4c1:	57                   	push   %edi
c002f4c2:	56                   	push   %esi
c002f4c3:	53                   	push   %ebx
c002f4c4:	83 ec 10             	sub    $0x10,%esp
c002f4c7:	e8 1a 30 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002f4cc:	81 c3 70 17 01 00    	add    $0x11770,%ebx
c002f4d2:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002f4d6:	8b 74 24 24          	mov    0x24(%esp),%esi
  ASSERT(current_dir != NULL);
c002f4da:	85 ff                	test   %edi,%edi
c002f4dc:	74 15                	je     c002f4f3 <subdir_create+0x32>
  ASSERT(subdir_name != NULL);
c002f4de:	85 f6                	test   %esi,%esi
c002f4e0:	74 3a                	je     c002f51c <subdir_create+0x5b>
  if (strlen(subdir_name) == 0)
    return false;
c002f4e2:	b8 00 00 00 00       	mov    $0x0,%eax
  if (strlen(subdir_name) == 0)
c002f4e7:	80 3e 00             	cmpb   $0x0,(%esi)
c002f4ea:	75 59                	jne    c002f545 <subdir_create+0x84>
  block_sector_t block_sector = -1;
  bool success = (current_dir != NULL && free_map_allocate(1, &block_sector) && dir_create(block_sector, 0) && dir_add(current_dir, subdir_name, block_sector));
  if (!success && block_sector != -1)
    free_map_release(block_sector, 1);
  return success;
}
c002f4ec:	83 c4 10             	add    $0x10,%esp
c002f4ef:	5b                   	pop    %ebx
c002f4f0:	5e                   	pop    %esi
c002f4f1:	5f                   	pop    %edi
c002f4f2:	c3                   	ret    
  ASSERT(current_dir != NULL);
c002f4f3:	83 ec 0c             	sub    $0xc,%esp
c002f4f6:	8d 83 d0 51 ff ff    	lea    -0xae30(%ebx),%eax
c002f4fc:	50                   	push   %eax
c002f4fd:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f503:	50                   	push   %eax
c002f504:	8d 83 b4 2a ff ff    	lea    -0xd54c(%ebx),%eax
c002f50a:	50                   	push   %eax
c002f50b:	68 05 01 00 00       	push   $0x105
c002f510:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f516:	50                   	push   %eax
c002f517:	e8 79 a3 ff ff       	call   c0029895 <debug_panic>
  ASSERT(subdir_name != NULL);
c002f51c:	83 ec 0c             	sub    $0xc,%esp
c002f51f:	8d 83 e4 51 ff ff    	lea    -0xae1c(%ebx),%eax
c002f525:	50                   	push   %eax
c002f526:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f52c:	50                   	push   %eax
c002f52d:	8d 83 b4 2a ff ff    	lea    -0xd54c(%ebx),%eax
c002f533:	50                   	push   %eax
c002f534:	68 06 01 00 00       	push   $0x106
c002f539:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f53f:	50                   	push   %eax
c002f540:	e8 50 a3 ff ff       	call   c0029895 <debug_panic>
  block_sector_t block_sector = -1;
c002f545:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
c002f54c:	ff 
  bool success = (current_dir != NULL && free_map_allocate(1, &block_sector) && dir_create(block_sector, 0) && dir_add(current_dir, subdir_name, block_sector));
c002f54d:	83 ec 08             	sub    $0x8,%esp
c002f550:	8d 44 24 14          	lea    0x14(%esp),%eax
c002f554:	50                   	push   %eax
c002f555:	6a 01                	push   $0x1
c002f557:	e8 bf f1 ff ff       	call   c002e71b <free_map_allocate>
c002f55c:	83 c4 10             	add    $0x10,%esp
c002f55f:	85 c0                	test   %eax,%eax
c002f561:	75 2a                	jne    c002f58d <subdir_create+0xcc>
  if (!success && block_sector != -1)
c002f563:	8b 54 24 0c          	mov    0xc(%esp),%edx
  return success;
c002f567:	b8 00 00 00 00       	mov    $0x0,%eax
  if (!success && block_sector != -1)
c002f56c:	83 fa ff             	cmp    $0xffffffff,%edx
c002f56f:	0f 84 77 ff ff ff    	je     c002f4ec <subdir_create+0x2b>
    free_map_release(block_sector, 1);
c002f575:	83 ec 08             	sub    $0x8,%esp
c002f578:	6a 01                	push   $0x1
c002f57a:	52                   	push   %edx
c002f57b:	e8 10 f2 ff ff       	call   c002e790 <free_map_release>
c002f580:	83 c4 10             	add    $0x10,%esp
  return success;
c002f583:	b8 00 00 00 00       	mov    $0x0,%eax
c002f588:	e9 5f ff ff ff       	jmp    c002f4ec <subdir_create+0x2b>
  bool success = (current_dir != NULL && free_map_allocate(1, &block_sector) && dir_create(block_sector, 0) && dir_add(current_dir, subdir_name, block_sector));
c002f58d:	83 ec 08             	sub    $0x8,%esp
c002f590:	6a 00                	push   $0x0
c002f592:	ff 74 24 18          	pushl  0x18(%esp)
c002f596:	e8 7c fc ff ff       	call   c002f217 <dir_create>
c002f59b:	83 c4 10             	add    $0x10,%esp
c002f59e:	84 c0                	test   %al,%al
c002f5a0:	74 c1                	je     c002f563 <subdir_create+0xa2>
c002f5a2:	83 ec 04             	sub    $0x4,%esp
c002f5a5:	ff 74 24 10          	pushl  0x10(%esp)
c002f5a9:	56                   	push   %esi
c002f5aa:	57                   	push   %edi
c002f5ab:	e8 d8 f9 ff ff       	call   c002ef88 <dir_add>
  if (!success && block_sector != -1)
c002f5b0:	83 c4 10             	add    $0x10,%esp
c002f5b3:	84 c0                	test   %al,%al
c002f5b5:	0f 85 31 ff ff ff    	jne    c002f4ec <subdir_create+0x2b>
c002f5bb:	eb a6                	jmp    c002f563 <subdir_create+0xa2>

c002f5bd <subdir_lookup>:

struct dir *
subdir_lookup(struct dir *current_dir, char *subdir_name)
{
c002f5bd:	53                   	push   %ebx
c002f5be:	83 ec 18             	sub    $0x18,%esp
c002f5c1:	e8 20 2f 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002f5c6:	81 c3 76 16 01 00    	add    $0x11676,%ebx
c002f5cc:	8b 54 24 20          	mov    0x20(%esp),%edx
c002f5d0:	8b 44 24 24          	mov    0x24(%esp),%eax
  ASSERT(current_dir != NULL)
c002f5d4:	85 d2                	test   %edx,%edx
c002f5d6:	74 63                	je     c002f63b <subdir_lookup+0x7e>
  ASSERT(subdir_name != NULL)
c002f5d8:	85 c0                	test   %eax,%eax
c002f5da:	0f 84 84 00 00 00    	je     c002f664 <subdir_lookup+0xa7>
  if (strlen(subdir_name) == 0)
c002f5e0:	80 38 00             	cmpb   $0x0,(%eax)
c002f5e3:	0f 84 ba 00 00 00    	je     c002f6a3 <subdir_lookup+0xe6>
    return NULL;
  struct inode *inode = NULL;
c002f5e9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002f5f0:	00 
  bool res = dir_lookup(current_dir, subdir_name, &inode);
c002f5f1:	83 ec 04             	sub    $0x4,%esp
c002f5f4:	8d 4c 24 10          	lea    0x10(%esp),%ecx
c002f5f8:	51                   	push   %ecx
c002f5f9:	50                   	push   %eax
c002f5fa:	52                   	push   %edx
c002f5fb:	e8 db f8 ff ff       	call   c002eedb <dir_lookup>
  if (!res || inode == NULL)
c002f600:	83 c4 10             	add    $0x10,%esp
c002f603:	84 c0                	test   %al,%al
c002f605:	0f 84 9f 00 00 00    	je     c002f6aa <subdir_lookup+0xed>
c002f60b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002f60f:	85 c0                	test   %eax,%eax
c002f611:	0f 84 9a 00 00 00    	je     c002f6b1 <subdir_lookup+0xf4>
    return NULL;
  if (!inode_isdir(inode))
c002f617:	83 ec 0c             	sub    $0xc,%esp
c002f61a:	50                   	push   %eax
c002f61b:	e8 60 11 00 00       	call   c0030780 <inode_isdir>
c002f620:	83 c4 10             	add    $0x10,%esp
c002f623:	84 c0                	test   %al,%al
c002f625:	74 66                	je     c002f68d <subdir_lookup+0xd0>
  {
    inode_close(inode);
    return NULL;
  }
  return dir_open(inode);
c002f627:	83 ec 0c             	sub    $0xc,%esp
c002f62a:	ff 74 24 18          	pushl  0x18(%esp)
c002f62e:	e8 99 f7 ff ff       	call   c002edcc <dir_open>
c002f633:	83 c4 10             	add    $0x10,%esp
}
c002f636:	83 c4 18             	add    $0x18,%esp
c002f639:	5b                   	pop    %ebx
c002f63a:	c3                   	ret    
  ASSERT(current_dir != NULL)
c002f63b:	83 ec 0c             	sub    $0xc,%esp
c002f63e:	8d 83 d0 51 ff ff    	lea    -0xae30(%ebx),%eax
c002f644:	50                   	push   %eax
c002f645:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f64b:	50                   	push   %eax
c002f64c:	8d 83 a4 2a ff ff    	lea    -0xd55c(%ebx),%eax
c002f652:	50                   	push   %eax
c002f653:	68 13 01 00 00       	push   $0x113
c002f658:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f65e:	50                   	push   %eax
c002f65f:	e8 31 a2 ff ff       	call   c0029895 <debug_panic>
  ASSERT(subdir_name != NULL)
c002f664:	83 ec 0c             	sub    $0xc,%esp
c002f667:	8d 83 e4 51 ff ff    	lea    -0xae1c(%ebx),%eax
c002f66d:	50                   	push   %eax
c002f66e:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f674:	50                   	push   %eax
c002f675:	8d 83 a4 2a ff ff    	lea    -0xd55c(%ebx),%eax
c002f67b:	50                   	push   %eax
c002f67c:	68 14 01 00 00       	push   $0x114
c002f681:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f687:	50                   	push   %eax
c002f688:	e8 08 a2 ff ff       	call   c0029895 <debug_panic>
    inode_close(inode);
c002f68d:	83 ec 0c             	sub    $0xc,%esp
c002f690:	ff 74 24 18          	pushl  0x18(%esp)
c002f694:	e8 9b 0b 00 00       	call   c0030234 <inode_close>
    return NULL;
c002f699:	83 c4 10             	add    $0x10,%esp
c002f69c:	b8 00 00 00 00       	mov    $0x0,%eax
c002f6a1:	eb 93                	jmp    c002f636 <subdir_lookup+0x79>
    return NULL;
c002f6a3:	b8 00 00 00 00       	mov    $0x0,%eax
c002f6a8:	eb 8c                	jmp    c002f636 <subdir_lookup+0x79>
    return NULL;
c002f6aa:	b8 00 00 00 00       	mov    $0x0,%eax
c002f6af:	eb 85                	jmp    c002f636 <subdir_lookup+0x79>
c002f6b1:	b8 00 00 00 00       	mov    $0x0,%eax
c002f6b6:	e9 7b ff ff ff       	jmp    c002f636 <subdir_lookup+0x79>

c002f6bb <subdir_delete>:

bool subdir_delete(struct dir *current_dir, char *subdir_name)
{
c002f6bb:	55                   	push   %ebp
c002f6bc:	57                   	push   %edi
c002f6bd:	56                   	push   %esi
c002f6be:	53                   	push   %ebx
c002f6bf:	83 ec 2c             	sub    $0x2c,%esp
c002f6c2:	e8 1f 2e 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002f6c7:	81 c3 75 15 01 00    	add    $0x11575,%ebx
c002f6cd:	8b 6c 24 40          	mov    0x40(%esp),%ebp
c002f6d1:	8b 74 24 44          	mov    0x44(%esp),%esi
  ASSERT(current_dir != NULL)
c002f6d5:	85 ed                	test   %ebp,%ebp
c002f6d7:	74 18                	je     c002f6f1 <subdir_delete+0x36>
  ASSERT(subdir_name != NULL)
c002f6d9:	85 f6                	test   %esi,%esi
c002f6db:	74 3d                	je     c002f71a <subdir_delete+0x5f>
  if (strlen(subdir_name) == 0)
    return false;
c002f6dd:	bf 00 00 00 00       	mov    $0x0,%edi
  if (strlen(subdir_name) == 0)
c002f6e2:	80 3e 00             	cmpb   $0x0,(%esi)
c002f6e5:	75 5c                	jne    c002f743 <subdir_delete+0x88>
    return false;
  }
  dir_close(dir_copy);
  free(buffer);
  return dir_remove(current_dir, subdir_name);
}
c002f6e7:	89 f8                	mov    %edi,%eax
c002f6e9:	83 c4 2c             	add    $0x2c,%esp
c002f6ec:	5b                   	pop    %ebx
c002f6ed:	5e                   	pop    %esi
c002f6ee:	5f                   	pop    %edi
c002f6ef:	5d                   	pop    %ebp
c002f6f0:	c3                   	ret    
  ASSERT(current_dir != NULL)
c002f6f1:	83 ec 0c             	sub    $0xc,%esp
c002f6f4:	8d 83 d0 51 ff ff    	lea    -0xae30(%ebx),%eax
c002f6fa:	50                   	push   %eax
c002f6fb:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f701:	50                   	push   %eax
c002f702:	8d 83 94 2a ff ff    	lea    -0xd56c(%ebx),%eax
c002f708:	50                   	push   %eax
c002f709:	68 25 01 00 00       	push   $0x125
c002f70e:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f714:	50                   	push   %eax
c002f715:	e8 7b a1 ff ff       	call   c0029895 <debug_panic>
  ASSERT(subdir_name != NULL)
c002f71a:	83 ec 0c             	sub    $0xc,%esp
c002f71d:	8d 83 e4 51 ff ff    	lea    -0xae1c(%ebx),%eax
c002f723:	50                   	push   %eax
c002f724:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f72a:	50                   	push   %eax
c002f72b:	8d 83 94 2a ff ff    	lea    -0xd56c(%ebx),%eax
c002f731:	50                   	push   %eax
c002f732:	68 26 01 00 00       	push   $0x126
c002f737:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f73d:	50                   	push   %eax
c002f73e:	e8 52 a1 ff ff       	call   c0029895 <debug_panic>
  struct inode *inode = NULL;
c002f743:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c002f74a:	00 
  bool res = dir_lookup(current_dir, subdir_name, &inode);
c002f74b:	83 ec 04             	sub    $0x4,%esp
c002f74e:	8d 44 24 20          	lea    0x20(%esp),%eax
c002f752:	50                   	push   %eax
c002f753:	56                   	push   %esi
c002f754:	55                   	push   %ebp
c002f755:	e8 81 f7 ff ff       	call   c002eedb <dir_lookup>
c002f75a:	89 c7                	mov    %eax,%edi
  if (!res || inode == NULL)
c002f75c:	83 c4 10             	add    $0x10,%esp
c002f75f:	84 c0                	test   %al,%al
c002f761:	74 84                	je     c002f6e7 <subdir_delete+0x2c>
c002f763:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002f767:	85 c0                	test   %eax,%eax
c002f769:	0f 84 41 01 00 00    	je     c002f8b0 <subdir_delete+0x1f5>
  if (!inode_isdir(inode))
c002f76f:	83 ec 0c             	sub    $0xc,%esp
c002f772:	50                   	push   %eax
c002f773:	e8 08 10 00 00       	call   c0030780 <inode_isdir>
c002f778:	89 c7                	mov    %eax,%edi
c002f77a:	83 c4 10             	add    $0x10,%esp
c002f77d:	84 c0                	test   %al,%al
c002f77f:	74 57                	je     c002f7d8 <subdir_delete+0x11d>
  if (inode_get_inumber(inode) == inode_get_inumber(dir_get_inode(thread_current()->current_dir)))
c002f781:	83 ec 0c             	sub    $0xc,%esp
c002f784:	ff 74 24 28          	pushl  0x28(%esp)
c002f788:	e8 9f 0a 00 00       	call   c003022c <inode_get_inumber>
c002f78d:	89 c7                	mov    %eax,%edi
c002f78f:	e8 b1 18 ff ff       	call   c0021045 <thread_current>
c002f794:	83 c4 04             	add    $0x4,%esp
  return dir->inode;
c002f797:	8b 80 b0 00 00 00    	mov    0xb0(%eax),%eax
  if (inode_get_inumber(inode) == inode_get_inumber(dir_get_inode(thread_current()->current_dir)))
c002f79d:	ff 30                	pushl  (%eax)
c002f79f:	e8 88 0a 00 00       	call   c003022c <inode_get_inumber>
c002f7a4:	83 c4 10             	add    $0x10,%esp
c002f7a7:	39 c7                	cmp    %eax,%edi
c002f7a9:	74 41                	je     c002f7ec <subdir_delete+0x131>
  if (inode_get_opencnt(inode) > 1)
c002f7ab:	83 ec 0c             	sub    $0xc,%esp
c002f7ae:	ff 74 24 28          	pushl  0x28(%esp)
c002f7b2:	e8 00 10 00 00       	call   c00307b7 <inode_get_opencnt>
c002f7b7:	83 c4 10             	add    $0x10,%esp
c002f7ba:	83 f8 01             	cmp    $0x1,%eax
c002f7bd:	7e 46                	jle    c002f805 <subdir_delete+0x14a>
    inode_close(inode);
c002f7bf:	83 ec 0c             	sub    $0xc,%esp
c002f7c2:	ff 74 24 28          	pushl  0x28(%esp)
c002f7c6:	e8 69 0a 00 00       	call   c0030234 <inode_close>
    return false;
c002f7cb:	83 c4 10             	add    $0x10,%esp
c002f7ce:	bf 00 00 00 00       	mov    $0x0,%edi
c002f7d3:	e9 0f ff ff ff       	jmp    c002f6e7 <subdir_delete+0x2c>
    inode_close(inode);
c002f7d8:	83 ec 0c             	sub    $0xc,%esp
c002f7db:	ff 74 24 28          	pushl  0x28(%esp)
c002f7df:	e8 50 0a 00 00       	call   c0030234 <inode_close>
    return false;
c002f7e4:	83 c4 10             	add    $0x10,%esp
c002f7e7:	e9 fb fe ff ff       	jmp    c002f6e7 <subdir_delete+0x2c>
    inode_close(inode);
c002f7ec:	83 ec 0c             	sub    $0xc,%esp
c002f7ef:	ff 74 24 28          	pushl  0x28(%esp)
c002f7f3:	e8 3c 0a 00 00       	call   c0030234 <inode_close>
    return false;
c002f7f8:	83 c4 10             	add    $0x10,%esp
c002f7fb:	bf 00 00 00 00       	mov    $0x0,%edi
c002f800:	e9 e2 fe ff ff       	jmp    c002f6e7 <subdir_delete+0x2c>
  struct dir *dir_copy = dir_open(inode);
c002f805:	83 ec 0c             	sub    $0xc,%esp
c002f808:	ff 74 24 28          	pushl  0x28(%esp)
c002f80c:	e8 bb f5 ff ff       	call   c002edcc <dir_open>
c002f811:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  char *buffer = malloc(NAME_MAX + 1);
c002f815:	c7 04 24 0f 00 00 00 	movl   $0xf,(%esp)
c002f81c:	e8 c3 4a ff ff       	call   c00242e4 <malloc>
c002f821:	89 c7                	mov    %eax,%edi
  ASSERT(buffer != NULL)
c002f823:	83 c4 10             	add    $0x10,%esp
c002f826:	85 c0                	test   %eax,%eax
c002f828:	74 3c                	je     c002f866 <subdir_delete+0x1ab>
  if (dir_readdir(dir_copy, buffer))
c002f82a:	83 ec 08             	sub    $0x8,%esp
c002f82d:	50                   	push   %eax
c002f82e:	ff 74 24 18          	pushl  0x18(%esp)
c002f832:	e8 25 fc ff ff       	call   c002f45c <dir_readdir>
c002f837:	83 c4 10             	add    $0x10,%esp
c002f83a:	84 c0                	test   %al,%al
c002f83c:	75 51                	jne    c002f88f <subdir_delete+0x1d4>
  dir_close(dir_copy);
c002f83e:	83 ec 0c             	sub    $0xc,%esp
c002f841:	ff 74 24 18          	pushl  0x18(%esp)
c002f845:	e8 57 f6 ff ff       	call   c002eea1 <dir_close>
  free(buffer);
c002f84a:	89 3c 24             	mov    %edi,(%esp)
c002f84d:	e8 48 4c ff ff       	call   c002449a <free>
  return dir_remove(current_dir, subdir_name);
c002f852:	83 c4 08             	add    $0x8,%esp
c002f855:	56                   	push   %esi
c002f856:	55                   	push   %ebp
c002f857:	e8 ff fa ff ff       	call   c002f35b <dir_remove>
c002f85c:	89 c7                	mov    %eax,%edi
c002f85e:	83 c4 10             	add    $0x10,%esp
c002f861:	e9 81 fe ff ff       	jmp    c002f6e7 <subdir_delete+0x2c>
  ASSERT(buffer != NULL)
c002f866:	83 ec 0c             	sub    $0xc,%esp
c002f869:	8d 83 f8 51 ff ff    	lea    -0xae08(%ebx),%eax
c002f86f:	50                   	push   %eax
c002f870:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f876:	50                   	push   %eax
c002f877:	8d 83 94 2a ff ff    	lea    -0xd56c(%ebx),%eax
c002f87d:	50                   	push   %eax
c002f87e:	68 3e 01 00 00       	push   $0x13e
c002f883:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f889:	50                   	push   %eax
c002f88a:	e8 06 a0 ff ff       	call   c0029895 <debug_panic>
    dir_close(dir_copy);
c002f88f:	83 ec 0c             	sub    $0xc,%esp
c002f892:	ff 74 24 18          	pushl  0x18(%esp)
c002f896:	e8 06 f6 ff ff       	call   c002eea1 <dir_close>
    free(buffer);
c002f89b:	89 3c 24             	mov    %edi,(%esp)
c002f89e:	e8 f7 4b ff ff       	call   c002449a <free>
    return false;
c002f8a3:	83 c4 10             	add    $0x10,%esp
c002f8a6:	bf 00 00 00 00       	mov    $0x0,%edi
c002f8ab:	e9 37 fe ff ff       	jmp    c002f6e7 <subdir_delete+0x2c>
    return false;
c002f8b0:	bf 00 00 00 00       	mov    $0x0,%edi
c002f8b5:	e9 2d fe ff ff       	jmp    c002f6e7 <subdir_delete+0x2c>

c002f8ba <subfile_create>:

bool subfile_create(struct dir *current_dir, char *file_name, off_t initial_size)
{
c002f8ba:	56                   	push   %esi
c002f8bb:	53                   	push   %ebx
c002f8bc:	83 ec 14             	sub    $0x14,%esp
c002f8bf:	e8 22 2c 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002f8c4:	81 c3 78 13 01 00    	add    $0x11378,%ebx
c002f8ca:	8b 74 24 24          	mov    0x24(%esp),%esi
  ASSERT(file_name != NULL);
c002f8ce:	85 f6                	test   %esi,%esi
c002f8d0:	74 51                	je     c002f923 <subfile_create+0x69>
  if (strlen(file_name) == 0)
    return false;
c002f8d2:	b8 00 00 00 00       	mov    $0x0,%eax
  if (strlen(file_name) == 0)
c002f8d7:	80 3e 00             	cmpb   $0x0,(%esi)
c002f8da:	74 41                	je     c002f91d <subfile_create+0x63>
  block_sector_t block_sector = -1;
c002f8dc:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
c002f8e3:	ff 
  bool success = (current_dir != NULL && free_map_allocate(1, &block_sector) && inode_create(block_sector, initial_size) && dir_add(current_dir, file_name, block_sector));
c002f8e4:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c002f8e9:	74 32                	je     c002f91d <subfile_create+0x63>
c002f8eb:	83 ec 08             	sub    $0x8,%esp
c002f8ee:	8d 44 24 14          	lea    0x14(%esp),%eax
c002f8f2:	50                   	push   %eax
c002f8f3:	6a 01                	push   $0x1
c002f8f5:	e8 21 ee ff ff       	call   c002e71b <free_map_allocate>
c002f8fa:	83 c4 10             	add    $0x10,%esp
c002f8fd:	85 c0                	test   %eax,%eax
c002f8ff:	75 4b                	jne    c002f94c <subfile_create+0x92>
  if (!success && block_sector != -1)
c002f901:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002f905:	83 f8 ff             	cmp    $0xffffffff,%eax
c002f908:	74 73                	je     c002f97d <subfile_create+0xc3>
    free_map_release(block_sector, 1);
c002f90a:	83 ec 08             	sub    $0x8,%esp
c002f90d:	6a 01                	push   $0x1
c002f90f:	50                   	push   %eax
c002f910:	e8 7b ee ff ff       	call   c002e790 <free_map_release>
c002f915:	83 c4 10             	add    $0x10,%esp
  return success;
c002f918:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002f91d:	83 c4 14             	add    $0x14,%esp
c002f920:	5b                   	pop    %ebx
c002f921:	5e                   	pop    %esi
c002f922:	c3                   	ret    
  ASSERT(file_name != NULL);
c002f923:	83 ec 0c             	sub    $0xc,%esp
c002f926:	8d 83 07 52 ff ff    	lea    -0xadf9(%ebx),%eax
c002f92c:	50                   	push   %eax
c002f92d:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002f933:	50                   	push   %eax
c002f934:	8d 83 84 2a ff ff    	lea    -0xd57c(%ebx),%eax
c002f93a:	50                   	push   %eax
c002f93b:	68 4c 01 00 00       	push   $0x14c
c002f940:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002f946:	50                   	push   %eax
c002f947:	e8 49 9f ff ff       	call   c0029895 <debug_panic>
  bool success = (current_dir != NULL && free_map_allocate(1, &block_sector) && inode_create(block_sector, initial_size) && dir_add(current_dir, file_name, block_sector));
c002f94c:	83 ec 08             	sub    $0x8,%esp
c002f94f:	ff 74 24 30          	pushl  0x30(%esp)
c002f953:	ff 74 24 18          	pushl  0x18(%esp)
c002f957:	e8 8d 05 00 00       	call   c002fee9 <inode_create>
c002f95c:	83 c4 10             	add    $0x10,%esp
c002f95f:	84 c0                	test   %al,%al
c002f961:	74 9e                	je     c002f901 <subfile_create+0x47>
c002f963:	83 ec 04             	sub    $0x4,%esp
c002f966:	ff 74 24 10          	pushl  0x10(%esp)
c002f96a:	56                   	push   %esi
c002f96b:	ff 74 24 2c          	pushl  0x2c(%esp)
c002f96f:	e8 14 f6 ff ff       	call   c002ef88 <dir_add>
  if (!success && block_sector != -1)
c002f974:	83 c4 10             	add    $0x10,%esp
c002f977:	84 c0                	test   %al,%al
c002f979:	75 a2                	jne    c002f91d <subfile_create+0x63>
c002f97b:	eb 84                	jmp    c002f901 <subfile_create+0x47>
  return success;
c002f97d:	b8 00 00 00 00       	mov    $0x0,%eax
c002f982:	eb 99                	jmp    c002f91d <subfile_create+0x63>

c002f984 <subfile_lookup>:

struct file *
subfile_lookup(struct dir *current_dir, char *file_name)
{
c002f984:	57                   	push   %edi
c002f985:	56                   	push   %esi
c002f986:	53                   	push   %ebx
c002f987:	83 ec 10             	sub    $0x10,%esp
c002f98a:	e8 57 2b 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002f98f:	81 c3 ad 12 01 00    	add    $0x112ad,%ebx
c002f995:	8b 74 24 20          	mov    0x20(%esp),%esi
c002f999:	8b 44 24 24          	mov    0x24(%esp),%eax
  ASSERT(current_dir != NULL)
c002f99d:	85 f6                	test   %esi,%esi
c002f99f:	74 7b                	je     c002fa1c <subfile_lookup+0x98>
  ASSERT(file_name != NULL)
c002f9a1:	85 c0                	test   %eax,%eax
c002f9a3:	0f 84 9c 00 00 00    	je     c002fa45 <subfile_lookup+0xc1>
  if (strlen(file_name) == 0)
c002f9a9:	80 38 00             	cmpb   $0x0,(%eax)
c002f9ac:	0f 84 d2 00 00 00    	je     c002fa84 <subfile_lookup+0x100>
    return NULL;
  struct inode *inode = NULL;
c002f9b2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002f9b9:	00 
  bool res = dir_lookup(current_dir, file_name, &inode);
c002f9ba:	83 ec 04             	sub    $0x4,%esp
c002f9bd:	8d 54 24 10          	lea    0x10(%esp),%edx
c002f9c1:	52                   	push   %edx
c002f9c2:	50                   	push   %eax
c002f9c3:	56                   	push   %esi
c002f9c4:	e8 12 f5 ff ff       	call   c002eedb <dir_lookup>
  if (!res || inode == NULL)
c002f9c9:	83 c4 10             	add    $0x10,%esp
c002f9cc:	84 c0                	test   %al,%al
c002f9ce:	0f 84 b7 00 00 00    	je     c002fa8b <subfile_lookup+0x107>
c002f9d4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c002f9d8:	85 c0                	test   %eax,%eax
c002f9da:	0f 84 b2 00 00 00    	je     c002fa92 <subfile_lookup+0x10e>
    return false;
  if (inode_isdir(inode))
c002f9e0:	83 ec 0c             	sub    $0xc,%esp
c002f9e3:	50                   	push   %eax
c002f9e4:	e8 97 0d 00 00       	call   c0030780 <inode_isdir>
c002f9e9:	83 c4 10             	add    $0x10,%esp
c002f9ec:	84 c0                	test   %al,%al
c002f9ee:	75 7e                	jne    c002fa6e <subfile_lookup+0xea>
  {
    inode_close(inode);
    return NULL;
  }
  struct file *file = file_open(inode);
c002f9f0:	83 ec 0c             	sub    $0xc,%esp
c002f9f3:	ff 74 24 18          	pushl  0x18(%esp)
c002f9f7:	e8 68 ef ff ff       	call   c002e964 <file_open>
c002f9fc:	89 c7                	mov    %eax,%edi
  set_file_dir(file, dir_reopen(current_dir));
c002f9fe:	89 34 24             	mov    %esi,(%esp)
c002fa01:	e8 74 f4 ff ff       	call   c002ee7a <dir_reopen>
c002fa06:	83 c4 08             	add    $0x8,%esp
c002fa09:	50                   	push   %eax
c002fa0a:	57                   	push   %edi
c002fa0b:	e8 94 f2 ff ff       	call   c002eca4 <set_file_dir>
  return file;
c002fa10:	83 c4 10             	add    $0x10,%esp
}
c002fa13:	89 f8                	mov    %edi,%eax
c002fa15:	83 c4 10             	add    $0x10,%esp
c002fa18:	5b                   	pop    %ebx
c002fa19:	5e                   	pop    %esi
c002fa1a:	5f                   	pop    %edi
c002fa1b:	c3                   	ret    
  ASSERT(current_dir != NULL)
c002fa1c:	83 ec 0c             	sub    $0xc,%esp
c002fa1f:	8d 83 d0 51 ff ff    	lea    -0xae30(%ebx),%eax
c002fa25:	50                   	push   %eax
c002fa26:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002fa2c:	50                   	push   %eax
c002fa2d:	8d 83 74 2a ff ff    	lea    -0xd58c(%ebx),%eax
c002fa33:	50                   	push   %eax
c002fa34:	68 59 01 00 00       	push   $0x159
c002fa39:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002fa3f:	50                   	push   %eax
c002fa40:	e8 50 9e ff ff       	call   c0029895 <debug_panic>
  ASSERT(file_name != NULL)
c002fa45:	83 ec 0c             	sub    $0xc,%esp
c002fa48:	8d 83 07 52 ff ff    	lea    -0xadf9(%ebx),%eax
c002fa4e:	50                   	push   %eax
c002fa4f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002fa55:	50                   	push   %eax
c002fa56:	8d 83 74 2a ff ff    	lea    -0xd58c(%ebx),%eax
c002fa5c:	50                   	push   %eax
c002fa5d:	68 5a 01 00 00       	push   $0x15a
c002fa62:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002fa68:	50                   	push   %eax
c002fa69:	e8 27 9e ff ff       	call   c0029895 <debug_panic>
    inode_close(inode);
c002fa6e:	83 ec 0c             	sub    $0xc,%esp
c002fa71:	ff 74 24 18          	pushl  0x18(%esp)
c002fa75:	e8 ba 07 00 00       	call   c0030234 <inode_close>
    return NULL;
c002fa7a:	83 c4 10             	add    $0x10,%esp
c002fa7d:	bf 00 00 00 00       	mov    $0x0,%edi
c002fa82:	eb 8f                	jmp    c002fa13 <subfile_lookup+0x8f>
    return NULL;
c002fa84:	bf 00 00 00 00       	mov    $0x0,%edi
c002fa89:	eb 88                	jmp    c002fa13 <subfile_lookup+0x8f>
    return false;
c002fa8b:	bf 00 00 00 00       	mov    $0x0,%edi
c002fa90:	eb 81                	jmp    c002fa13 <subfile_lookup+0x8f>
c002fa92:	bf 00 00 00 00       	mov    $0x0,%edi
c002fa97:	e9 77 ff ff ff       	jmp    c002fa13 <subfile_lookup+0x8f>

c002fa9c <subfile_delete>:

bool subfile_delete(struct dir *current_dir, char *file_name)
{
c002fa9c:	57                   	push   %edi
c002fa9d:	56                   	push   %esi
c002fa9e:	53                   	push   %ebx
c002fa9f:	83 ec 10             	sub    $0x10,%esp
c002faa2:	e8 3f 2a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002faa7:	81 c3 95 11 01 00    	add    $0x11195,%ebx
c002faad:	8b 7c 24 20          	mov    0x20(%esp),%edi
c002fab1:	8b 74 24 24          	mov    0x24(%esp),%esi
  ASSERT(current_dir != NULL)
c002fab5:	85 ff                	test   %edi,%edi
c002fab7:	74 15                	je     c002face <subfile_delete+0x32>
  ASSERT(file_name != NULL)
c002fab9:	85 f6                	test   %esi,%esi
c002fabb:	74 3a                	je     c002faf7 <subfile_delete+0x5b>
  if (strlen(file_name) == 0)
    return false;
c002fabd:	b8 00 00 00 00       	mov    $0x0,%eax
  if (strlen(file_name) == 0)
c002fac2:	80 3e 00             	cmpb   $0x0,(%esi)
c002fac5:	75 59                	jne    c002fb20 <subfile_delete+0x84>
    inode_close(inode);
    return false;
  }
  inode_close(inode);
  return dir_remove(current_dir, file_name);
}
c002fac7:	83 c4 10             	add    $0x10,%esp
c002faca:	5b                   	pop    %ebx
c002facb:	5e                   	pop    %esi
c002facc:	5f                   	pop    %edi
c002facd:	c3                   	ret    
  ASSERT(current_dir != NULL)
c002face:	83 ec 0c             	sub    $0xc,%esp
c002fad1:	8d 83 d0 51 ff ff    	lea    -0xae30(%ebx),%eax
c002fad7:	50                   	push   %eax
c002fad8:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002fade:	50                   	push   %eax
c002fadf:	8d 83 64 2a ff ff    	lea    -0xd59c(%ebx),%eax
c002fae5:	50                   	push   %eax
c002fae6:	68 6d 01 00 00       	push   $0x16d
c002faeb:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002faf1:	50                   	push   %eax
c002faf2:	e8 9e 9d ff ff       	call   c0029895 <debug_panic>
  ASSERT(file_name != NULL)
c002faf7:	83 ec 0c             	sub    $0xc,%esp
c002fafa:	8d 83 07 52 ff ff    	lea    -0xadf9(%ebx),%eax
c002fb00:	50                   	push   %eax
c002fb01:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002fb07:	50                   	push   %eax
c002fb08:	8d 83 64 2a ff ff    	lea    -0xd59c(%ebx),%eax
c002fb0e:	50                   	push   %eax
c002fb0f:	68 6e 01 00 00       	push   $0x16e
c002fb14:	8d 83 60 51 ff ff    	lea    -0xaea0(%ebx),%eax
c002fb1a:	50                   	push   %eax
c002fb1b:	e8 75 9d ff ff       	call   c0029895 <debug_panic>
  struct inode *inode = NULL;
c002fb20:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c002fb27:	00 
  bool res = dir_lookup(current_dir, file_name, &inode);
c002fb28:	83 ec 04             	sub    $0x4,%esp
c002fb2b:	8d 44 24 10          	lea    0x10(%esp),%eax
c002fb2f:	50                   	push   %eax
c002fb30:	56                   	push   %esi
c002fb31:	57                   	push   %edi
c002fb32:	e8 a4 f3 ff ff       	call   c002eedb <dir_lookup>
  if (!res || inode == NULL)
c002fb37:	83 c4 10             	add    $0x10,%esp
c002fb3a:	84 c0                	test   %al,%al
c002fb3c:	74 89                	je     c002fac7 <subfile_delete+0x2b>
c002fb3e:	8b 54 24 0c          	mov    0xc(%esp),%edx
    return false;
c002fb42:	b8 00 00 00 00       	mov    $0x0,%eax
  if (!res || inode == NULL)
c002fb47:	85 d2                	test   %edx,%edx
c002fb49:	0f 84 78 ff ff ff    	je     c002fac7 <subfile_delete+0x2b>
  if (inode_isdir(inode))
c002fb4f:	83 ec 0c             	sub    $0xc,%esp
c002fb52:	52                   	push   %edx
c002fb53:	e8 28 0c 00 00       	call   c0030780 <inode_isdir>
c002fb58:	83 c4 10             	add    $0x10,%esp
c002fb5b:	84 c0                	test   %al,%al
c002fb5d:	75 1e                	jne    c002fb7d <subfile_delete+0xe1>
  inode_close(inode);
c002fb5f:	83 ec 0c             	sub    $0xc,%esp
c002fb62:	ff 74 24 18          	pushl  0x18(%esp)
c002fb66:	e8 c9 06 00 00       	call   c0030234 <inode_close>
  return dir_remove(current_dir, file_name);
c002fb6b:	83 c4 08             	add    $0x8,%esp
c002fb6e:	56                   	push   %esi
c002fb6f:	57                   	push   %edi
c002fb70:	e8 e6 f7 ff ff       	call   c002f35b <dir_remove>
c002fb75:	83 c4 10             	add    $0x10,%esp
c002fb78:	e9 4a ff ff ff       	jmp    c002fac7 <subfile_delete+0x2b>
    inode_close(inode);
c002fb7d:	83 ec 0c             	sub    $0xc,%esp
c002fb80:	ff 74 24 18          	pushl  0x18(%esp)
c002fb84:	e8 ab 06 00 00       	call   c0030234 <inode_close>
    return false;
c002fb89:	83 c4 10             	add    $0x10,%esp
c002fb8c:	b8 00 00 00 00       	mov    $0x0,%eax
c002fb91:	e9 31 ff ff ff       	jmp    c002fac7 <subfile_delete+0x2b>

c002fb96 <is_dirfile>:

bool is_dirfile(struct file_handle *fh)
{
c002fb96:	53                   	push   %ebx
c002fb97:	83 ec 14             	sub    $0x14,%esp
c002fb9a:	e8 47 29 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002fb9f:	81 c3 9d 10 01 00    	add    $0x1109d,%ebx
  return inode_isdir(file_get_inode(fh->opened_file));
c002fba5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002fba9:	ff 70 04             	pushl  0x4(%eax)
c002fbac:	e8 33 ee ff ff       	call   c002e9e4 <file_get_inode>
c002fbb1:	89 04 24             	mov    %eax,(%esp)
c002fbb4:	e8 c7 0b 00 00       	call   c0030780 <inode_isdir>
c002fbb9:	83 c4 18             	add    $0x18,%esp
c002fbbc:	5b                   	pop    %ebx
c002fbbd:	c3                   	ret    

c002fbbe <byte_to_sector>:
   within INODE.
   Returns -1 if INODE does not contain data for a byte at offset
   POS. */
static block_sector_t
byte_to_sector(struct inode *inode, off_t pos, bool create)
{
c002fbbe:	55                   	push   %ebp
c002fbbf:	57                   	push   %edi
c002fbc0:	56                   	push   %esi
c002fbc1:	53                   	push   %ebx
c002fbc2:	83 ec 4c             	sub    $0x4c,%esp
c002fbc5:	e8 1c 29 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002fbca:	81 c3 72 10 01 00    	add    $0x11072,%ebx
c002fbd0:	89 44 24 28          	mov    %eax,0x28(%esp)
c002fbd4:	89 54 24 2c          	mov    %edx,0x2c(%esp)
  ASSERT(inode != NULL);
c002fbd8:	85 c0                	test   %eax,%eax
c002fbda:	0f 84 ba 00 00 00    	je     c002fc9a <byte_to_sector+0xdc>
c002fbe0:	89 ce                	mov    %ecx,%esi

  block_sector_t *t1 = calloc(TABLE_SIZE, sizeof *t1);
c002fbe2:	83 ec 08             	sub    $0x8,%esp
c002fbe5:	6a 04                	push   $0x4
c002fbe7:	68 80 00 00 00       	push   $0x80
c002fbec:	e8 58 48 ff ff       	call   c0024449 <calloc>
c002fbf1:	89 44 24 40          	mov    %eax,0x40(%esp)
  block_sector_t *t2 = calloc(TABLE_SIZE, sizeof *t2);
c002fbf5:	83 c4 08             	add    $0x8,%esp
c002fbf8:	6a 04                	push   $0x4
c002fbfa:	68 80 00 00 00       	push   $0x80
c002fbff:	e8 45 48 ff ff       	call   c0024449 <calloc>
c002fc04:	89 44 24 28          	mov    %eax,0x28(%esp)

  if (!(pos < inode->data.length))
c002fc08:	8b 44 24 38          	mov    0x38(%esp),%eax
c002fc0c:	8b 40 1c             	mov    0x1c(%eax),%eax
c002fc0f:	83 c4 10             	add    $0x10,%esp
c002fc12:	3b 44 24 2c          	cmp    0x2c(%esp),%eax
c002fc16:	0f 8f 3c 02 00 00    	jg     c002fe58 <byte_to_sector+0x29a>
  {
    if (!create)
c002fc1c:	89 f1                	mov    %esi,%ecx
c002fc1e:	84 c9                	test   %cl,%cl
c002fc20:	0f 84 9a 00 00 00    	je     c002fcc0 <byte_to_sector+0x102>
/* Map the pos into tables
*/
static off_t
byte_to_t1(off_t pos)
{
  return (pos >> 16) & (TABLE_SIZE - 1);
c002fc26:	89 c2                	mov    %eax,%edx
c002fc28:	c1 fa 10             	sar    $0x10,%edx
c002fc2b:	83 e2 7f             	and    $0x7f,%edx
c002fc2e:	89 d6                	mov    %edx,%esi
c002fc30:	89 54 24 3c          	mov    %edx,0x3c(%esp)
}

static off_t
byte_to_t2(off_t pos)
{
  return (pos >> 9) & (TABLE_SIZE - 1);
c002fc34:	c1 f8 09             	sar    $0x9,%eax
c002fc37:	83 e0 7f             	and    $0x7f,%eax
c002fc3a:	89 c7                	mov    %eax,%edi
c002fc3c:	89 44 24 38          	mov    %eax,0x38(%esp)
  return (pos >> 16) & (TABLE_SIZE - 1);
c002fc40:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
c002fc44:	89 c8                	mov    %ecx,%eax
c002fc46:	c1 f8 10             	sar    $0x10,%eax
c002fc49:	83 e0 7f             	and    $0x7f,%eax
c002fc4c:	89 c5                	mov    %eax,%ebp
c002fc4e:	89 44 24 24          	mov    %eax,0x24(%esp)
  return (pos >> 9) & (TABLE_SIZE - 1);
c002fc52:	89 c8                	mov    %ecx,%eax
c002fc54:	c1 f8 09             	sar    $0x9,%eax
c002fc57:	83 e0 7f             	and    $0x7f,%eax
c002fc5a:	89 44 24 34          	mov    %eax,0x34(%esp)
      cache_read(inode->data.table, t1);
c002fc5e:	83 ec 08             	sub    $0x8,%esp
c002fc61:	ff 74 24 38          	pushl  0x38(%esp)
c002fc65:	8b 4c 24 34          	mov    0x34(%esp),%ecx
c002fc69:	ff 71 18             	pushl  0x18(%ecx)
c002fc6c:	e8 63 14 00 00       	call   c00310d4 <cache_read>
      for (off_t i = t1_s; i <= t1_t; i++)
c002fc71:	83 c4 10             	add    $0x10,%esp
c002fc74:	39 f5                	cmp    %esi,%ebp
c002fc76:	0f 8c ad 01 00 00    	jl     c002fe29 <byte_to_sector+0x26b>
c002fc7c:	8b 44 24 30          	mov    0x30(%esp),%eax
c002fc80:	8d 04 b0             	lea    (%eax,%esi,4),%eax
c002fc83:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c002fc87:	89 74 24 10          	mov    %esi,0x10(%esp)
            cache_write(t2[j], zeros);
c002fc8b:	8d 83 64 20 00 00    	lea    0x2064(%ebx),%eax
c002fc91:	89 44 24 20          	mov    %eax,0x20(%esp)
c002fc95:	e9 3c 01 00 00       	jmp    c002fdd6 <byte_to_sector+0x218>
  ASSERT(inode != NULL);
c002fc9a:	83 ec 0c             	sub    $0xc,%esp
c002fc9d:	8d 83 8d 51 ff ff    	lea    -0xae73(%ebx),%eax
c002fca3:	50                   	push   %eax
c002fca4:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002fcaa:	50                   	push   %eax
c002fcab:	8d 83 2c 2b ff ff    	lea    -0xd4d4(%ebx),%eax
c002fcb1:	50                   	push   %eax
c002fcb2:	6a 3e                	push   $0x3e
c002fcb4:	8d 83 79 52 ff ff    	lea    -0xad87(%ebx),%eax
c002fcba:	50                   	push   %eax
c002fcbb:	e8 d5 9b ff ff       	call   c0029895 <debug_panic>
      free(t1);
c002fcc0:	83 ec 0c             	sub    $0xc,%esp
c002fcc3:	ff 74 24 3c          	pushl  0x3c(%esp)
c002fcc7:	e8 ce 47 ff ff       	call   c002449a <free>
      free(t2);
c002fccc:	83 c4 04             	add    $0x4,%esp
c002fccf:	ff 74 24 24          	pushl  0x24(%esp)
c002fcd3:	e8 c2 47 ff ff       	call   c002449a <free>
      return -1;
c002fcd8:	83 c4 10             	add    $0x10,%esp
c002fcdb:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
c002fce0:	e9 c4 01 00 00       	jmp    c002fea9 <byte_to_sector+0x2eb>
          if (!free_map_allocate(1, &t1[i]))
c002fce5:	83 ec 08             	sub    $0x8,%esp
c002fce8:	ff 74 24 24          	pushl  0x24(%esp)
c002fcec:	6a 01                	push   $0x1
c002fcee:	e8 28 ea ff ff       	call   c002e71b <free_map_allocate>
c002fcf3:	83 c4 10             	add    $0x10,%esp
c002fcf6:	84 c0                	test   %al,%al
c002fcf8:	74 1d                	je     c002fd17 <byte_to_sector+0x159>
          cache_write(t1[i], empty);
c002fcfa:	83 ec 08             	sub    $0x8,%esp
c002fcfd:	8d 83 64 1e 00 00    	lea    0x1e64(%ebx),%eax
c002fd03:	50                   	push   %eax
c002fd04:	8b 44 24 20          	mov    0x20(%esp),%eax
c002fd08:	ff 30                	pushl  (%eax)
c002fd0a:	e8 ee 14 00 00       	call   c00311fd <cache_write>
c002fd0f:	83 c4 10             	add    $0x10,%esp
c002fd12:	e9 e8 00 00 00       	jmp    c002fdff <byte_to_sector+0x241>
            free(t1);
c002fd17:	83 ec 0c             	sub    $0xc,%esp
c002fd1a:	ff 74 24 3c          	pushl  0x3c(%esp)
c002fd1e:	e8 77 47 ff ff       	call   c002449a <free>
            free(t2);
c002fd23:	83 c4 04             	add    $0x4,%esp
c002fd26:	ff 74 24 24          	pushl  0x24(%esp)
c002fd2a:	e8 6b 47 ff ff       	call   c002449a <free>
            return -1;
c002fd2f:	83 c4 10             	add    $0x10,%esp
c002fd32:	e9 72 01 00 00       	jmp    c002fea9 <byte_to_sector+0x2eb>
c002fd37:	89 fd                	mov    %edi,%ebp
              free(t1);
c002fd39:	83 ec 0c             	sub    $0xc,%esp
c002fd3c:	ff 74 24 3c          	pushl  0x3c(%esp)
c002fd40:	e8 55 47 ff ff       	call   c002449a <free>
              free(t2);
c002fd45:	83 c4 04             	add    $0x4,%esp
c002fd48:	ff 74 24 24          	pushl  0x24(%esp)
c002fd4c:	e8 49 47 ff ff       	call   c002449a <free>
              return -1;
c002fd51:	83 c4 10             	add    $0x10,%esp
c002fd54:	e9 50 01 00 00       	jmp    c002fea9 <byte_to_sector+0x2eb>
        for (off_t j = l; j <= r; j++)
c002fd59:	83 c5 01             	add    $0x1,%ebp
c002fd5c:	83 c6 04             	add    $0x4,%esi
c002fd5f:	39 6c 24 0c          	cmp    %ebp,0xc(%esp)
c002fd63:	7c 34                	jl     c002fd99 <byte_to_sector+0x1db>
          if (t2[j] == -1)
c002fd65:	89 74 24 08          	mov    %esi,0x8(%esp)
c002fd69:	8b 3e                	mov    (%esi),%edi
c002fd6b:	83 ff ff             	cmp    $0xffffffff,%edi
c002fd6e:	75 e9                	jne    c002fd59 <byte_to_sector+0x19b>
            if (!free_map_allocate(1, &t2[j]))
c002fd70:	83 ec 08             	sub    $0x8,%esp
c002fd73:	56                   	push   %esi
c002fd74:	6a 01                	push   $0x1
c002fd76:	e8 a0 e9 ff ff       	call   c002e71b <free_map_allocate>
c002fd7b:	83 c4 10             	add    $0x10,%esp
c002fd7e:	84 c0                	test   %al,%al
c002fd80:	74 b5                	je     c002fd37 <byte_to_sector+0x179>
            cache_write(t2[j], zeros);
c002fd82:	83 ec 08             	sub    $0x8,%esp
c002fd85:	ff 74 24 28          	pushl  0x28(%esp)
c002fd89:	8b 44 24 14          	mov    0x14(%esp),%eax
c002fd8d:	ff 30                	pushl  (%eax)
c002fd8f:	e8 69 14 00 00       	call   c00311fd <cache_write>
c002fd94:	83 c4 10             	add    $0x10,%esp
c002fd97:	eb c0                	jmp    c002fd59 <byte_to_sector+0x19b>
        cache_write(t1[i], t2);
c002fd99:	83 ec 08             	sub    $0x8,%esp
c002fd9c:	ff 74 24 20          	pushl  0x20(%esp)
c002fda0:	8b 44 24 20          	mov    0x20(%esp),%eax
c002fda4:	ff 30                	pushl  (%eax)
c002fda6:	e8 52 14 00 00       	call   c00311fd <cache_write>
      for (off_t i = t1_s; i <= t1_t; i++)
c002fdab:	83 44 24 20 01       	addl   $0x1,0x20(%esp)
c002fdb0:	8b 44 24 20          	mov    0x20(%esp),%eax
c002fdb4:	83 c4 10             	add    $0x10,%esp
c002fdb7:	3b 44 24 24          	cmp    0x24(%esp),%eax
c002fdbb:	7f 6c                	jg     c002fe29 <byte_to_sector+0x26b>
        off_t l = (i == t1_s ? t2_s : 0);
c002fdbd:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
c002fdc1:	39 4c 24 10          	cmp    %ecx,0x10(%esp)
c002fdc5:	b8 00 00 00 00       	mov    $0x0,%eax
c002fdca:	0f 44 44 24 38       	cmove  0x38(%esp),%eax
c002fdcf:	89 c7                	mov    %eax,%edi
c002fdd1:	83 44 24 1c 04       	addl   $0x4,0x1c(%esp)
        off_t r = (i == t1_t ? t2_t : TABLE_SIZE - 1);
c002fdd6:	8b 54 24 24          	mov    0x24(%esp),%edx
c002fdda:	39 54 24 10          	cmp    %edx,0x10(%esp)
c002fdde:	b8 7f 00 00 00       	mov    $0x7f,%eax
c002fde3:	0f 44 44 24 34       	cmove  0x34(%esp),%eax
c002fde8:	89 44 24 0c          	mov    %eax,0xc(%esp)
        if (t1[i] == -1)
c002fdec:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c002fdf0:	89 44 24 14          	mov    %eax,0x14(%esp)
c002fdf4:	8b 28                	mov    (%eax),%ebp
c002fdf6:	83 fd ff             	cmp    $0xffffffff,%ebp
c002fdf9:	0f 84 e6 fe ff ff    	je     c002fce5 <byte_to_sector+0x127>
        cache_read(t1[i], t2);
c002fdff:	83 ec 08             	sub    $0x8,%esp
c002fe02:	8b 74 24 20          	mov    0x20(%esp),%esi
c002fe06:	56                   	push   %esi
c002fe07:	8b 44 24 20          	mov    0x20(%esp),%eax
c002fe0b:	ff 30                	pushl  (%eax)
c002fe0d:	e8 c2 12 00 00       	call   c00310d4 <cache_read>
        for (off_t j = l; j <= r; j++)
c002fe12:	83 c4 10             	add    $0x10,%esp
c002fe15:	3b 7c 24 0c          	cmp    0xc(%esp),%edi
c002fe19:	0f 8f 7a ff ff ff    	jg     c002fd99 <byte_to_sector+0x1db>
c002fe1f:	8d 34 be             	lea    (%esi,%edi,4),%esi
c002fe22:	89 fd                	mov    %edi,%ebp
c002fe24:	e9 3c ff ff ff       	jmp    c002fd65 <byte_to_sector+0x1a7>
      cache_write(inode->data.table, t1);
c002fe29:	83 ec 08             	sub    $0x8,%esp
c002fe2c:	ff 74 24 38          	pushl  0x38(%esp)
c002fe30:	8b 7c 24 34          	mov    0x34(%esp),%edi
c002fe34:	ff 77 18             	pushl  0x18(%edi)
c002fe37:	e8 c1 13 00 00       	call   c00311fd <cache_write>
      inode->data.length = pos + 1;
c002fe3c:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c002fe40:	83 c0 01             	add    $0x1,%eax
c002fe43:	89 47 1c             	mov    %eax,0x1c(%edi)
      cache_write(inode->sector, &inode->data);
c002fe46:	83 c4 08             	add    $0x8,%esp
c002fe49:	8d 47 18             	lea    0x18(%edi),%eax
c002fe4c:	50                   	push   %eax
c002fe4d:	ff 77 08             	pushl  0x8(%edi)
c002fe50:	e8 a8 13 00 00       	call   c00311fd <cache_write>
c002fe55:	83 c4 10             	add    $0x10,%esp
  cache_read(inode->data.table, t1);
c002fe58:	83 ec 08             	sub    $0x8,%esp
c002fe5b:	8b 74 24 38          	mov    0x38(%esp),%esi
c002fe5f:	56                   	push   %esi
c002fe60:	8b 44 24 34          	mov    0x34(%esp),%eax
c002fe64:	ff 70 18             	pushl  0x18(%eax)
c002fe67:	e8 68 12 00 00       	call   c00310d4 <cache_read>
  cache_read(t1[byte_to_t1(pos)], t2);
c002fe6c:	83 c4 08             	add    $0x8,%esp
c002fe6f:	8b 6c 24 20          	mov    0x20(%esp),%ebp
c002fe73:	55                   	push   %ebp
  return (pos >> 16) & (TABLE_SIZE - 1);
c002fe74:	8b 7c 24 38          	mov    0x38(%esp),%edi
c002fe78:	89 f8                	mov    %edi,%eax
c002fe7a:	c1 f8 10             	sar    $0x10,%eax
c002fe7d:	83 e0 7f             	and    $0x7f,%eax
  cache_read(t1[byte_to_t1(pos)], t2);
c002fe80:	ff 34 86             	pushl  (%esi,%eax,4)
c002fe83:	e8 4c 12 00 00       	call   c00310d4 <cache_read>
  return (pos >> 9) & (TABLE_SIZE - 1);
c002fe88:	89 f8                	mov    %edi,%eax
c002fe8a:	c1 f8 09             	sar    $0x9,%eax
c002fe8d:	83 e0 7f             	and    $0x7f,%eax
  block_sector_t result = t2[byte_to_t2(pos)];
c002fe90:	89 ef                	mov    %ebp,%edi
c002fe92:	8b 6c 85 00          	mov    0x0(%ebp,%eax,4),%ebp
  free(t1);
c002fe96:	89 34 24             	mov    %esi,(%esp)
c002fe99:	e8 fc 45 ff ff       	call   c002449a <free>
  free(t2);
c002fe9e:	89 3c 24             	mov    %edi,(%esp)
c002fea1:	e8 f4 45 ff ff       	call   c002449a <free>
  return result;
c002fea6:	83 c4 10             	add    $0x10,%esp
}
c002fea9:	89 e8                	mov    %ebp,%eax
c002feab:	83 c4 4c             	add    $0x4c,%esp
c002feae:	5b                   	pop    %ebx
c002feaf:	5e                   	pop    %esi
c002feb0:	5f                   	pop    %edi
c002feb1:	5d                   	pop    %ebp
c002feb2:	c3                   	ret    

c002feb3 <inode_init>:
{
c002feb3:	57                   	push   %edi
c002feb4:	53                   	push   %ebx
c002feb5:	83 ec 10             	sub    $0x10,%esp
c002feb8:	e8 29 26 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002febd:	81 c3 7f 0d 01 00    	add    $0x10d7f,%ebx
  list_init(&open_inodes);
c002fec3:	8d 83 44 1e 00 00    	lea    0x1e44(%ebx),%eax
c002fec9:	50                   	push   %eax
c002feca:	e8 93 9a ff ff       	call   c0029962 <list_init>
  memset(empty, -1, sizeof empty);
c002fecf:	8d 93 64 1e 00 00    	lea    0x1e64(%ebx),%edx
c002fed5:	b9 80 00 00 00       	mov    $0x80,%ecx
c002feda:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c002fedf:	89 d7                	mov    %edx,%edi
c002fee1:	f3 ab                	rep stos %eax,%es:(%edi)
}
c002fee3:	83 c4 14             	add    $0x14,%esp
c002fee6:	5b                   	pop    %ebx
c002fee7:	5f                   	pop    %edi
c002fee8:	c3                   	ret    

c002fee9 <inode_create>:
{
c002fee9:	55                   	push   %ebp
c002feea:	57                   	push   %edi
c002feeb:	56                   	push   %esi
c002feec:	53                   	push   %ebx
c002feed:	83 ec 3c             	sub    $0x3c,%esp
c002fef0:	e8 f1 25 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c002fef5:	81 c3 47 0d 01 00    	add    $0x10d47,%ebx
c002fefb:	8b 74 24 54          	mov    0x54(%esp),%esi
  ASSERT(length >= 0);
c002feff:	85 f6                	test   %esi,%esi
c002ff01:	0f 88 83 00 00 00    	js     c002ff8a <inode_create+0xa1>
  disk_inode = calloc(1, sizeof *disk_inode);
c002ff07:	83 ec 08             	sub    $0x8,%esp
c002ff0a:	68 00 02 00 00       	push   $0x200
c002ff0f:	6a 01                	push   $0x1
c002ff11:	e8 33 45 ff ff       	call   c0024449 <calloc>
c002ff16:	89 c5                	mov    %eax,%ebp
  if (disk_inode != NULL)
c002ff18:	83 c4 10             	add    $0x10,%esp
  bool success = false;
c002ff1b:	c6 44 24 0b 00       	movb   $0x0,0xb(%esp)
  if (disk_inode != NULL)
c002ff20:	85 c0                	test   %eax,%eax
c002ff22:	74 59                	je     c002ff7d <inode_create+0x94>
    disk_inode->length = length;
c002ff24:	89 70 04             	mov    %esi,0x4(%eax)
    disk_inode->magic = INODE_MAGIC;
c002ff27:	c7 40 08 44 4f 4e 49 	movl   $0x494e4f44,0x8(%eax)
    disk_inode->is_dir = false;
c002ff2e:	c6 80 ff 01 00 00 00 	movb   $0x0,0x1ff(%eax)
    if (free_map_allocate(1, &disk_inode->table))
c002ff35:	83 ec 08             	sub    $0x8,%esp
c002ff38:	50                   	push   %eax
c002ff39:	6a 01                	push   $0x1
c002ff3b:	e8 db e7 ff ff       	call   c002e71b <free_map_allocate>
c002ff40:	88 44 24 1b          	mov    %al,0x1b(%esp)
c002ff44:	83 c4 10             	add    $0x10,%esp
c002ff47:	84 c0                	test   %al,%al
c002ff49:	74 26                	je     c002ff71 <inode_create+0x88>
      cache_write(sector, disk_inode);
c002ff4b:	83 ec 08             	sub    $0x8,%esp
c002ff4e:	55                   	push   %ebp
c002ff4f:	ff 74 24 5c          	pushl  0x5c(%esp)
c002ff53:	e8 a5 12 00 00       	call   c00311fd <cache_write>
      cache_write(disk_inode->table, empty);
c002ff58:	83 c4 08             	add    $0x8,%esp
c002ff5b:	8d 83 64 1e 00 00    	lea    0x1e64(%ebx),%eax
c002ff61:	50                   	push   %eax
c002ff62:	ff 75 00             	pushl  0x0(%ebp)
c002ff65:	e8 93 12 00 00       	call   c00311fd <cache_write>
      if (length > 0)
c002ff6a:	83 c4 10             	add    $0x10,%esp
c002ff6d:	85 f6                	test   %esi,%esi
c002ff6f:	7f 42                	jg     c002ffb3 <inode_create+0xca>
    free(disk_inode);
c002ff71:	83 ec 0c             	sub    $0xc,%esp
c002ff74:	55                   	push   %ebp
c002ff75:	e8 20 45 ff ff       	call   c002449a <free>
c002ff7a:	83 c4 10             	add    $0x10,%esp
}
c002ff7d:	0f b6 44 24 0b       	movzbl 0xb(%esp),%eax
c002ff82:	83 c4 3c             	add    $0x3c,%esp
c002ff85:	5b                   	pop    %ebx
c002ff86:	5e                   	pop    %esi
c002ff87:	5f                   	pop    %edi
c002ff88:	5d                   	pop    %ebp
c002ff89:	c3                   	ret    
  ASSERT(length >= 0);
c002ff8a:	83 ec 0c             	sub    $0xc,%esp
c002ff8d:	8d 83 8f 52 ff ff    	lea    -0xad71(%ebx),%eax
c002ff93:	50                   	push   %eax
c002ff94:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c002ff9a:	50                   	push   %eax
c002ff9b:	8d 83 4c 2b ff ff    	lea    -0xd4b4(%ebx),%eax
c002ffa1:	50                   	push   %eax
c002ffa2:	68 99 00 00 00       	push   $0x99
c002ffa7:	8d 83 79 52 ff ff    	lea    -0xad87(%ebx),%eax
c002ffad:	50                   	push   %eax
c002ffae:	e8 e2 98 ff ff       	call   c0029895 <debug_panic>
        block_sector_t *t1 = calloc(TABLE_SIZE, sizeof *t1);
c002ffb3:	83 ec 08             	sub    $0x8,%esp
c002ffb6:	6a 04                	push   $0x4
c002ffb8:	68 80 00 00 00       	push   $0x80
c002ffbd:	e8 87 44 ff ff       	call   c0024449 <calloc>
c002ffc2:	89 c7                	mov    %eax,%edi
c002ffc4:	89 44 24 38          	mov    %eax,0x38(%esp)
        block_sector_t *t2 = calloc(TABLE_SIZE, sizeof *t2);
c002ffc8:	83 c4 08             	add    $0x8,%esp
c002ffcb:	6a 04                	push   $0x4
c002ffcd:	68 80 00 00 00       	push   $0x80
c002ffd2:	e8 72 44 ff ff       	call   c0024449 <calloc>
c002ffd7:	89 44 24 28          	mov    %eax,0x28(%esp)
        off_t t1_t = byte_to_t1(length - 1);
c002ffdb:	83 ee 01             	sub    $0x1,%esi
  return (pos >> 16) & (TABLE_SIZE - 1);
c002ffde:	89 f0                	mov    %esi,%eax
c002ffe0:	c1 f8 10             	sar    $0x10,%eax
c002ffe3:	83 e0 7f             	and    $0x7f,%eax
c002ffe6:	89 44 24 2c          	mov    %eax,0x2c(%esp)
  return (pos >> 9) & (TABLE_SIZE - 1);
c002ffea:	c1 fe 09             	sar    $0x9,%esi
c002ffed:	83 e6 7f             	and    $0x7f,%esi
c002fff0:	89 74 24 30          	mov    %esi,0x30(%esp)
        cache_read(disk_inode->table, t1);
c002fff4:	83 c4 08             	add    $0x8,%esp
c002fff7:	57                   	push   %edi
c002fff8:	ff 75 00             	pushl  0x0(%ebp)
c002fffb:	e8 d4 10 00 00       	call   c00310d4 <cache_read>
c0030000:	89 7c 24 24          	mov    %edi,0x24(%esp)
c0030004:	83 c4 10             	add    $0x10,%esp
        for (off_t i = 0; i <= t1_t; i++)
c0030007:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c003000e:	00 
            cache_write(t2[j], zeros);
c003000f:	8d 83 64 20 00 00    	lea    0x2064(%ebx),%eax
c0030015:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0030019:	89 6c 24 2c          	mov    %ebp,0x2c(%esp)
          off_t r = (i == t1_t ? t2_t : TABLE_SIZE - 1);
c003001d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0030021:	8b 54 24 10          	mov    0x10(%esp),%edx
c0030025:	39 d0                	cmp    %edx,%eax
c0030027:	bd 7f 00 00 00       	mov    $0x7f,%ebp
c003002c:	0f 44 6c 24 20       	cmove  0x20(%esp),%ebp
          if (!free_map_allocate(1, &t1[i]))
c0030031:	8b 44 24 14          	mov    0x14(%esp),%eax
c0030035:	89 44 24 24          	mov    %eax,0x24(%esp)
c0030039:	83 ec 08             	sub    $0x8,%esp
c003003c:	50                   	push   %eax
c003003d:	6a 01                	push   $0x1
c003003f:	e8 d7 e6 ff ff       	call   c002e71b <free_map_allocate>
c0030044:	88 44 24 1b          	mov    %al,0x1b(%esp)
c0030048:	83 c4 10             	add    $0x10,%esp
c003004b:	84 c0                	test   %al,%al
c003004d:	0f 84 be 00 00 00    	je     c0030111 <inode_create+0x228>
          cache_write(t1[i], empty);
c0030053:	83 ec 08             	sub    $0x8,%esp
c0030056:	8d 83 64 1e 00 00    	lea    0x1e64(%ebx),%eax
c003005c:	50                   	push   %eax
c003005d:	8b 7c 24 20          	mov    0x20(%esp),%edi
c0030061:	ff 37                	pushl  (%edi)
c0030063:	e8 95 11 00 00       	call   c00311fd <cache_write>
          cache_read(t1[i], t2);
c0030068:	83 c4 08             	add    $0x8,%esp
c003006b:	8b 74 24 20          	mov    0x20(%esp),%esi
c003006f:	56                   	push   %esi
c0030070:	ff 37                	pushl  (%edi)
c0030072:	e8 5d 10 00 00       	call   c00310d4 <cache_read>
c0030077:	83 c4 10             	add    $0x10,%esp
          for (off_t j = 0; j <= r; j++)
c003007a:	bf 00 00 00 00       	mov    $0x0,%edi
            if (!free_map_allocate(1, &t2[j]))
c003007f:	83 ec 08             	sub    $0x8,%esp
c0030082:	56                   	push   %esi
c0030083:	6a 01                	push   $0x1
c0030085:	e8 91 e6 ff ff       	call   c002e71b <free_map_allocate>
c003008a:	88 44 24 1b          	mov    %al,0x1b(%esp)
c003008e:	83 c4 10             	add    $0x10,%esp
c0030091:	84 c0                	test   %al,%al
c0030093:	0f 84 a4 00 00 00    	je     c003013d <inode_create+0x254>
            cache_write(t2[j], zeros);
c0030099:	83 ec 08             	sub    $0x8,%esp
c003009c:	ff 74 24 14          	pushl  0x14(%esp)
c00300a0:	ff 36                	pushl  (%esi)
c00300a2:	e8 56 11 00 00       	call   c00311fd <cache_write>
          for (off_t j = 0; j <= r; j++)
c00300a7:	83 c7 01             	add    $0x1,%edi
c00300aa:	83 c6 04             	add    $0x4,%esi
c00300ad:	83 c4 10             	add    $0x10,%esp
c00300b0:	39 fd                	cmp    %edi,%ebp
c00300b2:	7d cb                	jge    c003007f <inode_create+0x196>
          cache_write(t1[i], t2);
c00300b4:	83 ec 08             	sub    $0x8,%esp
c00300b7:	ff 74 24 20          	pushl  0x20(%esp)
c00300bb:	8b 44 24 30          	mov    0x30(%esp),%eax
c00300bf:	ff 30                	pushl  (%eax)
c00300c1:	e8 37 11 00 00       	call   c00311fd <cache_write>
        for (off_t i = 0; i <= t1_t; i++)
c00300c6:	83 44 24 20 01       	addl   $0x1,0x20(%esp)
c00300cb:	8b 44 24 20          	mov    0x20(%esp),%eax
c00300cf:	83 44 24 24 04       	addl   $0x4,0x24(%esp)
c00300d4:	83 c4 10             	add    $0x10,%esp
c00300d7:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
c00300db:	0f 8e 3c ff ff ff    	jle    c003001d <inode_create+0x134>
c00300e1:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
        cache_write(disk_inode->table, t1);
c00300e5:	83 ec 08             	sub    $0x8,%esp
c00300e8:	8b 7c 24 30          	mov    0x30(%esp),%edi
c00300ec:	57                   	push   %edi
c00300ed:	ff 75 00             	pushl  0x0(%ebp)
c00300f0:	e8 08 11 00 00       	call   c00311fd <cache_write>
        free(t1);
c00300f5:	89 3c 24             	mov    %edi,(%esp)
c00300f8:	e8 9d 43 ff ff       	call   c002449a <free>
        free(t2);
c00300fd:	83 c4 04             	add    $0x4,%esp
c0030100:	ff 74 24 24          	pushl  0x24(%esp)
c0030104:	e8 91 43 ff ff       	call   c002449a <free>
c0030109:	83 c4 10             	add    $0x10,%esp
c003010c:	e9 60 fe ff ff       	jmp    c002ff71 <inode_create+0x88>
c0030111:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
            free(t1);
c0030115:	83 ec 0c             	sub    $0xc,%esp
c0030118:	ff 74 24 34          	pushl  0x34(%esp)
c003011c:	e8 79 43 ff ff       	call   c002449a <free>
            free(t2);
c0030121:	83 c4 04             	add    $0x4,%esp
c0030124:	ff 74 24 24          	pushl  0x24(%esp)
c0030128:	e8 6d 43 ff ff       	call   c002449a <free>
            free(disk_inode);
c003012d:	89 2c 24             	mov    %ebp,(%esp)
c0030130:	e8 65 43 ff ff       	call   c002449a <free>
            return false;
c0030135:	83 c4 10             	add    $0x10,%esp
c0030138:	e9 40 fe ff ff       	jmp    c002ff7d <inode_create+0x94>
c003013d:	8b 6c 24 2c          	mov    0x2c(%esp),%ebp
              free(t1);
c0030141:	83 ec 0c             	sub    $0xc,%esp
c0030144:	ff 74 24 34          	pushl  0x34(%esp)
c0030148:	e8 4d 43 ff ff       	call   c002449a <free>
              free(t2);
c003014d:	83 c4 04             	add    $0x4,%esp
c0030150:	ff 74 24 24          	pushl  0x24(%esp)
c0030154:	e8 41 43 ff ff       	call   c002449a <free>
              free(disk_inode);
c0030159:	89 2c 24             	mov    %ebp,(%esp)
c003015c:	e8 39 43 ff ff       	call   c002449a <free>
              return false;
c0030161:	83 c4 10             	add    $0x10,%esp
c0030164:	e9 14 fe ff ff       	jmp    c002ff7d <inode_create+0x94>

c0030169 <inode_reopen>:
{
c0030169:	8b 44 24 04          	mov    0x4(%esp),%eax
  if (inode != NULL)
c003016d:	85 c0                	test   %eax,%eax
c003016f:	74 04                	je     c0030175 <inode_reopen+0xc>
    inode->open_cnt++;
c0030171:	83 40 0c 01          	addl   $0x1,0xc(%eax)
}
c0030175:	f3 c3                	repz ret 

c0030177 <inode_open>:
{
c0030177:	55                   	push   %ebp
c0030178:	57                   	push   %edi
c0030179:	56                   	push   %esi
c003017a:	53                   	push   %ebx
c003017b:	83 ec 18             	sub    $0x18,%esp
c003017e:	e8 63 23 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0030183:	81 c3 b9 0a 01 00    	add    $0x10ab9,%ebx
c0030189:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
  for (e = list_begin(&open_inodes); e != list_end(&open_inodes);
c003018d:	8d 83 44 1e 00 00    	lea    0x1e44(%ebx),%eax
c0030193:	50                   	push   %eax
c0030194:	e8 21 98 ff ff       	call   c00299ba <list_begin>
c0030199:	89 c6                	mov    %eax,%esi
c003019b:	83 c4 10             	add    $0x10,%esp
c003019e:	8d ab 44 1e 00 00    	lea    0x1e44(%ebx),%ebp
c00301a4:	83 ec 0c             	sub    $0xc,%esp
c00301a7:	55                   	push   %ebp
c00301a8:	e8 af 98 ff ff       	call   c0029a5c <list_end>
c00301ad:	83 c4 10             	add    $0x10,%esp
c00301b0:	39 f0                	cmp    %esi,%eax
c00301b2:	74 2b                	je     c00301df <inode_open+0x68>
    if (inode->sector == sector)
c00301b4:	39 7e 08             	cmp    %edi,0x8(%esi)
c00301b7:	74 10                	je     c00301c9 <inode_open+0x52>
       e = list_next(e))
c00301b9:	83 ec 0c             	sub    $0xc,%esp
c00301bc:	56                   	push   %esi
c00301bd:	e8 3d 98 ff ff       	call   c00299ff <list_next>
c00301c2:	89 c6                	mov    %eax,%esi
c00301c4:	83 c4 10             	add    $0x10,%esp
c00301c7:	eb db                	jmp    c00301a4 <inode_open+0x2d>
      inode_reopen(inode);
c00301c9:	83 ec 0c             	sub    $0xc,%esp
c00301cc:	56                   	push   %esi
c00301cd:	e8 97 ff ff ff       	call   c0030169 <inode_reopen>
      return inode;
c00301d2:	83 c4 10             	add    $0x10,%esp
}
c00301d5:	89 f0                	mov    %esi,%eax
c00301d7:	83 c4 0c             	add    $0xc,%esp
c00301da:	5b                   	pop    %ebx
c00301db:	5e                   	pop    %esi
c00301dc:	5f                   	pop    %edi
c00301dd:	5d                   	pop    %ebp
c00301de:	c3                   	ret    
  inode = malloc(sizeof *inode);
c00301df:	83 ec 0c             	sub    $0xc,%esp
c00301e2:	68 18 02 00 00       	push   $0x218
c00301e7:	e8 f8 40 ff ff       	call   c00242e4 <malloc>
c00301ec:	89 c6                	mov    %eax,%esi
  if (inode == NULL)
c00301ee:	83 c4 10             	add    $0x10,%esp
c00301f1:	85 c0                	test   %eax,%eax
c00301f3:	74 e0                	je     c00301d5 <inode_open+0x5e>
  list_push_front(&open_inodes, &inode->elem);
c00301f5:	83 ec 08             	sub    $0x8,%esp
c00301f8:	50                   	push   %eax
c00301f9:	8d 83 44 1e 00 00    	lea    0x1e44(%ebx),%eax
c00301ff:	50                   	push   %eax
c0030200:	e8 26 9d ff ff       	call   c0029f2b <list_push_front>
  inode->sector = sector;
c0030205:	89 7e 08             	mov    %edi,0x8(%esi)
  inode->open_cnt = 1;
c0030208:	c7 46 0c 01 00 00 00 	movl   $0x1,0xc(%esi)
  inode->deny_write_cnt = 0;
c003020f:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
  inode->removed = false;
c0030216:	c6 46 10 00          	movb   $0x0,0x10(%esi)
  cache_read(inode->sector, &inode->data);
c003021a:	83 c4 08             	add    $0x8,%esp
c003021d:	8d 46 18             	lea    0x18(%esi),%eax
c0030220:	50                   	push   %eax
c0030221:	57                   	push   %edi
c0030222:	e8 ad 0e 00 00       	call   c00310d4 <cache_read>
  return inode;
c0030227:	83 c4 10             	add    $0x10,%esp
c003022a:	eb a9                	jmp    c00301d5 <inode_open+0x5e>

c003022c <inode_get_inumber>:
  return inode->sector;
c003022c:	8b 44 24 04          	mov    0x4(%esp),%eax
c0030230:	8b 40 08             	mov    0x8(%eax),%eax
}
c0030233:	c3                   	ret    

c0030234 <inode_close>:
{
c0030234:	55                   	push   %ebp
c0030235:	57                   	push   %edi
c0030236:	56                   	push   %esi
c0030237:	53                   	push   %ebx
c0030238:	83 ec 2c             	sub    $0x2c,%esp
c003023b:	e8 a6 22 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0030240:	81 c3 fc 09 01 00    	add    $0x109fc,%ebx
c0030246:	8b 6c 24 40          	mov    0x40(%esp),%ebp
  if (inode == NULL)
c003024a:	85 ed                	test   %ebp,%ebp
c003024c:	74 11                	je     c003025f <inode_close+0x2b>
  if (--inode->open_cnt == 0)
c003024e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0030251:	83 e8 01             	sub    $0x1,%eax
c0030254:	89 44 24 04          	mov    %eax,0x4(%esp)
c0030258:	89 45 0c             	mov    %eax,0xc(%ebp)
c003025b:	85 c0                	test   %eax,%eax
c003025d:	74 08                	je     c0030267 <inode_close+0x33>
}
c003025f:	83 c4 2c             	add    $0x2c,%esp
c0030262:	5b                   	pop    %ebx
c0030263:	5e                   	pop    %esi
c0030264:	5f                   	pop    %edi
c0030265:	5d                   	pop    %ebp
c0030266:	c3                   	ret    
    list_remove(&inode->elem);
c0030267:	83 ec 0c             	sub    $0xc,%esp
c003026a:	55                   	push   %ebp
c003026b:	e8 f5 9c ff ff       	call   c0029f65 <list_remove>
    if (inode->removed)
c0030270:	83 c4 10             	add    $0x10,%esp
c0030273:	80 7d 10 00          	cmpb   $0x0,0x10(%ebp)
c0030277:	74 24                	je     c003029d <inode_close+0x69>
      off_t length = inode->data.length;
c0030279:	8b 75 1c             	mov    0x1c(%ebp),%esi
      if (length > 0)
c003027c:	85 f6                	test   %esi,%esi
c003027e:	7f 2b                	jg     c00302ab <inode_close+0x77>
      free_map_release(inode->sector, 1);
c0030280:	83 ec 08             	sub    $0x8,%esp
c0030283:	6a 01                	push   $0x1
c0030285:	ff 75 08             	pushl  0x8(%ebp)
c0030288:	e8 03 e5 ff ff       	call   c002e790 <free_map_release>
      free_map_release(inode->data.table, 1);
c003028d:	83 c4 08             	add    $0x8,%esp
c0030290:	6a 01                	push   $0x1
c0030292:	ff 75 18             	pushl  0x18(%ebp)
c0030295:	e8 f6 e4 ff ff       	call   c002e790 <free_map_release>
c003029a:	83 c4 10             	add    $0x10,%esp
    free(inode);
c003029d:	83 ec 0c             	sub    $0xc,%esp
c00302a0:	55                   	push   %ebp
c00302a1:	e8 f4 41 ff ff       	call   c002449a <free>
c00302a6:	83 c4 10             	add    $0x10,%esp
c00302a9:	eb b4                	jmp    c003025f <inode_close+0x2b>
        block_sector_t *t1 = calloc(TABLE_SIZE, sizeof *t1);
c00302ab:	83 ec 08             	sub    $0x8,%esp
c00302ae:	6a 04                	push   $0x4
c00302b0:	68 80 00 00 00       	push   $0x80
c00302b5:	e8 8f 41 ff ff       	call   c0024449 <calloc>
c00302ba:	89 44 24 18          	mov    %eax,0x18(%esp)
        block_sector_t *t2 = calloc(TABLE_SIZE, sizeof *t2);
c00302be:	83 c4 08             	add    $0x8,%esp
c00302c1:	6a 04                	push   $0x4
c00302c3:	68 80 00 00 00       	push   $0x80
c00302c8:	e8 7c 41 ff ff       	call   c0024449 <calloc>
c00302cd:	89 c7                	mov    %eax,%edi
        off_t t1_t = byte_to_t1(length - 1);
c00302cf:	83 ee 01             	sub    $0x1,%esi
  return (pos >> 16) & (TABLE_SIZE - 1);
c00302d2:	89 f0                	mov    %esi,%eax
c00302d4:	c1 f8 10             	sar    $0x10,%eax
c00302d7:	83 e0 7f             	and    $0x7f,%eax
c00302da:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  return (pos >> 9) & (TABLE_SIZE - 1);
c00302de:	c1 fe 09             	sar    $0x9,%esi
c00302e1:	83 e6 7f             	and    $0x7f,%esi
c00302e4:	89 74 24 2c          	mov    %esi,0x2c(%esp)
        cache_read(inode->data.table, t1);
c00302e8:	83 c4 08             	add    $0x8,%esp
c00302eb:	ff 74 24 10          	pushl  0x10(%esp)
c00302ef:	ff 75 18             	pushl  0x18(%ebp)
c00302f2:	e8 dd 0d 00 00       	call   c00310d4 <cache_read>
c00302f7:	83 c4 10             	add    $0x10,%esp
        for (off_t i = 0; i <= t1_t; i++)
c00302fa:	8b 44 24 04          	mov    0x4(%esp),%eax
          off_t r = (i == t1_t ? t2_t : TABLE_SIZE - 1);
c00302fe:	89 6c 24 40          	mov    %ebp,0x40(%esp)
c0030302:	89 c5                	mov    %eax,%ebp
c0030304:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0030308:	39 e8                	cmp    %ebp,%eax
c003030a:	b8 7f 00 00 00       	mov    $0x7f,%eax
c003030f:	0f 44 44 24 1c       	cmove  0x1c(%esp),%eax
c0030314:	89 44 24 10          	mov    %eax,0x10(%esp)
c0030318:	89 6c 24 14          	mov    %ebp,0x14(%esp)
          cache_read(t1[i], t2);
c003031c:	83 ec 08             	sub    $0x8,%esp
c003031f:	57                   	push   %edi
c0030320:	8b 4c 24 14          	mov    0x14(%esp),%ecx
c0030324:	ff 34 a9             	pushl  (%ecx,%ebp,4)
c0030327:	e8 a8 0d 00 00       	call   c00310d4 <cache_read>
c003032c:	83 c4 10             	add    $0x10,%esp
          for (off_t j = 0; j <= r; j++)
c003032f:	8b 74 24 04          	mov    0x4(%esp),%esi
c0030333:	89 6c 24 18          	mov    %ebp,0x18(%esp)
c0030337:	8b 6c 24 10          	mov    0x10(%esp),%ebp
            free_map_release(t2[j], 1);
c003033b:	83 ec 08             	sub    $0x8,%esp
c003033e:	6a 01                	push   $0x1
c0030340:	ff 34 b7             	pushl  (%edi,%esi,4)
c0030343:	e8 48 e4 ff ff       	call   c002e790 <free_map_release>
          for (off_t j = 0; j <= r; j++)
c0030348:	83 c6 01             	add    $0x1,%esi
c003034b:	83 c4 10             	add    $0x10,%esp
c003034e:	39 f5                	cmp    %esi,%ebp
c0030350:	7d e9                	jge    c003033b <inode_close+0x107>
c0030352:	8b 6c 24 18          	mov    0x18(%esp),%ebp
          free_map_release(t1[i], 1);
c0030356:	83 ec 08             	sub    $0x8,%esp
c0030359:	6a 01                	push   $0x1
c003035b:	8b 44 24 14          	mov    0x14(%esp),%eax
c003035f:	8b 54 24 20          	mov    0x20(%esp),%edx
c0030363:	ff 34 90             	pushl  (%eax,%edx,4)
c0030366:	e8 25 e4 ff ff       	call   c002e790 <free_map_release>
        for (off_t i = 0; i <= t1_t; i++)
c003036b:	83 c5 01             	add    $0x1,%ebp
c003036e:	83 c4 10             	add    $0x10,%esp
c0030371:	3b 6c 24 0c          	cmp    0xc(%esp),%ebp
c0030375:	7e 8d                	jle    c0030304 <inode_close+0xd0>
c0030377:	8b 6c 24 40          	mov    0x40(%esp),%ebp
        free(t1);
c003037b:	83 ec 0c             	sub    $0xc,%esp
c003037e:	ff 74 24 14          	pushl  0x14(%esp)
c0030382:	e8 13 41 ff ff       	call   c002449a <free>
        free(t2);
c0030387:	89 3c 24             	mov    %edi,(%esp)
c003038a:	e8 0b 41 ff ff       	call   c002449a <free>
c003038f:	83 c4 10             	add    $0x10,%esp
c0030392:	e9 e9 fe ff ff       	jmp    c0030280 <inode_close+0x4c>

c0030397 <inode_remove>:
{
c0030397:	53                   	push   %ebx
c0030398:	83 ec 08             	sub    $0x8,%esp
c003039b:	e8 46 21 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00303a0:	81 c3 9c 08 01 00    	add    $0x1089c,%ebx
c00303a6:	8b 44 24 10          	mov    0x10(%esp),%eax
  ASSERT(inode != NULL);
c00303aa:	85 c0                	test   %eax,%eax
c00303ac:	74 09                	je     c00303b7 <inode_remove+0x20>
  inode->removed = true;
c00303ae:	c6 40 10 01          	movb   $0x1,0x10(%eax)
}
c00303b2:	83 c4 08             	add    $0x8,%esp
c00303b5:	5b                   	pop    %ebx
c00303b6:	c3                   	ret    
  ASSERT(inode != NULL);
c00303b7:	83 ec 0c             	sub    $0xc,%esp
c00303ba:	8d 83 8d 51 ff ff    	lea    -0xae73(%ebx),%eax
c00303c0:	50                   	push   %eax
c00303c1:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00303c7:	50                   	push   %eax
c00303c8:	8d 83 3c 2b ff ff    	lea    -0xd4c4(%ebx),%eax
c00303ce:	50                   	push   %eax
c00303cf:	68 4a 01 00 00       	push   $0x14a
c00303d4:	8d 83 79 52 ff ff    	lea    -0xad87(%ebx),%eax
c00303da:	50                   	push   %eax
c00303db:	e8 b5 94 ff ff       	call   c0029895 <debug_panic>

c00303e0 <inode_read_at>:
{
c00303e0:	55                   	push   %ebp
c00303e1:	57                   	push   %edi
c00303e2:	56                   	push   %esi
c00303e3:	53                   	push   %ebx
c00303e4:	83 ec 1c             	sub    $0x1c,%esp
c00303e7:	e8 fa 20 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00303ec:	81 c3 50 08 01 00    	add    $0x10850,%ebx
c00303f2:	8b 6c 24 3c          	mov    0x3c(%esp),%ebp
  while (size > 0)
c00303f6:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c00303fb:	0f 8e 0e 01 00 00    	jle    c003050f <inode_read_at+0x12f>
  uint8_t *bounce = NULL;
c0030401:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  off_t bytes_read = 0;
c0030408:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c003040f:	00 
c0030410:	eb 49                	jmp    c003045b <inode_read_at+0x7b>
      if (bounce == NULL)
c0030412:	83 3c 24 00          	cmpl   $0x0,(%esp)
c0030416:	0f 84 bf 00 00 00    	je     c00304db <inode_read_at+0xfb>
      cache_read(sector_idx, bounce);
c003041c:	83 ec 08             	sub    $0x8,%esp
c003041f:	ff 74 24 08          	pushl  0x8(%esp)
c0030423:	ff 74 24 18          	pushl  0x18(%esp)
c0030427:	e8 a8 0c 00 00       	call   c00310d4 <cache_read>
      memcpy(buffer + bytes_read, bounce + sector_ofs, chunk_size);
c003042c:	8b 44 24 14          	mov    0x14(%esp),%eax
c0030430:	03 44 24 44          	add    0x44(%esp),%eax
c0030434:	03 7c 24 10          	add    0x10(%esp),%edi
c0030438:	83 c4 0c             	add    $0xc,%esp
c003043b:	56                   	push   %esi
c003043c:	57                   	push   %edi
c003043d:	50                   	push   %eax
c003043e:	e8 4e 86 ff ff       	call   c0028a91 <memcpy>
c0030443:	83 c4 10             	add    $0x10,%esp
    size -= chunk_size;
c0030446:	29 74 24 38          	sub    %esi,0x38(%esp)
    offset += chunk_size;
c003044a:	01 f5                	add    %esi,%ebp
    bytes_read += chunk_size;
c003044c:	01 74 24 04          	add    %esi,0x4(%esp)
  while (size > 0)
c0030450:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0030455:	0f 8e 9c 00 00 00    	jle    c00304f7 <inode_read_at+0x117>
    block_sector_t sector_idx = byte_to_sector(inode, offset, false);
c003045b:	b9 00 00 00 00       	mov    $0x0,%ecx
c0030460:	89 ea                	mov    %ebp,%edx
c0030462:	8b 44 24 30          	mov    0x30(%esp),%eax
c0030466:	e8 53 f7 ff ff       	call   c002fbbe <byte_to_sector>
c003046b:	89 c2                	mov    %eax,%edx
c003046d:	89 44 24 0c          	mov    %eax,0xc(%esp)
    int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c0030471:	89 e8                	mov    %ebp,%eax
c0030473:	c1 f8 1f             	sar    $0x1f,%eax
c0030476:	c1 e8 17             	shr    $0x17,%eax
c0030479:	8d 7c 05 00          	lea    0x0(%ebp,%eax,1),%edi
c003047d:	81 e7 ff 01 00 00    	and    $0x1ff,%edi
c0030483:	29 c7                	sub    %eax,%edi
    off_t inode_left = inode_length(inode) - offset;
c0030485:	8b 44 24 30          	mov    0x30(%esp),%eax
c0030489:	8b 40 1c             	mov    0x1c(%eax),%eax
c003048c:	89 44 24 08          	mov    %eax,0x8(%esp)
c0030490:	89 c6                	mov    %eax,%esi
c0030492:	29 ee                	sub    %ebp,%esi
    int chunk_size = size < min_left ? size : min_left;
c0030494:	3b 74 24 38          	cmp    0x38(%esp),%esi
c0030498:	0f 4f 74 24 38       	cmovg  0x38(%esp),%esi
    int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c003049d:	b8 00 02 00 00       	mov    $0x200,%eax
c00304a2:	29 f8                	sub    %edi,%eax
    int chunk_size = size < min_left ? size : min_left;
c00304a4:	39 c6                	cmp    %eax,%esi
c00304a6:	0f 4f f0             	cmovg  %eax,%esi
    if (chunk_size <= 0)
c00304a9:	85 f6                	test   %esi,%esi
c00304ab:	7e 4a                	jle    c00304f7 <inode_read_at+0x117>
    if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
c00304ad:	85 ff                	test   %edi,%edi
c00304af:	0f 85 5d ff ff ff    	jne    c0030412 <inode_read_at+0x32>
c00304b5:	81 fe 00 02 00 00    	cmp    $0x200,%esi
c00304bb:	0f 85 51 ff ff ff    	jne    c0030412 <inode_read_at+0x32>
      cache_read(sector_idx, buffer + bytes_read);
c00304c1:	83 ec 08             	sub    $0x8,%esp
c00304c4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c00304c8:	03 44 24 3c          	add    0x3c(%esp),%eax
c00304cc:	50                   	push   %eax
c00304cd:	52                   	push   %edx
c00304ce:	e8 01 0c 00 00       	call   c00310d4 <cache_read>
c00304d3:	83 c4 10             	add    $0x10,%esp
c00304d6:	e9 6b ff ff ff       	jmp    c0030446 <inode_read_at+0x66>
        bounce = malloc(BLOCK_SECTOR_SIZE);
c00304db:	83 ec 0c             	sub    $0xc,%esp
c00304de:	68 00 02 00 00       	push   $0x200
c00304e3:	e8 fc 3d ff ff       	call   c00242e4 <malloc>
c00304e8:	89 44 24 10          	mov    %eax,0x10(%esp)
        if (bounce == NULL)
c00304ec:	83 c4 10             	add    $0x10,%esp
c00304ef:	85 c0                	test   %eax,%eax
c00304f1:	0f 85 25 ff ff ff    	jne    c003041c <inode_read_at+0x3c>
  free(bounce);
c00304f7:	83 ec 0c             	sub    $0xc,%esp
c00304fa:	ff 74 24 0c          	pushl  0xc(%esp)
c00304fe:	e8 97 3f ff ff       	call   c002449a <free>
}
c0030503:	8b 44 24 14          	mov    0x14(%esp),%eax
c0030507:	83 c4 2c             	add    $0x2c,%esp
c003050a:	5b                   	pop    %ebx
c003050b:	5e                   	pop    %esi
c003050c:	5f                   	pop    %edi
c003050d:	5d                   	pop    %ebp
c003050e:	c3                   	ret    
  off_t bytes_read = 0;
c003050f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0030516:	00 
  uint8_t *bounce = NULL;
c0030517:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c003051e:	eb d7                	jmp    c00304f7 <inode_read_at+0x117>

c0030520 <inode_write_at>:
{
c0030520:	55                   	push   %ebp
c0030521:	57                   	push   %edi
c0030522:	56                   	push   %esi
c0030523:	53                   	push   %ebx
c0030524:	83 ec 1c             	sub    $0x1c,%esp
c0030527:	e8 ba 1f 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c003052c:	81 c3 10 07 01 00    	add    $0x10710,%ebx
  if (inode->deny_write_cnt)
c0030532:	8b 44 24 30          	mov    0x30(%esp),%eax
c0030536:	8b 40 14             	mov    0x14(%eax),%eax
c0030539:	89 04 24             	mov    %eax,(%esp)
c003053c:	85 c0                	test   %eax,%eax
c003053e:	0f 85 5d 01 00 00    	jne    c00306a1 <inode_write_at+0x181>
  while (size > 0)
c0030544:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0030549:	0f 8e 45 01 00 00    	jle    c0030694 <inode_write_at+0x174>
  uint8_t *bounce = NULL;
c003054f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0030556:	00 
c0030557:	e9 9a 00 00 00       	jmp    c00305f6 <inode_write_at+0xd6>
      cache_write(sector_idx, buffer + bytes_written);
c003055c:	83 ec 08             	sub    $0x8,%esp
c003055f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0030563:	03 44 24 3c          	add    0x3c(%esp),%eax
c0030567:	50                   	push   %eax
c0030568:	52                   	push   %edx
c0030569:	e8 8f 0c 00 00       	call   c00311fd <cache_write>
c003056e:	83 c4 10             	add    $0x10,%esp
c0030571:	eb 71                	jmp    c00305e4 <inode_write_at+0xc4>
        bounce = malloc(BLOCK_SECTOR_SIZE);
c0030573:	83 ec 0c             	sub    $0xc,%esp
c0030576:	68 00 02 00 00       	push   $0x200
c003057b:	e8 64 3d ff ff       	call   c00242e4 <malloc>
c0030580:	89 44 24 14          	mov    %eax,0x14(%esp)
        if (bounce == NULL)
c0030584:	83 c4 10             	add    $0x10,%esp
c0030587:	85 c0                	test   %eax,%eax
c0030589:	0f 85 e0 00 00 00    	jne    c003066f <inode_write_at+0x14f>
  free(bounce);
c003058f:	83 ec 0c             	sub    $0xc,%esp
c0030592:	ff 74 24 10          	pushl  0x10(%esp)
c0030596:	e8 ff 3e ff ff       	call   c002449a <free>
  return bytes_written;
c003059b:	83 c4 10             	add    $0x10,%esp
}
c003059e:	8b 04 24             	mov    (%esp),%eax
c00305a1:	83 c4 1c             	add    $0x1c,%esp
c00305a4:	5b                   	pop    %ebx
c00305a5:	5e                   	pop    %esi
c00305a6:	5f                   	pop    %edi
c00305a7:	5d                   	pop    %ebp
c00305a8:	c3                   	ret    
        cache_read(sector_idx, bounce);
c00305a9:	83 ec 08             	sub    $0x8,%esp
c00305ac:	ff 74 24 0c          	pushl  0xc(%esp)
c00305b0:	ff 74 24 18          	pushl  0x18(%esp)
c00305b4:	e8 1b 0b 00 00       	call   c00310d4 <cache_read>
c00305b9:	83 c4 10             	add    $0x10,%esp
      memcpy(bounce + sector_ofs, buffer + bytes_written, chunk_size);
c00305bc:	8b 7c 24 04          	mov    0x4(%esp),%edi
c00305c0:	01 fd                	add    %edi,%ebp
c00305c2:	8b 04 24             	mov    (%esp),%eax
c00305c5:	03 44 24 34          	add    0x34(%esp),%eax
c00305c9:	83 ec 04             	sub    $0x4,%esp
c00305cc:	56                   	push   %esi
c00305cd:	50                   	push   %eax
c00305ce:	55                   	push   %ebp
c00305cf:	e8 bd 84 ff ff       	call   c0028a91 <memcpy>
      cache_write(sector_idx, bounce);
c00305d4:	83 c4 08             	add    $0x8,%esp
c00305d7:	57                   	push   %edi
c00305d8:	ff 74 24 18          	pushl  0x18(%esp)
c00305dc:	e8 1c 0c 00 00       	call   c00311fd <cache_write>
c00305e1:	83 c4 10             	add    $0x10,%esp
    size -= chunk_size;
c00305e4:	29 74 24 38          	sub    %esi,0x38(%esp)
    offset += chunk_size;
c00305e8:	01 74 24 3c          	add    %esi,0x3c(%esp)
    bytes_written += chunk_size;
c00305ec:	01 34 24             	add    %esi,(%esp)
  while (size > 0)
c00305ef:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c00305f4:	7e 99                	jle    c003058f <inode_write_at+0x6f>
    block_sector_t sector_idx = byte_to_sector(inode, offset, true);
c00305f6:	b9 01 00 00 00       	mov    $0x1,%ecx
c00305fb:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c00305ff:	8b 44 24 30          	mov    0x30(%esp),%eax
c0030603:	e8 b6 f5 ff ff       	call   c002fbbe <byte_to_sector>
c0030608:	89 c2                	mov    %eax,%edx
c003060a:	89 44 24 0c          	mov    %eax,0xc(%esp)
    int sector_ofs = offset % BLOCK_SECTOR_SIZE;
c003060e:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0030612:	c1 f8 1f             	sar    $0x1f,%eax
c0030615:	c1 e8 17             	shr    $0x17,%eax
c0030618:	89 c5                	mov    %eax,%ebp
c003061a:	03 6c 24 3c          	add    0x3c(%esp),%ebp
c003061e:	81 e5 ff 01 00 00    	and    $0x1ff,%ebp
c0030624:	29 c5                	sub    %eax,%ebp
    int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
c0030626:	bf 00 02 00 00       	mov    $0x200,%edi
c003062b:	29 ef                	sub    %ebp,%edi
    off_t inode_left = inode_length(inode) - offset;
c003062d:	8b 44 24 30          	mov    0x30(%esp),%eax
c0030631:	8b 40 1c             	mov    0x1c(%eax),%eax
c0030634:	89 44 24 08          	mov    %eax,0x8(%esp)
c0030638:	89 c6                	mov    %eax,%esi
c003063a:	2b 74 24 3c          	sub    0x3c(%esp),%esi
    int chunk_size = size < min_left ? size : min_left;
c003063e:	3b 74 24 38          	cmp    0x38(%esp),%esi
c0030642:	0f 4f 74 24 38       	cmovg  0x38(%esp),%esi
c0030647:	39 fe                	cmp    %edi,%esi
c0030649:	0f 4f f7             	cmovg  %edi,%esi
    if (chunk_size <= 0)
c003064c:	85 f6                	test   %esi,%esi
c003064e:	0f 8e 3b ff ff ff    	jle    c003058f <inode_write_at+0x6f>
    if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
c0030654:	85 ed                	test   %ebp,%ebp
c0030656:	75 0c                	jne    c0030664 <inode_write_at+0x144>
c0030658:	81 fe 00 02 00 00    	cmp    $0x200,%esi
c003065e:	0f 84 f8 fe ff ff    	je     c003055c <inode_write_at+0x3c>
      if (bounce == NULL)
c0030664:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0030669:	0f 84 04 ff ff ff    	je     c0030573 <inode_write_at+0x53>
      if (sector_ofs > 0 || chunk_size < sector_left)
c003066f:	85 ed                	test   %ebp,%ebp
c0030671:	0f 8f 32 ff ff ff    	jg     c00305a9 <inode_write_at+0x89>
c0030677:	39 f7                	cmp    %esi,%edi
c0030679:	0f 8f 2a ff ff ff    	jg     c00305a9 <inode_write_at+0x89>
        memset(bounce, 0, BLOCK_SECTOR_SIZE);
c003067f:	b9 80 00 00 00       	mov    $0x80,%ecx
c0030684:	8b 7c 24 04          	mov    0x4(%esp),%edi
c0030688:	b8 00 00 00 00       	mov    $0x0,%eax
c003068d:	f3 ab                	rep stos %eax,%es:(%edi)
c003068f:	e9 28 ff ff ff       	jmp    c00305bc <inode_write_at+0x9c>
  uint8_t *bounce = NULL;
c0030694:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c003069b:	00 
c003069c:	e9 ee fe ff ff       	jmp    c003058f <inode_write_at+0x6f>
    return 0;
c00306a1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
c00306a8:	e9 f1 fe ff ff       	jmp    c003059e <inode_write_at+0x7e>

c00306ad <inode_deny_write>:
{
c00306ad:	53                   	push   %ebx
c00306ae:	83 ec 08             	sub    $0x8,%esp
c00306b1:	e8 30 1e 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00306b6:	81 c3 86 05 01 00    	add    $0x10586,%ebx
c00306bc:	8b 54 24 10          	mov    0x10(%esp),%edx
  inode->deny_write_cnt++;
c00306c0:	8b 42 14             	mov    0x14(%edx),%eax
c00306c3:	83 c0 01             	add    $0x1,%eax
c00306c6:	89 42 14             	mov    %eax,0x14(%edx)
  ASSERT(inode->deny_write_cnt <= inode->open_cnt);
c00306c9:	3b 42 0c             	cmp    0xc(%edx),%eax
c00306cc:	7f 05                	jg     c00306d3 <inode_deny_write+0x26>
}
c00306ce:	83 c4 08             	add    $0x8,%esp
c00306d1:	5b                   	pop    %ebx
c00306d2:	c3                   	ret    
  ASSERT(inode->deny_write_cnt <= inode->open_cnt);
c00306d3:	83 ec 0c             	sub    $0xc,%esp
c00306d6:	8d 83 b8 52 ff ff    	lea    -0xad48(%ebx),%eax
c00306dc:	50                   	push   %eax
c00306dd:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00306e3:	50                   	push   %eax
c00306e4:	8d 83 18 2b ff ff    	lea    -0xd4e8(%ebx),%eax
c00306ea:	50                   	push   %eax
c00306eb:	68 cc 01 00 00       	push   $0x1cc
c00306f0:	8d 83 79 52 ff ff    	lea    -0xad87(%ebx),%eax
c00306f6:	50                   	push   %eax
c00306f7:	e8 99 91 ff ff       	call   c0029895 <debug_panic>

c00306fc <inode_allow_write>:
{
c00306fc:	53                   	push   %ebx
c00306fd:	83 ec 08             	sub    $0x8,%esp
c0030700:	e8 e1 1d 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0030705:	81 c3 37 05 01 00    	add    $0x10537,%ebx
c003070b:	8b 54 24 10          	mov    0x10(%esp),%edx
  ASSERT(inode->deny_write_cnt > 0);
c003070f:	8b 42 14             	mov    0x14(%edx),%eax
c0030712:	85 c0                	test   %eax,%eax
c0030714:	7e 10                	jle    c0030726 <inode_allow_write+0x2a>
  ASSERT(inode->deny_write_cnt <= inode->open_cnt);
c0030716:	3b 42 0c             	cmp    0xc(%edx),%eax
c0030719:	7f 34                	jg     c003074f <inode_allow_write+0x53>
  inode->deny_write_cnt--;
c003071b:	83 e8 01             	sub    $0x1,%eax
c003071e:	89 42 14             	mov    %eax,0x14(%edx)
}
c0030721:	83 c4 08             	add    $0x8,%esp
c0030724:	5b                   	pop    %ebx
c0030725:	c3                   	ret    
  ASSERT(inode->deny_write_cnt > 0);
c0030726:	83 ec 0c             	sub    $0xc,%esp
c0030729:	8d 83 9b 52 ff ff    	lea    -0xad65(%ebx),%eax
c003072f:	50                   	push   %eax
c0030730:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0030736:	50                   	push   %eax
c0030737:	8d 83 04 2b ff ff    	lea    -0xd4fc(%ebx),%eax
c003073d:	50                   	push   %eax
c003073e:	68 d4 01 00 00       	push   $0x1d4
c0030743:	8d 83 79 52 ff ff    	lea    -0xad87(%ebx),%eax
c0030749:	50                   	push   %eax
c003074a:	e8 46 91 ff ff       	call   c0029895 <debug_panic>
  ASSERT(inode->deny_write_cnt <= inode->open_cnt);
c003074f:	83 ec 0c             	sub    $0xc,%esp
c0030752:	8d 83 b8 52 ff ff    	lea    -0xad48(%ebx),%eax
c0030758:	50                   	push   %eax
c0030759:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c003075f:	50                   	push   %eax
c0030760:	8d 83 04 2b ff ff    	lea    -0xd4fc(%ebx),%eax
c0030766:	50                   	push   %eax
c0030767:	68 d5 01 00 00       	push   $0x1d5
c003076c:	8d 83 79 52 ff ff    	lea    -0xad87(%ebx),%eax
c0030772:	50                   	push   %eax
c0030773:	e8 1d 91 ff ff       	call   c0029895 <debug_panic>

c0030778 <inode_length>:
  return inode->data.length;
c0030778:	8b 44 24 04          	mov    0x4(%esp),%eax
c003077c:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c003077f:	c3                   	ret    

c0030780 <inode_isdir>:
  return inode->data.is_dir;
c0030780:	8b 44 24 04          	mov    0x4(%esp),%eax
c0030784:	0f b6 80 17 02 00 00 	movzbl 0x217(%eax),%eax
}
c003078b:	c3                   	ret    

c003078c <inode_set_dir>:
{
c003078c:	53                   	push   %ebx
c003078d:	83 ec 10             	sub    $0x10,%esp
c0030790:	e8 51 1d 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0030795:	81 c3 a7 04 01 00    	add    $0x104a7,%ebx
c003079b:	8b 44 24 18          	mov    0x18(%esp),%eax
  inode->data.is_dir = true;
c003079f:	c6 80 17 02 00 00 01 	movb   $0x1,0x217(%eax)
  cache_write(inode->sector, &inode->data);
c00307a6:	8d 50 18             	lea    0x18(%eax),%edx
c00307a9:	52                   	push   %edx
c00307aa:	ff 70 08             	pushl  0x8(%eax)
c00307ad:	e8 4b 0a 00 00       	call   c00311fd <cache_write>
}
c00307b2:	83 c4 18             	add    $0x18,%esp
c00307b5:	5b                   	pop    %ebx
c00307b6:	c3                   	ret    

c00307b7 <inode_get_opencnt>:
  return inode->open_cnt;
c00307b7:	8b 44 24 04          	mov    0x4(%esp),%eax
c00307bb:	8b 40 0c             	mov    0xc(%eax),%eax
}
c00307be:	c3                   	ret    

c00307bf <fsutil_ls>:
#include "threads/palloc.h"
#include "threads/vaddr.h"

/* List files in the root directory. */
void fsutil_ls(char **argv UNUSED)
{
c00307bf:	57                   	push   %edi
c00307c0:	56                   	push   %esi
c00307c1:	53                   	push   %ebx
c00307c2:	83 ec 1c             	sub    $0x1c,%esp
c00307c5:	e8 1c 1d 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00307ca:	81 c3 72 04 01 00    	add    $0x10472,%ebx
  struct dir *dir;
  char name[NAME_MAX + 1];

  printf("Files in the root directory:\n");
c00307d0:	8d 83 e1 52 ff ff    	lea    -0xad1f(%ebx),%eax
c00307d6:	50                   	push   %eax
c00307d7:	e8 92 b0 ff ff       	call   c002b86e <puts>
  dir = dir_open_root();
c00307dc:	e8 76 e6 ff ff       	call   c002ee57 <dir_open_root>
  if (dir == NULL)
c00307e1:	83 c4 10             	add    $0x10,%esp
c00307e4:	85 c0                	test   %eax,%eax
c00307e6:	74 08                	je     c00307f0 <fsutil_ls+0x31>
c00307e8:	89 c7                	mov    %eax,%edi
    PANIC("root dir open failed");
  while (dir_readdir(dir, name))
c00307ea:	8d 74 24 01          	lea    0x1(%esp),%esi
c00307ee:	eb 28                	jmp    c0030818 <fsutil_ls+0x59>
    PANIC("root dir open failed");
c00307f0:	8d 83 fe 52 ff ff    	lea    -0xad02(%ebx),%eax
c00307f6:	50                   	push   %eax
c00307f7:	8d 83 94 2b ff ff    	lea    -0xd46c(%ebx),%eax
c00307fd:	50                   	push   %eax
c00307fe:	6a 17                	push   $0x17
c0030800:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c0030806:	50                   	push   %eax
c0030807:	e8 89 90 ff ff       	call   c0029895 <debug_panic>
    printf("%s\n", name);
c003080c:	83 ec 0c             	sub    $0xc,%esp
c003080f:	56                   	push   %esi
c0030810:	e8 59 b0 ff ff       	call   c002b86e <puts>
c0030815:	83 c4 10             	add    $0x10,%esp
  while (dir_readdir(dir, name))
c0030818:	83 ec 08             	sub    $0x8,%esp
c003081b:	56                   	push   %esi
c003081c:	57                   	push   %edi
c003081d:	e8 3a ec ff ff       	call   c002f45c <dir_readdir>
c0030822:	83 c4 10             	add    $0x10,%esp
c0030825:	84 c0                	test   %al,%al
c0030827:	75 e3                	jne    c003080c <fsutil_ls+0x4d>
  dir_close(dir);
c0030829:	83 ec 0c             	sub    $0xc,%esp
c003082c:	57                   	push   %edi
c003082d:	e8 6f e6 ff ff       	call   c002eea1 <dir_close>
  printf("End of listing.\n");
c0030832:	8d 83 2a 53 ff ff    	lea    -0xacd6(%ebx),%eax
c0030838:	89 04 24             	mov    %eax,(%esp)
c003083b:	e8 2e b0 ff ff       	call   c002b86e <puts>
}
c0030840:	83 c4 20             	add    $0x20,%esp
c0030843:	5b                   	pop    %ebx
c0030844:	5e                   	pop    %esi
c0030845:	5f                   	pop    %edi
c0030846:	c3                   	ret    

c0030847 <fsutil_cat>:

/* Prints the contents of file ARGV[1] to the system console as
   hex and ASCII. */
void fsutil_cat(char **argv)
{
c0030847:	55                   	push   %ebp
c0030848:	57                   	push   %edi
c0030849:	56                   	push   %esi
c003084a:	53                   	push   %ebx
c003084b:	83 ec 14             	sub    $0x14,%esp
c003084e:	e8 93 1c 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0030853:	81 c3 e9 03 01 00    	add    $0x103e9,%ebx
  const char *file_name = argv[1];
c0030859:	8b 44 24 28          	mov    0x28(%esp),%eax
c003085d:	8b 78 04             	mov    0x4(%eax),%edi

  struct file *file;
  char *buffer;

  printf("Printing '%s' to the console...\n", file_name);
c0030860:	57                   	push   %edi
c0030861:	8d 83 04 54 ff ff    	lea    -0xabfc(%ebx),%eax
c0030867:	50                   	push   %eax
c0030868:	e8 91 72 ff ff       	call   c0027afe <printf>
  file = filesys_open(file_name);
c003086d:	89 3c 24             	mov    %edi,(%esp)
c0030870:	e8 a0 dd ff ff       	call   c002e615 <filesys_open>
  if (file == NULL)
c0030875:	83 c4 10             	add    $0x10,%esp
c0030878:	85 c0                	test   %eax,%eax
c003087a:	74 41                	je     c00308bd <fsutil_cat+0x76>
c003087c:	89 c6                	mov    %eax,%esi
    PANIC("%s: open failed", file_name);
  buffer = palloc_get_page(PAL_ASSERT);
c003087e:	83 ec 0c             	sub    $0xc,%esp
c0030881:	6a 01                	push   $0x1
c0030883:	e8 47 36 ff ff       	call   c0023ecf <palloc_get_page>
c0030888:	89 c7                	mov    %eax,%edi
c003088a:	83 c4 10             	add    $0x10,%esp
  for (;;)
  {
    off_t pos = file_tell(file);
c003088d:	83 ec 0c             	sub    $0xc,%esp
c0030890:	56                   	push   %esi
c0030891:	e8 c6 e3 ff ff       	call   c002ec5c <file_tell>
c0030896:	89 c5                	mov    %eax,%ebp
    off_t n = file_read(file, buffer, PGSIZE);
c0030898:	83 c4 0c             	add    $0xc,%esp
c003089b:	68 00 10 00 00       	push   $0x1000
c00308a0:	57                   	push   %edi
c00308a1:	56                   	push   %esi
c00308a2:	e8 44 e1 ff ff       	call   c002e9eb <file_read>
    if (n == 0)
c00308a7:	83 c4 10             	add    $0x10,%esp
c00308aa:	85 c0                	test   %eax,%eax
c00308ac:	74 2f                	je     c00308dd <fsutil_cat+0x96>
      break;

    hex_dump(pos, buffer, n, true);
c00308ae:	6a 01                	push   $0x1
c00308b0:	50                   	push   %eax
c00308b1:	57                   	push   %edi
c00308b2:	55                   	push   %ebp
c00308b3:	e8 84 7b ff ff       	call   c002843c <hex_dump>
  {
c00308b8:	83 c4 10             	add    $0x10,%esp
c00308bb:	eb d0                	jmp    c003088d <fsutil_cat+0x46>
    PANIC("%s: open failed", file_name);
c00308bd:	83 ec 0c             	sub    $0xc,%esp
c00308c0:	57                   	push   %edi
c00308c1:	8d 83 3a 53 ff ff    	lea    -0xacc6(%ebx),%eax
c00308c7:	50                   	push   %eax
c00308c8:	8d 83 88 2b ff ff    	lea    -0xd478(%ebx),%eax
c00308ce:	50                   	push   %eax
c00308cf:	6a 2a                	push   $0x2a
c00308d1:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c00308d7:	50                   	push   %eax
c00308d8:	e8 b8 8f ff ff       	call   c0029895 <debug_panic>
  }
  palloc_free_page(buffer);
c00308dd:	83 ec 0c             	sub    $0xc,%esp
c00308e0:	57                   	push   %edi
c00308e1:	e8 57 37 ff ff       	call   c002403d <palloc_free_page>
  file_close(file);
c00308e6:	89 34 24             	mov    %esi,(%esp)
c00308e9:	e8 6a e2 ff ff       	call   c002eb58 <file_close>
}
c00308ee:	83 c4 1c             	add    $0x1c,%esp
c00308f1:	5b                   	pop    %ebx
c00308f2:	5e                   	pop    %esi
c00308f3:	5f                   	pop    %edi
c00308f4:	5d                   	pop    %ebp
c00308f5:	c3                   	ret    

c00308f6 <fsutil_rm>:

/* Deletes file ARGV[1]. */
void fsutil_rm(char **argv)
{
c00308f6:	56                   	push   %esi
c00308f7:	53                   	push   %ebx
c00308f8:	83 ec 0c             	sub    $0xc,%esp
c00308fb:	e8 e6 1b 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0030900:	81 c3 3c 03 01 00    	add    $0x1033c,%ebx
  const char *file_name = argv[1];
c0030906:	8b 44 24 18          	mov    0x18(%esp),%eax
c003090a:	8b 70 04             	mov    0x4(%eax),%esi

  printf("Deleting '%s'...\n", file_name);
c003090d:	56                   	push   %esi
c003090e:	8d 83 4a 53 ff ff    	lea    -0xacb6(%ebx),%eax
c0030914:	50                   	push   %eax
c0030915:	e8 e4 71 ff ff       	call   c0027afe <printf>
  if (!filesys_remove(file_name))
c003091a:	89 34 24             	mov    %esi,(%esp)
c003091d:	e8 46 dd ff ff       	call   c002e668 <filesys_remove>
c0030922:	83 c4 10             	add    $0x10,%esp
c0030925:	84 c0                	test   %al,%al
c0030927:	74 06                	je     c003092f <fsutil_rm+0x39>
    PANIC("%s: delete failed\n", file_name);
}
c0030929:	83 c4 04             	add    $0x4,%esp
c003092c:	5b                   	pop    %ebx
c003092d:	5e                   	pop    %esi
c003092e:	c3                   	ret    
    PANIC("%s: delete failed\n", file_name);
c003092f:	83 ec 0c             	sub    $0xc,%esp
c0030932:	56                   	push   %esi
c0030933:	8d 83 5c 53 ff ff    	lea    -0xaca4(%ebx),%eax
c0030939:	50                   	push   %eax
c003093a:	8d 83 7c 2b ff ff    	lea    -0xd484(%ebx),%eax
c0030940:	50                   	push   %eax
c0030941:	6a 40                	push   $0x40
c0030943:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c0030949:	50                   	push   %eax
c003094a:	e8 46 8f ff ff       	call   c0029895 <debug_panic>

c003094f <fsutil_extract>:

/* Extracts a ustar-format tar archive from the scratch block
   device into the Pintos file system. */
void fsutil_extract(char **argv UNUSED)
{
c003094f:	55                   	push   %ebp
c0030950:	57                   	push   %edi
c0030951:	56                   	push   %esi
c0030952:	53                   	push   %ebx
c0030953:	83 ec 38             	sub    $0x38,%esp
c0030956:	e8 8b 1b 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c003095b:	81 c3 e1 02 01 00    	add    $0x102e1,%ebx

  struct block *src;
  void *header, *data;

  /* Allocate buffers. */
  header = malloc(BLOCK_SECTOR_SIZE);
c0030961:	68 00 02 00 00       	push   $0x200
c0030966:	e8 79 39 ff ff       	call   c00242e4 <malloc>
c003096b:	89 c7                	mov    %eax,%edi
c003096d:	89 44 24 14          	mov    %eax,0x14(%esp)
  data = malloc(BLOCK_SECTOR_SIZE);
c0030971:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
c0030978:	e8 67 39 ff ff       	call   c00242e4 <malloc>
c003097d:	89 c5                	mov    %eax,%ebp
  if (header == NULL || data == NULL)
c003097f:	83 c4 10             	add    $0x10,%esp
c0030982:	85 ff                	test   %edi,%edi
c0030984:	74 3d                	je     c00309c3 <fsutil_extract+0x74>
c0030986:	85 c0                	test   %eax,%eax
c0030988:	74 39                	je     c00309c3 <fsutil_extract+0x74>
    PANIC("couldn't allocate buffers");

  /* Open source block device. */
  src = block_get_role(BLOCK_SCRATCH);
c003098a:	83 ec 0c             	sub    $0xc,%esp
c003098d:	6a 02                	push   $0x2
c003098f:	e8 39 4d ff ff       	call   c00256cd <block_get_role>
c0030994:	89 44 24 10          	mov    %eax,0x10(%esp)
  if (src == NULL)
c0030998:	83 c4 10             	add    $0x10,%esp
c003099b:	85 c0                	test   %eax,%eax
c003099d:	74 40                	je     c00309df <fsutil_extract+0x90>
    PANIC("couldn't open scratch device");

  printf("Extracting ustar archive from scratch device "
c003099f:	83 ec 0c             	sub    $0xc,%esp
c00309a2:	8d 83 28 54 ff ff    	lea    -0xabd8(%ebx),%eax
c00309a8:	50                   	push   %eax
c00309a9:	e8 c0 ae ff ff       	call   c002b86e <puts>
c00309ae:	83 c4 10             	add    $0x10,%esp
    enum ustar_type type;
    int size;

    /* Read and parse ustar header. */
    block_read(src, sector++, header);
    error = ustar_parse_header(header, &file_name, &type, &size);
c00309b1:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c00309b5:	89 44 24 08          	mov    %eax,0x8(%esp)
c00309b9:	8d 44 24 18          	lea    0x18(%esp),%eax
c00309bd:	89 44 24 0c          	mov    %eax,0xc(%esp)
c00309c1:	eb 78                	jmp    c0030a3b <fsutil_extract+0xec>
    PANIC("couldn't allocate buffers");
c00309c3:	8d 83 6f 53 ff ff    	lea    -0xac91(%ebx),%eax
c00309c9:	50                   	push   %eax
c00309ca:	8d 83 6c 2b ff ff    	lea    -0xd494(%ebx),%eax
c00309d0:	50                   	push   %eax
c00309d1:	6a 50                	push   $0x50
c00309d3:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c00309d9:	50                   	push   %eax
c00309da:	e8 b6 8e ff ff       	call   c0029895 <debug_panic>
    PANIC("couldn't open scratch device");
c00309df:	8d 83 89 53 ff ff    	lea    -0xac77(%ebx),%eax
c00309e5:	50                   	push   %eax
c00309e6:	8d 83 6c 2b ff ff    	lea    -0xd494(%ebx),%eax
c00309ec:	50                   	push   %eax
c00309ed:	6a 55                	push   $0x55
c00309ef:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c00309f5:	50                   	push   %eax
c00309f6:	e8 9a 8e ff ff       	call   c0029895 <debug_panic>
    if (error != NULL)
      PANIC("bad ustar header in sector %" PRDSNu " (%s)", sector - 1, error);
c00309fb:	83 ec 08             	sub    $0x8,%esp
c00309fe:	50                   	push   %eax
c00309ff:	8b 83 68 22 00 00    	mov    0x2268(%ebx),%eax
c0030a05:	83 e8 01             	sub    $0x1,%eax
c0030a08:	50                   	push   %eax
c0030a09:	8d 83 6c 54 ff ff    	lea    -0xab94(%ebx),%eax
c0030a0f:	50                   	push   %eax
c0030a10:	8d 83 6c 2b ff ff    	lea    -0xd494(%ebx),%eax
c0030a16:	50                   	push   %eax
c0030a17:	6a 65                	push   $0x65
c0030a19:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c0030a1f:	50                   	push   %eax
c0030a20:	e8 70 8e ff ff       	call   c0029895 <debug_panic>
    {
      /* End of archive. */
      break;
    }
    else if (type == USTAR_DIRECTORY)
      printf("ignoring directory %s\n", file_name);
c0030a25:	83 ec 08             	sub    $0x8,%esp
c0030a28:	ff 74 24 1c          	pushl  0x1c(%esp)
c0030a2c:	8d 83 a6 53 ff ff    	lea    -0xac5a(%ebx),%eax
c0030a32:	50                   	push   %eax
c0030a33:	e8 c6 70 ff ff       	call   c0027afe <printf>
c0030a38:	83 c4 10             	add    $0x10,%esp
    block_read(src, sector++, header);
c0030a3b:	8b 83 68 22 00 00    	mov    0x2268(%ebx),%eax
c0030a41:	8d 50 01             	lea    0x1(%eax),%edx
c0030a44:	89 93 68 22 00 00    	mov    %edx,0x2268(%ebx)
c0030a4a:	83 ec 04             	sub    $0x4,%esp
c0030a4d:	8b 7c 24 08          	mov    0x8(%esp),%edi
c0030a51:	57                   	push   %edi
c0030a52:	50                   	push   %eax
c0030a53:	ff 74 24 0c          	pushl  0xc(%esp)
c0030a57:	e8 ee 4d ff ff       	call   c002584a <block_read>
    error = ustar_parse_header(header, &file_name, &type, &size);
c0030a5c:	ff 74 24 18          	pushl  0x18(%esp)
c0030a60:	ff 74 24 20          	pushl  0x20(%esp)
c0030a64:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c0030a68:	50                   	push   %eax
c0030a69:	57                   	push   %edi
c0030a6a:	e8 8d 8b ff ff       	call   c00295fc <ustar_parse_header>
    if (error != NULL)
c0030a6f:	83 c4 20             	add    $0x20,%esp
c0030a72:	85 c0                	test   %eax,%eax
c0030a74:	75 85                	jne    c00309fb <fsutil_extract+0xac>
    if (type == USTAR_EOF)
c0030a76:	8b 44 24 18          	mov    0x18(%esp),%eax
c0030a7a:	83 f8 ff             	cmp    $0xffffffff,%eax
c0030a7d:	0f 84 23 01 00 00    	je     c0030ba6 <fsutil_extract+0x257>
    else if (type == USTAR_DIRECTORY)
c0030a83:	83 f8 35             	cmp    $0x35,%eax
c0030a86:	74 9d                	je     c0030a25 <fsutil_extract+0xd6>
    else if (type == USTAR_REGULAR)
c0030a88:	83 f8 30             	cmp    $0x30,%eax
c0030a8b:	75 ae                	jne    c0030a3b <fsutil_extract+0xec>
    {
      struct file *dst;

      printf("Putting '%s' into the file system...\n", file_name);
c0030a8d:	83 ec 08             	sub    $0x8,%esp
c0030a90:	ff 74 24 1c          	pushl  0x1c(%esp)
c0030a94:	8d 83 90 54 ff ff    	lea    -0xab70(%ebx),%eax
c0030a9a:	50                   	push   %eax
c0030a9b:	e8 5e 70 ff ff       	call   c0027afe <printf>

      /* Create destination file. */
      if (!filesys_create(file_name, size))
c0030aa0:	83 c4 08             	add    $0x8,%esp
c0030aa3:	ff 74 24 24          	pushl  0x24(%esp)
c0030aa7:	ff 74 24 20          	pushl  0x20(%esp)
c0030aab:	e8 c9 da ff ff       	call   c002e579 <filesys_create>
c0030ab0:	83 c4 10             	add    $0x10,%esp
c0030ab3:	84 c0                	test   %al,%al
c0030ab5:	74 7f                	je     c0030b36 <fsutil_extract+0x1e7>
        PANIC("%s: create failed", file_name);
      dst = filesys_open(file_name);
c0030ab7:	83 ec 0c             	sub    $0xc,%esp
c0030aba:	ff 74 24 20          	pushl  0x20(%esp)
c0030abe:	e8 52 db ff ff       	call   c002e615 <filesys_open>
c0030ac3:	89 c7                	mov    %eax,%edi
      if (dst == NULL)
c0030ac5:	83 c4 10             	add    $0x10,%esp
c0030ac8:	85 c0                	test   %eax,%eax
c0030aca:	0f 84 89 00 00 00    	je     c0030b59 <fsutil_extract+0x20a>
        PANIC("%s: open failed", file_name);

      /* Do copy. */
      while (size > 0)
c0030ad0:	8b 74 24 1c          	mov    0x1c(%esp),%esi
c0030ad4:	85 f6                	test   %esi,%esi
c0030ad6:	7e 4d                	jle    c0030b25 <fsutil_extract+0x1d6>
      {
        int chunk_size = (size > BLOCK_SECTOR_SIZE
c0030ad8:	81 fe 00 02 00 00    	cmp    $0x200,%esi
c0030ade:	b8 00 02 00 00       	mov    $0x200,%eax
c0030ae3:	0f 4f f0             	cmovg  %eax,%esi
                              ? BLOCK_SECTOR_SIZE
                              : size);
        block_read(src, sector++, data);
c0030ae6:	8b 83 68 22 00 00    	mov    0x2268(%ebx),%eax
c0030aec:	8d 50 01             	lea    0x1(%eax),%edx
c0030aef:	89 93 68 22 00 00    	mov    %edx,0x2268(%ebx)
c0030af5:	83 ec 04             	sub    $0x4,%esp
c0030af8:	55                   	push   %ebp
c0030af9:	50                   	push   %eax
c0030afa:	ff 74 24 0c          	pushl  0xc(%esp)
c0030afe:	e8 47 4d ff ff       	call   c002584a <block_read>
        if (file_write(dst, data, chunk_size) != chunk_size)
c0030b03:	83 c4 0c             	add    $0xc,%esp
c0030b06:	56                   	push   %esi
c0030b07:	55                   	push   %ebp
c0030b08:	57                   	push   %edi
c0030b09:	e8 37 df ff ff       	call   c002ea45 <file_write>
c0030b0e:	83 c4 10             	add    $0x10,%esp
c0030b11:	39 f0                	cmp    %esi,%eax
c0030b13:	75 67                	jne    c0030b7c <fsutil_extract+0x22d>
          PANIC("%s: write failed with %d bytes unwritten",
                file_name, size);
        size -= chunk_size;
c0030b15:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0030b19:	29 f0                	sub    %esi,%eax
c0030b1b:	89 c6                	mov    %eax,%esi
c0030b1d:	89 44 24 1c          	mov    %eax,0x1c(%esp)
      while (size > 0)
c0030b21:	85 c0                	test   %eax,%eax
c0030b23:	7f b3                	jg     c0030ad8 <fsutil_extract+0x189>
      }

      /* Finish up. */
      file_close(dst);
c0030b25:	83 ec 0c             	sub    $0xc,%esp
c0030b28:	57                   	push   %edi
c0030b29:	e8 2a e0 ff ff       	call   c002eb58 <file_close>
c0030b2e:	83 c4 10             	add    $0x10,%esp
  {
c0030b31:	e9 05 ff ff ff       	jmp    c0030a3b <fsutil_extract+0xec>
        PANIC("%s: create failed", file_name);
c0030b36:	83 ec 0c             	sub    $0xc,%esp
c0030b39:	ff 74 24 20          	pushl  0x20(%esp)
c0030b3d:	8d 83 bd 53 ff ff    	lea    -0xac43(%ebx),%eax
c0030b43:	50                   	push   %eax
c0030b44:	8d 83 6c 2b ff ff    	lea    -0xd494(%ebx),%eax
c0030b4a:	50                   	push   %eax
c0030b4b:	6a 76                	push   $0x76
c0030b4d:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c0030b53:	50                   	push   %eax
c0030b54:	e8 3c 8d ff ff       	call   c0029895 <debug_panic>
        PANIC("%s: open failed", file_name);
c0030b59:	83 ec 0c             	sub    $0xc,%esp
c0030b5c:	ff 74 24 20          	pushl  0x20(%esp)
c0030b60:	8d 83 3a 53 ff ff    	lea    -0xacc6(%ebx),%eax
c0030b66:	50                   	push   %eax
c0030b67:	8d 83 6c 2b ff ff    	lea    -0xd494(%ebx),%eax
c0030b6d:	50                   	push   %eax
c0030b6e:	6a 79                	push   $0x79
c0030b70:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c0030b76:	50                   	push   %eax
c0030b77:	e8 19 8d ff ff       	call   c0029895 <debug_panic>
          PANIC("%s: write failed with %d bytes unwritten",
c0030b7c:	83 ec 08             	sub    $0x8,%esp
c0030b7f:	ff 74 24 24          	pushl  0x24(%esp)
c0030b83:	ff 74 24 20          	pushl  0x20(%esp)
c0030b87:	8d 83 b8 54 ff ff    	lea    -0xab48(%ebx),%eax
c0030b8d:	50                   	push   %eax
c0030b8e:	8d 83 6c 2b ff ff    	lea    -0xd494(%ebx),%eax
c0030b94:	50                   	push   %eax
c0030b95:	68 84 00 00 00       	push   $0x84
c0030b9a:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c0030ba0:	50                   	push   %eax
c0030ba1:	e8 ef 8c ff ff       	call   c0029895 <debug_panic>

  /* Erase the ustar header from the start of the block device,
     so that the extraction operation is idempotent.  We erase
     two blocks because two blocks of zeros are the ustar
     end-of-archive marker. */
  printf("Erasing ustar archive...\n");
c0030ba6:	83 ec 0c             	sub    $0xc,%esp
c0030ba9:	8d 83 cf 53 ff ff    	lea    -0xac31(%ebx),%eax
c0030baf:	50                   	push   %eax
c0030bb0:	e8 b9 ac ff ff       	call   c002b86e <puts>
  memset(header, 0, BLOCK_SECTOR_SIZE);
c0030bb5:	b9 80 00 00 00       	mov    $0x80,%ecx
c0030bba:	b8 00 00 00 00       	mov    $0x0,%eax
c0030bbf:	8b 7c 24 14          	mov    0x14(%esp),%edi
c0030bc3:	f3 ab                	rep stos %eax,%es:(%edi)
  block_write(src, 0, header);
c0030bc5:	83 c4 0c             	add    $0xc,%esp
c0030bc8:	8b 7c 24 08          	mov    0x8(%esp),%edi
c0030bcc:	57                   	push   %edi
c0030bcd:	6a 00                	push   $0x0
c0030bcf:	8b 74 24 0c          	mov    0xc(%esp),%esi
c0030bd3:	56                   	push   %esi
c0030bd4:	e8 a5 4c ff ff       	call   c002587e <block_write>
  block_write(src, 1, header);
c0030bd9:	83 c4 0c             	add    $0xc,%esp
c0030bdc:	57                   	push   %edi
c0030bdd:	6a 01                	push   $0x1
c0030bdf:	56                   	push   %esi
c0030be0:	e8 99 4c ff ff       	call   c002587e <block_write>

  free(data);
c0030be5:	89 2c 24             	mov    %ebp,(%esp)
c0030be8:	e8 ad 38 ff ff       	call   c002449a <free>
  free(header);
c0030bed:	89 3c 24             	mov    %edi,(%esp)
c0030bf0:	e8 a5 38 ff ff       	call   c002449a <free>
}
c0030bf5:	83 c4 3c             	add    $0x3c,%esp
c0030bf8:	5b                   	pop    %ebx
c0030bf9:	5e                   	pop    %esi
c0030bfa:	5f                   	pop    %edi
c0030bfb:	5d                   	pop    %ebp
c0030bfc:	c3                   	ret    

c0030bfd <fsutil_append>:
   beginning of the scratch device.  Later calls advance across
   the device.  This position is independent of that used for
   fsutil_extract(), so `extract' should precede all
   `append's. */
void fsutil_append(char **argv)
{
c0030bfd:	55                   	push   %ebp
c0030bfe:	57                   	push   %edi
c0030bff:	56                   	push   %esi
c0030c00:	53                   	push   %ebx
c0030c01:	83 ec 24             	sub    $0x24,%esp
c0030c04:	e8 dd 18 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0030c09:	81 c3 33 00 01 00    	add    $0x10033,%ebx
  static block_sector_t sector = 0;

  const char *file_name = argv[1];
c0030c0f:	8b 44 24 38          	mov    0x38(%esp),%eax
c0030c13:	8b 40 04             	mov    0x4(%eax),%eax
c0030c16:	89 44 24 14          	mov    %eax,0x14(%esp)
  void *buffer;
  struct file *src;
  struct block *dst;
  off_t size;

  printf("Appending '%s' to ustar archive on scratch device...\n", file_name);
c0030c1a:	50                   	push   %eax
c0030c1b:	8d 83 e4 54 ff ff    	lea    -0xab1c(%ebx),%eax
c0030c21:	50                   	push   %eax
c0030c22:	e8 d7 6e ff ff       	call   c0027afe <printf>

  /* Allocate buffer. */
  buffer = malloc(BLOCK_SECTOR_SIZE);
c0030c27:	c7 04 24 00 02 00 00 	movl   $0x200,(%esp)
c0030c2e:	e8 b1 36 ff ff       	call   c00242e4 <malloc>
  if (buffer == NULL)
c0030c33:	83 c4 10             	add    $0x10,%esp
c0030c36:	85 c0                	test   %eax,%eax
c0030c38:	0f 84 52 01 00 00    	je     c0030d90 <fsutil_append+0x193>
c0030c3e:	89 c5                	mov    %eax,%ebp
    PANIC("couldn't allocate buffer");

  /* Open source file. */
  src = filesys_open(file_name);
c0030c40:	83 ec 0c             	sub    $0xc,%esp
c0030c43:	ff 74 24 18          	pushl  0x18(%esp)
c0030c47:	e8 c9 d9 ff ff       	call   c002e615 <filesys_open>
c0030c4c:	89 44 24 18          	mov    %eax,0x18(%esp)
  if (src == NULL)
c0030c50:	83 c4 10             	add    $0x10,%esp
c0030c53:	85 c0                	test   %eax,%eax
c0030c55:	0f 84 54 01 00 00    	je     c0030daf <fsutil_append+0x1b2>
    PANIC("%s: open failed", file_name);
  size = file_length(src);
c0030c5b:	83 ec 0c             	sub    $0xc,%esp
c0030c5e:	ff 74 24 14          	pushl  0x14(%esp)
c0030c62:	e8 2d df ff ff       	call   c002eb94 <file_length>
c0030c67:	89 c7                	mov    %eax,%edi

  /* Open target block device. */
  dst = block_get_role(BLOCK_SCRATCH);
c0030c69:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
c0030c70:	e8 58 4a ff ff       	call   c00256cd <block_get_role>
c0030c75:	89 44 24 14          	mov    %eax,0x14(%esp)
  if (dst == NULL)
c0030c79:	83 c4 10             	add    $0x10,%esp
c0030c7c:	85 c0                	test   %eax,%eax
c0030c7e:	0f 84 51 01 00 00    	je     c0030dd5 <fsutil_append+0x1d8>
    PANIC("couldn't open scratch device");

  /* Write ustar header to first sector. */
  if (!ustar_make_header(file_name, USTAR_REGULAR, size, buffer))
c0030c84:	55                   	push   %ebp
c0030c85:	57                   	push   %edi
c0030c86:	6a 30                	push   $0x30
c0030c88:	ff 74 24 18          	pushl  0x18(%esp)
c0030c8c:	e8 78 87 ff ff       	call   c0029409 <ustar_make_header>
c0030c91:	83 c4 10             	add    $0x10,%esp
c0030c94:	84 c0                	test   %al,%al
c0030c96:	0f 84 58 01 00 00    	je     c0030df4 <fsutil_append+0x1f7>
    PANIC("%s: name too long for ustar format", file_name);
  block_write(dst, sector++, buffer);
c0030c9c:	8b 83 64 22 00 00    	mov    0x2264(%ebx),%eax
c0030ca2:	8d 50 01             	lea    0x1(%eax),%edx
c0030ca5:	89 93 64 22 00 00    	mov    %edx,0x2264(%ebx)
c0030cab:	83 ec 04             	sub    $0x4,%esp
c0030cae:	55                   	push   %ebp
c0030caf:	50                   	push   %eax
c0030cb0:	ff 74 24 10          	pushl  0x10(%esp)
c0030cb4:	e8 c5 4b ff ff       	call   c002587e <block_write>

  /* Do copy. */
  while (size > 0)
c0030cb9:	83 c4 10             	add    $0x10,%esp
c0030cbc:	85 ff                	test   %edi,%edi
c0030cbe:	7e 7f                	jle    c0030d3f <fsutil_append+0x142>
  {
    int chunk_size = size > BLOCK_SECTOR_SIZE ? BLOCK_SECTOR_SIZE : size;
c0030cc0:	81 ff 00 02 00 00    	cmp    $0x200,%edi
c0030cc6:	be 00 02 00 00       	mov    $0x200,%esi
c0030ccb:	0f 4e f7             	cmovle %edi,%esi
    if (sector >= block_size(dst))
c0030cce:	83 ec 0c             	sub    $0xc,%esp
c0030cd1:	ff 74 24 10          	pushl  0x10(%esp)
c0030cd5:	e8 12 4c ff ff       	call   c00258ec <block_size>
c0030cda:	83 c4 10             	add    $0x10,%esp
c0030cdd:	3b 83 64 22 00 00    	cmp    0x2264(%ebx),%eax
c0030ce3:	0f 86 31 01 00 00    	jbe    c0030e1a <fsutil_append+0x21d>
      PANIC("%s: out of space on scratch device", file_name);
    if (file_read(src, buffer, chunk_size) != chunk_size)
c0030ce9:	83 ec 04             	sub    $0x4,%esp
c0030cec:	56                   	push   %esi
c0030ced:	55                   	push   %ebp
c0030cee:	ff 74 24 14          	pushl  0x14(%esp)
c0030cf2:	e8 f4 dc ff ff       	call   c002e9eb <file_read>
c0030cf7:	83 c4 10             	add    $0x10,%esp
c0030cfa:	39 f0                	cmp    %esi,%eax
c0030cfc:	0f 85 3e 01 00 00    	jne    c0030e40 <fsutil_append+0x243>
      PANIC("%s: read failed with %" PROTd " bytes unread", file_name, size);
    memset(buffer + chunk_size, 0, BLOCK_SECTOR_SIZE - chunk_size);
c0030d02:	ba 00 02 00 00       	mov    $0x200,%edx
c0030d07:	29 f2                	sub    %esi,%edx
c0030d09:	8d 44 35 00          	lea    0x0(%ebp,%esi,1),%eax
c0030d0d:	83 ec 04             	sub    $0x4,%esp
c0030d10:	52                   	push   %edx
c0030d11:	6a 00                	push   $0x0
c0030d13:	50                   	push   %eax
c0030d14:	e8 fb 80 ff ff       	call   c0028e14 <memset>
    block_write(dst, sector++, buffer);
c0030d19:	8b 83 64 22 00 00    	mov    0x2264(%ebx),%eax
c0030d1f:	8d 50 01             	lea    0x1(%eax),%edx
c0030d22:	89 93 64 22 00 00    	mov    %edx,0x2264(%ebx)
c0030d28:	83 c4 0c             	add    $0xc,%esp
c0030d2b:	55                   	push   %ebp
c0030d2c:	50                   	push   %eax
c0030d2d:	ff 74 24 10          	pushl  0x10(%esp)
c0030d31:	e8 48 4b ff ff       	call   c002587e <block_write>
    size -= chunk_size;
c0030d36:	29 f7                	sub    %esi,%edi
  while (size > 0)
c0030d38:	83 c4 10             	add    $0x10,%esp
c0030d3b:	85 ff                	test   %edi,%edi
c0030d3d:	7f 81                	jg     c0030cc0 <fsutil_append+0xc3>
  }

  /* Write ustar end-of-archive marker, which is two consecutive
     sectors full of zeros.  Don't advance our position past
     them, though, in case we have more files to append. */
  memset(buffer, 0, BLOCK_SECTOR_SIZE);
c0030d3f:	b9 80 00 00 00       	mov    $0x80,%ecx
c0030d44:	b8 00 00 00 00       	mov    $0x0,%eax
c0030d49:	89 ef                	mov    %ebp,%edi
c0030d4b:	f3 ab                	rep stos %eax,%es:(%edi)
  block_write(dst, sector, buffer);
c0030d4d:	83 ec 04             	sub    $0x4,%esp
c0030d50:	55                   	push   %ebp
c0030d51:	ff b3 64 22 00 00    	pushl  0x2264(%ebx)
c0030d57:	8b 7c 24 10          	mov    0x10(%esp),%edi
c0030d5b:	57                   	push   %edi
c0030d5c:	e8 1d 4b ff ff       	call   c002587e <block_write>
  block_write(dst, sector, buffer + 1);
c0030d61:	83 c4 0c             	add    $0xc,%esp
c0030d64:	8d 45 01             	lea    0x1(%ebp),%eax
c0030d67:	50                   	push   %eax
c0030d68:	ff b3 64 22 00 00    	pushl  0x2264(%ebx)
c0030d6e:	57                   	push   %edi
c0030d6f:	e8 0a 4b ff ff       	call   c002587e <block_write>

  /* Finish up. */
  file_close(src);
c0030d74:	83 c4 04             	add    $0x4,%esp
c0030d77:	ff 74 24 14          	pushl  0x14(%esp)
c0030d7b:	e8 d8 dd ff ff       	call   c002eb58 <file_close>
  free(buffer);
c0030d80:	89 2c 24             	mov    %ebp,(%esp)
c0030d83:	e8 12 37 ff ff       	call   c002449a <free>
}
c0030d88:	83 c4 2c             	add    $0x2c,%esp
c0030d8b:	5b                   	pop    %ebx
c0030d8c:	5e                   	pop    %esi
c0030d8d:	5f                   	pop    %edi
c0030d8e:	5d                   	pop    %ebp
c0030d8f:	c3                   	ret    
    PANIC("couldn't allocate buffer");
c0030d90:	8d 83 e8 53 ff ff    	lea    -0xac18(%ebx),%eax
c0030d96:	50                   	push   %eax
c0030d97:	8d 83 5c 2b ff ff    	lea    -0xd4a4(%ebx),%eax
c0030d9d:	50                   	push   %eax
c0030d9e:	68 b1 00 00 00       	push   $0xb1
c0030da3:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c0030da9:	50                   	push   %eax
c0030daa:	e8 e6 8a ff ff       	call   c0029895 <debug_panic>
    PANIC("%s: open failed", file_name);
c0030daf:	83 ec 0c             	sub    $0xc,%esp
c0030db2:	ff 74 24 18          	pushl  0x18(%esp)
c0030db6:	8d 83 3a 53 ff ff    	lea    -0xacc6(%ebx),%eax
c0030dbc:	50                   	push   %eax
c0030dbd:	8d 83 5c 2b ff ff    	lea    -0xd4a4(%ebx),%eax
c0030dc3:	50                   	push   %eax
c0030dc4:	68 b6 00 00 00       	push   $0xb6
c0030dc9:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c0030dcf:	50                   	push   %eax
c0030dd0:	e8 c0 8a ff ff       	call   c0029895 <debug_panic>
    PANIC("couldn't open scratch device");
c0030dd5:	8d 83 89 53 ff ff    	lea    -0xac77(%ebx),%eax
c0030ddb:	50                   	push   %eax
c0030ddc:	8d 83 5c 2b ff ff    	lea    -0xd4a4(%ebx),%eax
c0030de2:	50                   	push   %eax
c0030de3:	68 bc 00 00 00       	push   $0xbc
c0030de8:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c0030dee:	50                   	push   %eax
c0030def:	e8 a1 8a ff ff       	call   c0029895 <debug_panic>
    PANIC("%s: name too long for ustar format", file_name);
c0030df4:	83 ec 0c             	sub    $0xc,%esp
c0030df7:	ff 74 24 18          	pushl  0x18(%esp)
c0030dfb:	8d 83 1c 55 ff ff    	lea    -0xaae4(%ebx),%eax
c0030e01:	50                   	push   %eax
c0030e02:	8d 83 5c 2b ff ff    	lea    -0xd4a4(%ebx),%eax
c0030e08:	50                   	push   %eax
c0030e09:	68 c0 00 00 00       	push   $0xc0
c0030e0e:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c0030e14:	50                   	push   %eax
c0030e15:	e8 7b 8a ff ff       	call   c0029895 <debug_panic>
      PANIC("%s: out of space on scratch device", file_name);
c0030e1a:	83 ec 0c             	sub    $0xc,%esp
c0030e1d:	ff 74 24 18          	pushl  0x18(%esp)
c0030e21:	8d 83 40 55 ff ff    	lea    -0xaac0(%ebx),%eax
c0030e27:	50                   	push   %eax
c0030e28:	8d 83 5c 2b ff ff    	lea    -0xd4a4(%ebx),%eax
c0030e2e:	50                   	push   %eax
c0030e2f:	68 c8 00 00 00       	push   $0xc8
c0030e34:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c0030e3a:	50                   	push   %eax
c0030e3b:	e8 55 8a ff ff       	call   c0029895 <debug_panic>
      PANIC("%s: read failed with %" PROTd " bytes unread", file_name, size);
c0030e40:	83 ec 08             	sub    $0x8,%esp
c0030e43:	57                   	push   %edi
c0030e44:	ff 74 24 18          	pushl  0x18(%esp)
c0030e48:	8d 83 64 55 ff ff    	lea    -0xaa9c(%ebx),%eax
c0030e4e:	50                   	push   %eax
c0030e4f:	8d 83 5c 2b ff ff    	lea    -0xd4a4(%ebx),%eax
c0030e55:	50                   	push   %eax
c0030e56:	68 ca 00 00 00       	push   $0xca
c0030e5b:	8d 83 13 53 ff ff    	lea    -0xaced(%ebx),%eax
c0030e61:	50                   	push   %eax
c0030e62:	e8 2e 8a ff ff       	call   c0029895 <debug_panic>

c0030e67 <cache_get_free_cache>:
static struct lock lock_cache_all;

int cnt_used, current_cache;

int cache_get_free_cache()
{
c0030e67:	53                   	push   %ebx
c0030e68:	83 ec 08             	sub    $0x8,%esp
c0030e6b:	e8 76 16 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0030e70:	81 c3 cc fd 00 00    	add    $0xfdcc,%ebx
  if (cnt_used == 0)
c0030e76:	c7 c0 c0 b2 04 c0    	mov    $0xc004b2c0,%eax
c0030e7c:	8b 00                	mov    (%eax),%eax
c0030e7e:	85 c0                	test   %eax,%eax
c0030e80:	0f 84 bb 00 00 00    	je     c0030f41 <cache_get_free_cache+0xda>
  {
    current_cache = 1;
    return 0;
  }
  while (cache[current_cache].used && cache[current_cache].accessed)
c0030e86:	c7 c0 c4 b2 04 c0    	mov    $0xc004b2c4,%eax
c0030e8c:	8b 10                	mov    (%eax),%edx
c0030e8e:	69 c2 0c 02 00 00    	imul   $0x20c,%edx,%eax
c0030e94:	80 bc 03 cd 24 00 00 	cmpb   $0x0,0x24cd(%ebx,%eax,1)
c0030e9b:	00 
c0030e9c:	0f 84 f9 00 00 00    	je     c0030f9b <cache_get_free_cache+0x134>
c0030ea2:	83 bc 03 c8 24 00 00 	cmpl   $0x0,0x24c8(%ebx,%eax,1)
c0030ea9:	00 
c0030eaa:	74 47                	je     c0030ef3 <cache_get_free_cache+0x8c>
  {
    //lock_acquire (&locks_cache[current_cache]);
    cache[current_cache].accessed = 0;
c0030eac:	69 c2 0c 02 00 00    	imul   $0x20c,%edx,%eax
c0030eb2:	c7 84 03 c8 24 00 00 	movl   $0x0,0x24c8(%ebx,%eax,1)
c0030eb9:	00 00 00 00 
    //lock_release (&locks_cache[current_cache]);
    current_cache = (current_cache + 1) % CACHE_SIZE;
c0030ebd:	8d 42 01             	lea    0x1(%edx),%eax
c0030ec0:	99                   	cltd   
c0030ec1:	c1 ea 1a             	shr    $0x1a,%edx
c0030ec4:	01 d0                	add    %edx,%eax
c0030ec6:	83 e0 3f             	and    $0x3f,%eax
c0030ec9:	29 d0                	sub    %edx,%eax
c0030ecb:	89 c2                	mov    %eax,%edx
  while (cache[current_cache].used && cache[current_cache].accessed)
c0030ecd:	69 c8 0c 02 00 00    	imul   $0x20c,%eax,%ecx
c0030ed3:	80 bc 0b cd 24 00 00 	cmpb   $0x0,0x24cd(%ebx,%ecx,1)
c0030eda:	00 
c0030edb:	0f 84 b2 00 00 00    	je     c0030f93 <cache_get_free_cache+0x12c>
c0030ee1:	83 bc 0b c8 24 00 00 	cmpl   $0x0,0x24c8(%ebx,%ecx,1)
c0030ee8:	00 
c0030ee9:	75 c1                	jne    c0030eac <cache_get_free_cache+0x45>
c0030eeb:	c7 c0 c4 b2 04 c0    	mov    $0xc004b2c4,%eax
c0030ef1:	89 10                	mov    %edx,(%eax)
  }
  //lock_acquire (&locks_cache[current_cache]);
  if (cache[current_cache].used && cache[current_cache].dirty)
c0030ef3:	69 c2 0c 02 00 00    	imul   $0x20c,%edx,%eax
c0030ef9:	80 bc 03 cc 24 00 00 	cmpb   $0x0,0x24cc(%ebx,%eax,1)
c0030f00:	00 
c0030f01:	75 4c                	jne    c0030f4f <cache_get_free_cache+0xe8>
  {
    block_write(fs_device, cache[current_cache].sector_idx, cache[current_cache].buf);
  }
  if (cache[current_cache].used)
c0030f03:	c7 c0 c4 b2 04 c0    	mov    $0xc004b2c4,%eax
c0030f09:	8b 00                	mov    (%eax),%eax
  {
    cache[current_cache].used = false;
c0030f0b:	69 d0 0c 02 00 00    	imul   $0x20c,%eax,%edx
c0030f11:	c6 84 13 cd 24 00 00 	movb   $0x0,0x24cd(%ebx,%edx,1)
c0030f18:	00 
    --cnt_used;
c0030f19:	c7 c2 c0 b2 04 c0    	mov    $0xc004b2c0,%edx
c0030f1f:	83 2a 01             	subl   $0x1,(%edx)
  }
  //lock_release (&locks_cache[current_cache]);
  int ret = current_cache;
  current_cache = (current_cache + 1) % CACHE_SIZE;
c0030f22:	8d 50 01             	lea    0x1(%eax),%edx
c0030f25:	89 d1                	mov    %edx,%ecx
c0030f27:	c1 f9 1f             	sar    $0x1f,%ecx
c0030f2a:	c1 e9 1a             	shr    $0x1a,%ecx
c0030f2d:	01 ca                	add    %ecx,%edx
c0030f2f:	83 e2 3f             	and    $0x3f,%edx
c0030f32:	29 ca                	sub    %ecx,%edx
c0030f34:	c7 c1 c4 b2 04 c0    	mov    $0xc004b2c4,%ecx
c0030f3a:	89 11                	mov    %edx,(%ecx)
  return ret;
}
c0030f3c:	83 c4 08             	add    $0x8,%esp
c0030f3f:	5b                   	pop    %ebx
c0030f40:	c3                   	ret    
    current_cache = 1;
c0030f41:	c7 c2 c4 b2 04 c0    	mov    $0xc004b2c4,%edx
c0030f47:	c7 02 01 00 00 00    	movl   $0x1,(%edx)
    return 0;
c0030f4d:	eb ed                	jmp    c0030f3c <cache_get_free_cache+0xd5>
    block_write(fs_device, cache[current_cache].sector_idx, cache[current_cache].buf);
c0030f4f:	83 ec 04             	sub    $0x4,%esp
c0030f52:	69 c2 0c 02 00 00    	imul   $0x20c,%edx,%eax
c0030f58:	8d 84 03 c4 22 00 00 	lea    0x22c4(%ebx,%eax,1),%eax
c0030f5f:	50                   	push   %eax
c0030f60:	ff b0 00 02 00 00    	pushl  0x200(%eax)
c0030f66:	c7 c0 b8 b2 04 c0    	mov    $0xc004b2b8,%eax
c0030f6c:	ff 30                	pushl  (%eax)
c0030f6e:	e8 0b 49 ff ff       	call   c002587e <block_write>
  if (cache[current_cache].used)
c0030f73:	c7 c0 c4 b2 04 c0    	mov    $0xc004b2c4,%eax
c0030f79:	8b 00                	mov    (%eax),%eax
c0030f7b:	69 d0 0c 02 00 00    	imul   $0x20c,%eax,%edx
c0030f81:	83 c4 10             	add    $0x10,%esp
c0030f84:	80 bc 13 cd 24 00 00 	cmpb   $0x0,0x24cd(%ebx,%edx,1)
c0030f8b:	00 
c0030f8c:	74 94                	je     c0030f22 <cache_get_free_cache+0xbb>
c0030f8e:	e9 78 ff ff ff       	jmp    c0030f0b <cache_get_free_cache+0xa4>
c0030f93:	c7 c0 c4 b2 04 c0    	mov    $0xc004b2c4,%eax
c0030f99:	89 10                	mov    %edx,(%eax)
c0030f9b:	c7 c0 c4 b2 04 c0    	mov    $0xc004b2c4,%eax
c0030fa1:	8b 00                	mov    (%eax),%eax
c0030fa3:	e9 7a ff ff ff       	jmp    c0030f22 <cache_get_free_cache+0xbb>

c0030fa8 <cache_init>:

void cache_init()
{
c0030fa8:	57                   	push   %edi
c0030fa9:	53                   	push   %ebx
c0030faa:	83 ec 10             	sub    $0x10,%esp
c0030fad:	e8 34 15 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0030fb2:	81 c3 8a fc 00 00    	add    $0xfc8a,%ebx
  lock_init(&lock_cache_all);
c0030fb8:	8d 83 84 22 00 00    	lea    0x2284(%ebx),%eax
c0030fbe:	50                   	push   %eax
c0030fbf:	e8 3e 25 ff ff       	call   c0023502 <lock_init>
  cnt_used = 0;
c0030fc4:	c7 c0 c0 b2 04 c0    	mov    $0xc004b2c0,%eax
c0030fca:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  current_cache = -1;
c0030fd0:	c7 c0 c4 b2 04 c0    	mov    $0xc004b2c4,%eax
c0030fd6:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
c0030fdc:	8d 93 c4 22 00 00    	lea    0x22c4(%ebx),%edx
c0030fe2:	8d 9b c4 a5 00 00    	lea    0xa5c4(%ebx),%ebx
c0030fe8:	83 c4 10             	add    $0x10,%esp
  for (int i = 0; i < CACHE_SIZE; ++i)
  {
    cache[i].dirty = cache[i].used = false;
    cache[i].accessed = 0;
    memset(cache[i].buf, 0, BLOCK_SECTOR_SIZE);
c0030feb:	b8 00 00 00 00       	mov    $0x0,%eax
    cache[i].dirty = cache[i].used = false;
c0030ff0:	c6 82 09 02 00 00 00 	movb   $0x0,0x209(%edx)
c0030ff7:	c6 82 08 02 00 00 00 	movb   $0x0,0x208(%edx)
    cache[i].accessed = 0;
c0030ffe:	c7 82 04 02 00 00 00 	movl   $0x0,0x204(%edx)
c0031005:	00 00 00 
    memset(cache[i].buf, 0, BLOCK_SECTOR_SIZE);
c0031008:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
c003100e:	c7 82 fc 01 00 00 00 	movl   $0x0,0x1fc(%edx)
c0031015:	00 00 00 
c0031018:	8d 7a 04             	lea    0x4(%edx),%edi
c003101b:	83 e7 fc             	and    $0xfffffffc,%edi
c003101e:	89 d1                	mov    %edx,%ecx
c0031020:	29 f9                	sub    %edi,%ecx
c0031022:	81 c1 00 02 00 00    	add    $0x200,%ecx
c0031028:	c1 e9 02             	shr    $0x2,%ecx
c003102b:	f3 ab                	rep stos %eax,%es:(%edi)
c003102d:	81 c2 0c 02 00 00    	add    $0x20c,%edx
  for (int i = 0; i < CACHE_SIZE; ++i)
c0031033:	39 da                	cmp    %ebx,%edx
c0031035:	75 b9                	jne    c0030ff0 <cache_init+0x48>
    //lock_init (&locks_cache[i]);
  }
}
c0031037:	83 c4 04             	add    $0x4,%esp
c003103a:	5b                   	pop    %ebx
c003103b:	5f                   	pop    %edi
c003103c:	c3                   	ret    

c003103d <cache_finish>:

void cache_finish()
{
c003103d:	55                   	push   %ebp
c003103e:	57                   	push   %edi
c003103f:	56                   	push   %esi
c0031040:	53                   	push   %ebx
c0031041:	83 ec 28             	sub    $0x28,%esp
c0031044:	e8 9d 14 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031049:	81 c3 f3 fb 00 00    	add    $0xfbf3,%ebx
  lock_acquire(&lock_cache_all);
c003104f:	8d 83 84 22 00 00    	lea    0x2284(%ebx),%eax
c0031055:	50                   	push   %eax
c0031056:	e8 67 25 ff ff       	call   c00235c2 <lock_acquire>
c003105b:	8d b3 c4 24 00 00    	lea    0x24c4(%ebx),%esi
c0031061:	8d ab c4 a7 00 00    	lea    0xa7c4(%ebx),%ebp
c0031067:	83 c4 10             	add    $0x10,%esp
  for (int i = 0; i < CACHE_SIZE; ++i)
    if (cache[i].used && cache[i].dirty)
    {
      //lock_acquire (&locks_cache[i]);
      block_write(fs_device, cache[i].sector_idx, cache[i].buf);
c003106a:	c7 c0 b8 b2 04 c0    	mov    $0xc004b2b8,%eax
c0031070:	89 44 24 08          	mov    %eax,0x8(%esp)
      cache[i].used = false;
      //lock_release (&locks_cache[i]);
      --cnt_used;
c0031074:	c7 c0 c0 b2 04 c0    	mov    $0xc004b2c0,%eax
c003107a:	89 44 24 0c          	mov    %eax,0xc(%esp)
c003107e:	eb 0a                	jmp    c003108a <cache_finish+0x4d>
c0031080:	81 c6 0c 02 00 00    	add    $0x20c,%esi
  for (int i = 0; i < CACHE_SIZE; ++i)
c0031086:	39 ee                	cmp    %ebp,%esi
c0031088:	74 33                	je     c00310bd <cache_finish+0x80>
    if (cache[i].used && cache[i].dirty)
c003108a:	80 7e 09 00          	cmpb   $0x0,0x9(%esi)
c003108e:	74 f0                	je     c0031080 <cache_finish+0x43>
c0031090:	80 7e 08 00          	cmpb   $0x0,0x8(%esi)
c0031094:	74 ea                	je     c0031080 <cache_finish+0x43>
      block_write(fs_device, cache[i].sector_idx, cache[i].buf);
c0031096:	83 ec 04             	sub    $0x4,%esp
c0031099:	8d 86 00 fe ff ff    	lea    -0x200(%esi),%eax
c003109f:	50                   	push   %eax
c00310a0:	ff 36                	pushl  (%esi)
c00310a2:	8b 44 24 14          	mov    0x14(%esp),%eax
c00310a6:	ff 30                	pushl  (%eax)
c00310a8:	e8 d1 47 ff ff       	call   c002587e <block_write>
      cache[i].used = false;
c00310ad:	c6 46 09 00          	movb   $0x0,0x9(%esi)
      --cnt_used;
c00310b1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c00310b5:	83 28 01             	subl   $0x1,(%eax)
c00310b8:	83 c4 10             	add    $0x10,%esp
c00310bb:	eb c3                	jmp    c0031080 <cache_finish+0x43>
    }
  lock_release(&lock_cache_all);
c00310bd:	83 ec 0c             	sub    $0xc,%esp
c00310c0:	8d 83 84 22 00 00    	lea    0x2284(%ebx),%eax
c00310c6:	50                   	push   %eax
c00310c7:	e8 ca 26 ff ff       	call   c0023796 <lock_release>
}
c00310cc:	83 c4 2c             	add    $0x2c,%esp
c00310cf:	5b                   	pop    %ebx
c00310d0:	5e                   	pop    %esi
c00310d1:	5f                   	pop    %edi
c00310d2:	5d                   	pop    %ebp
c00310d3:	c3                   	ret    

c00310d4 <cache_read>:


void cache_read(block_sector_t sector, void *buffer)
{
c00310d4:	55                   	push   %ebp
c00310d5:	57                   	push   %edi
c00310d6:	56                   	push   %esi
c00310d7:	53                   	push   %ebx
c00310d8:	83 ec 18             	sub    $0x18,%esp
c00310db:	e8 06 14 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00310e0:	81 c3 5c fb 00 00    	add    $0xfb5c,%ebx
c00310e6:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c00310ea:	8b 6c 24 30          	mov    0x30(%esp),%ebp
  lock_acquire(&lock_cache_all);
c00310ee:	8d 83 84 22 00 00    	lea    0x2284(%ebx),%eax
c00310f4:	50                   	push   %eax
c00310f5:	e8 c8 24 ff ff       	call   c00235c2 <lock_acquire>
c00310fa:	8d 83 c4 24 00 00    	lea    0x24c4(%ebx),%eax
c0031100:	83 c4 10             	add    $0x10,%esp
  bool found = false;
  for (int i = 0; i < CACHE_SIZE; ++i)
c0031103:	ba 00 00 00 00       	mov    $0x0,%edx
c0031108:	eb 0d                	jmp    c0031117 <cache_read+0x43>
c003110a:	83 c2 01             	add    $0x1,%edx
c003110d:	05 0c 02 00 00       	add    $0x20c,%eax
c0031112:	83 fa 40             	cmp    $0x40,%edx
c0031115:	74 5f                	je     c0031176 <cache_read+0xa2>
    if (cache[i].used && cache[i].sector_idx == sector)
c0031117:	80 78 09 00          	cmpb   $0x0,0x9(%eax)
c003111b:	74 ed                	je     c003110a <cache_read+0x36>
c003111d:	39 38                	cmp    %edi,(%eax)
c003111f:	75 e9                	jne    c003110a <cache_read+0x36>
    {
      //lock_acquire (&locks_cache[i]);
      memcpy(buffer, cache[i].buf, BLOCK_SECTOR_SIZE);
c0031121:	69 d2 0c 02 00 00    	imul   $0x20c,%edx,%edx
c0031127:	8d b4 13 c4 22 00 00 	lea    0x22c4(%ebx,%edx,1),%esi
c003112e:	8b 06                	mov    (%esi),%eax
c0031130:	89 45 00             	mov    %eax,0x0(%ebp)
c0031133:	8b 86 fc 01 00 00    	mov    0x1fc(%esi),%eax
c0031139:	89 85 fc 01 00 00    	mov    %eax,0x1fc(%ebp)
c003113f:	8d 7d 04             	lea    0x4(%ebp),%edi
c0031142:	83 e7 fc             	and    $0xfffffffc,%edi
c0031145:	29 fd                	sub    %edi,%ebp
c0031147:	29 ee                	sub    %ebp,%esi
c0031149:	8d 8d 00 02 00 00    	lea    0x200(%ebp),%ecx
c003114f:	c1 e9 02             	shr    $0x2,%ecx
c0031152:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
      ++cache[i].accessed;
c0031154:	83 84 13 c8 24 00 00 	addl   $0x1,0x24c8(%ebx,%edx,1)
c003115b:	01 
      //lock_release (&locks_cache[i]);
      found = true;
      lock_release(&lock_cache_all);
c003115c:	83 ec 0c             	sub    $0xc,%esp
c003115f:	8d 83 84 22 00 00    	lea    0x2284(%ebx),%eax
c0031165:	50                   	push   %eax
c0031166:	e8 2b 26 ff ff       	call   c0023796 <lock_release>
c003116b:	83 c4 10             	add    $0x10,%esp
  cache[index].accessed = 1;
  block_read(fs_device, sector, cache[index].buf);
  memcpy(buffer, cache[index].buf, BLOCK_SECTOR_SIZE);
  //lock_release (&locks_cache[index]);
  lock_release(&lock_cache_all);
}
c003116e:	83 c4 0c             	add    $0xc,%esp
c0031171:	5b                   	pop    %ebx
c0031172:	5e                   	pop    %esi
c0031173:	5f                   	pop    %edi
c0031174:	5d                   	pop    %ebp
c0031175:	c3                   	ret    
  int index = cache_get_free_cache();
c0031176:	e8 ec fc ff ff       	call   c0030e67 <cache_get_free_cache>
  ++cnt_used;
c003117b:	c7 c2 c0 b2 04 c0    	mov    $0xc004b2c0,%edx
c0031181:	83 02 01             	addl   $0x1,(%edx)
  cache[index].sector_idx = sector;
c0031184:	69 c0 0c 02 00 00    	imul   $0x20c,%eax,%eax
c003118a:	8d b4 03 c4 22 00 00 	lea    0x22c4(%ebx,%eax,1),%esi
c0031191:	89 be 00 02 00 00    	mov    %edi,0x200(%esi)
  cache[index].dirty = false;
c0031197:	c6 86 08 02 00 00 00 	movb   $0x0,0x208(%esi)
  cache[index].used = true;
c003119e:	c6 86 09 02 00 00 01 	movb   $0x1,0x209(%esi)
  cache[index].accessed = 1;
c00311a5:	c7 86 04 02 00 00 01 	movl   $0x1,0x204(%esi)
c00311ac:	00 00 00 
  block_read(fs_device, sector, cache[index].buf);
c00311af:	83 ec 04             	sub    $0x4,%esp
c00311b2:	56                   	push   %esi
c00311b3:	57                   	push   %edi
c00311b4:	c7 c0 b8 b2 04 c0    	mov    $0xc004b2b8,%eax
c00311ba:	ff 30                	pushl  (%eax)
c00311bc:	e8 89 46 ff ff       	call   c002584a <block_read>
  memcpy(buffer, cache[index].buf, BLOCK_SECTOR_SIZE);
c00311c1:	8b 06                	mov    (%esi),%eax
c00311c3:	89 45 00             	mov    %eax,0x0(%ebp)
c00311c6:	8b 86 fc 01 00 00    	mov    0x1fc(%esi),%eax
c00311cc:	89 85 fc 01 00 00    	mov    %eax,0x1fc(%ebp)
c00311d2:	8d 7d 04             	lea    0x4(%ebp),%edi
c00311d5:	83 e7 fc             	and    $0xfffffffc,%edi
c00311d8:	29 fd                	sub    %edi,%ebp
c00311da:	29 ee                	sub    %ebp,%esi
c00311dc:	8d 8d 00 02 00 00    	lea    0x200(%ebp),%ecx
c00311e2:	c1 e9 02             	shr    $0x2,%ecx
c00311e5:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lock_release(&lock_cache_all);
c00311e7:	8d 83 84 22 00 00    	lea    0x2284(%ebx),%eax
c00311ed:	89 04 24             	mov    %eax,(%esp)
c00311f0:	e8 a1 25 ff ff       	call   c0023796 <lock_release>
c00311f5:	83 c4 10             	add    $0x10,%esp
c00311f8:	e9 71 ff ff ff       	jmp    c003116e <cache_read+0x9a>

c00311fd <cache_write>:

void cache_write(block_sector_t sector, const void *buffer)
{
c00311fd:	57                   	push   %edi
c00311fe:	56                   	push   %esi
c00311ff:	53                   	push   %ebx
c0031200:	e8 e1 12 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031205:	81 c3 37 fa 00 00    	add    $0xfa37,%ebx
c003120b:	8b 74 24 10          	mov    0x10(%esp),%esi
  lock_acquire(&lock_cache_all);
c003120f:	83 ec 0c             	sub    $0xc,%esp
c0031212:	8d 83 84 22 00 00    	lea    0x2284(%ebx),%eax
c0031218:	50                   	push   %eax
c0031219:	e8 a4 23 ff ff       	call   c00235c2 <lock_acquire>
c003121e:	8d 83 c4 24 00 00    	lea    0x24c4(%ebx),%eax
c0031224:	83 c4 10             	add    $0x10,%esp
  bool found = false;
  for (int i = 0; i < CACHE_SIZE; ++i)
c0031227:	ba 00 00 00 00       	mov    $0x0,%edx
c003122c:	eb 0d                	jmp    c003123b <cache_write+0x3e>
c003122e:	83 c2 01             	add    $0x1,%edx
c0031231:	05 0c 02 00 00       	add    $0x20c,%eax
c0031236:	83 fa 40             	cmp    $0x40,%edx
c0031239:	74 48                	je     c0031283 <cache_write+0x86>
    if (cache[i].used && cache[i].sector_idx == sector)
c003123b:	80 78 09 00          	cmpb   $0x0,0x9(%eax)
c003123f:	74 ed                	je     c003122e <cache_write+0x31>
c0031241:	39 30                	cmp    %esi,(%eax)
c0031243:	75 e9                	jne    c003122e <cache_write+0x31>
    {
      //lock_acquire (&locks_cache[i]);
      memcpy(cache[i].buf, buffer, BLOCK_SECTOR_SIZE);
c0031245:	69 d2 0c 02 00 00    	imul   $0x20c,%edx,%edx
c003124b:	8d 84 13 c4 22 00 00 	lea    0x22c4(%ebx,%edx,1),%eax
c0031252:	b9 80 00 00 00       	mov    $0x80,%ecx
c0031257:	89 c7                	mov    %eax,%edi
c0031259:	8b 74 24 14          	mov    0x14(%esp),%esi
c003125d:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
      cache[i].dirty = true;
c003125f:	c6 80 08 02 00 00 01 	movb   $0x1,0x208(%eax)
      ++cache[i].accessed;
c0031266:	83 80 04 02 00 00 01 	addl   $0x1,0x204(%eax)
      //lock_release (&locks_cache[i]);
      found = true;
      lock_release(&lock_cache_all);
c003126d:	83 ec 0c             	sub    $0xc,%esp
c0031270:	8d 83 84 22 00 00    	lea    0x2284(%ebx),%eax
c0031276:	50                   	push   %eax
c0031277:	e8 1a 25 ff ff       	call   c0023796 <lock_release>
c003127c:	83 c4 10             	add    $0x10,%esp
  cache[index].used = true;
  cache[index].accessed = 1;
  memcpy(cache[index].buf, buffer, BLOCK_SECTOR_SIZE);
  //lock_release (&locks_cache[index]);
  lock_release(&lock_cache_all);
}
c003127f:	5b                   	pop    %ebx
c0031280:	5e                   	pop    %esi
c0031281:	5f                   	pop    %edi
c0031282:	c3                   	ret    
  int index = cache_get_free_cache();
c0031283:	e8 df fb ff ff       	call   c0030e67 <cache_get_free_cache>
  ++cnt_used;
c0031288:	c7 c2 c0 b2 04 c0    	mov    $0xc004b2c0,%edx
c003128e:	83 02 01             	addl   $0x1,(%edx)
  cache[index].sector_idx = sector;
c0031291:	69 d0 0c 02 00 00    	imul   $0x20c,%eax,%edx
c0031297:	8d 84 13 c4 22 00 00 	lea    0x22c4(%ebx,%edx,1),%eax
c003129e:	89 b0 00 02 00 00    	mov    %esi,0x200(%eax)
  cache[index].dirty = true;
c00312a4:	c6 80 08 02 00 00 01 	movb   $0x1,0x208(%eax)
  cache[index].used = true;
c00312ab:	c6 80 09 02 00 00 01 	movb   $0x1,0x209(%eax)
  cache[index].accessed = 1;
c00312b2:	c7 80 04 02 00 00 01 	movl   $0x1,0x204(%eax)
c00312b9:	00 00 00 
  memcpy(cache[index].buf, buffer, BLOCK_SECTOR_SIZE);
c00312bc:	b9 80 00 00 00       	mov    $0x80,%ecx
c00312c1:	89 c7                	mov    %eax,%edi
c00312c3:	8b 74 24 14          	mov    0x14(%esp),%esi
c00312c7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  lock_release(&lock_cache_all);
c00312c9:	83 ec 0c             	sub    $0xc,%esp
c00312cc:	8d 83 84 22 00 00    	lea    0x2284(%ebx),%eax
c00312d2:	50                   	push   %eax
c00312d3:	e8 be 24 ff ff       	call   c0023796 <lock_release>
c00312d8:	83 c4 10             	add    $0x10,%esp
c00312db:	eb a2                	jmp    c003127f <cache_write+0x82>

c00312dd <frame_hash_less>:
}

bool frame_hash_less(const struct hash_elem* a, const struct hash_elem* b, void* aux UNUSED){
    const struct frame_table_entry * ta = hash_entry(a, struct frame_table_entry, hash_elem);
    const struct frame_table_entry * tb = hash_entry(b, struct frame_table_entry, hash_elem);
    return ta->frame < tb->frame;
c00312dd:	8b 54 24 04          	mov    0x4(%esp),%edx
c00312e1:	8b 44 24 08          	mov    0x8(%esp),%eax
c00312e5:	8b 40 f0             	mov    -0x10(%eax),%eax
c00312e8:	39 42 f0             	cmp    %eax,-0x10(%edx)
c00312eb:	0f 92 c0             	setb   %al
}
c00312ee:	c3                   	ret    

c00312ef <frame_hash>:

unsigned frame_hash(const struct hash_elem* e, void* aux UNUSED){
c00312ef:	53                   	push   %ebx
c00312f0:	83 ec 10             	sub    $0x10,%esp
c00312f3:	e8 ee 11 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00312f8:	81 c3 44 f9 00 00    	add    $0xf944,%ebx
    struct frame_table_entry* t = hash_entry(e, struct frame_table_entry, hash_elem);
    return hash_bytes(&t->frame, sizeof(t->frame));
c00312fe:	6a 04                	push   $0x4
c0031300:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0031304:	83 e8 10             	sub    $0x10,%eax
c0031307:	50                   	push   %eax
c0031308:	e8 8b a2 ff ff       	call   c002b598 <hash_bytes>
}
c003130d:	83 c4 18             	add    $0x18,%esp
c0031310:	5b                   	pop    %ebx
c0031311:	c3                   	ret    

c0031312 <frame_init>:
void frame_init(){
c0031312:	53                   	push   %ebx
c0031313:	83 ec 08             	sub    $0x8,%esp
c0031316:	e8 cb 11 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c003131b:	81 c3 21 f9 00 00    	add    $0xf921,%ebx
    hash_init(&frame_table, frame_hash, frame_hash_less, NULL);
c0031321:	6a 00                	push   $0x0
c0031323:	8d 83 a1 06 ff ff    	lea    -0xf95f(%ebx),%eax
c0031329:	50                   	push   %eax
c003132a:	8d 83 b3 06 ff ff    	lea    -0xf94d(%ebx),%eax
c0031330:	50                   	push   %eax
c0031331:	8d 83 18 a6 00 00    	lea    0xa618(%ebx),%eax
c0031337:	50                   	push   %eax
c0031338:	e8 90 9e ff ff       	call   c002b1cd <hash_init>
    list_init(&frame_clock_list);
c003133d:	8d 83 c4 a5 00 00    	lea    0xa5c4(%ebx),%eax
c0031343:	89 04 24             	mov    %eax,(%esp)
c0031346:	e8 17 86 ff ff       	call   c0029962 <list_init>
    lock_init(&frame_lock);
c003134b:	8d 83 e4 a5 00 00    	lea    0xa5e4(%ebx),%eax
c0031351:	89 04 24             	mov    %eax,(%esp)
c0031354:	e8 a9 21 ff ff       	call   c0023502 <lock_init>
    cur_fte = NULL;
c0031359:	c7 c0 c8 b2 04 c0    	mov    $0xc004b2c8,%eax
c003135f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c0031365:	83 c4 18             	add    $0x18,%esp
c0031368:	5b                   	pop    %ebx
c0031369:	c3                   	ret    

c003136a <frame_find_entry>:
void* frame_find_entry(void* frame){
c003136a:	53                   	push   %ebx
c003136b:	83 ec 30             	sub    $0x30,%esp
c003136e:	e8 73 11 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031373:	81 c3 c9 f8 00 00    	add    $0xf8c9,%ebx
    tmp.frame = frame;
c0031379:	8b 44 24 38          	mov    0x38(%esp),%eax
c003137d:	89 44 24 08          	mov    %eax,0x8(%esp)
    struct hash_elem*  he = hash_find(&frame_table, &tmp.hash_elem);
c0031381:	8d 44 24 18          	lea    0x18(%esp),%eax
c0031385:	50                   	push   %eax
c0031386:	8d 83 18 a6 00 00    	lea    0xa618(%ebx),%eax
c003138c:	50                   	push   %eax
c003138d:	e8 9e 9f ff ff       	call   c002b330 <hash_find>
    return he == NULL? NULL : hash_entry(he, struct frame_table_entry, hash_elem);
c0031392:	8d 50 f0             	lea    -0x10(%eax),%edx
c0031395:	85 c0                	test   %eax,%eax
c0031397:	b8 00 00 00 00       	mov    $0x0,%eax
c003139c:	0f 45 c2             	cmovne %edx,%eax
}
c003139f:	83 c4 38             	add    $0x38,%esp
c00313a2:	5b                   	pop    %ebx
c00313a3:	c3                   	ret    

c00313a4 <frame_reset>:
bool frame_reset(void* frame){
c00313a4:	55                   	push   %ebp
c00313a5:	57                   	push   %edi
c00313a6:	56                   	push   %esi
c00313a7:	53                   	push   %ebx
c00313a8:	83 ec 18             	sub    $0x18,%esp
c00313ab:	e8 36 11 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00313b0:	81 c3 8c f8 00 00    	add    $0xf88c,%ebx
    lock_acquire(&frame_lock);
c00313b6:	8d 83 e4 a5 00 00    	lea    0xa5e4(%ebx),%eax
c00313bc:	50                   	push   %eax
c00313bd:	e8 00 22 ff ff       	call   c00235c2 <lock_acquire>
    struct frame_table_entry* fte = frame_find_entry(frame);
c00313c2:	83 c4 04             	add    $0x4,%esp
c00313c5:	ff 74 24 2c          	pushl  0x2c(%esp)
c00313c9:	e8 9c ff ff ff       	call   c003136a <frame_find_entry>
    if (fte == NULL){
c00313ce:	83 c4 10             	add    $0x10,%esp
c00313d1:	85 c0                	test   %eax,%eax
c00313d3:	74 4f                	je     c0031424 <frame_reset+0x80>
c00313d5:	89 c6                	mov    %eax,%esi
    if (fte->pinned == false){
c00313d7:	0f b6 78 0c          	movzbl 0xc(%eax),%edi
c00313db:	89 f8                	mov    %edi,%eax
c00313dd:	84 c0                	test   %al,%al
c00313df:	74 5c                	je     c003143d <frame_reset+0x99>
    fte->pinned = false;
c00313e1:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
    list_push_back(&frame_clock_list, &fte->list_elem);
c00313e5:	83 ec 08             	sub    $0x8,%esp
c00313e8:	8d 46 18             	lea    0x18(%esi),%eax
c00313eb:	50                   	push   %eax
c00313ec:	8d ab c4 a5 00 00    	lea    0xa5c4(%ebx),%ebp
c00313f2:	55                   	push   %ebp
c00313f3:	e8 50 8b ff ff       	call   c0029f48 <list_push_back>
    if (list_size(&frame_clock_list) == 1)
c00313f8:	89 2c 24             	mov    %ebp,(%esp)
c00313fb:	e8 c4 8b ff ff       	call   c0029fc4 <list_size>
c0031400:	83 c4 10             	add    $0x10,%esp
c0031403:	83 f8 01             	cmp    $0x1,%eax
c0031406:	74 4e                	je     c0031456 <frame_reset+0xb2>
    lock_release(&frame_lock);
c0031408:	83 ec 0c             	sub    $0xc,%esp
c003140b:	8d 83 e4 a5 00 00    	lea    0xa5e4(%ebx),%eax
c0031411:	50                   	push   %eax
c0031412:	e8 7f 23 ff ff       	call   c0023796 <lock_release>
    return true;
c0031417:	83 c4 10             	add    $0x10,%esp
}
c003141a:	89 f8                	mov    %edi,%eax
c003141c:	83 c4 0c             	add    $0xc,%esp
c003141f:	5b                   	pop    %ebx
c0031420:	5e                   	pop    %esi
c0031421:	5f                   	pop    %edi
c0031422:	5d                   	pop    %ebp
c0031423:	c3                   	ret    
        lock_release(&frame_lock);
c0031424:	83 ec 0c             	sub    $0xc,%esp
c0031427:	8d 83 e4 a5 00 00    	lea    0xa5e4(%ebx),%eax
c003142d:	50                   	push   %eax
c003142e:	e8 63 23 ff ff       	call   c0023796 <lock_release>
        return false;
c0031433:	83 c4 10             	add    $0x10,%esp
c0031436:	bf 00 00 00 00       	mov    $0x0,%edi
c003143b:	eb dd                	jmp    c003141a <frame_reset+0x76>
        lock_release(&frame_lock);
c003143d:	83 ec 0c             	sub    $0xc,%esp
c0031440:	8d 83 e4 a5 00 00    	lea    0xa5e4(%ebx),%eax
c0031446:	50                   	push   %eax
c0031447:	e8 4a 23 ff ff       	call   c0023796 <lock_release>
        return true;
c003144c:	83 c4 10             	add    $0x10,%esp
c003144f:	bf 01 00 00 00       	mov    $0x1,%edi
c0031454:	eb c4                	jmp    c003141a <frame_reset+0x76>
        cur_fte = fte;
c0031456:	c7 c0 c8 b2 04 c0    	mov    $0xc004b2c8,%eax
c003145c:	89 30                	mov    %esi,(%eax)
c003145e:	eb a8                	jmp    c0031408 <frame_reset+0x64>

c0031460 <frame_clock_next>:
void frame_clock_next(){
c0031460:	56                   	push   %esi
c0031461:	53                   	push   %ebx
c0031462:	83 ec 04             	sub    $0x4,%esp
c0031465:	e8 7c 10 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c003146a:	81 c3 d2 f7 00 00    	add    $0xf7d2,%ebx
    ASSERT(cur_fte != NULL);
c0031470:	c7 c0 c8 b2 04 c0    	mov    $0xc004b2c8,%eax
c0031476:	83 38 00             	cmpl   $0x0,(%eax)
c0031479:	74 5a                	je     c00314d5 <frame_clock_next+0x75>
    if (list_size(&frame_clock_list) == 1)
c003147b:	83 ec 0c             	sub    $0xc,%esp
c003147e:	8d 83 c4 a5 00 00    	lea    0xa5c4(%ebx),%eax
c0031484:	50                   	push   %eax
c0031485:	e8 3a 8b ff ff       	call   c0029fc4 <list_size>
c003148a:	83 c4 10             	add    $0x10,%esp
c003148d:	83 f8 01             	cmp    $0x1,%eax
c0031490:	74 3d                	je     c00314cf <frame_clock_next+0x6f>
    if (&cur_fte->list_elem == list_back(&frame_clock_list))
c0031492:	c7 c0 c8 b2 04 c0    	mov    $0xc004b2c8,%eax
c0031498:	8b 30                	mov    (%eax),%esi
c003149a:	83 c6 18             	add    $0x18,%esi
c003149d:	83 ec 0c             	sub    $0xc,%esp
c00314a0:	8d 83 c4 a5 00 00    	lea    0xa5c4(%ebx),%eax
c00314a6:	50                   	push   %eax
c00314a7:	e8 f0 8b ff ff       	call   c002a09c <list_back>
c00314ac:	83 c4 10             	add    $0x10,%esp
c00314af:	39 c6                	cmp    %eax,%esi
c00314b1:	74 4b                	je     c00314fe <frame_clock_next+0x9e>
    cur_fte = list_entry(list_next(&cur_fte->list_elem),
c00314b3:	83 ec 0c             	sub    $0xc,%esp
c00314b6:	c7 c6 c8 b2 04 c0    	mov    $0xc004b2c8,%esi
c00314bc:	8b 06                	mov    (%esi),%eax
c00314be:	83 c0 18             	add    $0x18,%eax
c00314c1:	50                   	push   %eax
c00314c2:	e8 38 85 ff ff       	call   c00299ff <list_next>
c00314c7:	83 e8 18             	sub    $0x18,%eax
c00314ca:	89 06                	mov    %eax,(%esi)
c00314cc:	83 c4 10             	add    $0x10,%esp
}
c00314cf:	83 c4 04             	add    $0x4,%esp
c00314d2:	5b                   	pop    %ebx
c00314d3:	5e                   	pop    %esi
c00314d4:	c3                   	ret    
    ASSERT(cur_fte != NULL);
c00314d5:	83 ec 0c             	sub    $0xc,%esp
c00314d8:	8d 83 89 55 ff ff    	lea    -0xaa77(%ebx),%eax
c00314de:	50                   	push   %eax
c00314df:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00314e5:	50                   	push   %eax
c00314e6:	8d 83 a0 2b ff ff    	lea    -0xd460(%ebx),%eax
c00314ec:	50                   	push   %eax
c00314ed:	68 9a 00 00 00       	push   $0x9a
c00314f2:	8d 83 99 55 ff ff    	lea    -0xaa67(%ebx),%eax
c00314f8:	50                   	push   %eax
c00314f9:	e8 97 83 ff ff       	call   c0029895 <debug_panic>
        cur_fte = list_entry(list_head(&frame_clock_list),
c00314fe:	83 ec 0c             	sub    $0xc,%esp
c0031501:	8d 83 c4 a5 00 00    	lea    0xa5c4(%ebx),%eax
c0031507:	50                   	push   %eax
c0031508:	e8 f4 87 ff ff       	call   c0029d01 <list_head>
c003150d:	83 e8 18             	sub    $0x18,%eax
c0031510:	c7 c2 c8 b2 04 c0    	mov    $0xc004b2c8,%edx
c0031516:	89 02                	mov    %eax,(%edx)
c0031518:	83 c4 10             	add    $0x10,%esp
c003151b:	eb 96                	jmp    c00314b3 <frame_clock_next+0x53>

c003151d <frame_replace>:
void* frame_replace(void* va){
c003151d:	55                   	push   %ebp
c003151e:	57                   	push   %edi
c003151f:	56                   	push   %esi
c0031520:	53                   	push   %ebx
c0031521:	83 ec 0c             	sub    $0xc,%esp
c0031524:	e8 bd 0f 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031529:	81 c3 13 f7 00 00    	add    $0xf713,%ebx
    ASSERT(cur_fte != NULL);
c003152f:	c7 c0 c8 b2 04 c0    	mov    $0xc004b2c8,%eax
c0031535:	83 38 00             	cmpl   $0x0,(%eax)
c0031538:	74 66                	je     c00315a0 <frame_replace+0x83>
    while(pagedir_is_accessed(cur_fte->t->pagedir, cur_fte->va)){
c003153a:	89 c7                	mov    %eax,%edi
        pagedir_set_accessed(cur_fte->t->pagedir, cur_fte->va, false);
c003153c:	89 c6                	mov    %eax,%esi
    while(pagedir_is_accessed(cur_fte->t->pagedir, cur_fte->va)){
c003153e:	8b 07                	mov    (%edi),%eax
c0031540:	83 ec 08             	sub    $0x8,%esp
c0031543:	ff 70 04             	pushl  0x4(%eax)
c0031546:	8b 40 08             	mov    0x8(%eax),%eax
c0031549:	ff 70 30             	pushl  0x30(%eax)
c003154c:	e8 f0 b2 ff ff       	call   c002c841 <pagedir_is_accessed>
c0031551:	83 c4 10             	add    $0x10,%esp
c0031554:	84 c0                	test   %al,%al
c0031556:	74 6e                	je     c00315c6 <frame_replace+0xa9>
        pagedir_set_accessed(cur_fte->t->pagedir, cur_fte->va, false);
c0031558:	8b 06                	mov    (%esi),%eax
c003155a:	83 ec 04             	sub    $0x4,%esp
c003155d:	6a 00                	push   $0x0
c003155f:	ff 70 04             	pushl  0x4(%eax)
c0031562:	8b 40 08             	mov    0x8(%eax),%eax
c0031565:	ff 70 30             	pushl  0x30(%eax)
c0031568:	e8 96 b4 ff ff       	call   c002ca03 <pagedir_set_accessed>
        frame_clock_next();
c003156d:	e8 ee fe ff ff       	call   c0031460 <frame_clock_next>
        ASSERT( cur_fte != NULL );
c0031572:	83 c4 10             	add    $0x10,%esp
c0031575:	83 3e 00             	cmpl   $0x0,(%esi)
c0031578:	75 c4                	jne    c003153e <frame_replace+0x21>
c003157a:	83 ec 0c             	sub    $0xc,%esp
c003157d:	8d 83 89 55 ff ff    	lea    -0xaa77(%ebx),%eax
c0031583:	50                   	push   %eax
c0031584:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c003158a:	50                   	push   %eax
c003158b:	8d 83 c0 2b ff ff    	lea    -0xd440(%ebx),%eax
c0031591:	50                   	push   %eax
c0031592:	6a 50                	push   $0x50
c0031594:	8d 83 99 55 ff ff    	lea    -0xaa67(%ebx),%eax
c003159a:	50                   	push   %eax
c003159b:	e8 f5 82 ff ff       	call   c0029895 <debug_panic>
    ASSERT(cur_fte != NULL);
c00315a0:	83 ec 0c             	sub    $0xc,%esp
c00315a3:	8d 83 89 55 ff ff    	lea    -0xaa77(%ebx),%eax
c00315a9:	50                   	push   %eax
c00315aa:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00315b0:	50                   	push   %eax
c00315b1:	8d 83 c0 2b ff ff    	lea    -0xd440(%ebx),%eax
c00315b7:	50                   	push   %eax
c00315b8:	6a 4c                	push   $0x4c
c00315ba:	8d 83 99 55 ff ff    	lea    -0xaa67(%ebx),%eax
c00315c0:	50                   	push   %eax
c00315c1:	e8 cf 82 ff ff       	call   c0029895 <debug_panic>
    struct frame_table_entry* fte = cur_fte;
c00315c6:	c7 c0 c8 b2 04 c0    	mov    $0xc004b2c8,%eax
c00315cc:	8b 30                	mov    (%eax),%esi
    void* tmp_frame = fte->frame;
c00315ce:	8b 3e                	mov    (%esi),%edi
    ASSERT(page_find_entry(cur_fte->t->page_table, cur_fte->va) != NULL);
c00315d0:	83 ec 08             	sub    $0x8,%esp
c00315d3:	ff 76 04             	pushl  0x4(%esi)
c00315d6:	8b 46 08             	mov    0x8(%esi),%eax
c00315d9:	ff b0 b8 00 00 00    	pushl  0xb8(%eax)
c00315df:	e8 79 07 00 00       	call   c0031d5d <page_find_entry>
c00315e4:	83 c4 10             	add    $0x10,%esp
c00315e7:	85 c0                	test   %eax,%eax
c00315e9:	0f 84 c8 00 00 00    	je     c00316b7 <frame_replace+0x19a>
    struct page_table_entry *pte = page_find_entry(cur_fte->t->page_table, cur_fte->va);
c00315ef:	c7 c0 c8 b2 04 c0    	mov    $0xc004b2c8,%eax
c00315f5:	8b 00                	mov    (%eax),%eax
c00315f7:	83 ec 08             	sub    $0x8,%esp
c00315fa:	ff 70 04             	pushl  0x4(%eax)
c00315fd:	8b 40 08             	mov    0x8(%eax),%eax
c0031600:	ff b0 b8 00 00 00    	pushl  0xb8(%eax)
c0031606:	e8 52 07 00 00       	call   c0031d5d <page_find_entry>
    if (pte == NULL || pte->fa == NULL || ((struct mmap_handler *)(pte->fa))->is_static){
c003160b:	83 c4 10             	add    $0x10,%esp
c003160e:	85 c0                	test   %eax,%eax
c0031610:	74 11                	je     c0031623 <frame_replace+0x106>
c0031612:	8b 40 0c             	mov    0xc(%eax),%eax
c0031615:	85 c0                	test   %eax,%eax
c0031617:	74 0a                	je     c0031623 <frame_replace+0x106>
c0031619:	80 78 21 00          	cmpb   $0x0,0x21(%eax)
c003161d:	0f 84 e0 00 00 00    	je     c0031703 <frame_replace+0x1e6>
        sa = swap_store(cur_fte->frame);
c0031623:	83 ec 0c             	sub    $0xc,%esp
c0031626:	c7 c0 c8 b2 04 c0    	mov    $0xc004b2c8,%eax
c003162c:	8b 00                	mov    (%eax),%eax
c003162e:	ff 30                	pushl  (%eax)
c0031630:	e8 06 06 00 00       	call   c0031c3b <swap_store>
        if (sa == -1)
c0031635:	83 c4 10             	add    $0x10,%esp
c0031638:	83 f8 ff             	cmp    $0xffffffff,%eax
c003163b:	0f 84 25 01 00 00    	je     c0031766 <frame_replace+0x249>
        ASSERT(page_eviction(cur_fte->t, cur_fte->va, sa, true));
c0031641:	c7 c2 c8 b2 04 c0    	mov    $0xc004b2c8,%edx
c0031647:	8b 12                	mov    (%edx),%edx
c0031649:	6a 01                	push   $0x1
c003164b:	50                   	push   %eax
c003164c:	ff 72 04             	pushl  0x4(%edx)
c003164f:	ff 72 08             	pushl  0x8(%edx)
c0031652:	e8 a9 0d 00 00       	call   c0032400 <page_eviction>
c0031657:	83 c4 10             	add    $0x10,%esp
c003165a:	84 c0                	test   %al,%al
c003165c:	74 7f                	je     c00316dd <frame_replace+0x1c0>
    list_remove(&fte->list_elem);
c003165e:	83 ec 0c             	sub    $0xc,%esp
c0031661:	8d 46 18             	lea    0x18(%esi),%eax
c0031664:	50                   	push   %eax
c0031665:	e8 fb 88 ff ff       	call   c0029f65 <list_remove>
    if (list_empty(&frame_clock_list))
c003166a:	8d 83 c4 a5 00 00    	lea    0xa5c4(%ebx),%eax
c0031670:	89 04 24             	mov    %eax,(%esp)
c0031673:	e8 8f 89 ff ff       	call   c002a007 <list_empty>
c0031678:	83 c4 10             	add    $0x10,%esp
c003167b:	84 c0                	test   %al,%al
c003167d:	0f 84 d9 00 00 00    	je     c003175c <frame_replace+0x23f>
        cur_fte = NULL;
c0031683:	c7 c0 c8 b2 04 c0    	mov    $0xc004b2c8,%eax
c0031689:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    hash_delete(&frame_table, &fte->hash_elem);
c003168f:	83 ec 08             	sub    $0x8,%esp
c0031692:	8d 46 10             	lea    0x10(%esi),%eax
c0031695:	50                   	push   %eax
c0031696:	8d 83 18 a6 00 00    	lea    0xa618(%ebx),%eax
c003169c:	50                   	push   %eax
c003169d:	e8 b5 9c ff ff       	call   c002b357 <hash_delete>
    free(fte);
c00316a2:	89 34 24             	mov    %esi,(%esp)
c00316a5:	e8 f0 2d ff ff       	call   c002449a <free>
    return tmp_frame;
c00316aa:	83 c4 10             	add    $0x10,%esp
}
c00316ad:	89 f8                	mov    %edi,%eax
c00316af:	83 c4 0c             	add    $0xc,%esp
c00316b2:	5b                   	pop    %ebx
c00316b3:	5e                   	pop    %esi
c00316b4:	5f                   	pop    %edi
c00316b5:	5d                   	pop    %ebp
c00316b6:	c3                   	ret    
    ASSERT(page_find_entry(cur_fte->t->page_table, cur_fte->va) != NULL);
c00316b7:	83 ec 0c             	sub    $0xc,%esp
c00316ba:	8d 83 f4 55 ff ff    	lea    -0xaa0c(%ebx),%eax
c00316c0:	50                   	push   %eax
c00316c1:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00316c7:	50                   	push   %eax
c00316c8:	8d 83 c0 2b ff ff    	lea    -0xd440(%ebx),%eax
c00316ce:	50                   	push   %eax
c00316cf:	6a 56                	push   $0x56
c00316d1:	8d 83 99 55 ff ff    	lea    -0xaa67(%ebx),%eax
c00316d7:	50                   	push   %eax
c00316d8:	e8 b8 81 ff ff       	call   c0029895 <debug_panic>
        ASSERT(page_eviction(cur_fte->t, cur_fte->va, sa, true));
c00316dd:	83 ec 0c             	sub    $0xc,%esp
c00316e0:	8d 83 34 56 ff ff    	lea    -0xa9cc(%ebx),%eax
c00316e6:	50                   	push   %eax
c00316e7:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00316ed:	50                   	push   %eax
c00316ee:	8d 83 c0 2b ff ff    	lea    -0xd440(%ebx),%eax
c00316f4:	50                   	push   %eax
c00316f5:	6a 5c                	push   $0x5c
c00316f7:	8d 83 99 55 ff ff    	lea    -0xaa67(%ebx),%eax
c00316fd:	50                   	push   %eax
c00316fe:	e8 92 81 ff ff       	call   c0029895 <debug_panic>
        mmap_write(pte->fa, cur_fte->va, tmp_frame);
c0031703:	83 ec 04             	sub    $0x4,%esp
c0031706:	57                   	push   %edi
c0031707:	c7 c5 c8 b2 04 c0    	mov    $0xc004b2c8,%ebp
c003170d:	8b 55 00             	mov    0x0(%ebp),%edx
c0031710:	ff 72 04             	pushl  0x4(%edx)
c0031713:	50                   	push   %eax
c0031714:	e8 b8 b9 ff ff       	call   c002d0d1 <mmap_write>
        ASSERT(page_eviction(cur_fte->t, cur_fte->va, sa, false));
c0031719:	8b 45 00             	mov    0x0(%ebp),%eax
c003171c:	6a 00                	push   $0x0
c003171e:	6a ff                	push   $0xffffffff
c0031720:	ff 70 04             	pushl  0x4(%eax)
c0031723:	ff 70 08             	pushl  0x8(%eax)
c0031726:	e8 d5 0c 00 00       	call   c0032400 <page_eviction>
c003172b:	83 c4 20             	add    $0x20,%esp
c003172e:	84 c0                	test   %al,%al
c0031730:	0f 85 28 ff ff ff    	jne    c003165e <frame_replace+0x141>
c0031736:	83 ec 0c             	sub    $0xc,%esp
c0031739:	8d 83 68 56 ff ff    	lea    -0xa998(%ebx),%eax
c003173f:	50                   	push   %eax
c0031740:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0031746:	50                   	push   %eax
c0031747:	8d 83 c0 2b ff ff    	lea    -0xd440(%ebx),%eax
c003174d:	50                   	push   %eax
c003174e:	6a 60                	push   $0x60
c0031750:	8d 83 99 55 ff ff    	lea    -0xaa67(%ebx),%eax
c0031756:	50                   	push   %eax
c0031757:	e8 39 81 ff ff       	call   c0029895 <debug_panic>
        frame_clock_next();
c003175c:	e8 ff fc ff ff       	call   c0031460 <frame_clock_next>
c0031761:	e9 29 ff ff ff       	jmp    c003168f <frame_replace+0x172>
            return NULL;
c0031766:	bf 00 00 00 00       	mov    $0x0,%edi
c003176b:	e9 3d ff ff ff       	jmp    c00316ad <frame_replace+0x190>

c0031770 <frame_apply>:
void* frame_apply(enum palloc_flags flag, void* va) {
c0031770:	55                   	push   %ebp
c0031771:	57                   	push   %edi
c0031772:	56                   	push   %esi
c0031773:	53                   	push   %ebx
c0031774:	83 ec 18             	sub    $0x18,%esp
c0031777:	e8 6a 0d 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c003177c:	81 c3 c0 f4 00 00    	add    $0xf4c0,%ebx
c0031782:	8b 6c 24 30          	mov    0x30(%esp),%ebp
    lock_acquire(&frame_lock);
c0031786:	8d 83 e4 a5 00 00    	lea    0xa5e4(%ebx),%eax
c003178c:	50                   	push   %eax
c003178d:	e8 30 1e ff ff       	call   c00235c2 <lock_acquire>
    ASSERT (pg_ofs (va) == 0);
c0031792:	83 c4 10             	add    $0x10,%esp
c0031795:	f7 c5 ff 0f 00 00    	test   $0xfff,%ebp
c003179b:	0f 85 80 00 00 00    	jne    c0031821 <frame_apply+0xb1>
    ASSERT (is_user_vaddr (va));
c00317a1:	81 fd ff ff ff bf    	cmp    $0xbfffffff,%ebp
c00317a7:	0f 87 9a 00 00 00    	ja     c0031847 <frame_apply+0xd7>
    void* frame = palloc_get_page(PAL_USER | flag);
c00317ad:	83 ec 0c             	sub    $0xc,%esp
c00317b0:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c00317b4:	83 c8 04             	or     $0x4,%eax
c00317b7:	50                   	push   %eax
c00317b8:	e8 12 27 ff ff       	call   c0023ecf <palloc_get_page>
c00317bd:	89 c6                	mov    %eax,%esi
    if (frame == NULL){
c00317bf:	83 c4 10             	add    $0x10,%esp
c00317c2:	85 c0                	test   %eax,%eax
c00317c4:	0f 84 a3 00 00 00    	je     c003186d <frame_apply+0xfd>
    ASSERT(pg_ofs(frame) == 0);
c00317ca:	f7 c6 ff 0f 00 00    	test   $0xfff,%esi
c00317d0:	0f 85 1a 01 00 00    	jne    c00318f0 <frame_apply+0x180>
    struct frame_table_entry* fte = (struct frame_table_entry*)malloc(sizeof (struct frame_table_entry));
c00317d6:	83 ec 0c             	sub    $0xc,%esp
c00317d9:	6a 20                	push   $0x20
c00317db:	e8 04 2b ff ff       	call   c00242e4 <malloc>
c00317e0:	89 c7                	mov    %eax,%edi
    fte->frame = frame;
c00317e2:	89 30                	mov    %esi,(%eax)
    fte->va = va;
c00317e4:	89 68 04             	mov    %ebp,0x4(%eax)
    fte->t = thread_current();
c00317e7:	e8 59 f8 fe ff       	call   c0021045 <thread_current>
c00317ec:	89 47 08             	mov    %eax,0x8(%edi)
    fte->pinned = true;
c00317ef:	c6 47 0c 01          	movb   $0x1,0xc(%edi)
    hash_insert(&frame_table, &fte->hash_elem);
c00317f3:	83 c4 08             	add    $0x8,%esp
c00317f6:	83 c7 10             	add    $0x10,%edi
c00317f9:	57                   	push   %edi
c00317fa:	8d 83 18 a6 00 00    	lea    0xa618(%ebx),%eax
c0031800:	50                   	push   %eax
c0031801:	e8 68 9a ff ff       	call   c002b26e <hash_insert>
    lock_release(&frame_lock);
c0031806:	8d 83 e4 a5 00 00    	lea    0xa5e4(%ebx),%eax
c003180c:	89 04 24             	mov    %eax,(%esp)
c003180f:	e8 82 1f ff ff       	call   c0023796 <lock_release>
    return frame;
c0031814:	83 c4 10             	add    $0x10,%esp
}
c0031817:	89 f0                	mov    %esi,%eax
c0031819:	83 c4 0c             	add    $0xc,%esp
c003181c:	5b                   	pop    %ebx
c003181d:	5e                   	pop    %esi
c003181e:	5f                   	pop    %edi
c003181f:	5d                   	pop    %ebp
c0031820:	c3                   	ret    
    ASSERT (pg_ofs (va) == 0);
c0031821:	83 ec 0c             	sub    $0xc,%esp
c0031824:	8d 83 aa 55 ff ff    	lea    -0xaa56(%ebx),%eax
c003182a:	50                   	push   %eax
c003182b:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0031831:	50                   	push   %eax
c0031832:	8d 83 d0 2b ff ff    	lea    -0xd430(%ebx),%eax
c0031838:	50                   	push   %eax
c0031839:	6a 2c                	push   $0x2c
c003183b:	8d 83 99 55 ff ff    	lea    -0xaa67(%ebx),%eax
c0031841:	50                   	push   %eax
c0031842:	e8 4e 80 ff ff       	call   c0029895 <debug_panic>
    ASSERT (is_user_vaddr (va));
c0031847:	83 ec 0c             	sub    $0xc,%esp
c003184a:	8d 83 bb 55 ff ff    	lea    -0xaa45(%ebx),%eax
c0031850:	50                   	push   %eax
c0031851:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0031857:	50                   	push   %eax
c0031858:	8d 83 d0 2b ff ff    	lea    -0xd430(%ebx),%eax
c003185e:	50                   	push   %eax
c003185f:	6a 2d                	push   $0x2d
c0031861:	8d 83 99 55 ff ff    	lea    -0xaa67(%ebx),%eax
c0031867:	50                   	push   %eax
c0031868:	e8 28 80 ff ff       	call   c0029895 <debug_panic>
        frame = frame_replace(va);
c003186d:	83 ec 0c             	sub    $0xc,%esp
c0031870:	55                   	push   %ebp
c0031871:	e8 a7 fc ff ff       	call   c003151d <frame_replace>
c0031876:	89 c6                	mov    %eax,%esi
        if (flag & PAL_ZERO)
c0031878:	83 c4 10             	add    $0x10,%esp
c003187b:	f6 44 24 20 02       	testb  $0x2,0x20(%esp)
c0031880:	75 26                	jne    c00318a8 <frame_apply+0x138>
        if (flag & PAL_ASSERT)
c0031882:	f6 44 24 20 01       	testb  $0x1,0x20(%esp)
c0031887:	75 4b                	jne    c00318d4 <frame_apply+0x164>
    if (frame == NULL){
c0031889:	85 f6                	test   %esi,%esi
c003188b:	0f 85 39 ff ff ff    	jne    c00317ca <frame_apply+0x5a>
        lock_release(&frame_lock);
c0031891:	83 ec 0c             	sub    $0xc,%esp
c0031894:	8d 83 e4 a5 00 00    	lea    0xa5e4(%ebx),%eax
c003189a:	50                   	push   %eax
c003189b:	e8 f6 1e ff ff       	call   c0023796 <lock_release>
        return NULL;
c00318a0:	83 c4 10             	add    $0x10,%esp
c00318a3:	e9 6f ff ff ff       	jmp    c0031817 <frame_apply+0xa7>
            memset (frame, 0, PGSIZE);
c00318a8:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c00318ae:	c7 80 fc 0f 00 00 00 	movl   $0x0,0xffc(%eax)
c00318b5:	00 00 00 
c00318b8:	8d 78 04             	lea    0x4(%eax),%edi
c00318bb:	83 e7 fc             	and    $0xfffffffc,%edi
c00318be:	89 c1                	mov    %eax,%ecx
c00318c0:	29 f9                	sub    %edi,%ecx
c00318c2:	81 c1 00 10 00 00    	add    $0x1000,%ecx
c00318c8:	c1 e9 02             	shr    $0x2,%ecx
c00318cb:	b8 00 00 00 00       	mov    $0x0,%eax
c00318d0:	f3 ab                	rep stos %eax,%es:(%edi)
c00318d2:	eb ae                	jmp    c0031882 <frame_apply+0x112>
            PANIC ("frame_apply_fail");
c00318d4:	8d 83 ce 55 ff ff    	lea    -0xaa32(%ebx),%eax
c00318da:	50                   	push   %eax
c00318db:	8d 83 d0 2b ff ff    	lea    -0xd430(%ebx),%eax
c00318e1:	50                   	push   %eax
c00318e2:	6a 36                	push   $0x36
c00318e4:	8d 83 99 55 ff ff    	lea    -0xaa67(%ebx),%eax
c00318ea:	50                   	push   %eax
c00318eb:	e8 a5 7f ff ff       	call   c0029895 <debug_panic>
    ASSERT(pg_ofs(frame) == 0);
c00318f0:	83 ec 0c             	sub    $0xc,%esp
c00318f3:	8d 83 df 55 ff ff    	lea    -0xaa21(%ebx),%eax
c00318f9:	50                   	push   %eax
c00318fa:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0031900:	50                   	push   %eax
c0031901:	8d 83 d0 2b ff ff    	lea    -0xd430(%ebx),%eax
c0031907:	50                   	push   %eax
c0031908:	6a 3e                	push   $0x3e
c003190a:	8d 83 99 55 ff ff    	lea    -0xaa67(%ebx),%eax
c0031910:	50                   	push   %eax
c0031911:	e8 7f 7f ff ff       	call   c0029895 <debug_panic>

c0031916 <frame_free>:
void frame_free(void* frame){
c0031916:	57                   	push   %edi
c0031917:	56                   	push   %esi
c0031918:	53                   	push   %ebx
c0031919:	e8 c8 0b 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c003191e:	81 c3 1e f3 00 00    	add    $0xf31e,%ebx
c0031924:	8b 7c 24 10          	mov    0x10(%esp),%edi
    lock_acquire(&frame_lock);
c0031928:	83 ec 0c             	sub    $0xc,%esp
c003192b:	8d 83 e4 a5 00 00    	lea    0xa5e4(%ebx),%eax
c0031931:	50                   	push   %eax
c0031932:	e8 8b 1c ff ff       	call   c00235c2 <lock_acquire>
    struct frame_table_entry* fte = frame_find_entry(frame);
c0031937:	89 3c 24             	mov    %edi,(%esp)
c003193a:	e8 2b fa ff ff       	call   c003136a <frame_find_entry>
    if (fte == NULL)
c003193f:	83 c4 10             	add    $0x10,%esp
c0031942:	85 c0                	test   %eax,%eax
c0031944:	74 59                	je     c003199f <frame_free+0x89>
c0031946:	89 c6                	mov    %eax,%esi
    if (!fte->pinned){
c0031948:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
c003194c:	75 19                	jne    c0031967 <frame_free+0x51>
        if (cur_fte == fte){
c003194e:	c7 c0 c8 b2 04 c0    	mov    $0xc004b2c8,%eax
c0031954:	39 30                	cmp    %esi,(%eax)
c0031956:	74 63                	je     c00319bb <frame_free+0xa5>
        list_remove(&fte->list_elem);
c0031958:	83 ec 0c             	sub    $0xc,%esp
c003195b:	8d 46 18             	lea    0x18(%esi),%eax
c003195e:	50                   	push   %eax
c003195f:	e8 01 86 ff ff       	call   c0029f65 <list_remove>
c0031964:	83 c4 10             	add    $0x10,%esp
    hash_delete(&frame_table, &fte->hash_elem);
c0031967:	83 ec 08             	sub    $0x8,%esp
c003196a:	8d 46 10             	lea    0x10(%esi),%eax
c003196d:	50                   	push   %eax
c003196e:	8d 83 18 a6 00 00    	lea    0xa618(%ebx),%eax
c0031974:	50                   	push   %eax
c0031975:	e8 dd 99 ff ff       	call   c002b357 <hash_delete>
    free(fte);
c003197a:	89 34 24             	mov    %esi,(%esp)
c003197d:	e8 18 2b ff ff       	call   c002449a <free>
    palloc_free_page(frame);
c0031982:	89 3c 24             	mov    %edi,(%esp)
c0031985:	e8 b3 26 ff ff       	call   c002403d <palloc_free_page>
    lock_release(&frame_lock);
c003198a:	8d 83 e4 a5 00 00    	lea    0xa5e4(%ebx),%eax
c0031990:	89 04 24             	mov    %eax,(%esp)
c0031993:	e8 fe 1d ff ff       	call   c0023796 <lock_release>
}
c0031998:	83 c4 10             	add    $0x10,%esp
c003199b:	5b                   	pop    %ebx
c003199c:	5e                   	pop    %esi
c003199d:	5f                   	pop    %edi
c003199e:	c3                   	ret    
        PANIC("what the fuck? where is the frame to be free?");
c003199f:	8d 83 9c 56 ff ff    	lea    -0xa964(%ebx),%eax
c00319a5:	50                   	push   %eax
c00319a6:	8d 83 b4 2b ff ff    	lea    -0xd44c(%ebx),%eax
c00319ac:	50                   	push   %eax
c00319ad:	6a 72                	push   $0x72
c00319af:	8d 83 99 55 ff ff    	lea    -0xaa67(%ebx),%eax
c00319b5:	50                   	push   %eax
c00319b6:	e8 da 7e ff ff       	call   c0029895 <debug_panic>
            if (list_empty(&frame_clock_list))
c00319bb:	83 ec 0c             	sub    $0xc,%esp
c00319be:	8d 83 c4 a5 00 00    	lea    0xa5c4(%ebx),%eax
c00319c4:	50                   	push   %eax
c00319c5:	e8 3d 86 ff ff       	call   c002a007 <list_empty>
c00319ca:	83 c4 10             	add    $0x10,%esp
c00319cd:	84 c0                	test   %al,%al
c00319cf:	74 11                	je     c00319e2 <frame_free+0xcc>
                cur_fte = NULL;
c00319d1:	c7 c0 c8 b2 04 c0    	mov    $0xc004b2c8,%eax
c00319d7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c00319dd:	e9 76 ff ff ff       	jmp    c0031958 <frame_free+0x42>
                frame_clock_next();
c00319e2:	e8 79 fa ff ff       	call   c0031460 <frame_clock_next>
c00319e7:	e9 6c ff ff ff       	jmp    c0031958 <frame_free+0x42>

c00319ec <swap_init>:
static struct list swap_free_list;
const int PAGE_BLOCK_CNT = PGSIZE / BLOCK_SECTOR_SIZE;
struct block* swap_block;
swap_address top_sa = 0;

void swap_init(){
c00319ec:	53                   	push   %ebx
c00319ed:	83 ec 14             	sub    $0x14,%esp
c00319f0:	e8 f1 0a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00319f5:	81 c3 47 f2 00 00    	add    $0xf247,%ebx
    swap_block = block_get_role(BLOCK_SWAP);
c00319fb:	6a 03                	push   $0x3
c00319fd:	e8 cb 3c ff ff       	call   c00256cd <block_get_role>
c0031a02:	c7 c2 cc b2 04 c0    	mov    $0xc004b2cc,%edx
c0031a08:	89 02                	mov    %eax,(%edx)
    ASSERT(swap_block != NULL);
c0031a0a:	83 c4 10             	add    $0x10,%esp
c0031a0d:	85 c0                	test   %eax,%eax
c0031a0f:	74 14                	je     c0031a25 <swap_init+0x39>
    list_init(&swap_free_list);
c0031a11:	83 ec 0c             	sub    $0xc,%esp
c0031a14:	8d 83 34 a6 00 00    	lea    0xa634(%ebx),%eax
c0031a1a:	50                   	push   %eax
c0031a1b:	e8 42 7f ff ff       	call   c0029962 <list_init>
}
c0031a20:	83 c4 18             	add    $0x18,%esp
c0031a23:	5b                   	pop    %ebx
c0031a24:	c3                   	ret    
    ASSERT(swap_block != NULL);
c0031a25:	83 ec 0c             	sub    $0xc,%esp
c0031a28:	8d 83 ca 56 ff ff    	lea    -0xa936(%ebx),%eax
c0031a2e:	50                   	push   %eax
c0031a2f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0031a35:	50                   	push   %eax
c0031a36:	8d 83 f4 2b ff ff    	lea    -0xd40c(%ebx),%eax
c0031a3c:	50                   	push   %eax
c0031a3d:	6a 0f                	push   $0xf
c0031a3f:	8d 83 dd 56 ff ff    	lea    -0xa923(%ebx),%eax
c0031a45:	50                   	push   %eax
c0031a46:	e8 4a 7e ff ff       	call   c0029895 <debug_panic>

c0031a4b <swap_free>:
        block_read(swap_block, sa + i, pa + i * BLOCK_SECTOR_SIZE);
    }
    swap_free(sa);
}

void swap_free(swap_address sa){
c0031a4b:	56                   	push   %esi
c0031a4c:	53                   	push   %ebx
c0031a4d:	83 ec 04             	sub    $0x4,%esp
c0031a50:	e8 91 0a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031a55:	81 c3 e7 f1 00 00    	add    $0xf1e7,%ebx
c0031a5b:	8b 74 24 10          	mov    0x10(%esp),%esi
    ASSERT(sa % PAGE_BLOCK_CNT == 0);
c0031a5f:	f7 c6 07 00 00 00    	test   $0x7,%esi
c0031a65:	75 33                	jne    c0031a9a <swap_free+0x4f>

    if (top_sa == sa + PAGE_BLOCK_CNT)
c0031a67:	8d 46 08             	lea    0x8(%esi),%eax
c0031a6a:	3b 83 30 a6 00 00    	cmp    0xa630(%ebx),%eax
c0031a70:	74 4e                	je     c0031ac0 <swap_free+0x75>
        top_sa = sa;
    else{
        struct swap_entry* st = malloc(sizeof(struct swap_entry));
c0031a72:	83 ec 0c             	sub    $0xc,%esp
c0031a75:	6a 0c                	push   $0xc
c0031a77:	e8 68 28 ff ff       	call   c00242e4 <malloc>
        st->sa = sa;
c0031a7c:	89 30                	mov    %esi,(%eax)
        list_push_back(&swap_free_list, &st->elem);
c0031a7e:	83 c4 08             	add    $0x8,%esp
c0031a81:	83 c0 04             	add    $0x4,%eax
c0031a84:	50                   	push   %eax
c0031a85:	8d 83 34 a6 00 00    	lea    0xa634(%ebx),%eax
c0031a8b:	50                   	push   %eax
c0031a8c:	e8 b7 84 ff ff       	call   c0029f48 <list_push_back>
c0031a91:	83 c4 10             	add    $0x10,%esp
    }
}
c0031a94:	83 c4 04             	add    $0x4,%esp
c0031a97:	5b                   	pop    %ebx
c0031a98:	5e                   	pop    %esi
c0031a99:	c3                   	ret    
    ASSERT(sa % PAGE_BLOCK_CNT == 0);
c0031a9a:	83 ec 0c             	sub    $0xc,%esp
c0031a9d:	8d 83 ed 56 ff ff    	lea    -0xa913(%ebx),%eax
c0031aa3:	50                   	push   %eax
c0031aa4:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0031aaa:	50                   	push   %eax
c0031aab:	8d 83 dc 2b ff ff    	lea    -0xd424(%ebx),%eax
c0031ab1:	50                   	push   %eax
c0031ab2:	6a 29                	push   $0x29
c0031ab4:	8d 83 dd 56 ff ff    	lea    -0xa923(%ebx),%eax
c0031aba:	50                   	push   %eax
c0031abb:	e8 d5 7d ff ff       	call   c0029895 <debug_panic>
        top_sa = sa;
c0031ac0:	89 b3 30 a6 00 00    	mov    %esi,0xa630(%ebx)
c0031ac6:	eb cc                	jmp    c0031a94 <swap_free+0x49>

c0031ac8 <swap_load>:
void swap_load(swap_address sa, void *pa){
c0031ac8:	55                   	push   %ebp
c0031ac9:	57                   	push   %edi
c0031aca:	56                   	push   %esi
c0031acb:	53                   	push   %ebx
c0031acc:	83 ec 1c             	sub    $0x1c,%esp
c0031acf:	e8 12 0a 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031ad4:	81 c3 68 f1 00 00    	add    $0xf168,%ebx
c0031ada:	8b 44 24 34          	mov    0x34(%esp),%eax
    ASSERT(sa != (swap_address)-1);
c0031ade:	83 7c 24 30 ff       	cmpl   $0xffffffff,0x30(%esp)
c0031ae3:	74 5a                	je     c0031b3f <swap_load+0x77>
    ASSERT(sa % PAGE_BLOCK_CNT == 0);
c0031ae5:	f6 44 24 30 07       	testb  $0x7,0x30(%esp)
c0031aea:	75 79                	jne    c0031b65 <swap_load+0x9d>
    ASSERT(is_kernel_vaddr(pa));
c0031aec:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0031af1:	0f 86 94 00 00 00    	jbe    c0031b8b <swap_load+0xc3>
c0031af7:	89 c6                	mov    %eax,%esi
c0031af9:	05 00 10 00 00       	add    $0x1000,%eax
c0031afe:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0031b02:	8b 7c 24 30          	mov    0x30(%esp),%edi
        block_read(swap_block, sa + i, pa + i * BLOCK_SECTOR_SIZE);
c0031b06:	c7 c5 cc b2 04 c0    	mov    $0xc004b2cc,%ebp
c0031b0c:	83 ec 04             	sub    $0x4,%esp
c0031b0f:	56                   	push   %esi
c0031b10:	57                   	push   %edi
c0031b11:	ff 75 00             	pushl  0x0(%ebp)
c0031b14:	e8 31 3d ff ff       	call   c002584a <block_read>
c0031b19:	83 c7 01             	add    $0x1,%edi
c0031b1c:	81 c6 00 02 00 00    	add    $0x200,%esi
    for (int i = 0; i < PAGE_BLOCK_CNT; i++){
c0031b22:	83 c4 10             	add    $0x10,%esp
c0031b25:	3b 74 24 0c          	cmp    0xc(%esp),%esi
c0031b29:	75 e1                	jne    c0031b0c <swap_load+0x44>
    swap_free(sa);
c0031b2b:	83 ec 0c             	sub    $0xc,%esp
c0031b2e:	ff 74 24 3c          	pushl  0x3c(%esp)
c0031b32:	e8 14 ff ff ff       	call   c0031a4b <swap_free>
}
c0031b37:	83 c4 2c             	add    $0x2c,%esp
c0031b3a:	5b                   	pop    %ebx
c0031b3b:	5e                   	pop    %esi
c0031b3c:	5f                   	pop    %edi
c0031b3d:	5d                   	pop    %ebp
c0031b3e:	c3                   	ret    
    ASSERT(sa != (swap_address)-1);
c0031b3f:	83 ec 0c             	sub    $0xc,%esp
c0031b42:	8d 83 06 57 ff ff    	lea    -0xa8fa(%ebx),%eax
c0031b48:	50                   	push   %eax
c0031b49:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0031b4f:	50                   	push   %eax
c0031b50:	8d 83 e8 2b ff ff    	lea    -0xd418(%ebx),%eax
c0031b56:	50                   	push   %eax
c0031b57:	6a 1e                	push   $0x1e
c0031b59:	8d 83 dd 56 ff ff    	lea    -0xa923(%ebx),%eax
c0031b5f:	50                   	push   %eax
c0031b60:	e8 30 7d ff ff       	call   c0029895 <debug_panic>
    ASSERT(sa % PAGE_BLOCK_CNT == 0);
c0031b65:	83 ec 0c             	sub    $0xc,%esp
c0031b68:	8d 83 ed 56 ff ff    	lea    -0xa913(%ebx),%eax
c0031b6e:	50                   	push   %eax
c0031b6f:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0031b75:	50                   	push   %eax
c0031b76:	8d 83 e8 2b ff ff    	lea    -0xd418(%ebx),%eax
c0031b7c:	50                   	push   %eax
c0031b7d:	6a 1f                	push   $0x1f
c0031b7f:	8d 83 dd 56 ff ff    	lea    -0xa923(%ebx),%eax
c0031b85:	50                   	push   %eax
c0031b86:	e8 0a 7d ff ff       	call   c0029895 <debug_panic>
    ASSERT(is_kernel_vaddr(pa));
c0031b8b:	83 ec 0c             	sub    $0xc,%esp
c0031b8e:	8d 83 1d 57 ff ff    	lea    -0xa8e3(%ebx),%eax
c0031b94:	50                   	push   %eax
c0031b95:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0031b9b:	50                   	push   %eax
c0031b9c:	8d 83 e8 2b ff ff    	lea    -0xd418(%ebx),%eax
c0031ba2:	50                   	push   %eax
c0031ba3:	6a 20                	push   $0x20
c0031ba5:	8d 83 dd 56 ff ff    	lea    -0xa923(%ebx),%eax
c0031bab:	50                   	push   %eax
c0031bac:	e8 e4 7c ff ff       	call   c0029895 <debug_panic>

c0031bb1 <swap_find_entry>:


swap_address swap_find_entry(){
c0031bb1:	57                   	push   %edi
c0031bb2:	56                   	push   %esi
c0031bb3:	53                   	push   %ebx
c0031bb4:	e8 2d 09 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031bb9:	81 c3 83 f0 00 00    	add    $0xf083,%ebx
    swap_address sa = (swap_address)-1;
    if (list_empty(&swap_free_list)){
c0031bbf:	83 ec 0c             	sub    $0xc,%esp
c0031bc2:	8d 83 34 a6 00 00    	lea    0xa634(%ebx),%eax
c0031bc8:	50                   	push   %eax
c0031bc9:	e8 39 84 ff ff       	call   c002a007 <list_empty>
c0031bce:	83 c4 10             	add    $0x10,%esp
c0031bd1:	84 c0                	test   %al,%al
c0031bd3:	74 36                	je     c0031c0b <swap_find_entry+0x5a>
        if (top_sa + PAGE_BLOCK_CNT < block_size(swap_block)){
c0031bd5:	8b bb 30 a6 00 00    	mov    0xa630(%ebx),%edi
c0031bdb:	83 c7 08             	add    $0x8,%edi
c0031bde:	83 ec 0c             	sub    $0xc,%esp
c0031be1:	c7 c0 cc b2 04 c0    	mov    $0xc004b2cc,%eax
c0031be7:	ff 30                	pushl  (%eax)
c0031be9:	e8 fe 3c ff ff       	call   c00258ec <block_size>
c0031bee:	83 c4 10             	add    $0x10,%esp
    swap_address sa = (swap_address)-1;
c0031bf1:	be ff ff ff ff       	mov    $0xffffffff,%esi
        if (top_sa + PAGE_BLOCK_CNT < block_size(swap_block)){
c0031bf6:	39 c7                	cmp    %eax,%edi
c0031bf8:	73 3b                	jae    c0031c35 <swap_find_entry+0x84>
            sa = top_sa;
c0031bfa:	8b b3 30 a6 00 00    	mov    0xa630(%ebx),%esi
            top_sa += PAGE_BLOCK_CNT;
c0031c00:	8d 46 08             	lea    0x8(%esi),%eax
c0031c03:	89 83 30 a6 00 00    	mov    %eax,0xa630(%ebx)
c0031c09:	eb 2a                	jmp    c0031c35 <swap_find_entry+0x84>
        }
    }
    else{
        struct swap_entry* t = list_entry(list_front(&swap_free_list), struct swap_entry, elem);
c0031c0b:	83 ec 0c             	sub    $0xc,%esp
c0031c0e:	8d 83 34 a6 00 00    	lea    0xa634(%ebx),%eax
c0031c14:	50                   	push   %eax
c0031c15:	e8 11 84 ff ff       	call   c002a02b <list_front>
c0031c1a:	89 c6                	mov    %eax,%esi
        list_remove(&t->elem);
c0031c1c:	8d 78 fc             	lea    -0x4(%eax),%edi
c0031c1f:	89 04 24             	mov    %eax,(%esp)
c0031c22:	e8 3e 83 ff ff       	call   c0029f65 <list_remove>
        sa = t->sa;
c0031c27:	8b 76 fc             	mov    -0x4(%esi),%esi
        free(t);
c0031c2a:	89 3c 24             	mov    %edi,(%esp)
c0031c2d:	e8 68 28 ff ff       	call   c002449a <free>
c0031c32:	83 c4 10             	add    $0x10,%esp
    }
    return sa;
}
c0031c35:	89 f0                	mov    %esi,%eax
c0031c37:	5b                   	pop    %ebx
c0031c38:	5e                   	pop    %esi
c0031c39:	5f                   	pop    %edi
c0031c3a:	c3                   	ret    

c0031c3b <swap_store>:
swap_address swap_store(void *pa){
c0031c3b:	55                   	push   %ebp
c0031c3c:	57                   	push   %edi
c0031c3d:	56                   	push   %esi
c0031c3e:	53                   	push   %ebx
c0031c3f:	83 ec 1c             	sub    $0x1c,%esp
c0031c42:	e8 9f 08 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031c47:	81 c3 f5 ef 00 00    	add    $0xeff5,%ebx
c0031c4d:	8b 7c 24 30          	mov    0x30(%esp),%edi
    swap_address sa = swap_find_entry();
c0031c51:	e8 5b ff ff ff       	call   c0031bb1 <swap_find_entry>
c0031c56:	89 44 24 0c          	mov    %eax,0xc(%esp)
    if (sa == (swap_address)-1)
c0031c5a:	83 f8 ff             	cmp    $0xffffffff,%eax
c0031c5d:	74 33                	je     c0031c92 <swap_store+0x57>
c0031c5f:	89 fe                	mov    %edi,%esi
c0031c61:	8d 97 00 10 00 00    	lea    0x1000(%edi),%edx
c0031c67:	89 54 24 08          	mov    %edx,0x8(%esp)
c0031c6b:	89 c7                	mov    %eax,%edi
        block_write(swap_block, sa + i, pa + i * BLOCK_SECTOR_SIZE);
c0031c6d:	c7 c5 cc b2 04 c0    	mov    $0xc004b2cc,%ebp
c0031c73:	83 ec 04             	sub    $0x4,%esp
c0031c76:	56                   	push   %esi
c0031c77:	57                   	push   %edi
c0031c78:	ff 75 00             	pushl  0x0(%ebp)
c0031c7b:	e8 fe 3b ff ff       	call   c002587e <block_write>
c0031c80:	83 c7 01             	add    $0x1,%edi
c0031c83:	81 c6 00 02 00 00    	add    $0x200,%esi
    for (int i = 0; i < PAGE_BLOCK_CNT; i++){
c0031c89:	83 c4 10             	add    $0x10,%esp
c0031c8c:	3b 74 24 08          	cmp    0x8(%esp),%esi
c0031c90:	75 e1                	jne    c0031c73 <swap_store+0x38>
}
c0031c92:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0031c96:	83 c4 1c             	add    $0x1c,%esp
c0031c99:	5b                   	pop    %ebx
c0031c9a:	5e                   	pop    %esi
c0031c9b:	5f                   	pop    %edi
c0031c9c:	5d                   	pop    %ebp
c0031c9d:	c3                   	ret    

c0031c9e <page_hash_less>:
    return success;

}

bool page_hash_less(const struct hash_elem *lhs, const struct hash_elem *rhs, void* aux UNUSED) {
    return hash_entry(lhs, struct page_table_entry, elem)->va < hash_entry(rhs, struct page_table_entry, elem)->va;
c0031c9e:	8b 54 24 04          	mov    0x4(%esp),%edx
c0031ca2:	8b 44 24 08          	mov    0x8(%esp),%eax
c0031ca6:	8b 40 ec             	mov    -0x14(%eax),%eax
c0031ca9:	39 42 ec             	cmp    %eax,-0x14(%edx)
c0031cac:	0f 92 c0             	setb   %al
}
c0031caf:	c3                   	ret    

c0031cb0 <page_hash>:

unsigned page_hash(const struct hash_elem *e, void* aux UNUSED){
c0031cb0:	53                   	push   %ebx
c0031cb1:	83 ec 10             	sub    $0x10,%esp
c0031cb4:	e8 2d 08 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031cb9:	81 c3 83 ef 00 00    	add    $0xef83,%ebx
    struct page_table_entry *pte = hash_entry(e, struct page_table_entry, elem);
    return hash_bytes(&(pte->va), sizeof(pte->va));
c0031cbf:	6a 04                	push   $0x4
c0031cc1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0031cc5:	83 e8 14             	sub    $0x14,%eax
c0031cc8:	50                   	push   %eax
c0031cc9:	e8 ca 98 ff ff       	call   c002b598 <hash_bytes>
}
c0031cce:	83 c4 18             	add    $0x18,%esp
c0031cd1:	5b                   	pop    %ebx
c0031cd2:	c3                   	ret    

c0031cd3 <page_destructor>:

void page_destructor(struct hash_elem *e, void* aux UNUSED) {
c0031cd3:	55                   	push   %ebp
c0031cd4:	57                   	push   %edi
c0031cd5:	56                   	push   %esi
c0031cd6:	53                   	push   %ebx
c0031cd7:	83 ec 0c             	sub    $0xc,%esp
c0031cda:	e8 07 08 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031cdf:	81 c3 5d ef 00 00    	add    $0xef5d,%ebx
c0031ce5:	8b 74 24 20          	mov    0x20(%esp),%esi
    struct page_table_entry *pte = hash_entry(e, struct page_table_entry, elem);
c0031ce9:	8d 7e ec             	lea    -0x14(%esi),%edi

    if(pte->status == Frame) {
c0031cec:	8b 46 f0             	mov    -0x10(%esi),%eax
c0031cef:	85 c0                	test   %eax,%eax
c0031cf1:	74 16                	je     c0031d09 <page_destructor+0x36>
        pagedir_clear_page(thread_current()->pagedir, pte->va);
        frame_free(pte->pa);
    }
    else if(pte->status == Swap)
c0031cf3:	83 f8 01             	cmp    $0x1,%eax
c0031cf6:	74 35                	je     c0031d2d <page_destructor+0x5a>
        swap_free((swap_address) pte->pa);

    free(pte);
c0031cf8:	83 ec 0c             	sub    $0xc,%esp
c0031cfb:	57                   	push   %edi
c0031cfc:	e8 99 27 ff ff       	call   c002449a <free>
}
c0031d01:	83 c4 1c             	add    $0x1c,%esp
c0031d04:	5b                   	pop    %ebx
c0031d05:	5e                   	pop    %esi
c0031d06:	5f                   	pop    %edi
c0031d07:	5d                   	pop    %ebp
c0031d08:	c3                   	ret    
        pagedir_clear_page(thread_current()->pagedir, pte->va);
c0031d09:	8b 6e ec             	mov    -0x14(%esi),%ebp
c0031d0c:	e8 34 f3 fe ff       	call   c0021045 <thread_current>
c0031d11:	83 ec 08             	sub    $0x8,%esp
c0031d14:	55                   	push   %ebp
c0031d15:	ff 70 30             	pushl  0x30(%eax)
c0031d18:	e8 0b ac ff ff       	call   c002c928 <pagedir_clear_page>
        frame_free(pte->pa);
c0031d1d:	83 c4 04             	add    $0x4,%esp
c0031d20:	ff 76 f4             	pushl  -0xc(%esi)
c0031d23:	e8 ee fb ff ff       	call   c0031916 <frame_free>
c0031d28:	83 c4 10             	add    $0x10,%esp
c0031d2b:	eb cb                	jmp    c0031cf8 <page_destructor+0x25>
        swap_free((swap_address) pte->pa);
c0031d2d:	83 ec 0c             	sub    $0xc,%esp
c0031d30:	ff 76 f4             	pushl  -0xc(%esi)
c0031d33:	e8 13 fd ff ff       	call   c0031a4b <swap_free>
c0031d38:	83 c4 10             	add    $0x10,%esp
c0031d3b:	eb bb                	jmp    c0031cf8 <page_destructor+0x25>

c0031d3d <page_init>:
void page_init() {
c0031d3d:	53                   	push   %ebx
c0031d3e:	83 ec 14             	sub    $0x14,%esp
c0031d41:	e8 a0 07 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031d46:	81 c3 f6 ee 00 00    	add    $0xeef6,%ebx
    lock_init(&page_lock);
c0031d4c:	8d 83 44 a6 00 00    	lea    0xa644(%ebx),%eax
c0031d52:	50                   	push   %eax
c0031d53:	e8 aa 17 ff ff       	call   c0023502 <lock_init>
}
c0031d58:	83 c4 18             	add    $0x18,%esp
c0031d5b:	5b                   	pop    %ebx
c0031d5c:	c3                   	ret    

c0031d5d <page_find_entry>:
struct page_table_entry* page_find_entry(page_table* pt, void* va) {
c0031d5d:	53                   	push   %ebx
c0031d5e:	83 ec 28             	sub    $0x28,%esp
c0031d61:	e8 80 07 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031d66:	81 c3 d6 ee 00 00    	add    $0xeed6,%ebx
c0031d6c:	8b 44 24 30          	mov    0x30(%esp),%eax
    ASSERT(pt != NULL);
c0031d70:	85 c0                	test   %eax,%eax
c0031d72:	74 28                	je     c0031d9c <page_find_entry+0x3f>
    tmp.va = va;
c0031d74:	8b 54 24 34          	mov    0x34(%esp),%edx
c0031d78:	89 54 24 04          	mov    %edx,0x4(%esp)
    struct hash_elem* he = hash_find(pt, &(tmp.elem));
c0031d7c:	83 ec 08             	sub    $0x8,%esp
c0031d7f:	8d 54 24 20          	lea    0x20(%esp),%edx
c0031d83:	52                   	push   %edx
c0031d84:	50                   	push   %eax
c0031d85:	e8 a6 95 ff ff       	call   c002b330 <hash_find>
    return he == NULL? NULL : hash_entry(he, struct page_table_entry, elem);
c0031d8a:	8d 50 ec             	lea    -0x14(%eax),%edx
c0031d8d:	85 c0                	test   %eax,%eax
c0031d8f:	b8 00 00 00 00       	mov    $0x0,%eax
c0031d94:	0f 45 c2             	cmovne %edx,%eax
}
c0031d97:	83 c4 38             	add    $0x38,%esp
c0031d9a:	5b                   	pop    %ebx
c0031d9b:	c3                   	ret    
    ASSERT(pt != NULL);
c0031d9c:	83 ec 0c             	sub    $0xc,%esp
c0031d9f:	8d 83 31 57 ff ff    	lea    -0xa8cf(%ebx),%eax
c0031da5:	50                   	push   %eax
c0031da6:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0031dac:	50                   	push   %eax
c0031dad:	8d 83 38 2c ff ff    	lea    -0xd3c8(%ebx),%eax
c0031db3:	50                   	push   %eax
c0031db4:	6a 1a                	push   $0x1a
c0031db6:	8d 83 3c 57 ff ff    	lea    -0xa8c4(%ebx),%eax
c0031dbc:	50                   	push   %eax
c0031dbd:	e8 d3 7a ff ff       	call   c0029895 <debug_panic>

c0031dc2 <page_find_entry_with_lock>:
struct page_table_entry* page_find_entry_with_lock(page_table* pt, void* va){
c0031dc2:	57                   	push   %edi
c0031dc3:	56                   	push   %esi
c0031dc4:	53                   	push   %ebx
c0031dc5:	e8 1c 07 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031dca:	81 c3 72 ee 00 00    	add    $0xee72,%ebx
    lock_acquire(&page_lock);
c0031dd0:	83 ec 0c             	sub    $0xc,%esp
c0031dd3:	8d b3 44 a6 00 00    	lea    0xa644(%ebx),%esi
c0031dd9:	56                   	push   %esi
c0031dda:	e8 e3 17 ff ff       	call   c00235c2 <lock_acquire>
    struct page_table_entry* pte = page_find_entry(pt, va);
c0031ddf:	83 c4 08             	add    $0x8,%esp
c0031de2:	ff 74 24 1c          	pushl  0x1c(%esp)
c0031de6:	ff 74 24 1c          	pushl  0x1c(%esp)
c0031dea:	e8 6e ff ff ff       	call   c0031d5d <page_find_entry>
c0031def:	89 c7                	mov    %eax,%edi
    lock_release(&page_lock);
c0031df1:	89 34 24             	mov    %esi,(%esp)
c0031df4:	e8 9d 19 ff ff       	call   c0023796 <lock_release>
    return pte;
c0031df9:	83 c4 10             	add    $0x10,%esp
}
c0031dfc:	89 f8                	mov    %edi,%eax
c0031dfe:	5b                   	pop    %ebx
c0031dff:	5e                   	pop    %esi
c0031e00:	5f                   	pop    %edi
c0031e01:	c3                   	ret    

c0031e02 <page_create>:
page_table* page_create() {
c0031e02:	56                   	push   %esi
c0031e03:	53                   	push   %ebx
c0031e04:	83 ec 10             	sub    $0x10,%esp
c0031e07:	e8 da 06 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031e0c:	81 c3 30 ee 00 00    	add    $0xee30,%ebx
    page_table* pt = malloc(sizeof(page_table));
c0031e12:	6a 18                	push   $0x18
c0031e14:	e8 cb 24 ff ff       	call   c00242e4 <malloc>
c0031e19:	89 c6                	mov    %eax,%esi
    if(pt != NULL) {
c0031e1b:	83 c4 10             	add    $0x10,%esp
c0031e1e:	85 c0                	test   %eax,%eax
c0031e20:	74 1d                	je     c0031e3f <page_create+0x3d>
        if(hash_init(pt, page_hash, page_hash_less, NULL) == false) {
c0031e22:	6a 00                	push   $0x0
c0031e24:	8d 83 62 10 ff ff    	lea    -0xef9e(%ebx),%eax
c0031e2a:	50                   	push   %eax
c0031e2b:	8d 83 74 10 ff ff    	lea    -0xef8c(%ebx),%eax
c0031e31:	50                   	push   %eax
c0031e32:	56                   	push   %esi
c0031e33:	e8 95 93 ff ff       	call   c002b1cd <hash_init>
c0031e38:	83 c4 10             	add    $0x10,%esp
c0031e3b:	84 c0                	test   %al,%al
c0031e3d:	74 08                	je     c0031e47 <page_create+0x45>
}
c0031e3f:	89 f0                	mov    %esi,%eax
c0031e41:	83 c4 04             	add    $0x4,%esp
c0031e44:	5b                   	pop    %ebx
c0031e45:	5e                   	pop    %esi
c0031e46:	c3                   	ret    
            free(pt);
c0031e47:	83 ec 0c             	sub    $0xc,%esp
c0031e4a:	56                   	push   %esi
c0031e4b:	e8 4a 26 ff ff       	call   c002449a <free>
            return NULL;
c0031e50:	83 c4 10             	add    $0x10,%esp
c0031e53:	be 00 00 00 00       	mov    $0x0,%esi
c0031e58:	eb e5                	jmp    c0031e3f <page_create+0x3d>

c0031e5a <page_free>:
void page_free(page_table* page_table) {
c0031e5a:	56                   	push   %esi
c0031e5b:	53                   	push   %ebx
c0031e5c:	83 ec 10             	sub    $0x10,%esp
c0031e5f:	e8 82 06 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031e64:	81 c3 d8 ed 00 00    	add    $0xedd8,%ebx
    lock_acquire(&page_lock);
c0031e6a:	8d b3 44 a6 00 00    	lea    0xa644(%ebx),%esi
c0031e70:	56                   	push   %esi
c0031e71:	e8 4c 17 ff ff       	call   c00235c2 <lock_acquire>
    hash_destroy(page_table, page_destructor);
c0031e76:	83 c4 08             	add    $0x8,%esp
c0031e79:	8d 83 97 10 ff ff    	lea    -0xef69(%ebx),%eax
c0031e7f:	50                   	push   %eax
c0031e80:	ff 74 24 1c          	pushl  0x1c(%esp)
c0031e84:	e8 ab 93 ff ff       	call   c002b234 <hash_destroy>
    lock_release(&page_lock);
c0031e89:	89 34 24             	mov    %esi,(%esp)
c0031e8c:	e8 05 19 ff ff       	call   c0023796 <lock_release>
}
c0031e91:	83 c4 14             	add    $0x14,%esp
c0031e94:	5b                   	pop    %ebx
c0031e95:	5e                   	pop    %esi
c0031e96:	c3                   	ret    

c0031e97 <page_fault_handler>:
bool page_fault_handler(const void* vaddr, bool dirty, void* esp) {
c0031e97:	55                   	push   %ebp
c0031e98:	57                   	push   %edi
c0031e99:	56                   	push   %esi
c0031e9a:	53                   	push   %ebx
c0031e9b:	83 ec 1c             	sub    $0x1c,%esp
c0031e9e:	e8 43 06 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c0031ea3:	81 c3 99 ed 00 00    	add    $0xed99,%ebx
c0031ea9:	8b 44 24 34          	mov    0x34(%esp),%eax
c0031ead:	89 44 24 08          	mov    %eax,0x8(%esp)
    struct thread* curT = thread_current();
c0031eb1:	e8 8f f1 fe ff       	call   c0021045 <thread_current>
    page_table* page_table = curT->page_table;
c0031eb6:	8b a8 b8 00 00 00    	mov    0xb8(%eax),%ebp
    uint32_t* pagedir = curT->pagedir;
c0031ebc:	8b 40 30             	mov    0x30(%eax),%eax
c0031ebf:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0031ec3:	8b 7c 24 30          	mov    0x30(%esp),%edi
c0031ec7:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
    lock_acquire(&page_lock);
c0031ecd:	83 ec 0c             	sub    $0xc,%esp
c0031ed0:	8d 83 44 a6 00 00    	lea    0xa644(%ebx),%eax
c0031ed6:	50                   	push   %eax
c0031ed7:	e8 e6 16 ff ff       	call   c00235c2 <lock_acquire>
    struct page_table_entry* pte = page_find_entry(page_table, va);
c0031edc:	83 c4 08             	add    $0x8,%esp
c0031edf:	57                   	push   %edi
c0031ee0:	55                   	push   %ebp
c0031ee1:	e8 77 fe ff ff       	call   c0031d5d <page_find_entry>
    ASSERT(is_user_vaddr(vaddr));
c0031ee6:	83 c4 10             	add    $0x10,%esp
c0031ee9:	81 7c 24 30 ff ff ff 	cmpl   $0xbfffffff,0x30(%esp)
c0031ef0:	bf 
c0031ef1:	0f 87 83 00 00 00    	ja     c0031f7a <page_fault_handler+0xe3>
c0031ef7:	89 c6                	mov    %eax,%esi
    ASSERT(!(pte != NULL && pte->status == Frame));
c0031ef9:	85 c0                	test   %eax,%eax
c0031efb:	0f 84 05 02 00 00    	je     c0032106 <page_fault_handler+0x26f>
c0031f01:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0031f05:	0f 84 95 00 00 00    	je     c0031fa0 <page_fault_handler+0x109>
    if(dirty && pte != NULL && pte -> dirty == false)
c0031f0b:	80 7c 24 08 00       	cmpb   $0x0,0x8(%esp)
c0031f10:	74 0c                	je     c0031f1e <page_fault_handler+0x87>
c0031f12:	0f b6 40 10          	movzbl 0x10(%eax),%eax
c0031f16:	84 c0                	test   %al,%al
c0031f18:	0f 84 e0 01 00 00    	je     c00320fe <page_fault_handler+0x267>
    if(va >= PAGE_STACK_LOWER_BOUND) {
c0031f1e:	81 ff ff ff 7f bf    	cmp    $0xbf7fffff,%edi
c0031f24:	0f 87 e4 01 00 00    	ja     c003210e <page_fault_handler+0x277>
            switch(pte->status) {
c0031f2a:	8b 46 04             	mov    0x4(%esi),%eax
c0031f2d:	83 f8 01             	cmp    $0x1,%eax
c0031f30:	0f 84 1a 01 00 00    	je     c0032050 <page_fault_handler+0x1b9>
c0031f36:	83 f8 02             	cmp    $0x2,%eax
c0031f39:	0f 85 ee 01 00 00    	jne    c003212d <page_fault_handler+0x296>
                    pa = frame_apply(PAGE_PAL_FLAG, va);
c0031f3f:	83 ec 08             	sub    $0x8,%esp
c0031f42:	57                   	push   %edi
c0031f43:	6a 00                	push   $0x0
c0031f45:	e8 26 f8 ff ff       	call   c0031770 <frame_apply>
c0031f4a:	89 44 24 18          	mov    %eax,0x18(%esp)
                    if(pa == NULL) {
c0031f4e:	83 c4 10             	add    $0x10,%esp
c0031f51:	89 c5                	mov    %eax,%ebp
c0031f53:	85 c0                	test   %eax,%eax
c0031f55:	0f 84 83 01 00 00    	je     c00320de <page_fault_handler+0x247>
                    mmap_read(pte->pa, va, pa);
c0031f5b:	83 ec 04             	sub    $0x4,%esp
c0031f5e:	50                   	push   %eax
c0031f5f:	57                   	push   %edi
c0031f60:	ff 76 08             	pushl  0x8(%esi)
c0031f63:	e8 23 b0 ff ff       	call   c002cf8b <mmap_read>
                    pte->pa = pa;
c0031f68:	89 6e 08             	mov    %ebp,0x8(%esi)
                    pte->status = Frame;
c0031f6b:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
                    break;
c0031f72:	83 c4 10             	add    $0x10,%esp
c0031f75:	e9 07 01 00 00       	jmp    c0032081 <page_fault_handler+0x1ea>
    ASSERT(is_user_vaddr(vaddr));
c0031f7a:	83 ec 0c             	sub    $0xc,%esp
c0031f7d:	8d 83 4c 57 ff ff    	lea    -0xa8b4(%ebx),%eax
c0031f83:	50                   	push   %eax
c0031f84:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0031f8a:	50                   	push   %eax
c0031f8b:	8d 83 24 2c ff ff    	lea    -0xd3dc(%ebx),%eax
c0031f91:	50                   	push   %eax
c0031f92:	6a 48                	push   $0x48
c0031f94:	8d 83 3c 57 ff ff    	lea    -0xa8c4(%ebx),%eax
c0031f9a:	50                   	push   %eax
c0031f9b:	e8 f5 78 ff ff       	call   c0029895 <debug_panic>
    ASSERT(!(pte != NULL && pte->status == Frame));
c0031fa0:	83 ec 0c             	sub    $0xc,%esp
c0031fa3:	8d 83 74 57 ff ff    	lea    -0xa88c(%ebx),%eax
c0031fa9:	50                   	push   %eax
c0031faa:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c0031fb0:	50                   	push   %eax
c0031fb1:	8d 83 24 2c ff ff    	lea    -0xd3dc(%ebx),%eax
c0031fb7:	50                   	push   %eax
c0031fb8:	6a 49                	push   $0x49
c0031fba:	8d 83 3c 57 ff ff    	lea    -0xa8c4(%ebx),%eax
c0031fc0:	50                   	push   %eax
c0031fc1:	e8 cf 78 ff ff       	call   c0029895 <debug_panic>
                pa = frame_apply(PAGE_PAL_FLAG, va);
c0031fc6:	83 ec 08             	sub    $0x8,%esp
c0031fc9:	57                   	push   %edi
c0031fca:	6a 00                	push   $0x0
c0031fcc:	e8 9f f7 ff ff       	call   c0031770 <frame_apply>
                if(pa == NULL)
c0031fd1:	83 c4 10             	add    $0x10,%esp
c0031fd4:	89 44 24 08          	mov    %eax,0x8(%esp)
c0031fd8:	85 c0                	test   %eax,%eax
c0031fda:	0f 84 fe 00 00 00    	je     c00320de <page_fault_handler+0x247>
                    pte = malloc(sizeof(*pte));
c0031fe0:	83 ec 0c             	sub    $0xc,%esp
c0031fe3:	6a 1c                	push   $0x1c
c0031fe5:	e8 fa 22 ff ff       	call   c00242e4 <malloc>
c0031fea:	89 c6                	mov    %eax,%esi
                    pte->va = va;
c0031fec:	89 38                	mov    %edi,(%eax)
                    pte->status = Frame;
c0031fee:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
                    pte->pa = pa;
c0031ff5:	8b 44 24 18          	mov    0x18(%esp),%eax
c0031ff9:	89 46 08             	mov    %eax,0x8(%esi)
                    pte->fa = NULL;
c0031ffc:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
                    pte->dirty = true;
c0032003:	c6 46 10 01          	movb   $0x1,0x10(%esi)
                    hash_insert(page_table, &pte->elem);
c0032007:	83 c4 08             	add    $0x8,%esp
c003200a:	8d 46 14             	lea    0x14(%esi),%eax
c003200d:	50                   	push   %eax
c003200e:	55                   	push   %ebp
c003200f:	e8 5a 92 ff ff       	call   c002b26e <hash_insert>
c0032014:	83 c4 10             	add    $0x10,%esp
c0032017:	eb 68                	jmp    c0032081 <page_fault_handler+0x1ea>
                        pa = frame_apply(PAGE_PAL_FLAG, va);
c0032019:	83 ec 08             	sub    $0x8,%esp
c003201c:	57                   	push   %edi
c003201d:	6a 00                	push   $0x0
c003201f:	e8 4c f7 ff ff       	call   c0031770 <frame_apply>
c0032024:	89 44 24 18          	mov    %eax,0x18(%esp)
                        if(pa == NULL) {
c0032028:	83 c4 10             	add    $0x10,%esp
c003202b:	89 c7                	mov    %eax,%edi
c003202d:	85 c0                	test   %eax,%eax
c003202f:	0f 84 a9 00 00 00    	je     c00320de <page_fault_handler+0x247>
                        swap_load((swap_address) pte->pa, pa);
c0032035:	83 ec 08             	sub    $0x8,%esp
c0032038:	50                   	push   %eax
c0032039:	ff 76 08             	pushl  0x8(%esi)
c003203c:	e8 87 fa ff ff       	call   c0031ac8 <swap_load>
                        pte->pa = pa;
c0032041:	89 7e 08             	mov    %edi,0x8(%esi)
                        pte->status = Frame;
c0032044:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
                        break;
c003204b:	83 c4 10             	add    $0x10,%esp
c003204e:	eb 31                	jmp    c0032081 <page_fault_handler+0x1ea>
                    pa = frame_apply(PAGE_PAL_FLAG, va);
c0032050:	83 ec 08             	sub    $0x8,%esp
c0032053:	57                   	push   %edi
c0032054:	6a 00                	push   $0x0
c0032056:	e8 15 f7 ff ff       	call   c0031770 <frame_apply>
c003205b:	89 44 24 18          	mov    %eax,0x18(%esp)
                    if(pa == NULL) {
c003205f:	83 c4 10             	add    $0x10,%esp
c0032062:	89 c7                	mov    %eax,%edi
c0032064:	85 c0                	test   %eax,%eax
c0032066:	74 76                	je     c00320de <page_fault_handler+0x247>
                    swap_load((swap_address)pte->pa, pa);
c0032068:	83 ec 08             	sub    $0x8,%esp
c003206b:	50                   	push   %eax
c003206c:	ff 76 08             	pushl  0x8(%esi)
c003206f:	e8 54 fa ff ff       	call   c0031ac8 <swap_load>
                    pte->pa = pa;
c0032074:	89 7e 08             	mov    %edi,0x8(%esi)
                    pte->status = Frame;
c0032077:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
                    break;
c003207e:	83 c4 10             	add    $0x10,%esp
    frame_reset(pa);
c0032081:	83 ec 0c             	sub    $0xc,%esp
c0032084:	ff 74 24 14          	pushl  0x14(%esp)
c0032088:	e8 17 f3 ff ff       	call   c00313a4 <frame_reset>
    lock_release(&page_lock);
c003208d:	8d 83 44 a6 00 00    	lea    0xa644(%ebx),%eax
c0032093:	89 04 24             	mov    %eax,(%esp)
c0032096:	e8 fb 16 ff ff       	call   c0023796 <lock_release>
        ASSERT(pagedir_set_page(pagedir, pte->va, pte->pa, pte->dirty));
c003209b:	0f b6 46 10          	movzbl 0x10(%esi),%eax
c003209f:	50                   	push   %eax
c00320a0:	ff 76 08             	pushl  0x8(%esi)
c00320a3:	ff 36                	pushl  (%esi)
c00320a5:	ff 74 24 28          	pushl  0x28(%esp)
c00320a9:	e8 e9 a4 ff ff       	call   c002c597 <pagedir_set_page>
c00320ae:	83 c4 20             	add    $0x20,%esp
c00320b1:	84 c0                	test   %al,%al
c00320b3:	75 49                	jne    c00320fe <page_fault_handler+0x267>
c00320b5:	83 ec 0c             	sub    $0xc,%esp
c00320b8:	8d 83 9c 57 ff ff    	lea    -0xa864(%ebx),%eax
c00320be:	50                   	push   %eax
c00320bf:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c00320c5:	50                   	push   %eax
c00320c6:	8d 83 24 2c ff ff    	lea    -0xd3dc(%ebx),%eax
c00320cc:	50                   	push   %eax
c00320cd:	68 97 00 00 00       	push   $0x97
c00320d2:	8d 83 3c 57 ff ff    	lea    -0xa8c4(%ebx),%eax
c00320d8:	50                   	push   %eax
c00320d9:	e8 b7 77 ff ff       	call   c0029895 <debug_panic>
    frame_reset(pa);
c00320de:	83 ec 0c             	sub    $0xc,%esp
c00320e1:	6a 00                	push   $0x0
c00320e3:	e8 bc f2 ff ff       	call   c00313a4 <frame_reset>
    lock_release(&page_lock);
c00320e8:	8d 83 44 a6 00 00    	lea    0xa644(%ebx),%eax
c00320ee:	89 04 24             	mov    %eax,(%esp)
c00320f1:	e8 a0 16 ff ff       	call   c0023796 <lock_release>
c00320f6:	83 c4 10             	add    $0x10,%esp
    return success;
c00320f9:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00320fe:	83 c4 1c             	add    $0x1c,%esp
c0032101:	5b                   	pop    %ebx
c0032102:	5e                   	pop    %esi
c0032103:	5f                   	pop    %edi
c0032104:	5d                   	pop    %ebp
c0032105:	c3                   	ret    
    if(va >= PAGE_STACK_LOWER_BOUND) {
c0032106:	81 ff ff ff 7f bf    	cmp    $0xbf7fffff,%edi
c003210c:	76 d0                	jbe    c00320de <page_fault_handler+0x247>
        if(vaddr >= esp - PAGE_INST_MARGIN) {
c003210e:	8b 44 24 38          	mov    0x38(%esp),%eax
c0032112:	83 e8 20             	sub    $0x20,%eax
c0032115:	39 44 24 30          	cmp    %eax,0x30(%esp)
c0032119:	72 c3                	jb     c00320de <page_fault_handler+0x247>
            if(pte == NULL) {
c003211b:	85 f6                	test   %esi,%esi
c003211d:	0f 84 a3 fe ff ff    	je     c0031fc6 <page_fault_handler+0x12f>
                switch(pte->status) {
c0032123:	83 7e 04 01          	cmpl   $0x1,0x4(%esi)
c0032127:	0f 84 ec fe ff ff    	je     c0032019 <page_fault_handler+0x182>
    frame_reset(pa);
c003212d:	83 ec 0c             	sub    $0xc,%esp
c0032130:	6a 00                	push   $0x0
c0032132:	e8 6d f2 ff ff       	call   c00313a4 <frame_reset>
    lock_release(&page_lock);
c0032137:	8d 83 44 a6 00 00    	lea    0xa644(%ebx),%eax
c003213d:	89 04 24             	mov    %eax,(%esp)
c0032140:	e8 51 16 ff ff       	call   c0023796 <lock_release>
c0032145:	83 c4 10             	add    $0x10,%esp
    return success;
c0032148:	b8 00 00 00 00       	mov    $0x0,%eax
c003214d:	eb af                	jmp    c00320fe <page_fault_handler+0x267>

c003214f <page_set_frame>:
bool page_set_frame(void* va, void* pa, bool dirty) {
c003214f:	55                   	push   %ebp
c0032150:	57                   	push   %edi
c0032151:	56                   	push   %esi
c0032152:	53                   	push   %ebx
c0032153:	83 ec 1c             	sub    $0x1c,%esp
c0032156:	e8 8b 03 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c003215b:	81 c3 e1 ea 00 00    	add    $0xeae1,%ebx
c0032161:	8b 44 24 38          	mov    0x38(%esp),%eax
c0032165:	89 44 24 0c          	mov    %eax,0xc(%esp)
    struct thread* curT = thread_current();
c0032169:	e8 d7 ee fe ff       	call   c0021045 <thread_current>
    page_table* pt = curT->page_table;
c003216e:	8b b8 b8 00 00 00    	mov    0xb8(%eax),%edi
    uint32_t* pagedir = curT->pagedir;
c0032174:	8b 68 30             	mov    0x30(%eax),%ebp
    lock_acquire(&page_lock);
c0032177:	83 ec 0c             	sub    $0xc,%esp
c003217a:	8d 83 44 a6 00 00    	lea    0xa644(%ebx),%eax
c0032180:	50                   	push   %eax
c0032181:	e8 3c 14 ff ff       	call   c00235c2 <lock_acquire>
    struct page_table_entry* pte = page_find_entry(pt, va);
c0032186:	83 c4 08             	add    $0x8,%esp
c0032189:	ff 74 24 38          	pushl  0x38(%esp)
c003218d:	57                   	push   %edi
c003218e:	e8 ca fb ff ff       	call   c0031d5d <page_find_entry>
    if(pte == NULL) {
c0032193:	83 c4 10             	add    $0x10,%esp
c0032196:	85 c0                	test   %eax,%eax
c0032198:	74 1f                	je     c00321b9 <page_set_frame+0x6a>
    lock_release(&page_lock);
c003219a:	83 ec 0c             	sub    $0xc,%esp
c003219d:	8d 83 44 a6 00 00    	lea    0xa644(%ebx),%eax
c00321a3:	50                   	push   %eax
c00321a4:	e8 ed 15 ff ff       	call   c0023796 <lock_release>
c00321a9:	83 c4 10             	add    $0x10,%esp
        success = false;
c00321ac:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00321b1:	83 c4 1c             	add    $0x1c,%esp
c00321b4:	5b                   	pop    %ebx
c00321b5:	5e                   	pop    %esi
c00321b6:	5f                   	pop    %edi
c00321b7:	5d                   	pop    %ebp
c00321b8:	c3                   	ret    
        pte = malloc(sizeof(*pte));
c00321b9:	83 ec 0c             	sub    $0xc,%esp
c00321bc:	6a 1c                	push   $0x1c
c00321be:	e8 21 21 ff ff       	call   c00242e4 <malloc>
c00321c3:	89 c6                	mov    %eax,%esi
        pte->va = va;
c00321c5:	8b 44 24 40          	mov    0x40(%esp),%eax
c00321c9:	89 06                	mov    %eax,(%esi)
        pte->status = Frame;
c00321cb:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
        pte->pa = pa;
c00321d2:	8b 44 24 44          	mov    0x44(%esp),%eax
c00321d6:	89 46 08             	mov    %eax,0x8(%esi)
        pte->fa = NULL;
c00321d9:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
        pte->dirty = dirty;
c00321e0:	0f b6 44 24 1c       	movzbl 0x1c(%esp),%eax
c00321e5:	88 46 10             	mov    %al,0x10(%esi)
        hash_insert(pt, &pte->elem);
c00321e8:	83 c4 08             	add    $0x8,%esp
c00321eb:	8d 46 14             	lea    0x14(%esi),%eax
c00321ee:	50                   	push   %eax
c00321ef:	57                   	push   %edi
c00321f0:	e8 79 90 ff ff       	call   c002b26e <hash_insert>
    lock_release(&page_lock);
c00321f5:	8d 83 44 a6 00 00    	lea    0xa644(%ebx),%eax
c00321fb:	89 04 24             	mov    %eax,(%esp)
c00321fe:	e8 93 15 ff ff       	call   c0023796 <lock_release>
        ASSERT(pagedir_set_page(pagedir, pte->va, pte->pa, pte->dirty));
c0032203:	0f b6 46 10          	movzbl 0x10(%esi),%eax
c0032207:	50                   	push   %eax
c0032208:	ff 76 08             	pushl  0x8(%esi)
c003220b:	ff 36                	pushl  (%esi)
c003220d:	55                   	push   %ebp
c003220e:	e8 84 a3 ff ff       	call   c002c597 <pagedir_set_page>
c0032213:	83 c4 20             	add    $0x20,%esp
c0032216:	84 c0                	test   %al,%al
c0032218:	75 97                	jne    c00321b1 <page_set_frame+0x62>
c003221a:	83 ec 0c             	sub    $0xc,%esp
c003221d:	8d 83 9c 57 ff ff    	lea    -0xa864(%ebx),%eax
c0032223:	50                   	push   %eax
c0032224:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c003222a:	50                   	push   %eax
c003222b:	8d 83 14 2c ff ff    	lea    -0xd3ec(%ebx),%eax
c0032231:	50                   	push   %eax
c0032232:	68 b4 00 00 00       	push   $0xb4
c0032237:	8d 83 3c 57 ff ff    	lea    -0xa8c4(%ebx),%eax
c003223d:	50                   	push   %eax
c003223e:	e8 52 76 ff ff       	call   c0029895 <debug_panic>

c0032243 <page_mmap>:
bool page_mmap(page_table* pt, struct mmap_handler* mh, void* va) {
c0032243:	57                   	push   %edi
c0032244:	56                   	push   %esi
c0032245:	53                   	push   %ebx
c0032246:	e8 9b 02 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c003224b:	81 c3 f1 e9 00 00    	add    $0xe9f1,%ebx
c0032251:	8b 7c 24 18          	mov    0x18(%esp),%edi
    struct thread *curT = thread_current();
c0032255:	e8 eb ed fe ff       	call   c0021045 <thread_current>
    lock_acquire(&page_lock);
c003225a:	83 ec 0c             	sub    $0xc,%esp
c003225d:	8d 83 44 a6 00 00    	lea    0xa644(%ebx),%eax
c0032263:	50                   	push   %eax
c0032264:	e8 59 13 ff ff       	call   c00235c2 <lock_acquire>
    if(va < PAGE_STACK_LOWER_BOUND && page_find_entry(pt, va) == NULL) {
c0032269:	83 c4 10             	add    $0x10,%esp
        success = false;
c003226c:	be 00 00 00 00       	mov    $0x0,%esi
    if(va < PAGE_STACK_LOWER_BOUND && page_find_entry(pt, va) == NULL) {
c0032271:	81 ff ff ff 7f bf    	cmp    $0xbf7fffff,%edi
c0032277:	76 18                	jbe    c0032291 <page_mmap+0x4e>
    lock_release(&page_lock);
c0032279:	83 ec 0c             	sub    $0xc,%esp
c003227c:	8d 83 44 a6 00 00    	lea    0xa644(%ebx),%eax
c0032282:	50                   	push   %eax
c0032283:	e8 0e 15 ff ff       	call   c0023796 <lock_release>
    return success;
c0032288:	83 c4 10             	add    $0x10,%esp
}
c003228b:	89 f0                	mov    %esi,%eax
c003228d:	5b                   	pop    %ebx
c003228e:	5e                   	pop    %esi
c003228f:	5f                   	pop    %edi
c0032290:	c3                   	ret    
    if(va < PAGE_STACK_LOWER_BOUND && page_find_entry(pt, va) == NULL) {
c0032291:	83 ec 08             	sub    $0x8,%esp
c0032294:	57                   	push   %edi
c0032295:	ff 74 24 1c          	pushl  0x1c(%esp)
c0032299:	e8 bf fa ff ff       	call   c0031d5d <page_find_entry>
c003229e:	83 c4 10             	add    $0x10,%esp
c00322a1:	85 c0                	test   %eax,%eax
c00322a3:	75 d4                	jne    c0032279 <page_mmap+0x36>
        struct page_table_entry *pte = malloc(sizeof(*pte));
c00322a5:	83 ec 0c             	sub    $0xc,%esp
c00322a8:	6a 1c                	push   $0x1c
c00322aa:	e8 35 20 ff ff       	call   c00242e4 <malloc>
        pte->va = va;
c00322af:	89 38                	mov    %edi,(%eax)
        pte->status = Disk;
c00322b1:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
        pte->pa = mh;
c00322b8:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c00322bc:	89 48 08             	mov    %ecx,0x8(%eax)
        pte->fa = mh;
c00322bf:	89 48 0c             	mov    %ecx,0xc(%eax)
        pte->dirty = mh->dirty;
c00322c2:	0f b6 51 20          	movzbl 0x20(%ecx),%edx
c00322c6:	88 50 10             	mov    %dl,0x10(%eax)
        hash_insert(pt, &pte->elem);
c00322c9:	83 c4 08             	add    $0x8,%esp
c00322cc:	83 c0 14             	add    $0x14,%eax
c00322cf:	50                   	push   %eax
c00322d0:	ff 74 24 1c          	pushl  0x1c(%esp)
c00322d4:	e8 95 8f ff ff       	call   c002b26e <hash_insert>
    if(va < PAGE_STACK_LOWER_BOUND && page_find_entry(pt, va) == NULL) {
c00322d9:	83 c4 10             	add    $0x10,%esp
    bool success = true;
c00322dc:	be 01 00 00 00       	mov    $0x1,%esi
    if(va < PAGE_STACK_LOWER_BOUND && page_find_entry(pt, va) == NULL) {
c00322e1:	eb 96                	jmp    c0032279 <page_mmap+0x36>

c00322e3 <page_unmap>:
bool page_unmap(page_table* pt, void* va) {
c00322e3:	55                   	push   %ebp
c00322e4:	57                   	push   %edi
c00322e5:	56                   	push   %esi
c00322e6:	53                   	push   %ebx
c00322e7:	83 ec 0c             	sub    $0xc,%esp
c00322ea:	e8 f7 01 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c00322ef:	81 c3 4d e9 00 00    	add    $0xe94d,%ebx
c00322f5:	8b 7c 24 24          	mov    0x24(%esp),%edi
    struct thread *curT = thread_current();
c00322f9:	e8 47 ed fe ff       	call   c0021045 <thread_current>
c00322fe:	89 c5                	mov    %eax,%ebp
    lock_acquire(&page_lock);
c0032300:	83 ec 0c             	sub    $0xc,%esp
c0032303:	8d 83 44 a6 00 00    	lea    0xa644(%ebx),%eax
c0032309:	50                   	push   %eax
c003230a:	e8 b3 12 ff ff       	call   c00235c2 <lock_acquire>
    if(va < PAGE_STACK_LOWER_BOUND && page_find_entry(pt, va) != NULL) {
c003230f:	83 c4 10             	add    $0x10,%esp
        success = false;
c0032312:	be 00 00 00 00       	mov    $0x0,%esi
    if(va < PAGE_STACK_LOWER_BOUND && page_find_entry(pt, va) != NULL) {
c0032317:	81 ff ff ff 7f bf    	cmp    $0xbf7fffff,%edi
c003231d:	76 19                	jbe    c0032338 <page_unmap+0x55>
    lock_release(&page_lock);
c003231f:	83 ec 0c             	sub    $0xc,%esp
c0032322:	8d 83 44 a6 00 00    	lea    0xa644(%ebx),%eax
c0032328:	50                   	push   %eax
c0032329:	e8 68 14 ff ff       	call   c0023796 <lock_release>
}
c003232e:	89 f0                	mov    %esi,%eax
c0032330:	83 c4 1c             	add    $0x1c,%esp
c0032333:	5b                   	pop    %ebx
c0032334:	5e                   	pop    %esi
c0032335:	5f                   	pop    %edi
c0032336:	5d                   	pop    %ebp
c0032337:	c3                   	ret    
    if(va < PAGE_STACK_LOWER_BOUND && page_find_entry(pt, va) != NULL) {
c0032338:	83 ec 08             	sub    $0x8,%esp
c003233b:	57                   	push   %edi
c003233c:	ff 74 24 2c          	pushl  0x2c(%esp)
c0032340:	e8 18 fa ff ff       	call   c0031d5d <page_find_entry>
c0032345:	83 c4 10             	add    $0x10,%esp
c0032348:	85 c0                	test   %eax,%eax
c003234a:	74 d3                	je     c003231f <page_unmap+0x3c>
        struct page_table_entry *pte = page_find_entry(pt, va);
c003234c:	83 ec 08             	sub    $0x8,%esp
c003234f:	57                   	push   %edi
c0032350:	ff 74 24 2c          	pushl  0x2c(%esp)
c0032354:	e8 04 fa ff ff       	call   c0031d5d <page_find_entry>
c0032359:	89 c6                	mov    %eax,%esi
        switch(pte->status) {
c003235b:	83 c4 10             	add    $0x10,%esp
c003235e:	8b 40 04             	mov    0x4(%eax),%eax
c0032361:	85 c0                	test   %eax,%eax
c0032363:	74 2b                	je     c0032390 <page_unmap+0xad>
c0032365:	83 f8 02             	cmp    $0x2,%eax
c0032368:	0f 85 88 00 00 00    	jne    c00323f6 <page_unmap+0x113>
                hash_delete(pt, &(pte->elem));
c003236e:	83 ec 08             	sub    $0x8,%esp
c0032371:	8d 46 14             	lea    0x14(%esi),%eax
c0032374:	50                   	push   %eax
c0032375:	ff 74 24 2c          	pushl  0x2c(%esp)
c0032379:	e8 d9 8f ff ff       	call   c002b357 <hash_delete>
                free(pte);
c003237e:	89 34 24             	mov    %esi,(%esp)
c0032381:	e8 14 21 ff ff       	call   c002449a <free>
                break;
c0032386:	83 c4 10             	add    $0x10,%esp
    bool success = true;
c0032389:	be 01 00 00 00       	mov    $0x1,%esi
                break;
c003238e:	eb 8f                	jmp    c003231f <page_unmap+0x3c>
                if(pagedir_is_dirty(curT->pagedir, pte->va)) {
c0032390:	83 ec 08             	sub    $0x8,%esp
c0032393:	ff 36                	pushl  (%esi)
c0032395:	ff 75 30             	pushl  0x30(%ebp)
c0032398:	e8 75 a4 ff ff       	call   c002c812 <pagedir_is_dirty>
c003239d:	83 c4 10             	add    $0x10,%esp
c00323a0:	84 c0                	test   %al,%al
c00323a2:	75 3d                	jne    c00323e1 <page_unmap+0xfe>
                pagedir_clear_page(curT->pagedir, pte->va);
c00323a4:	83 ec 08             	sub    $0x8,%esp
c00323a7:	ff 36                	pushl  (%esi)
c00323a9:	ff 75 30             	pushl  0x30(%ebp)
c00323ac:	e8 77 a5 ff ff       	call   c002c928 <pagedir_clear_page>
                hash_delete(pt, &(pte->elem));
c00323b1:	83 c4 08             	add    $0x8,%esp
c00323b4:	8d 46 14             	lea    0x14(%esi),%eax
c00323b7:	50                   	push   %eax
c00323b8:	ff 74 24 2c          	pushl  0x2c(%esp)
c00323bc:	e8 96 8f ff ff       	call   c002b357 <hash_delete>
                frame_free(pte->pa);
c00323c1:	83 c4 04             	add    $0x4,%esp
c00323c4:	ff 76 08             	pushl  0x8(%esi)
c00323c7:	e8 4a f5 ff ff       	call   c0031916 <frame_free>
                free(pte);
c00323cc:	89 34 24             	mov    %esi,(%esp)
c00323cf:	e8 c6 20 ff ff       	call   c002449a <free>
                break;
c00323d4:	83 c4 10             	add    $0x10,%esp
    bool success = true;
c00323d7:	be 01 00 00 00       	mov    $0x1,%esi
                break;
c00323dc:	e9 3e ff ff ff       	jmp    c003231f <page_unmap+0x3c>
                    mmap_write(pte->fa, pte->va, pte->pa);
c00323e1:	83 ec 04             	sub    $0x4,%esp
c00323e4:	ff 76 08             	pushl  0x8(%esi)
c00323e7:	ff 36                	pushl  (%esi)
c00323e9:	ff 76 0c             	pushl  0xc(%esi)
c00323ec:	e8 e0 ac ff ff       	call   c002d0d1 <mmap_write>
c00323f1:	83 c4 10             	add    $0x10,%esp
c00323f4:	eb ae                	jmp    c00323a4 <page_unmap+0xc1>
                success = false;
c00323f6:	be 00 00 00 00       	mov    $0x0,%esi
c00323fb:	e9 1f ff ff ff       	jmp    c003231f <page_unmap+0x3c>

c0032400 <page_eviction>:
bool page_eviction(struct thread* curT, void* va, void* sa, bool toSwap) {
c0032400:	55                   	push   %ebp
c0032401:	57                   	push   %edi
c0032402:	56                   	push   %esi
c0032403:	53                   	push   %ebx
c0032404:	83 ec 14             	sub    $0x14,%esp
c0032407:	e8 da 00 00 00       	call   c00324e6 <__x86.get_pc_thunk.bx>
c003240c:	81 c3 30 e8 00 00    	add    $0xe830,%ebx
c0032412:	8b 74 24 28          	mov    0x28(%esp),%esi
c0032416:	8b 7c 24 2c          	mov    0x2c(%esp),%edi
c003241a:	8b 6c 24 34          	mov    0x34(%esp),%ebp
    struct page_table_entry *pte = page_find_entry(curT->page_table, va);
c003241e:	57                   	push   %edi
c003241f:	ff b6 b8 00 00 00    	pushl  0xb8(%esi)
c0032425:	e8 33 f9 ff ff       	call   c0031d5d <page_find_entry>
    if(pte != NULL && pte->status == Frame) {
c003242a:	83 c4 10             	add    $0x10,%esp
c003242d:	85 c0                	test   %eax,%eax
c003242f:	74 72                	je     c00324a3 <page_eviction+0xa3>
c0032431:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
c0032435:	75 73                	jne    c00324aa <page_eviction+0xaa>
        if(toSwap) {
c0032437:	89 e9                	mov    %ebp,%ecx
c0032439:	84 c9                	test   %cl,%cl
c003243b:	74 2a                	je     c0032467 <page_eviction+0x67>
            pte->pa = sa;
c003243d:	8b 54 24 28          	mov    0x28(%esp),%edx
c0032441:	89 50 08             	mov    %edx,0x8(%eax)
            pte->status = Swap;
c0032444:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        pagedir_clear_page(curT->pagedir, va);
c003244b:	83 ec 08             	sub    $0x8,%esp
c003244e:	57                   	push   %edi
c003244f:	ff 76 30             	pushl  0x30(%esi)
c0032452:	e8 d1 a4 ff ff       	call   c002c928 <pagedir_clear_page>
c0032457:	83 c4 10             	add    $0x10,%esp
    bool success = true;
c003245a:	b8 01 00 00 00       	mov    $0x1,%eax
}
c003245f:	83 c4 0c             	add    $0xc,%esp
c0032462:	5b                   	pop    %ebx
c0032463:	5e                   	pop    %esi
c0032464:	5f                   	pop    %edi
c0032465:	5d                   	pop    %ebp
c0032466:	c3                   	ret    
            ASSERT(pte->fa != NULL );
c0032467:	8b 50 0c             	mov    0xc(%eax),%edx
c003246a:	85 d2                	test   %edx,%edx
c003246c:	74 0c                	je     c003247a <page_eviction+0x7a>
            pte->pa = pte->fa;
c003246e:	89 50 08             	mov    %edx,0x8(%eax)
            pte->status = Disk;
c0032471:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
c0032478:	eb d1                	jmp    c003244b <page_eviction+0x4b>
            ASSERT(pte->fa != NULL );
c003247a:	83 ec 0c             	sub    $0xc,%esp
c003247d:	8d 83 61 57 ff ff    	lea    -0xa89f(%ebx),%eax
c0032483:	50                   	push   %eax
c0032484:	8d 83 fc 2c ff ff    	lea    -0xd304(%ebx),%eax
c003248a:	50                   	push   %eax
c003248b:	8d 83 04 2c ff ff    	lea    -0xd3fc(%ebx),%eax
c0032491:	50                   	push   %eax
c0032492:	68 f5 00 00 00       	push   $0xf5
c0032497:	8d 83 3c 57 ff ff    	lea    -0xa8c4(%ebx),%eax
c003249d:	50                   	push   %eax
c003249e:	e8 f2 73 ff ff       	call   c0029895 <debug_panic>
        success = false;
c00324a3:	b8 00 00 00 00       	mov    $0x0,%eax
c00324a8:	eb b5                	jmp    c003245f <page_eviction+0x5f>
c00324aa:	b8 00 00 00 00       	mov    $0x0,%eax
    return success;
c00324af:	eb ae                	jmp    c003245f <page_eviction+0x5f>

c00324b1 <page_available>:

//check if the vaddr is available
bool page_available(page_table* pt, void* va) {
c00324b1:	83 ec 0c             	sub    $0xc,%esp
c00324b4:	8b 54 24 14          	mov    0x14(%esp),%edx
    return va < PAGE_STACK_LOWER_BOUND && page_find_entry(pt, va) == NULL;
c00324b8:	b8 00 00 00 00       	mov    $0x0,%eax
c00324bd:	81 fa ff ff 7f bf    	cmp    $0xbf7fffff,%edx
c00324c3:	76 07                	jbe    c00324cc <page_available+0x1b>
c00324c5:	83 e0 01             	and    $0x1,%eax
}
c00324c8:	83 c4 0c             	add    $0xc,%esp
c00324cb:	c3                   	ret    
    return va < PAGE_STACK_LOWER_BOUND && page_find_entry(pt, va) == NULL;
c00324cc:	83 ec 08             	sub    $0x8,%esp
c00324cf:	52                   	push   %edx
c00324d0:	ff 74 24 1c          	pushl  0x1c(%esp)
c00324d4:	e8 84 f8 ff ff       	call   c0031d5d <page_find_entry>
c00324d9:	83 c4 10             	add    $0x10,%esp
c00324dc:	85 c0                	test   %eax,%eax
c00324de:	0f 94 c0             	sete   %al
c00324e1:	0f b6 c0             	movzbl %al,%eax
c00324e4:	eb df                	jmp    c00324c5 <page_available+0x14>

Disassembly of section .text.__x86.get_pc_thunk.bx:

c00324e6 <__x86.get_pc_thunk.bx>:
c00324e6:	8b 1c 24             	mov    (%esp),%ebx
c00324e9:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.ax:

c00324ea <__x86.get_pc_thunk.ax>:
c00324ea:	8b 04 24             	mov    (%esp),%eax
c00324ed:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.dx:

c00324ee <__x86.get_pc_thunk.dx>:
c00324ee:	8b 14 24             	mov    (%esp),%edx
c00324f1:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.si:

c00324f2 <__x86.get_pc_thunk.si>:
c00324f2:	8b 34 24             	mov    (%esp),%esi
c00324f5:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.di:

c00324f6 <__x86.get_pc_thunk.di>:
c00324f6:	8b 3c 24             	mov    (%esp),%edi
c00324f9:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.cx:

c00324fa <__x86.get_pc_thunk.cx>:
c00324fa:	8b 0c 24             	mov    (%esp),%ecx
c00324fd:	c3                   	ret    

Disassembly of section .text.__x86.get_pc_thunk.bp:

c00324fe <__x86.get_pc_thunk.bp>:
c00324fe:	8b 2c 24             	mov    (%esp),%ebp
c0032501:	c3                   	ret    
